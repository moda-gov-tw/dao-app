"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.autoload = exports.defaultConfig = void 0;
const ethers_1 = require("ethers");
const types_js_1 = require("./types.js");
const loaders_js_1 = require("./loaders.js");
const disasm_js_1 = require("./disasm.js");
function isAddress(address) {
    return address.length === 42 && address.startsWith("0x");
}
exports.defaultConfig = {
    onProgress: (_) => { },
    onError: (phase, err) => { console.error(phase + ":", err); return false; },
};
async function autoload(address, config) {
    const onProgress = config.onProgress || exports.defaultConfig.onProgress;
    const onError = config.onError || exports.defaultConfig.onError;
    const provider = (0, types_js_1.CompatibleProvider)(config.provider);
    const result = {
        address,
        abi: [],
        proxies: [],
    };
    if (config === undefined) {
        throw new Error("autoload: config is undefined, must include 'provider'");
    }
    let abiLoader = config.abiLoader;
    if (abiLoader === undefined)
        abiLoader = loaders_js_1.defaultABILoader;
    if (!isAddress(address)) {
        onProgress("resolveName", { address });
        address = await provider.getAddress(address);
    }
    onProgress("getCode", { address });
    const program = (0, disasm_js_1.disasm)(await provider.getCode(address));
    result.proxies = program.proxies;
    if (result.proxies.length > 0) {
        result.followProxies = async function (selector) {
            for (const resolver of result.proxies) {
                onProgress("followProxies", { resolver: resolver, address });
                const resolved = await resolver.resolve(provider, address, selector);
                if (resolved !== undefined)
                    return await autoload(resolved, config);
            }
            onError("followProxies", new Error("failed to resolve proxy"));
            return result;
        };
        if (config.followProxies) {
            return await result.followProxies();
        }
    }
    if (abiLoader) {
        onProgress("abiLoader", { address });
        try {
            result.abi = await abiLoader.loadABI(address);
            if (result.abi.length > 0)
                return result;
        }
        catch (error) {
            if (onError("abiLoad", error) === true)
                return result;
        }
    }
    onProgress("getCode", { address });
    result.abi = (0, disasm_js_1.abiFromBytecode)(program);
    if (!config.enableExperimentalMetadata) {
        result.abi = stripUnreliableABI(result.abi);
    }
    let signatureLookup = config.signatureLookup;
    if (signatureLookup === undefined)
        signatureLookup = loaders_js_1.defaultSignatureLookup;
    if (!signatureLookup)
        return result;
    onProgress("signatureLookup", { abiItems: result.abi.length });
    let promises = [];
    for (const a of result.abi) {
        if (a.type === "function") {
            promises.push(signatureLookup.loadFunctions(a.selector).then((r) => {
                if (r.length >= 1) {
                    a.sig = r[0];
                    const extracted = JSON.parse(ethers_1.Fragment.from("function " + a.sig).format("json"));
                    if (extracted.outputs.length === 0) {
                        delete (extracted.outputs);
                    }
                    Object.assign(a, extracted);
                }
                if (r.length > 1)
                    a.sigAlts = r.slice(1);
            }));
        }
        else if (a.type === "event") {
            promises.push(signatureLookup.loadEvents(a.hash).then((r) => {
                if (r.length >= 1) {
                    a.sig = r[0];
                    Object.assign(a, JSON.parse(ethers_1.Fragment.from("event " + a.sig).format("json")));
                }
                if (r.length > 1)
                    a.sigAlts = r.slice(1);
            }));
        }
    }
    await Promise.all(promises);
    return result;
}
exports.autoload = autoload;
function stripUnreliableABI(abi) {
    const r = [];
    for (const a of abi) {
        if (a.type !== "function")
            continue;
        r.push({
            type: "function",
            selector: a.selector,
        });
    }
    return r;
}
//# sourceMappingURL=auto.js.map