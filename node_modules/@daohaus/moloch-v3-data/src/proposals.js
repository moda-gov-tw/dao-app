"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listVotes = exports.listProposals = exports.findProposal = void 0;
const tslib_1 = require("tslib");
const data_fetch_utils_1 = require("@daohaus/data-fetch-utils");
const keychain_utils_1 = require("@daohaus/keychain-utils");
const votes_generated_1 = require("./subgraph/queries/votes.generated");
const types_1 = require("./types");
const utils_1 = require("./utils");
const findProposal = ({ networkId, dao, proposalId, connectedAddress, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' }),
        };
    }
    try {
        const queryResult = yield (0, data_fetch_utils_1.graphFetch)(types_1.FindProposalDocument, url, networkId, {
            id: `${dao.toLowerCase()}-proposal-${proposalId}`,
            connectedAddress,
        });
        return Object.assign(Object.assign({}, queryResult), { data: {
                proposal: ((_a = queryResult === null || queryResult === void 0 ? void 0 : queryResult.data) === null || _a === void 0 ? void 0 : _a.proposal) &&
                    (0, utils_1.transformProposal)(queryResult.data.proposal),
            } });
    }
    catch (err) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'SUBGRAPH_ERROR', errorObject: err }),
        };
    }
});
exports.findProposal = findProposal;
const listProposals = ({ networkId, filter, ordering = {
    orderBy: 'createdAt',
    orderDirection: 'desc',
}, paging = {
    pageSize: utils_1.DEFAULT_RECORDS_PER_PAGE,
    offset: 0,
}, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        throw (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' });
    }
    const res = yield (0, data_fetch_utils_1.graphFetchList)(types_1.ListProposalsDocument, url, {
        where: Object.assign(Object.assign({}, filter), { id_gt: paging.lastId || '' }),
        orderBy: paging.lastId ? 'id' : ordering.orderBy,
        orderDirection: paging.lastId ? 'asc' : ordering.orderDirection,
        first: paging.pageSize + 1,
        skip: paging.offset,
    });
    const pagingUpdates = (0, utils_1.createPaging)(res['proposals'], paging);
    return {
        networkId,
        filter,
        ordering,
        nextPaging: pagingUpdates.nextPaging,
        previousPaging: pagingUpdates.previousPaging,
        items: pagingUpdates.pageItems.map((prop) => (0, utils_1.transformProposal)(prop)),
    };
});
exports.listProposals = listProposals;
const listVotes = ({ networkId, filter, ordering = {
    orderBy: 'createdAt',
    orderDirection: 'desc',
}, paging = {
    pageSize: utils_1.DEFAULT_RECORDS_PER_PAGE,
    offset: 0,
}, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        throw (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' });
    }
    const res = yield (0, data_fetch_utils_1.graphFetchList)(votes_generated_1.ListVotesDocument, url, {
        where: Object.assign(Object.assign({}, filter), { id_gt: paging.lastId || '' }),
        orderBy: paging.lastId ? 'id' : ordering.orderBy,
        orderDirection: paging.lastId ? 'asc' : ordering.orderDirection,
        first: paging.pageSize + 1,
        skip: paging.offset,
    });
    const pagingUpdates = (0, utils_1.createPaging)(res['votes'], paging);
    return {
        networkId,
        filter,
        ordering,
        nextPaging: pagingUpdates.nextPaging,
        previousPaging: pagingUpdates.previousPaging,
        items: pagingUpdates.pageItems,
    };
});
exports.listVotes = listVotes;
//# sourceMappingURL=proposals.js.map