"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listDaos = exports.findDao = void 0;
const tslib_1 = require("tslib");
const data_fetch_utils_1 = require("@daohaus/data-fetch-utils");
const keychain_utils_1 = require("@daohaus/keychain-utils");
const utils_1 = require("@daohaus/utils");
const types_1 = require("./types");
const utils_2 = require("./utils");
const vaults_1 = require("./vaults");
const findDao = ({ networkId, dao, graphApiKeys, includeTokens = false, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' }),
        };
    }
    try {
        const daoRes = yield (0, data_fetch_utils_1.graphFetch)(types_1.FindDaoDocument, url, networkId, {
            id: dao.toLowerCase(),
            now: (0, utils_1.nowInSeconds)().toFixed(),
        });
        const gnosisUrl = keychain_utils_1.ENDPOINTS['GNOSIS_API'][networkId];
        if (includeTokens && ((_a = daoRes === null || daoRes === void 0 ? void 0 : daoRes.data) === null || _a === void 0 ? void 0 : _a.dao) && gnosisUrl) {
            try {
                const tokenPromises = [];
                daoRes.data.dao.vaults.forEach((vault) => {
                    tokenPromises.push((0, vaults_1.listTokenBalances)({
                        networkId,
                        safeAddress: vault.safeAddress,
                    }));
                });
                const tokenData = yield Promise.all(tokenPromises);
                const hydratedVaults = daoRes.data.dao.vaults.map((vault) => {
                    var _a, _b;
                    const vaultResMatch = tokenData.find((tokenRes) => {
                        var _a;
                        return ((_a = tokenRes.data) === null || _a === void 0 ? void 0 : _a.safeAddress.toLowerCase()) ===
                            vault.safeAddress.toLowerCase();
                    });
                    return Object.assign(Object.assign({}, vault), { fiatTotal: (_a = vaultResMatch === null || vaultResMatch === void 0 ? void 0 : vaultResMatch.data) === null || _a === void 0 ? void 0 : _a.fiatTotal, tokenBalances: (_b = vaultResMatch === null || vaultResMatch === void 0 ? void 0 : vaultResMatch.data) === null || _b === void 0 ? void 0 : _b.tokenBalances });
                });
                return {
                    data: {
                        dao: Object.assign(Object.assign(Object.assign({}, daoRes.data.dao), (0, utils_2.addDaoProfileFields)(daoRes.data.dao)), { vaults: hydratedVaults, fiatTotal: tokenData.reduce((sum, vault) => {
                                var _a;
                                sum += Number((_a = vault.data) === null || _a === void 0 ? void 0 : _a.fiatTotal);
                                return sum;
                            }, 0) }),
                    },
                };
            }
            catch (err) {
                console.error('gnosis api fetch error', err);
            }
        }
        if ((_b = daoRes.data) === null || _b === void 0 ? void 0 : _b.dao) {
            return {
                data: {
                    dao: Object.assign(Object.assign({}, daoRes.data.dao), (0, utils_2.addDaoProfileFields)(daoRes.data.dao)),
                },
            };
        }
        else {
            return daoRes;
        }
    }
    catch (err) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'SUBGRAPH_ERROR', errorObject: err }),
        };
    }
});
exports.findDao = findDao;
const listDaos = ({ networkId, filter, ordering = {
    orderBy: 'id',
    orderDirection: 'desc',
}, paging = {
    pageSize: utils_2.DEFAULT_RECORDS_PER_PAGE,
    offset: 0,
}, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        throw (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' });
    }
    const res = yield (0, data_fetch_utils_1.graphFetchList)(types_1.ListDaosDocument, url, {
        where: Object.assign(Object.assign({}, filter), { id_gt: paging.lastId || '' }),
        now: (0, utils_1.nowInSeconds)().toFixed(),
        orderBy: paging.lastId ? 'id' : ordering.orderBy,
        orderDirection: paging.lastId ? 'asc' : ordering.orderDirection,
        first: paging.pageSize + 1,
        skip: paging.offset,
    });
    const pagingUpdates = (0, utils_2.createPaging)(res['daos'], paging);
    return {
        networkId,
        filter,
        ordering,
        nextPaging: pagingUpdates.nextPaging,
        previousPaging: pagingUpdates.previousPaging,
        items: pagingUpdates.pageItems.map((item) => {
            return Object.assign(Object.assign({}, item), (0, utils_2.addDaoProfileFields)(item));
        }),
    };
});
exports.listDaos = listDaos;
//# sourceMappingURL=daos.js.map