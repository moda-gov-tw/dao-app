"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listProposalVotesByMember = exports.listDaosByMember = exports.listMembers = exports.findMember = void 0;
const tslib_1 = require("tslib");
const data_fetch_utils_1 = require("@daohaus/data-fetch-utils");
const keychain_utils_1 = require("@daohaus/keychain-utils");
const utils_1 = require("@daohaus/utils");
const types_1 = require("./types");
const utils_2 = require("./utils");
const findMember = ({ networkId, dao, memberAddress, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' }),
        };
    }
    try {
        return yield (0, data_fetch_utils_1.graphFetch)(types_1.FindMemberDocument, url, networkId, {
            id: `${dao.toLowerCase()}-member-${memberAddress.toLowerCase()}`,
        });
    }
    catch (err) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'SUBGRAPH_ERROR', errorObject: err }),
        };
    }
});
exports.findMember = findMember;
const listMembers = ({ networkId, filter, ordering = {
    orderBy: 'id',
    orderDirection: 'desc',
}, paging = {
    pageSize: utils_2.DEFAULT_RECORDS_PER_PAGE,
    offset: 0,
}, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        throw (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' });
    }
    const res = yield (0, data_fetch_utils_1.graphFetchList)(types_1.ListMembersDocument, url, {
        where: Object.assign(Object.assign({}, filter), { id_gt: paging.lastId || '' }),
        orderBy: paging.lastId ? 'id' : ordering.orderBy,
        orderDirection: paging.lastId ? 'asc' : ordering.orderDirection,
        first: paging.pageSize + 1,
        skip: paging.offset,
    });
    const pagingUpdates = (0, utils_2.createPaging)(res['members'], paging);
    return {
        networkId,
        filter,
        ordering,
        nextPaging: pagingUpdates.nextPaging,
        previousPaging: pagingUpdates.previousPaging,
        items: pagingUpdates.pageItems,
    };
});
exports.listMembers = listMembers;
const listDaosByMember = ({ memberAddress, daoFilter, memberFilter, ordering = {
    orderBy: 'createdAt',
    orderDirection: 'desc',
}, networkIds, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const promises = [];
    networkIds.forEach((networkId) => {
        const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
        if (url) {
            promises.push((0, data_fetch_utils_1.graphFetch)(types_1.ListMembershipsDocument, url, networkId, {
                where: Object.assign({ members_: Object.assign({ memberAddress: memberAddress }, memberFilter) }, daoFilter),
                memberWhere: { memberAddress },
                now: (0, utils_1.nowInSeconds)().toFixed(),
                orderBy: ordering.orderBy,
                orderDirection: ordering.orderDirection,
            }));
        }
    });
    const memberData = yield Promise.all(promises);
    return { data: { daos: (0, utils_2.transformMembershipList)(memberData) } };
});
exports.listDaosByMember = listDaosByMember;
const listProposalVotesByMember = ({ networkId, filter, memberAddress, ordering = {
    orderBy: 'createdAt',
    orderDirection: 'desc',
}, paging = {
    pageSize: utils_2.DEFAULT_RECORDS_PER_PAGE,
    offset: 0,
}, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        throw (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' });
    }
    const res = yield (0, data_fetch_utils_1.graphFetchList)(types_1.ListConnectedMemberProposalsDocument, url, {
        where: Object.assign(Object.assign({}, filter), { id_gt: paging.lastId || '' }),
        memberWhere: { memberAddress },
        orderBy: paging.lastId ? 'id' : ordering.orderBy,
        orderDirection: paging.lastId ? 'asc' : ordering.orderDirection,
        first: paging.pageSize + 1,
        skip: paging.offset,
    });
    const pagingUpdates = (0, utils_2.createPaging)(res['proposals'], paging);
    return {
        networkId,
        filter,
        ordering,
        nextPaging: pagingUpdates.nextPaging,
        previousPaging: pagingUpdates.previousPaging,
        items: pagingUpdates.pageItems,
    };
});
exports.listProposalVotesByMember = listProposalVotesByMember;
//# sourceMappingURL=members.js.map