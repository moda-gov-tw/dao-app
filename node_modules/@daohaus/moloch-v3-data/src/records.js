"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listRecords = exports.findRecord = void 0;
const tslib_1 = require("tslib");
const data_fetch_utils_1 = require("@daohaus/data-fetch-utils");
const keychain_utils_1 = require("@daohaus/keychain-utils");
const utils_1 = require("./utils");
const records_generated_1 = require("./subgraph/queries/records.generated");
const findRecord = ({ networkId, recordId, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' }),
        };
    }
    try {
        const res = yield (0, data_fetch_utils_1.graphFetch)(records_generated_1.FindRecordDocument, url, networkId, {
            id: recordId,
        });
        return Object.assign(Object.assign({}, res), { data: { record: (0, utils_1.addParsedContent)((_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.record) } });
    }
    catch (err) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'SUBGRAPH_ERROR', errorObject: err }),
        };
    }
});
exports.findRecord = findRecord;
const listRecords = ({ networkId, filter, ordering = {
    orderBy: 'createdAt',
    orderDirection: 'desc',
}, paging = {
    pageSize: utils_1.DEFAULT_RECORDS_PER_PAGE,
    offset: 0,
}, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        throw (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' });
    }
    const res = yield (0, data_fetch_utils_1.graphFetchList)(records_generated_1.ListRecordsDocument, url, {
        where: Object.assign(Object.assign({}, filter), { id_gt: paging.lastId || '' }),
        orderBy: paging.lastId ? 'id' : ordering.orderBy,
        orderDirection: paging.lastId ? 'asc' : ordering.orderDirection,
        first: paging.pageSize + 1,
        skip: paging.offset,
    });
    const pagingUpdates = (0, utils_1.createPaging)(res['records'], paging);
    return {
        networkId,
        filter,
        ordering,
        nextPaging: pagingUpdates.nextPaging,
        previousPaging: pagingUpdates.previousPaging,
        items: pagingUpdates.pageItems.map((item) => {
            return Object.assign(Object.assign({}, item), (0, utils_1.addParsedContent)(item));
        }),
    };
});
exports.listRecords = listRecords;
//# sourceMappingURL=records.js.map