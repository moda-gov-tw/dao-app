"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listTransactions = exports.findTransaction = void 0;
const tslib_1 = require("tslib");
const data_fetch_utils_1 = require("@daohaus/data-fetch-utils");
const keychain_utils_1 = require("@daohaus/keychain-utils");
const utils_1 = require("./utils");
const types_1 = require("./types");
const findTransaction = ({ networkId, txHash, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' }),
        };
    }
    try {
        return yield (0, data_fetch_utils_1.graphFetch)(types_1.FindTxDocument, url, networkId, {
            id: txHash,
        });
    }
    catch (err) {
        return {
            error: (0, data_fetch_utils_1.formatFetchError)({ type: 'SUBGRAPH_ERROR', errorObject: err }),
        };
    }
});
exports.findTransaction = findTransaction;
const listTransactions = ({ networkId, filter, ordering = {
    orderBy: 'createdAt',
    orderDirection: 'desc',
}, paging = {
    pageSize: utils_1.DEFAULT_RECORDS_PER_PAGE,
    offset: 0,
}, graphApiKeys, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const url = (0, keychain_utils_1.getGraphUrl)(networkId, graphApiKeys);
    if (!url) {
        throw (0, data_fetch_utils_1.formatFetchError)({ type: 'INVALID_NETWORK_ERROR' });
    }
    const res = yield (0, data_fetch_utils_1.graphFetchList)(types_1.ListTxsDocument, url, {
        where: Object.assign(Object.assign({}, filter), { id_gt: paging.lastId || '' }),
        orderBy: paging.lastId ? 'id' : ordering.orderBy,
        orderDirection: paging.lastId ? 'asc' : ordering.orderDirection,
        first: paging.pageSize + 1,
        skip: paging.offset,
    });
    const pagingUpdates = (0, utils_1.createPaging)(res['transactions'], paging);
    return {
        networkId,
        filter,
        ordering,
        nextPaging: pagingUpdates.nextPaging,
        previousPaging: pagingUpdates.previousPaging,
        items: pagingUpdates.pageItems,
    };
});
exports.listTransactions = listTransactions;
//# sourceMappingURL=transactions.js.map