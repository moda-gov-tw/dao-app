"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MolochV3Contract = void 0;
const tslib_1 = require("tslib");
const baal_contracts_1 = require("@daohaus/baal-contracts");
const contract_meta_1 = require("./contract-meta");
const encoding_utils_1 = require("./encoding-utils");
const estimate_util_1 = require("./estimate-util");
class MolochV3Contract {
    constructor(molochV3Contract, sharesContract, lootContract) {
        this.molochV3 = molochV3Contract;
        this.shares = sharesContract;
        this.loot = lootContract;
    }
    static create({ address, provider, }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const molochV3Contract = baal_contracts_1.BaalFactory.connect(address, provider);
            const sharesAddress = yield molochV3Contract.sharesToken();
            const lootAddress = yield molochV3Contract.lootToken();
            const sharesContract = baal_contracts_1.SharesFactory.connect(sharesAddress, provider);
            const lootContract = baal_contracts_1.LootFactory.connect(lootAddress, provider);
            return new MolochV3Contract(molochV3Contract, sharesContract, lootContract);
        });
    }
    /**
     * Submit proposal
     * @param proposalActions array of action parameters - to address, value, operation, abi, function name, function args
     * @param expiration epoch time in seconds for when the proposal will expire, 0 for no expiration
     * @param baalGas esitmated gas limit for executing the above actions
     * @param details Context for proposal.
     */
    submitProposal(args) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const multisendAbi = (0, contract_meta_1.getContractAbi)('GNOSIS_MULTISEND');
            if (!multisendAbi)
                throw 'missing multisend abi';
            const proposalData = args.proposalActions.map((action) => {
                return {
                    to: action.to,
                    value: action.value,
                    operation: action.operation,
                    data: (0, encoding_utils_1.encodeFunctionWrapper)(action.abi, action.fnName, action.functionArgs),
                };
            });
            const encodedActions = (0, encoding_utils_1.encodeFunctionWrapper)(multisendAbi, 'multiSend', proposalData);
            let estimate = args.baalGas;
            if (!estimate) {
                estimate = yield (0, estimate_util_1.gasEstimateFromActions)({
                    actions: proposalData,
                    chainId: args.networkId,
                    safeId: yield this.molochV3.avatar(),
                });
            }
            return yield this.molochV3.submitProposal(encodedActions, args.expiration, estimate || '0', args.details, args.overrides);
        });
    }
    /**
     * Process/execute proposal
     * @param id uint256 id of the proposal
     * @param proposalData Multisend encoded transactions or proposal data
     */
    processProposal(args) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const proposal = yield this.molochV3.proposals(args.id);
            const overrides = args.overrides || {};
            if (((_a = proposal[6]) === null || _a === void 0 ? void 0 : _a.toString()) !== '0') {
                overrides.gasLimit = proposal[6];
            }
            return yield this.molochV3.processProposal(args.id, args.proposalData, overrides);
        });
    }
}
exports.MolochV3Contract = MolochV3Contract;
//# sourceMappingURL=moloch-v3-contract.js.map