import {
  _setPrototypeOf,
  init_setPrototypeOf
} from "./chunk-365EK2P6.js";
import {
  require_localforage
} from "./chunk-PSSTWNFB.js";
import {
  require_abi,
  require_abis,
  require_address,
  require_assertRequest,
  require_base,
  require_call,
  require_ccip,
  require_chain,
  require_chain2,
  require_concat,
  require_contract,
  require_createBatchScheduler,
  require_data,
  require_decodeAbiParameters,
  require_decodeErrorResult,
  require_decodeFunctionResult,
  require_encodeAbiParameters,
  require_encodeFunctionData,
  require_encoding,
  require_extract,
  require_extractFunctionParts,
  require_formatAbiItem,
  require_formatAbiItemWithArgs,
  require_formatEther,
  require_formatGwei,
  require_formatUnits,
  require_formatter,
  require_fromHex,
  require_getAbiItem,
  require_getAddress,
  require_getCallError,
  require_getFunctionSelector,
  require_getNodeError,
  require_hashFunction,
  require_isAddress,
  require_isAddressEqual,
  require_isHex,
  require_keccak256,
  require_node,
  require_pad,
  require_parseAccount,
  require_request,
  require_rpc,
  require_size,
  require_slice,
  require_solidity,
  require_stringify,
  require_toBytes,
  require_toHex,
  require_transaction,
  require_transactionRequest,
  require_trim,
  require_unit
} from "./chunk-4OGDHTCQ.js";
import {
  require_src
} from "./chunk-EBQ4QPBR.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-LMAYTEU7.js";

// node_modules/@daohaus/utils/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/@daohaus/utils/node_modules/tslib/tslib.js"(exports, module) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __esDecorate;
    var __runInitializers;
    var __propKey;
    var __setFunctionName;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    var __addDisposableResource;
    var __disposeResources;
    (function(factory) {
      var root = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
        d3.__proto__ = b2;
      } || function(d3, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d3[p] = b2[p];
      };
      __extends = function(d3, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d3, b2);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      __rest = function(s3, e2) {
        var t2 = {};
        for (var p in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p) && e2.indexOf(p) < 0)
            t2[p] = s3[p];
        if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
            if (e2.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
              t2[p[i2]] = s3[p[i2]];
          }
        return t2;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d3 = decorators[i2])
              r = (c2 < 3 ? d3(r) : c2 > 3 ? d3(target, key, r) : d3(target, key)) || r;
        return c2 > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
          if (f !== void 0 && typeof f !== "function")
            throw new TypeError("Function expected");
          return f;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
          var context = {};
          for (var p in contextIn)
            context[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access)
            context.access[p] = contextIn.access[p];
          context.addInitializer = function(f) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
          };
          var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_ = accept(result.get))
              descriptor.get = _;
            if (_ = accept(result.set))
              descriptor.set = _;
            if (_ = accept(result.init))
              initializers.unshift(_);
          } else if (_ = accept(result)) {
            if (kind === "field")
              initializers.unshift(_);
            else
              descriptor[key] = _;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i2 = 0; i2 < initializers.length; i2++) {
          value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __propKey = function(x2) {
        return typeof x2 === "symbol" ? x2 : "".concat(x2);
      };
      __setFunctionName = function(f, name, prefix) {
        if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1)
            throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f, y3, t2, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _)
            try {
              if (f = 1, y3 && (t2 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t2 = y3["return"]) && t2.call(y3), 0) : y3.next) && !(t2 = t2.call(y3, op[1])).done)
                return t2;
              if (y3 = 0, t2)
                op = [op[0] & 2, t2.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t2 = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y3 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t2[1]) {
                    _.label = t2[1];
                    t2 = op;
                    break;
                  }
                  if (t2 && _.label < t2[2]) {
                    _.label = t2[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t2[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e2) {
              op = [6, e2];
              y3 = 0;
            } finally {
              f = t2 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m3, o) {
        for (var p in m3)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m3, p);
      };
      __createBinding = Object.create ? function(o, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m3, k2);
        if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m3[k2];
          } };
        }
        Object.defineProperty(o, k22, desc);
      } : function(o, m3, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o[k22] = m3[k2];
      };
      __values = function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3)
          return m3.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i2 >= o.length)
                o = void 0;
              return { value: o && o[i2++], done: !o };
            }
          };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m3 = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m3)
          return o;
        var i2 = m3.call(o), r, ar = [], e2;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
            ar.push(r.value);
        } catch (error) {
          e2 = { error };
        } finally {
          try {
            if (r && !r.done && (m3 = i2["return"]))
              m3.call(i2);
          } finally {
            if (e2)
              throw e2.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
          ar = ar.concat(__read(arguments[i2]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s3 += arguments[i2].length;
        for (var r = Array(s3), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a3 = arguments[i2], j = 0, jl = a3.length; j < jl; j++, k2++)
            r[k2] = a3[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l = from.length, ar; i2 < l; i2++) {
            if (ar || !(i2 in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i2);
              ar[i2] = from[i2];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n) {
          if (g[n])
            i2[n] = function(v) {
              return new Promise(function(a3, b2) {
                q2.push([n, v, a3, b2]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e2) {
            settle(q2[0][3], e2);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q2[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i2, p;
        return i2 = {}, verb("next"), verb("throw", function(e2) {
          throw e2;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n, f) {
          i2[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o[Symbol.asyncIterator], i2;
        return m3 ? m3.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n) {
          i2[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d3, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d3 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k2 in mod)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
              __createBinding(result, mod, k2);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      __addDisposableResource = function(env, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env.stack.push({ value, dispose, async });
        } else if (async) {
          env.stack.push({ async: true });
        }
        return value;
      };
      var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e2 = new Error(message);
        return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
      };
      __disposeResources = function(env) {
        function fail(e2) {
          env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;
          env.hasError = true;
        }
        function next() {
          while (env.stack.length) {
            var rec = env.stack.pop();
            try {
              var result = rec.dispose && rec.dispose.call(rec.value);
              if (rec.async)
                return Promise.resolve(result).then(next, function(e2) {
                  fail(e2);
                  return next();
                });
            } catch (e2) {
              fail(e2);
            }
          }
          if (env.hasError)
            throw env.error;
        }
        return next();
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__esDecorate", __esDecorate);
      exporter("__runInitializers", __runInitializers);
      exporter("__propKey", __propKey);
      exporter("__setFunctionName", __setFunctionName);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
      exporter("__addDisposableResource", __addDisposableResource);
      exporter("__disposeResources", __disposeResources);
    });
  }
});

// node_modules/@daohaus/utils/src/types/react.js
var require_react = __commonJS({
  "node_modules/@daohaus/utils/src/types/react.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@daohaus/utils/src/types/contract.js
var require_contract2 = __commonJS({
  "node_modules/@daohaus/utils/src/types/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@daohaus/utils/src/types/general.js
var require_general = __commonJS({
  "node_modules/@daohaus/utils/src/types/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@daohaus/utils/src/types/legoTypes.js
var require_legoTypes = __commonJS({
  "node_modules/@daohaus/utils/src/types/legoTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@daohaus/utils/src/types/query.js
var require_query = __commonJS({
  "node_modules/@daohaus/utils/src/types/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@daohaus/utils/src/types/viem.js
var require_viem = __commonJS({
  "node_modules/@daohaus/utils/src/types/viem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxUint256 = void 0;
    exports.MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
});

// node_modules/@daohaus/utils/src/types/index.js
var require_types = __commonJS({
  "node_modules/@daohaus/utils/src/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_react(), exports);
    tslib_1.__exportStar(require_contract2(), exports);
    tslib_1.__exportStar(require_general(), exports);
    tslib_1.__exportStar(require_legoTypes(), exports);
    tslib_1.__exportStar(require_query(), exports);
    tslib_1.__exportStar(require_viem(), exports);
  }
});

// node_modules/@daohaus/utils/src/constants/posterTags.js
var require_posterTags = __commonJS({
  "node_modules/@daohaus/utils/src/constants/posterTags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DAO_DATA_TABLE_NAMES = exports.TABULA_TAGS = exports.POSTER_TAGS = void 0;
    exports.POSTER_TAGS = {
      summoner: "daohaus.summoner.daoProfile",
      daoProfileUpdate: "daohaus.shares.daoProfile",
      signalProposal: "daohaus.proposal.signalProposal",
      daoDatabaseProposal: "daohaus.proposal.database",
      daoDatabaseShares: "daohaus.shares.database",
      daoDatabaseSharesOrLoot: "daohaus.member.database"
    };
    exports.TABULA_TAGS = {
      PUBLICATION: "PUBLICATION",
      PUB_ACTION: "publication/create",
      ARTICLE_ACTION: "article/create"
    };
    exports.DAO_DATA_TABLE_NAMES = {
      daoProfile: "daoProfile",
      credential: "credential",
      signal: "signal"
    };
  }
});

// node_modules/@daohaus/utils/src/constants/proposals.js
var require_proposals = __commonJS({
  "node_modules/@daohaus/utils/src/constants/proposals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.L2_ADDITIONAL_GAS = exports.ACTION_GAS_LIMIT_ADDITION = exports.PROCESS_PROPOSAL_GAS_LIMIT_ADDITION = exports.GAS_BUFFER_MULTIPLIER = exports.PROPOSAL_FILTERS = exports.PROP_CARD_HELP = exports.DAO_METHOD_TO_PROPOSAL_TYPE = exports.SENSITIVE_PROPOSAL_TYPES = exports.PROPOSAL_TYPE_WARNINGS = exports.PROPOSAL_TYPE_LABELS = exports.ENCODED_0X0_DATA = exports.PROPOSAL_STATUS = exports.ProposalTypeIds = void 0;
    var ProposalTypeIds;
    (function(ProposalTypeIds2) {
      ProposalTypeIds2["Signal"] = "SIGNAL";
      ProposalTypeIds2["IssueSharesLoot"] = "ISSUE";
      ProposalTypeIds2["AddShaman"] = "ADD_SHAMAN";
      ProposalTypeIds2["TransferErc20"] = "TRANSFER_ERC20";
      ProposalTypeIds2["TransferNetworkToken"] = "TRANSFER_NETWORK_TOKEN";
      ProposalTypeIds2["UpdateGovSettings"] = "UPDATE_GOV_SETTINGS";
      ProposalTypeIds2["UpdateTokenSettings"] = "TOKEN_SETTINGS";
      ProposalTypeIds2["TokensForShares"] = "TOKENS_FOR_SHARES";
      ProposalTypeIds2["GuildKick"] = "GUILDKICK";
      ProposalTypeIds2["WalletConnect"] = "WALLETCONNECT";
      ProposalTypeIds2["Multicall"] = "MULTICALL";
      ProposalTypeIds2["AddSigner"] = "ADD_SIGNER";
    })(ProposalTypeIds = exports.ProposalTypeIds || (exports.ProposalTypeIds = {}));
    exports.PROPOSAL_STATUS = {
      unsponsored: "Unsponsored",
      voting: "Voting",
      grace: "Grace",
      expired: "Expired",
      cancelled: "Cancelled",
      needsProcessing: "Ready for Execution",
      failed: "Failed",
      passed: "Passed",
      actionFailed: "Execution Failed",
      unknown: "Unknown"
    };
    exports.ENCODED_0X0_DATA = "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    exports.PROPOSAL_TYPE_LABELS = {
      SIGNAL: "Signal Proposal",
      ISSUE: "Token Proposal",
      ADD_SHAMAN: "Shaman Proposal",
      TRANSFER_ERC20: "Funding Proposal",
      TRANSFER_NETWORK_TOKEN: "Funding Proposal",
      UPDATE_GOV_SETTINGS: "Governance Proposal",
      TOKEN_SETTINGS: "Token Proposal",
      TOKENS_FOR_SHARES: "Token Proposal",
      GUILDKICK: "Token Proposal",
      WALLETCONNECT: "WalletConnect Proposal",
      MULTICALL: "Multicall Proposal",
      ADD_SIGNER: "Add Safe Signer Proposal"
    };
    exports.PROPOSAL_TYPE_WARNINGS = {
      SIGNAL: "Proposal for DAO voting signal. No transactions are executed.",
      ISSUE: "Proposal issues voting or non-voting tokens from the DAO.",
      TRANSFER_ERC20: "Proposal transfers ERC-20 tokens from a DAO safe.",
      TRANSFER_NETWORK_TOKEN: "Proposal transfers native tokens from a DAO safe.",
      ADD_SHAMAN: "Proposal grants DAO permissions to an external contract.",
      UPDATE_GOV_SETTINGS: "Proposal updates DAO proposal timing or advanced governance settings.",
      TOKEN_SETTINGS: "Proposal updates DAO voting or non-voting token transferability settings.",
      TOKENS_FOR_SHARES: "Proposal issues voting or non-voting tokens from the DAO.",
      GUILDKICK: "Proposal transfers DAO voting tokens into non-voting tokens.",
      WALLETCONNECT: "Proposal interacts with external contracts and applications.",
      ADD_SIGNER: "Proposal adds a signer to one of the DAO non-ragequittable safes",
      MULTICALL: "Proposal bundles a multiple actions to be executed in batch",
      ERROR_CANNOT_DECODE: "Cannot decode contract details for this proposal. Please proceed with extreme caution!",
      ERROR_UNKOWN: "Cannot verify contract details for this proposal. Please proceed with extreme caution!"
    };
    exports.SENSITIVE_PROPOSAL_TYPES = {
      ADD_SHAMAN: true
    };
    exports.DAO_METHOD_TO_PROPOSAL_TYPE = {
      setShamans: ProposalTypeIds.AddShaman
    };
    exports.PROP_CARD_HELP = {
      UNSPONSORED: "A member of the DAO can sponsor this proposal."
    };
    exports.PROPOSAL_FILTERS = {
      unsponsored: "Unsponsored",
      voting: "In Voting",
      grace: "In Grace",
      needsProcessing: "Ready to Execute",
      passed: "Passed",
      actionFailed: "Action Failed",
      failed: "Defeated",
      expired: "Expired"
    };
    exports.GAS_BUFFER_MULTIPLIER = 2;
    exports.PROCESS_PROPOSAL_GAS_LIMIT_ADDITION = 15e4;
    exports.ACTION_GAS_LIMIT_ADDITION = 15e4;
    exports.L2_ADDITIONAL_GAS = 5e6;
  }
});

// node_modules/@daohaus/utils/src/constants/contracts.js
var require_contracts = __commonJS({
  "node_modules/@daohaus/utils/src/constants/contracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHAMAN_PERMISSIONS = exports.NETWORK_TOKEN_ETH_ADDRESS = void 0;
    exports.NETWORK_TOKEN_ETH_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
    exports.SHAMAN_PERMISSIONS = [
      {
        id: "0",
        displayName: "0 - No permission"
      },
      {
        id: "1",
        displayName: "1 - Admin only"
      },
      {
        id: "2",
        displayName: "2 - Manager only"
      },
      {
        id: "3",
        displayName: "3 - Admin and manager"
      },
      {
        id: "4",
        displayName: "4 - Governance only"
      },
      {
        id: "5",
        displayName: "5 - Admin and governance"
      },
      {
        id: "6",
        displayName: "6 - Manager and governance"
      },
      {
        id: "7",
        displayName: "7 - Admin, manager and governance"
      }
    ];
  }
});

// node_modules/@daohaus/utils/src/constants/queues.js
var require_queues = __commonJS({
  "node_modules/@daohaus/utils/src/constants/queues.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DAO_PRODUCER_QUEUE = void 0;
    exports.DAO_PRODUCER_QUEUE = "dao-producer";
  }
});

// node_modules/@daohaus/utils/src/constants/summoning.js
var require_summoning = __commonJS({
  "node_modules/@daohaus/utils/src/constants/summoning.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SUMMON_COPY = exports.DAOHAUS_CONTRACT_UTILS_REFERRER = exports.DAOHAUS_SAFE_SUMMONER_REFERRER = exports.DAOHAUS_SUMMONER_REFERRER = void 0;
    exports.DAOHAUS_SUMMONER_REFERRER = "0x64616f6861757300000000000000000000000000000000000000000000000000";
    exports.DAOHAUS_SAFE_SUMMONER_REFERRER = "0x64616f686175732d736166652d61707000000000000000000000000000000000";
    exports.DAOHAUS_CONTRACT_UTILS_REFERRER = "0x64616f686175732d636f6e74726163742d7574696c7300000000000000000000";
    exports.SUMMON_COPY = {
      VOTING_STK: "What does your DAO want to name the tokens representing voting stake?",
      TOKEN_SYMBOL: "How would your DAO like to abbreviate the tokens representing voting stake?",
      STAKE_TRANSFER: "Should DAO members be allowed to transfer voting stake to other accounts? After summoning, the DAO can change this with a proposal.",
      NV_STAKE_TRANSFER: "Should DAO members be allowed to transfer non-voting stake to other accounts? After summoning, the DAO can change this with a proposal.",
      VOTING_PERIOD: "How long should proposals remain open for voting?",
      GRACE_PERIOD: "How long is the period between proposal approval and execution? This provides time for members to ragequit their shares before approved proposals are executed.",
      QUORUM: "What is the minimum percentage of DAO members (voting stake) required to approve a proposal for it to be executed? This percentage can greatly affect DAO operations. After summoning, the DAO can change it with a proposal.",
      MIN_RETENTION: "What is the maximum percentage of DAO members (voting and non-voting stake) required to remain in the DAO after grace period? If the percentage falls below this number, the proposal is not executed.",
      SPONSOR_THRESHOLD: "What is minimum number of delegated stake tokens a member needs to sponsor a proposal?",
      NEW_OFFERING: "Would you like to require a fee to submit proposals? This feature is intended to protect against spam proposals. Fees go into the DAO treasury.",
      SHAMAN: "Input shaman list with contract address and permission level per row using spaces. Example: \n 0x00000000000000 2 \n 0x00000000000000 1",
      MEMBERS: "Input member list with member address, voting stake amount, and non-voting stake amount per row using spaces. Example: \n 0x00000000000000 20 0 \n 0x00000000000000 10 0"
    };
  }
});

// node_modules/@daohaus/utils/src/constants/index.js
var require_constants = __commonJS({
  "node_modules/@daohaus/utils/src/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_posterTags(), exports);
    tslib_1.__exportStar(require_proposals(), exports);
    tslib_1.__exportStar(require_posterTags(), exports);
    tslib_1.__exportStar(require_contracts(), exports);
    tslib_1.__exportStar(require_queues(), exports);
    tslib_1.__exportStar(require_summoning(), exports);
  }
});

// node_modules/@daohaus/utils/src/content/form.js
var require_form = __commonJS({
  "node_modules/@daohaus/utils/src/content/form.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FORM_COPY = void 0;
    exports.FORM_COPY = {
      TOKENS: {
        title: "Stake Tokens",
        description: "Stake tokens represent both voting weight and economic stake within the DAO."
      },
      TIMING: {
        title: "Proposal Timing",
        description: "Define the timing for voting and grace periods. After summoning, the DAO can update these settings through a proposal."
      },
      ADVANCED: {
        title: "Advanced Governance",
        description: "Customize advanced governance settings."
      },
      SHAMANS: {
        title: "Starting Shamans",
        description: "Shamans are powerful and have control over key components of the DAO. Use caution in the spirit world."
      },
      MEMBERS: {
        title: "Starting Members",
        description: "You must have at least one member to summon. Add other summoning members as desired. Members can be added later through a proposal."
      }
    };
  }
});

// node_modules/@daohaus/utils/src/content/info.js
var require_info = __commonJS({
  "node_modules/@daohaus/utils/src/content/info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.INFO_COPY = void 0;
    exports.INFO_COPY = {
      VOTING_STK: "What does your DAO want to name the tokens representing voting stake?",
      TOKEN_SYMBOL: "How would your DAO like to abbreviate the tokens representing voting stake?",
      NON_VOTING_STK: "What does your DAO want to name the tokens representing non-voting stake?",
      LOOT_TOKEN_SYMBOL: "How would your DAO like to abbreviate the tokens representing non-voting stake?",
      STAKE_TRANSFER: "Should DAO members be allowed to transfer voting stake to other accounts? After summoning, the DAO can change this with a proposal.",
      NV_STAKE_TRANSFER: "Should DAO members be allowed to transfer non-voting stake to other accounts? After summoning, the DAO can change this with a proposal.",
      VOTING_PERIOD: "How long should proposals remain open for voting?",
      GRACE_PERIOD: "How long is the period between proposal approval and execution? This provides time for members to ragequit their shares before approved proposals are executed.",
      QUORUM: "What is the minimum percentage of DAO members (voting stake) required to approve a proposal for it to be executed? This percentage can greatly affect DAO operations. After summoning, the DAO can change it with a proposal.",
      MIN_RETENTION: "What is the maximum percentage of DAO members (voting and non-voting stake) required to remain in the DAO after grace period? If the percentage falls below this number, the proposal is not executed.",
      SPONSOR_THRESHOLD: "What is minimum number of voting stake tokens a member needs to sponsor a proposal?",
      NEW_OFFERING: "Would you like to require a fee to submit proposals? This feature is intended to protect against spam proposals. Fees in the form of native asset go into the DAO treasury.",
      SHAMAN: "Input shaman list with contract address and permission level per row using spaces. Example: \n 0x00000000000000 2 \n 0x00000000000000 1",
      MEMBERS: "Input member list with member address, voting stake amount, and non-voting stake amount per row using spaces. Example: \n 0x00000000000000 20 0 \n 0x00000000000000 10 0"
    };
  }
});

// node_modules/@daohaus/utils/src/content/index.js
var require_content = __commonJS({
  "node_modules/@daohaus/utils/src/content/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_form(), exports);
    tslib_1.__exportStar(require_info(), exports);
  }
});

// node_modules/@daohaus/utils/src/utils/cache.js
var require_cache = __commonJS({
  "node_modules/@daohaus/utils/src/utils/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getlocalForage = exports.CacheStoreName = exports.CACHE_CONFIG = void 0;
    var tslib_1 = require_tslib();
    var localforage = tslib_1.__importStar(require_localforage());
    exports.CACHE_CONFIG = {
      name: "DAOhaus",
      version: 3,
      storeName: "Universal DH Cache",
      description: "Store for DH apps. Used for caching ABIs, member Profiles, and other data."
    };
    var CacheStoreName;
    (function(CacheStoreName2) {
      CacheStoreName2["ABI"] = "ABI";
      CacheStoreName2["MEMBERS_PROFILE"] = "MEMBERS_PROFILE";
    })(CacheStoreName = exports.CacheStoreName || (exports.CacheStoreName = {}));
    var getlocalForage = (storeName) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      try {
        const store = yield localforage.getItem(storeName);
        return store;
      } catch (error) {
        console.error(error);
      }
    });
    exports.getlocalForage = getlocalForage;
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
var init_toInteger = __esm({
  "node_modules/date-fns/esm/_lib/toInteger/index.js"() {
  }
});

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
var init_requiredArgs = __esm({
  "node_modules/date-fns/esm/_lib/requiredArgs/index.js"() {
  }
});

// node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
var init_toDate = __esm({
  "node_modules/date-fns/esm/toDate/index.js"() {
    init_typeof();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addDays/index.js
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
var init_addDays = __esm({
  "node_modules/date-fns/esm/addDays/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addMonths/index.js
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
var init_addMonths = __esm({
  "node_modules/date-fns/esm/addMonths/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/add/index.js
function add(dirtyDate, duration) {
  requiredArgs(2, arguments);
  if (!duration || _typeof(duration) !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months2 = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days2 = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var date = toDate(dirtyDate);
  var dateWithMonths = months2 || years ? addMonths(date, months2 + years * 12) : date;
  var dateWithDays = days2 || weeks ? addDays(dateWithMonths, days2 + weeks * 7) : dateWithMonths;
  var minutesToAdd = minutes + hours * 60;
  var secondsToAdd = seconds + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1e3;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}
var init_add = __esm({
  "node_modules/date-fns/esm/add/index.js"() {
    init_typeof();
    init_addDays();
    init_addMonths();
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/isWeekend/index.js
function isWeekend(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day === 0 || day === 6;
}
var init_isWeekend = __esm({
  "node_modules/date-fns/esm/isWeekend/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSunday/index.js
function isSunday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 0;
}
var init_isSunday = __esm({
  "node_modules/date-fns/esm/isSunday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSaturday/index.js
function isSaturday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 6;
}
var init_isSaturday = __esm({
  "node_modules/date-fns/esm/isSaturday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addBusinessDays/index.js
function addBusinessDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var startedOnWeekend = isWeekend(date);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount))
    return new Date(NaN);
  var hours = date.getHours();
  var sign = amount < 0 ? -1 : 1;
  var fullWeeks = toInteger(amount / 5);
  date.setDate(date.getDate() + fullWeeks * 7);
  var restDays = Math.abs(amount % 5);
  while (restDays > 0) {
    date.setDate(date.getDate() + sign);
    if (!isWeekend(date))
      restDays -= 1;
  }
  if (startedOnWeekend && isWeekend(date) && amount !== 0) {
    if (isSaturday(date))
      date.setDate(date.getDate() + (sign < 0 ? 2 : -1));
    if (isSunday(date))
      date.setDate(date.getDate() + (sign < 0 ? 1 : -2));
  }
  date.setHours(hours);
  return date;
}
var init_addBusinessDays = __esm({
  "node_modules/date-fns/esm/addBusinessDays/index.js"() {
    init_isWeekend();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_isSunday();
    init_isSaturday();
  }
});

// node_modules/date-fns/esm/addMilliseconds/index.js
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
var init_addMilliseconds = __esm({
  "node_modules/date-fns/esm/addMilliseconds/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addHours/index.js
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}
var MILLISECONDS_IN_HOUR;
var init_addHours = __esm({
  "node_modules/date-fns/esm/addHours/index.js"() {
    init_toInteger();
    init_addMilliseconds();
    init_requiredArgs();
    MILLISECONDS_IN_HOUR = 36e5;
  }
});

// node_modules/date-fns/esm/_lib/defaultOptions/index.js
function getDefaultOptions() {
  return defaultOptions;
}
function setDefaultOptions(newOptions) {
  defaultOptions = newOptions;
}
var defaultOptions;
var init_defaultOptions = __esm({
  "node_modules/date-fns/esm/_lib/defaultOptions/index.js"() {
    defaultOptions = {};
  }
});

// node_modules/date-fns/esm/startOfWeek/index.js
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfWeek = __esm({
  "node_modules/date-fns/esm/startOfWeek/index.js"() {
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/startOfISOWeek/index.js
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
var init_startOfISOWeek = __esm({
  "node_modules/date-fns/esm/startOfISOWeek/index.js"() {
    init_startOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getISOWeekYear/index.js
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getISOWeekYear = __esm({
  "node_modules/date-fns/esm/getISOWeekYear/index.js"() {
    init_toDate();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfISOWeekYear/index.js
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}
var init_startOfISOWeekYear = __esm({
  "node_modules/date-fns/esm/startOfISOWeekYear/index.js"() {
    init_getISOWeekYear();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
var init_getTimezoneOffsetInMilliseconds = __esm({
  "node_modules/date-fns/esm/_lib/getTimezoneOffsetInMilliseconds/index.js"() {
  }
});

// node_modules/date-fns/esm/startOfDay/index.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfDay = __esm({
  "node_modules/date-fns/esm/startOfDay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarDays/index.js
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}
var MILLISECONDS_IN_DAY;
var init_differenceInCalendarDays = __esm({
  "node_modules/date-fns/esm/differenceInCalendarDays/index.js"() {
    init_getTimezoneOffsetInMilliseconds();
    init_startOfDay();
    init_requiredArgs();
    MILLISECONDS_IN_DAY = 864e5;
  }
});

// node_modules/date-fns/esm/setISOWeekYear/index.js
function setISOWeekYear(dirtyDate, dirtyISOWeekYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeekYear = toInteger(dirtyISOWeekYear);
  var diff = differenceInCalendarDays(date, startOfISOWeekYear(date));
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(isoWeekYear, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  date = startOfISOWeekYear(fourthOfJanuary);
  date.setDate(date.getDate() + diff);
  return date;
}
var init_setISOWeekYear = __esm({
  "node_modules/date-fns/esm/setISOWeekYear/index.js"() {
    init_toInteger();
    init_toDate();
    init_startOfISOWeekYear();
    init_differenceInCalendarDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addISOWeekYears/index.js
function addISOWeekYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return setISOWeekYear(dirtyDate, getISOWeekYear(dirtyDate) + amount);
}
var init_addISOWeekYears = __esm({
  "node_modules/date-fns/esm/addISOWeekYears/index.js"() {
    init_toInteger();
    init_getISOWeekYear();
    init_setISOWeekYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addMinutes/index.js
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}
var MILLISECONDS_IN_MINUTE;
var init_addMinutes = __esm({
  "node_modules/date-fns/esm/addMinutes/index.js"() {
    init_toInteger();
    init_addMilliseconds();
    init_requiredArgs();
    MILLISECONDS_IN_MINUTE = 6e4;
  }
});

// node_modules/date-fns/esm/addQuarters/index.js
function addQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var months2 = amount * 3;
  return addMonths(dirtyDate, months2);
}
var init_addQuarters = __esm({
  "node_modules/date-fns/esm/addQuarters/index.js"() {
    init_toInteger();
    init_addMonths();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addSeconds/index.js
function addSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1e3);
}
var init_addSeconds = __esm({
  "node_modules/date-fns/esm/addSeconds/index.js"() {
    init_toInteger();
    init_addMilliseconds();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addWeeks/index.js
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days2 = amount * 7;
  return addDays(dirtyDate, days2);
}
var init_addWeeks = __esm({
  "node_modules/date-fns/esm/addWeeks/index.js"() {
    init_toInteger();
    init_addDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/addYears/index.js
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
var init_addYears = __esm({
  "node_modules/date-fns/esm/addYears/index.js"() {
    init_toInteger();
    init_addMonths();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/areIntervalsOverlapping/index.js
function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
  requiredArgs(2, arguments);
  var leftStartTime = toDate(intervalLeft === null || intervalLeft === void 0 ? void 0 : intervalLeft.start).getTime();
  var leftEndTime = toDate(intervalLeft === null || intervalLeft === void 0 ? void 0 : intervalLeft.end).getTime();
  var rightStartTime = toDate(intervalRight === null || intervalRight === void 0 ? void 0 : intervalRight.start).getTime();
  var rightEndTime = toDate(intervalRight === null || intervalRight === void 0 ? void 0 : intervalRight.end).getTime();
  if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
    throw new RangeError("Invalid interval");
  }
  if (options !== null && options !== void 0 && options.inclusive) {
    return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;
  }
  return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
}
var init_areIntervalsOverlapping = __esm({
  "node_modules/date-fns/esm/areIntervalsOverlapping/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/max/index.js
function max(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
var init_max = __esm({
  "node_modules/date-fns/esm/max/index.js"() {
    init_typeof();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/min/index.js
function min(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result > currentDate || isNaN(currentDate.getDate())) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
var init_min = __esm({
  "node_modules/date-fns/esm/min/index.js"() {
    init_typeof();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/clamp/index.js
function clamp(date, _ref) {
  var start = _ref.start, end = _ref.end;
  requiredArgs(2, arguments);
  return min([max([date, start]), end]);
}
var init_clamp = __esm({
  "node_modules/date-fns/esm/clamp/index.js"() {
    init_max();
    init_min();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/closestIndexTo/index.js
function closestIndexTo(dirtyDateToCompare, dirtyDatesArray) {
  requiredArgs(2, arguments);
  var dateToCompare = toDate(dirtyDateToCompare);
  if (isNaN(Number(dateToCompare)))
    return NaN;
  var timeToCompare = dateToCompare.getTime();
  var datesArray;
  if (dirtyDatesArray == null) {
    datesArray = [];
  } else if (typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  }
  var result;
  var minDistance;
  datesArray.forEach(function(dirtyDate, index) {
    var currentDate = toDate(dirtyDate);
    if (isNaN(Number(currentDate))) {
      result = NaN;
      minDistance = NaN;
      return;
    }
    var distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < Number(minDistance)) {
      result = index;
      minDistance = distance;
    }
  });
  return result;
}
var init_closestIndexTo = __esm({
  "node_modules/date-fns/esm/closestIndexTo/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/closestTo/index.js
function closestTo(dirtyDateToCompare, dirtyDatesArray) {
  requiredArgs(2, arguments);
  var dateToCompare = toDate(dirtyDateToCompare);
  if (isNaN(Number(dateToCompare)))
    return new Date(NaN);
  var timeToCompare = dateToCompare.getTime();
  var datesArray;
  if (dirtyDatesArray == null) {
    datesArray = [];
  } else if (typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  }
  var result;
  var minDistance;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (isNaN(Number(currentDate))) {
      result = new Date(NaN);
      minDistance = NaN;
      return;
    }
    var distance = Math.abs(timeToCompare - currentDate.getTime());
    if (result == null || distance < Number(minDistance)) {
      result = currentDate;
      minDistance = distance;
    }
  });
  return result;
}
var init_closestTo = __esm({
  "node_modules/date-fns/esm/closestTo/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/compareAsc/index.js
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
var init_compareAsc = __esm({
  "node_modules/date-fns/esm/compareAsc/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/compareDesc/index.js
function compareDesc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff > 0) {
    return -1;
  } else if (diff < 0) {
    return 1;
  } else {
    return diff;
  }
}
var init_compareDesc = __esm({
  "node_modules/date-fns/esm/compareDesc/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/constants/index.js
var daysInWeek, daysInYear, maxTime, millisecondsInMinute, millisecondsInHour, millisecondsInSecond, minTime, minutesInHour, monthsInQuarter, monthsInYear, quartersInYear, secondsInHour, secondsInMinute, secondsInDay, secondsInWeek, secondsInYear, secondsInMonth, secondsInQuarter;
var init_constants = __esm({
  "node_modules/date-fns/esm/constants/index.js"() {
    daysInWeek = 7;
    daysInYear = 365.2425;
    maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
    millisecondsInMinute = 6e4;
    millisecondsInHour = 36e5;
    millisecondsInSecond = 1e3;
    minTime = -maxTime;
    minutesInHour = 60;
    monthsInQuarter = 3;
    monthsInYear = 12;
    quartersInYear = 4;
    secondsInHour = 3600;
    secondsInMinute = 60;
    secondsInDay = secondsInHour * 24;
    secondsInWeek = secondsInDay * 7;
    secondsInYear = secondsInDay * daysInYear;
    secondsInMonth = secondsInYear / 12;
    secondsInQuarter = secondsInMonth * 3;
  }
});

// node_modules/date-fns/esm/daysToWeeks/index.js
function daysToWeeks(days2) {
  requiredArgs(1, arguments);
  var weeks = days2 / daysInWeek;
  return Math.floor(weeks);
}
var init_daysToWeeks = __esm({
  "node_modules/date-fns/esm/daysToWeeks/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/isSameDay/index.js
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
var init_isSameDay = __esm({
  "node_modules/date-fns/esm/isSameDay/index.js"() {
    init_startOfDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isDate/index.js
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
var init_isDate = __esm({
  "node_modules/date-fns/esm/isDate/index.js"() {
    init_typeof();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isValid/index.js
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
var init_isValid = __esm({
  "node_modules/date-fns/esm/isValid/index.js"() {
    init_isDate();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInBusinessDays/index.js
function differenceInBusinessDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  if (!isValid(dateLeft) || !isValid(dateRight))
    return NaN;
  var calendarDifference = differenceInCalendarDays(dateLeft, dateRight);
  var sign = calendarDifference < 0 ? -1 : 1;
  var weeks = toInteger(calendarDifference / 7);
  var result = weeks * 5;
  dateRight = addDays(dateRight, weeks * 7);
  while (!isSameDay(dateLeft, dateRight)) {
    result += isWeekend(dateRight) ? 0 : sign;
    dateRight = addDays(dateRight, sign);
  }
  return result === 0 ? 0 : result;
}
var init_differenceInBusinessDays = __esm({
  "node_modules/date-fns/esm/differenceInBusinessDays/index.js"() {
    init_addDays();
    init_differenceInCalendarDays();
    init_isSameDay();
    init_isValid();
    init_isWeekend();
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/differenceInCalendarISOWeekYears/index.js
function differenceInCalendarISOWeekYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  return getISOWeekYear(dirtyDateLeft) - getISOWeekYear(dirtyDateRight);
}
var init_differenceInCalendarISOWeekYears = __esm({
  "node_modules/date-fns/esm/differenceInCalendarISOWeekYears/index.js"() {
    init_getISOWeekYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarISOWeeks/index.js
function differenceInCalendarISOWeeks(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfISOWeekLeft = startOfISOWeek(dirtyDateLeft);
  var startOfISOWeekRight = startOfISOWeek(dirtyDateRight);
  var timestampLeft = startOfISOWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfISOWeekLeft);
  var timestampRight = startOfISOWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfISOWeekRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK);
}
var MILLISECONDS_IN_WEEK;
var init_differenceInCalendarISOWeeks = __esm({
  "node_modules/date-fns/esm/differenceInCalendarISOWeeks/index.js"() {
    init_getTimezoneOffsetInMilliseconds();
    init_startOfISOWeek();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK = 6048e5;
  }
});

// node_modules/date-fns/esm/differenceInCalendarMonths/index.js
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
var init_differenceInCalendarMonths = __esm({
  "node_modules/date-fns/esm/differenceInCalendarMonths/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getQuarter/index.js
function getQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var quarter = Math.floor(date.getMonth() / 3) + 1;
  return quarter;
}
var init_getQuarter = __esm({
  "node_modules/date-fns/esm/getQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarQuarters/index.js
function differenceInCalendarQuarters(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var quarterDiff = getQuarter(dateLeft) - getQuarter(dateRight);
  return yearDiff * 4 + quarterDiff;
}
var init_differenceInCalendarQuarters = __esm({
  "node_modules/date-fns/esm/differenceInCalendarQuarters/index.js"() {
    init_getQuarter();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInCalendarWeeks/index.js
function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var startOfWeekLeft = startOfWeek(dirtyDateLeft, options);
  var startOfWeekRight = startOfWeek(dirtyDateRight, options);
  var timestampLeft = startOfWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
  var timestampRight = startOfWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK2);
}
var MILLISECONDS_IN_WEEK2;
var init_differenceInCalendarWeeks = __esm({
  "node_modules/date-fns/esm/differenceInCalendarWeeks/index.js"() {
    init_startOfWeek();
    init_getTimezoneOffsetInMilliseconds();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK2 = 6048e5;
  }
});

// node_modules/date-fns/esm/differenceInCalendarYears/index.js
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
var init_differenceInCalendarYears = __esm({
  "node_modules/date-fns/esm/differenceInCalendarYears/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInDays/index.js
function compareLocalAsc(dateLeft, dateRight) {
  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign * difference);
  var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
  var result = sign * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
var init_differenceInDays = __esm({
  "node_modules/date-fns/esm/differenceInDays/index.js"() {
    init_toDate();
    init_differenceInCalendarDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInMilliseconds/index.js
function differenceInMilliseconds(dateLeft, dateRight) {
  requiredArgs(2, arguments);
  return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
}
var init_differenceInMilliseconds = __esm({
  "node_modules/date-fns/esm/differenceInMilliseconds/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/roundingMethods/index.js
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}
var roundingMap, defaultRoundingMethod;
var init_roundingMethods = __esm({
  "node_modules/date-fns/esm/_lib/roundingMethods/index.js"() {
    roundingMap = {
      ceil: Math.ceil,
      round: Math.round,
      floor: Math.floor,
      trunc: function trunc(value) {
        return value < 0 ? Math.ceil(value) : Math.floor(value);
      }
    };
    defaultRoundingMethod = "trunc";
  }
});

// node_modules/date-fns/esm/differenceInHours/index.js
function differenceInHours(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
var init_differenceInHours = __esm({
  "node_modules/date-fns/esm/differenceInHours/index.js"() {
    init_constants();
    init_differenceInMilliseconds();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/subISOWeekYears/index.js
function subISOWeekYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addISOWeekYears(dirtyDate, -amount);
}
var init_subISOWeekYears = __esm({
  "node_modules/date-fns/esm/subISOWeekYears/index.js"() {
    init_addISOWeekYears();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/differenceInISOWeekYears/index.js
function differenceInISOWeekYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarISOWeekYears(dateLeft, dateRight));
  dateLeft = subISOWeekYears(dateLeft, sign * difference);
  var isLastISOWeekYearNotFull = Number(compareAsc(dateLeft, dateRight) === -sign);
  var result = sign * (difference - isLastISOWeekYearNotFull);
  return result === 0 ? 0 : result;
}
var init_differenceInISOWeekYears = __esm({
  "node_modules/date-fns/esm/differenceInISOWeekYears/index.js"() {
    init_toDate();
    init_differenceInCalendarISOWeekYears();
    init_compareAsc();
    init_subISOWeekYears();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInMinutes/index.js
function differenceInMinutes(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
var init_differenceInMinutes = __esm({
  "node_modules/date-fns/esm/differenceInMinutes/index.js"() {
    init_constants();
    init_differenceInMilliseconds();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/endOfDay/index.js
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfDay = __esm({
  "node_modules/date-fns/esm/endOfDay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfMonth/index.js
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfMonth = __esm({
  "node_modules/date-fns/esm/endOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isLastDayOfMonth/index.js
function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return endOfDay(date).getTime() === endOfMonth(date).getTime();
}
var init_isLastDayOfMonth = __esm({
  "node_modules/date-fns/esm/isLastDayOfMonth/index.js"() {
    init_toDate();
    init_endOfDay();
    init_endOfMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/differenceInMonths/index.js
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  var result;
  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
    var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;
    if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign * (difference - Number(isLastMonthNotFull));
  }
  return result === 0 ? 0 : result;
}
var init_differenceInMonths = __esm({
  "node_modules/date-fns/esm/differenceInMonths/index.js"() {
    init_toDate();
    init_differenceInCalendarMonths();
    init_compareAsc();
    init_requiredArgs();
    init_isLastDayOfMonth();
  }
});

// node_modules/date-fns/esm/differenceInQuarters/index.js
function differenceInQuarters(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMonths(dateLeft, dateRight) / 3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
var init_differenceInQuarters = __esm({
  "node_modules/date-fns/esm/differenceInQuarters/index.js"() {
    init_differenceInMonths();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/differenceInSeconds/index.js
function differenceInSeconds(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
var init_differenceInSeconds = __esm({
  "node_modules/date-fns/esm/differenceInSeconds/index.js"() {
    init_differenceInMilliseconds();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/differenceInWeeks/index.js
function differenceInWeeks(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInDays(dateLeft, dateRight) / 7;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
var init_differenceInWeeks = __esm({
  "node_modules/date-fns/esm/differenceInWeeks/index.js"() {
    init_differenceInDays();
    init_requiredArgs();
    init_roundingMethods();
  }
});

// node_modules/date-fns/esm/differenceInYears/index.js
function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
  dateLeft.setFullYear(1584);
  dateRight.setFullYear(1584);
  var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign;
  var result = sign * (difference - Number(isLastYearNotFull));
  return result === 0 ? 0 : result;
}
var init_differenceInYears = __esm({
  "node_modules/date-fns/esm/differenceInYears/index.js"() {
    init_toDate();
    init_differenceInCalendarYears();
    init_compareAsc();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachDayOfInterval/index.js
function eachDayOfInterval(dirtyInterval, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}
var init_eachDayOfInterval = __esm({
  "node_modules/date-fns/esm/eachDayOfInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachHourOfInterval/index.js
function eachHourOfInterval(dirtyInterval, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var startTime = startDate.getTime();
  var endTime = endDate.getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setMinutes(0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate = addHours(currentDate, step);
  }
  return dates;
}
var init_eachHourOfInterval = __esm({
  "node_modules/date-fns/esm/eachHourOfInterval/index.js"() {
    init_addHours();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfMinute/index.js
function startOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setSeconds(0, 0);
  return date;
}
var init_startOfMinute = __esm({
  "node_modules/date-fns/esm/startOfMinute/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachMinuteOfInterval/index.js
function eachMinuteOfInterval(interval, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var startDate = startOfMinute(toDate(interval.start));
  var endDate = toDate(interval.end);
  var startTime = startDate.getTime();
  var endTime = endDate.getTime();
  if (startTime >= endTime) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number equal to or greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate = addMinutes(currentDate, step);
  }
  return dates;
}
var init_eachMinuteOfInterval = __esm({
  "node_modules/date-fns/esm/eachMinuteOfInterval/index.js"() {
    init_addMinutes();
    init_toDate();
    init_startOfMinute();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachMonthOfInterval/index.js
function eachMonthOfInterval(dirtyInterval) {
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  var dates = [];
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setDate(1);
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setMonth(currentDate.getMonth() + 1);
  }
  return dates;
}
var init_eachMonthOfInterval = __esm({
  "node_modules/date-fns/esm/eachMonthOfInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfQuarter/index.js
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfQuarter = __esm({
  "node_modules/date-fns/esm/startOfQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachQuarterOfInterval/index.js
function eachQuarterOfInterval(dirtyInterval) {
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var startDateQuarter = startOfQuarter(startDate);
  var endDateQuarter = startOfQuarter(endDate);
  endTime = endDateQuarter.getTime();
  var quarters = [];
  var currentQuarter = startDateQuarter;
  while (currentQuarter.getTime() <= endTime) {
    quarters.push(toDate(currentQuarter));
    currentQuarter = addQuarters(currentQuarter, 1);
  }
  return quarters;
}
var init_eachQuarterOfInterval = __esm({
  "node_modules/date-fns/esm/eachQuarterOfInterval/index.js"() {
    init_addQuarters();
    init_startOfQuarter();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachWeekOfInterval/index.js
function eachWeekOfInterval(dirtyInterval, options) {
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var startDateWeek = startOfWeek(startDate, options);
  var endDateWeek = startOfWeek(endDate, options);
  startDateWeek.setHours(15);
  endDateWeek.setHours(15);
  endTime = endDateWeek.getTime();
  var weeks = [];
  var currentWeek = startDateWeek;
  while (currentWeek.getTime() <= endTime) {
    currentWeek.setHours(0);
    weeks.push(toDate(currentWeek));
    currentWeek = addWeeks(currentWeek, 1);
    currentWeek.setHours(15);
  }
  return weeks;
}
var init_eachWeekOfInterval = __esm({
  "node_modules/date-fns/esm/eachWeekOfInterval/index.js"() {
    init_addWeeks();
    init_startOfWeek();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachWeekendOfInterval/index.js
function eachWeekendOfInterval(interval) {
  requiredArgs(1, arguments);
  var dateInterval = eachDayOfInterval(interval);
  var weekends = [];
  var index = 0;
  while (index < dateInterval.length) {
    var date = dateInterval[index++];
    if (isWeekend(date)) {
      weekends.push(date);
      if (isSunday(date))
        index = index + 5;
    }
  }
  return weekends;
}
var init_eachWeekendOfInterval = __esm({
  "node_modules/date-fns/esm/eachWeekendOfInterval/index.js"() {
    init_eachDayOfInterval();
    init_isSunday();
    init_isWeekend();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfMonth/index.js
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfMonth = __esm({
  "node_modules/date-fns/esm/startOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachWeekendOfMonth/index.js
function eachWeekendOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var startDate = startOfMonth(dirtyDate);
  if (isNaN(startDate.getTime()))
    throw new RangeError("The passed date is invalid");
  var endDate = endOfMonth(dirtyDate);
  return eachWeekendOfInterval({
    start: startDate,
    end: endDate
  });
}
var init_eachWeekendOfMonth = __esm({
  "node_modules/date-fns/esm/eachWeekendOfMonth/index.js"() {
    init_eachWeekendOfInterval();
    init_startOfMonth();
    init_endOfMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfYear/index.js
function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfYear = __esm({
  "node_modules/date-fns/esm/endOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfYear/index.js
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfYear = __esm({
  "node_modules/date-fns/esm/startOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachWeekendOfYear/index.js
function eachWeekendOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var startDate = startOfYear(dirtyDate);
  var endDate = endOfYear(dirtyDate);
  return eachWeekendOfInterval({
    start: startDate,
    end: endDate
  });
}
var init_eachWeekendOfYear = __esm({
  "node_modules/date-fns/esm/eachWeekendOfYear/index.js"() {
    init_eachWeekendOfInterval();
    init_endOfYear();
    init_startOfYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/eachYearOfInterval/index.js
function eachYearOfInterval(dirtyInterval) {
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  currentDate.setMonth(0, 1);
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setFullYear(currentDate.getFullYear() + 1);
  }
  return dates;
}
var init_eachYearOfInterval = __esm({
  "node_modules/date-fns/esm/eachYearOfInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfDecade/index.js
function endOfDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var decade = 9 + Math.floor(year / 10) * 10;
  date.setFullYear(decade, 11, 31);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfDecade = __esm({
  "node_modules/date-fns/esm/endOfDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfHour/index.js
function endOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMinutes(59, 59, 999);
  return date;
}
var init_endOfHour = __esm({
  "node_modules/date-fns/esm/endOfHour/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfWeek/index.js
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfWeek = __esm({
  "node_modules/date-fns/esm/endOfWeek/index.js"() {
    init_defaultOptions();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfISOWeek/index.js
function endOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return endOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
var init_endOfISOWeek = __esm({
  "node_modules/date-fns/esm/endOfISOWeek/index.js"() {
    init_endOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfISOWeekYear/index.js
function endOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuaryOfNextYear);
  date.setMilliseconds(date.getMilliseconds() - 1);
  return date;
}
var init_endOfISOWeekYear = __esm({
  "node_modules/date-fns/esm/endOfISOWeekYear/index.js"() {
    init_getISOWeekYear();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfMinute/index.js
function endOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setSeconds(59, 999);
  return date;
}
var init_endOfMinute = __esm({
  "node_modules/date-fns/esm/endOfMinute/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfQuarter/index.js
function endOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date.setMonth(month, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfQuarter = __esm({
  "node_modules/date-fns/esm/endOfQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfSecond/index.js
function endOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMilliseconds(999);
  return date;
}
var init_endOfSecond = __esm({
  "node_modules/date-fns/esm/endOfSecond/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/endOfToday/index.js
function endOfToday() {
  return endOfDay(Date.now());
}
var init_endOfToday = __esm({
  "node_modules/date-fns/esm/endOfToday/index.js"() {
    init_endOfDay();
  }
});

// node_modules/date-fns/esm/endOfTomorrow/index.js
function endOfTomorrow() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfTomorrow = __esm({
  "node_modules/date-fns/esm/endOfTomorrow/index.js"() {
  }
});

// node_modules/date-fns/esm/endOfYesterday/index.js
function endOfYesterday() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(23, 59, 59, 999);
  return date;
}
var init_endOfYesterday = __esm({
  "node_modules/date-fns/esm/endOfYesterday/index.js"() {
  }
});

// node_modules/date-fns/esm/subMilliseconds/index.js
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var init_subMilliseconds = __esm({
  "node_modules/date-fns/esm/subMilliseconds/index.js"() {
    init_addMilliseconds();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY2) + 1;
}
var MILLISECONDS_IN_DAY2;
var init_getUTCDayOfYear = __esm({
  "node_modules/date-fns/esm/_lib/getUTCDayOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
    MILLISECONDS_IN_DAY2 = 864e5;
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
var init_startOfUTCISOWeek = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getUTCISOWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_startOfUTCISOWeek();
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var init_startOfUTCISOWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js"() {
    init_getUTCISOWeekYear();
    init_startOfUTCISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK3) + 1;
}
var MILLISECONDS_IN_WEEK3;
var init_getUTCISOWeek = __esm({
  "node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js"() {
    init_toDate();
    init_startOfUTCISOWeek();
    init_startOfUTCISOWeekYear();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK3 = 6048e5;
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
var init_startOfUTCWeek = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getUTCWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_startOfUTCWeek();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var init_startOfUTCWeekYear = __esm({
  "node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js"() {
    init_getUTCWeekYear();
    init_requiredArgs();
    init_startOfUTCWeek();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK4) + 1;
}
var MILLISECONDS_IN_WEEK4;
var init_getUTCWeek = __esm({
  "node_modules/date-fns/esm/_lib/getUTCWeek/index.js"() {
    init_toDate();
    init_startOfUTCWeek();
    init_startOfUTCWeekYear();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK4 = 6048e5;
  }
});

// node_modules/date-fns/esm/_lib/addLeadingZeros/index.js
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var init_addLeadingZeros = __esm({
  "node_modules/date-fns/esm/_lib/addLeadingZeros/index.js"() {
  }
});

// node_modules/date-fns/esm/_lib/format/lightFormatters/index.js
var formatters, lightFormatters_default;
var init_lightFormatters = __esm({
  "node_modules/date-fns/esm/_lib/format/lightFormatters/index.js"() {
    init_addLeadingZeros();
    formatters = {
      y: function y(date, token) {
        var signedYear = date.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
      },
      M: function M(date, token) {
        var month = date.getUTCMonth();
        return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      d: function d(date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      a: function a(date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      h: function h(date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      H: function H(date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      m: function m(date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      s: function s(date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      S: function S(date, token) {
        var numberOfDigits = token.length;
        var milliseconds2 = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds2 * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };
    lightFormatters_default = formatters;
  }
});

// node_modules/date-fns/esm/_lib/format/formatters/index.js
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var dayPeriodEnum, formatters2, formatters_default;
var init_formatters = __esm({
  "node_modules/date-fns/esm/_lib/format/formatters/index.js"() {
    init_getUTCDayOfYear();
    init_getUTCISOWeek();
    init_getUTCISOWeekYear();
    init_getUTCWeek();
    init_getUTCWeekYear();
    init_addLeadingZeros();
    init_lightFormatters();
    dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    formatters2 = {
      G: function G(date, token, localize2) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return localize2.era(era, {
              width: "abbreviated"
            });
          case "GGGGG":
            return localize2.era(era, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return localize2.era(era, {
              width: "wide"
            });
        }
      },
      y: function y2(date, token, localize2) {
        if (token === "yo") {
          var signedYear = date.getUTCFullYear();
          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize2.ordinalNumber(year, {
            unit: "year"
          });
        }
        return lightFormatters_default.y(date, token);
      },
      Y: function Y(date, token, localize2, options) {
        var signedWeekYear = getUTCWeekYear(date, options);
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize2.ordinalNumber(weekYear, {
            unit: "year"
          });
        }
        return addLeadingZeros(weekYear, token.length);
      },
      R: function R(date, token) {
        var isoWeekYear = getUTCISOWeekYear(date);
        return addLeadingZeros(isoWeekYear, token.length);
      },
      u: function u(date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      Q: function Q(date, token, localize2) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          case "Q":
            return String(quarter);
          case "QQ":
            return addLeadingZeros(quarter, 2);
          case "Qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "QQQ":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      q: function q(date, token, localize2) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
        switch (token) {
          case "q":
            return String(quarter);
          case "qq":
            return addLeadingZeros(quarter, 2);
          case "qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "qqq":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      M: function M2(date, token, localize2) {
        var month = date.getUTCMonth();
        switch (token) {
          case "M":
          case "MM":
            return lightFormatters_default.M(date, token);
          case "Mo":
            return localize2.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "MMM":
            return localize2.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize2.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize2.month(month, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      L: function L(date, token, localize2) {
        var month = date.getUTCMonth();
        switch (token) {
          case "L":
            return String(month + 1);
          case "LL":
            return addLeadingZeros(month + 1, 2);
          case "Lo":
            return localize2.ordinalNumber(month + 1, {
              unit: "month"
            });
          case "LLL":
            return localize2.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize2.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize2.month(month, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      w: function w(date, token, localize2, options) {
        var week = getUTCWeek(date, options);
        if (token === "wo") {
          return localize2.ordinalNumber(week, {
            unit: "week"
          });
        }
        return addLeadingZeros(week, token.length);
      },
      I: function I(date, token, localize2) {
        var isoWeek = getUTCISOWeek(date);
        if (token === "Io") {
          return localize2.ordinalNumber(isoWeek, {
            unit: "week"
          });
        }
        return addLeadingZeros(isoWeek, token.length);
      },
      d: function d2(date, token, localize2) {
        if (token === "do") {
          return localize2.ordinalNumber(date.getUTCDate(), {
            unit: "date"
          });
        }
        return lightFormatters_default.d(date, token);
      },
      D: function D(date, token, localize2) {
        var dayOfYear = getUTCDayOfYear(date);
        if (token === "Do") {
          return localize2.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
          });
        }
        return addLeadingZeros(dayOfYear, token.length);
      },
      E: function E(date, token, localize2) {
        var dayOfWeek = date.getUTCDay();
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      e: function e(date, token, localize2, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return addLeadingZeros(localDayOfWeek, 2);
          case "eo":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "eee":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      c: function c(date, token, localize2, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return addLeadingZeros(localDayOfWeek, token.length);
          case "co":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "ccc":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      i: function i(date, token, localize2) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return addLeadingZeros(isoDayOfWeek, token.length);
          case "io":
            return localize2.ordinalNumber(isoDayOfWeek, {
              unit: "day"
            });
          case "iii":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      a: function a2(date, token, localize2) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      b: function b(date, token, localize2) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      B: function B(date, token, localize2) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      h: function h2(date, token, localize2) {
        if (token === "ho") {
          var hours = date.getUTCHours() % 12;
          if (hours === 0)
            hours = 12;
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return lightFormatters_default.h(date, token);
      },
      H: function H2(date, token, localize2) {
        if (token === "Ho") {
          return localize2.ordinalNumber(date.getUTCHours(), {
            unit: "hour"
          });
        }
        return lightFormatters_default.H(date, token);
      },
      K: function K(date, token, localize2) {
        var hours = date.getUTCHours() % 12;
        if (token === "Ko") {
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      k: function k(date, token, localize2) {
        var hours = date.getUTCHours();
        if (hours === 0)
          hours = 24;
        if (token === "ko") {
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      m: function m2(date, token, localize2) {
        if (token === "mo") {
          return localize2.ordinalNumber(date.getUTCMinutes(), {
            unit: "minute"
          });
        }
        return lightFormatters_default.m(date, token);
      },
      s: function s2(date, token, localize2) {
        if (token === "so") {
          return localize2.ordinalNumber(date.getUTCSeconds(), {
            unit: "second"
          });
        }
        return lightFormatters_default.s(date, token);
      },
      S: function S2(date, token) {
        return lightFormatters_default.S(date, token);
      },
      X: function X(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      x: function x(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      O: function O(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      z: function z(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      t: function t(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1e3);
        return addLeadingZeros(timestamp, token.length);
      },
      T: function T(date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };
    formatters_default = formatters2;
  }
});

// node_modules/date-fns/esm/_lib/format/longFormatters/index.js
var dateLongFormatter, timeLongFormatter, dateTimeLongFormatter, longFormatters, longFormatters_default;
var init_longFormatters = __esm({
  "node_modules/date-fns/esm/_lib/format/longFormatters/index.js"() {
    dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
      switch (pattern) {
        case "P":
          return formatLong2.date({
            width: "short"
          });
        case "PP":
          return formatLong2.date({
            width: "medium"
          });
        case "PPP":
          return formatLong2.date({
            width: "long"
          });
        case "PPPP":
        default:
          return formatLong2.date({
            width: "full"
          });
      }
    };
    timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
      switch (pattern) {
        case "p":
          return formatLong2.time({
            width: "short"
          });
        case "pp":
          return formatLong2.time({
            width: "medium"
          });
        case "ppp":
          return formatLong2.time({
            width: "long"
          });
        case "pppp":
        default:
          return formatLong2.time({
            width: "full"
          });
      }
    };
    dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
      var matchResult = pattern.match(/(P+)(p+)?/) || [];
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong2);
      }
      var dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong2.dateTime({
            width: "short"
          });
          break;
        case "PP":
          dateTimeFormat = formatLong2.dateTime({
            width: "medium"
          });
          break;
        case "PPP":
          dateTimeFormat = formatLong2.dateTime({
            width: "long"
          });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong2.dateTime({
            width: "full"
          });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
    };
    longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    longFormatters_default = longFormatters;
  }
});

// node_modules/date-fns/esm/_lib/protectedTokens/index.js
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var protectedDayOfYearTokens, protectedWeekYearTokens;
var init_protectedTokens = __esm({
  "node_modules/date-fns/esm/_lib/protectedTokens/index.js"() {
    protectedDayOfYearTokens = ["D", "DD"];
    protectedWeekYearTokens = ["YY", "YYYY"];
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js
var formatDistanceLocale, formatDistance, formatDistance_default;
var init_formatDistance = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/formatDistance/index.js"() {
    formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    formatDistance = function formatDistance2(token, count, options) {
      var result;
      var tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options !== null && options !== void 0 && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    formatDistance_default = formatDistance;
  }
});

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var init_buildFormatLongFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats, timeFormats, dateTimeFormats, formatLong, formatLong_default;
var init_formatLong = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js"() {
    init_buildFormatLongFn();
    dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    formatLong_default = formatLong;
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js
var formatRelativeLocale, formatRelative, formatRelative_default;
var init_formatRelative = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/formatRelative/index.js"() {
    formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    };
    formatRelative_default = formatRelative;
  }
});

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
var init_buildLocalizeFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues, quarterValues, monthValues, dayValues, dayPeriodValues, formattingDayPeriodValues, ordinalNumber, localize, localize_default;
var init_localize = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js"() {
    init_buildLocalizeFn();
    eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };
    dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
      var number = Number(dirtyNumber);
      var rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + "st";
          case 2:
            return number + "nd";
          case 3:
            return number + "rd";
        }
      }
      return number + "th";
    };
    localize = {
      ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function argumentCallback(quarter) {
          return quarter - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    localize_default = localize;
  }
});

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
var init_buildMatchFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var init_buildMatchPatternFn = __esm({
  "node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js"() {
  }
});

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern, parseOrdinalNumberPattern, matchEraPatterns, parseEraPatterns, matchQuarterPatterns, parseQuarterPatterns, matchMonthPatterns, parseMonthPatterns, matchDayPatterns, parseDayPatterns, matchDayPeriodPatterns, parseDayPeriodPatterns, match, match_default;
var init_match = __esm({
  "node_modules/date-fns/esm/locale/en-US/_lib/match/index.js"() {
    init_buildMatchFn();
    init_buildMatchPatternFn();
    matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    parseOrdinalNumberPattern = /\d+/i;
    matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function valueCallback2(index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    match_default = match;
  }
});

// node_modules/date-fns/esm/locale/en-US/index.js
var locale, en_US_default;
var init_en_US = __esm({
  "node_modules/date-fns/esm/locale/en-US/index.js"() {
    init_formatDistance();
    init_formatLong();
    init_formatRelative();
    init_localize();
    init_match();
    locale = {
      code: "en-US",
      formatDistance: formatDistance_default,
      formatLong: formatLong_default,
      formatRelative: formatRelative_default,
      localize: localize_default,
      match: match_default,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    en_US_default = locale;
  }
});

// node_modules/date-fns/esm/_lib/defaultLocale/index.js
var defaultLocale_default;
var init_defaultLocale = __esm({
  "node_modules/date-fns/esm/_lib/defaultLocale/index.js"() {
    init_en_US();
    defaultLocale_default = en_US_default;
  }
});

// node_modules/date-fns/esm/format/index.js
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters_default[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
var formattingTokensRegExp, longFormattingTokensRegExp, escapedStringRegExp, doubleQuoteRegExp, unescapedLatinCharacterRegExp;
var init_format = __esm({
  "node_modules/date-fns/esm/format/index.js"() {
    init_isValid();
    init_subMilliseconds();
    init_toDate();
    init_formatters();
    init_longFormatters();
    init_getTimezoneOffsetInMilliseconds();
    init_protectedTokens();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
    init_defaultLocale();
    formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp = /^'([^]*?)'?$/;
    doubleQuoteRegExp = /''/g;
    unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  }
});

// node_modules/date-fns/esm/_lib/assign/index.js
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      ;
      target[property] = object[property];
    }
  }
  return target;
}
var init_assign = __esm({
  "node_modules/date-fns/esm/_lib/assign/index.js"() {
  }
});

// node_modules/date-fns/esm/_lib/cloneObject/index.js
function cloneObject(object) {
  return assign({}, object);
}
var init_cloneObject = __esm({
  "node_modules/date-fns/esm/_lib/cloneObject/index.js"() {
    init_assign();
  }
});

// node_modules/date-fns/esm/formatDistance/index.js
function formatDistance3(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  if (!locale2.formatDistance) {
    throw new RangeError("locale must contain formatDistance property");
  }
  var comparison = compareAsc(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  var localizeOptions = assign(cloneObject(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = toDate(dirtyBaseDate);
    dateRight = toDate(dirtyDate);
  } else {
    dateLeft = toDate(dirtyDate);
    dateRight = toDate(dirtyBaseDate);
  }
  var seconds = differenceInSeconds(dateRight, dateLeft);
  var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
  var minutes = Math.round((seconds - offsetInSeconds) / 60);
  var months2;
  if (minutes < 2) {
    if (options !== null && options !== void 0 && options.includeSeconds) {
      if (seconds < 5) {
        return locale2.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale2.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale2.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale2.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale2.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale2.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale2.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale2.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale2.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale2.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < MINUTES_IN_DAY) {
    var hours = Math.round(minutes / 60);
    return locale2.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
    return locale2.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < MINUTES_IN_MONTH) {
    var days2 = Math.round(minutes / MINUTES_IN_DAY);
    return locale2.formatDistance("xDays", days2, localizeOptions);
  } else if (minutes < MINUTES_IN_TWO_MONTHS) {
    months2 = Math.round(minutes / MINUTES_IN_MONTH);
    return locale2.formatDistance("aboutXMonths", months2, localizeOptions);
  }
  months2 = differenceInMonths(dateRight, dateLeft);
  if (months2 < 12) {
    var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
    return locale2.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    var monthsSinceStartOfYear = months2 % 12;
    var years = Math.floor(months2 / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale2.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale2.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale2.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}
var MINUTES_IN_DAY, MINUTES_IN_ALMOST_TWO_DAYS, MINUTES_IN_MONTH, MINUTES_IN_TWO_MONTHS;
var init_formatDistance2 = __esm({
  "node_modules/date-fns/esm/formatDistance/index.js"() {
    init_defaultOptions();
    init_compareAsc();
    init_differenceInMonths();
    init_differenceInSeconds();
    init_defaultLocale();
    init_toDate();
    init_cloneObject();
    init_assign();
    init_getTimezoneOffsetInMilliseconds();
    init_requiredArgs();
    MINUTES_IN_DAY = 1440;
    MINUTES_IN_ALMOST_TWO_DAYS = 2520;
    MINUTES_IN_MONTH = 43200;
    MINUTES_IN_TWO_MONTHS = 86400;
  }
});

// node_modules/date-fns/esm/formatDistanceStrict/index.js
function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale, _options$roundingMeth;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  if (!locale2.formatDistance) {
    throw new RangeError("locale must contain localize.formatDistance property");
  }
  var comparison = compareAsc(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  var localizeOptions = assign(cloneObject(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = toDate(dirtyBaseDate);
    dateRight = toDate(dirtyDate);
  } else {
    dateLeft = toDate(dirtyDate);
    dateRight = toDate(dirtyBaseDate);
  }
  var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : "round");
  var roundingMethodFn;
  if (roundingMethod === "floor") {
    roundingMethodFn = Math.floor;
  } else if (roundingMethod === "ceil") {
    roundingMethodFn = Math.ceil;
  } else if (roundingMethod === "round") {
    roundingMethodFn = Math.round;
  } else {
    throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
  }
  var milliseconds2 = dateRight.getTime() - dateLeft.getTime();
  var minutes = milliseconds2 / MILLISECONDS_IN_MINUTE2;
  var timezoneOffset = getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft);
  var dstNormalizedMinutes = (milliseconds2 - timezoneOffset) / MILLISECONDS_IN_MINUTE2;
  var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
  var unit;
  if (!defaultUnit) {
    if (minutes < 1) {
      unit = "second";
    } else if (minutes < 60) {
      unit = "minute";
    } else if (minutes < MINUTES_IN_DAY2) {
      unit = "hour";
    } else if (dstNormalizedMinutes < MINUTES_IN_MONTH2) {
      unit = "day";
    } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
      unit = "month";
    } else {
      unit = "year";
    }
  } else {
    unit = String(defaultUnit);
  }
  if (unit === "second") {
    var seconds = roundingMethodFn(milliseconds2 / 1e3);
    return locale2.formatDistance("xSeconds", seconds, localizeOptions);
  } else if (unit === "minute") {
    var roundedMinutes = roundingMethodFn(minutes);
    return locale2.formatDistance("xMinutes", roundedMinutes, localizeOptions);
  } else if (unit === "hour") {
    var hours = roundingMethodFn(minutes / 60);
    return locale2.formatDistance("xHours", hours, localizeOptions);
  } else if (unit === "day") {
    var days2 = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY2);
    return locale2.formatDistance("xDays", days2, localizeOptions);
  } else if (unit === "month") {
    var months2 = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH2);
    return months2 === 12 && defaultUnit !== "month" ? locale2.formatDistance("xYears", 1, localizeOptions) : locale2.formatDistance("xMonths", months2, localizeOptions);
  } else if (unit === "year") {
    var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
    return locale2.formatDistance("xYears", years, localizeOptions);
  }
  throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
}
var MILLISECONDS_IN_MINUTE2, MINUTES_IN_DAY2, MINUTES_IN_MONTH2, MINUTES_IN_YEAR;
var init_formatDistanceStrict = __esm({
  "node_modules/date-fns/esm/formatDistanceStrict/index.js"() {
    init_defaultOptions();
    init_getTimezoneOffsetInMilliseconds();
    init_compareAsc();
    init_toDate();
    init_cloneObject();
    init_assign();
    init_defaultLocale();
    init_requiredArgs();
    MILLISECONDS_IN_MINUTE2 = 1e3 * 60;
    MINUTES_IN_DAY2 = 60 * 24;
    MINUTES_IN_MONTH2 = MINUTES_IN_DAY2 * 30;
    MINUTES_IN_YEAR = MINUTES_IN_DAY2 * 365;
  }
});

// node_modules/date-fns/esm/formatDistanceToNow/index.js
function formatDistanceToNow(dirtyDate, options) {
  requiredArgs(1, arguments);
  return formatDistance3(dirtyDate, Date.now(), options);
}
var init_formatDistanceToNow = __esm({
  "node_modules/date-fns/esm/formatDistanceToNow/index.js"() {
    init_formatDistance2();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatDistanceToNowStrict/index.js
function formatDistanceToNowStrict(dirtyDate, options) {
  requiredArgs(1, arguments);
  return formatDistanceStrict(dirtyDate, Date.now(), options);
}
var init_formatDistanceToNowStrict = __esm({
  "node_modules/date-fns/esm/formatDistanceToNowStrict/index.js"() {
    init_formatDistanceStrict();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatDuration/index.js
function formatDuration(duration, options) {
  var _ref, _options$locale, _options$format, _options$zero, _options$delimiter;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
  }
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  var format2 = (_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : defaultFormat;
  var zero = (_options$zero = options === null || options === void 0 ? void 0 : options.zero) !== null && _options$zero !== void 0 ? _options$zero : false;
  var delimiter = (_options$delimiter = options === null || options === void 0 ? void 0 : options.delimiter) !== null && _options$delimiter !== void 0 ? _options$delimiter : " ";
  if (!locale2.formatDistance) {
    return "";
  }
  var result = format2.reduce(function(acc, unit) {
    var token = "x".concat(unit.replace(/(^.)/, function(m3) {
      return m3.toUpperCase();
    }));
    var value = duration[unit];
    if (typeof value === "number" && (zero || duration[unit])) {
      return acc.concat(locale2.formatDistance(token, value));
    }
    return acc;
  }, []).join(delimiter);
  return result;
}
var defaultFormat;
var init_formatDuration = __esm({
  "node_modules/date-fns/esm/formatDuration/index.js"() {
    init_defaultOptions();
    init_defaultLocale();
    defaultFormat = ["years", "months", "weeks", "days", "hours", "minutes", "seconds"];
  }
});

// node_modules/date-fns/esm/formatISO/index.js
function formatISO(date, options) {
  var _options$format, _options$representati;
  requiredArgs(1, arguments);
  var originalDate = toDate(date);
  if (isNaN(originalDate.getTime())) {
    throw new RangeError("Invalid time value");
  }
  var format2 = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : "extended");
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : "complete");
  if (format2 !== "extended" && format2 !== "basic") {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== "date" && representation !== "time" && representation !== "complete") {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = "";
  var tzOffset = "";
  var dateDelimiter = format2 === "extended" ? "-" : "";
  var timeDelimiter = format2 === "extended" ? ":" : "";
  if (representation !== "time") {
    var day = addLeadingZeros(originalDate.getDate(), 2);
    var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros(originalDate.getFullYear(), 4);
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }
  if (representation !== "date") {
    var offset = originalDate.getTimezoneOffset();
    if (offset !== 0) {
      var absoluteOffset = Math.abs(offset);
      var hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2);
      var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
      var sign = offset < 0 ? "+" : "-";
      tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      tzOffset = "Z";
    }
    var hour = addLeadingZeros(originalDate.getHours(), 2);
    var minute = addLeadingZeros(originalDate.getMinutes(), 2);
    var second = addLeadingZeros(originalDate.getSeconds(), 2);
    var separator = result === "" ? "" : "T";
    var time = [hour, minute, second].join(timeDelimiter);
    result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
  }
  return result;
}
var init_formatISO = __esm({
  "node_modules/date-fns/esm/formatISO/index.js"() {
    init_toDate();
    init_addLeadingZeros();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatISO9075/index.js
function formatISO9075(dirtyDate, options) {
  var _options$format, _options$representati;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var format2 = String((_options$format = options === null || options === void 0 ? void 0 : options.format) !== null && _options$format !== void 0 ? _options$format : "extended");
  var representation = String((_options$representati = options === null || options === void 0 ? void 0 : options.representation) !== null && _options$representati !== void 0 ? _options$representati : "complete");
  if (format2 !== "extended" && format2 !== "basic") {
    throw new RangeError("format must be 'extended' or 'basic'");
  }
  if (representation !== "date" && representation !== "time" && representation !== "complete") {
    throw new RangeError("representation must be 'date', 'time', or 'complete'");
  }
  var result = "";
  var dateDelimiter = format2 === "extended" ? "-" : "";
  var timeDelimiter = format2 === "extended" ? ":" : "";
  if (representation !== "time") {
    var day = addLeadingZeros(originalDate.getDate(), 2);
    var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
    var year = addLeadingZeros(originalDate.getFullYear(), 4);
    result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
  }
  if (representation !== "date") {
    var hour = addLeadingZeros(originalDate.getHours(), 2);
    var minute = addLeadingZeros(originalDate.getMinutes(), 2);
    var second = addLeadingZeros(originalDate.getSeconds(), 2);
    var separator = result === "" ? "" : " ";
    result = "".concat(result).concat(separator).concat(hour).concat(timeDelimiter).concat(minute).concat(timeDelimiter).concat(second);
  }
  return result;
}
var init_formatISO9075 = __esm({
  "node_modules/date-fns/esm/formatISO9075/index.js"() {
    init_toDate();
    init_isValid();
    init_addLeadingZeros();
  }
});

// node_modules/date-fns/esm/formatISODuration/index.js
function formatISODuration(duration) {
  requiredArgs(1, arguments);
  if (_typeof(duration) !== "object")
    throw new Error("Duration must be an object");
  var _duration$years = duration.years, years = _duration$years === void 0 ? 0 : _duration$years, _duration$months = duration.months, months2 = _duration$months === void 0 ? 0 : _duration$months, _duration$days = duration.days, days2 = _duration$days === void 0 ? 0 : _duration$days, _duration$hours = duration.hours, hours = _duration$hours === void 0 ? 0 : _duration$hours, _duration$minutes = duration.minutes, minutes = _duration$minutes === void 0 ? 0 : _duration$minutes, _duration$seconds = duration.seconds, seconds = _duration$seconds === void 0 ? 0 : _duration$seconds;
  return "P".concat(years, "Y").concat(months2, "M").concat(days2, "DT").concat(hours, "H").concat(minutes, "M").concat(seconds, "S");
}
var init_formatISODuration = __esm({
  "node_modules/date-fns/esm/formatISODuration/index.js"() {
    init_typeof();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/formatRFC3339/index.js
function formatRFC3339(dirtyDate, options) {
  var _options$fractionDigi;
  if (arguments.length < 1) {
    throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var fractionDigits = Number((_options$fractionDigi = options === null || options === void 0 ? void 0 : options.fractionDigits) !== null && _options$fractionDigi !== void 0 ? _options$fractionDigi : 0);
  if (!(fractionDigits >= 0 && fractionDigits <= 3)) {
    throw new RangeError("fractionDigits must be between 0 and 3 inclusively");
  }
  var day = addLeadingZeros(originalDate.getDate(), 2);
  var month = addLeadingZeros(originalDate.getMonth() + 1, 2);
  var year = originalDate.getFullYear();
  var hour = addLeadingZeros(originalDate.getHours(), 2);
  var minute = addLeadingZeros(originalDate.getMinutes(), 2);
  var second = addLeadingZeros(originalDate.getSeconds(), 2);
  var fractionalSecond = "";
  if (fractionDigits > 0) {
    var milliseconds2 = originalDate.getMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds2 * Math.pow(10, fractionDigits - 3));
    fractionalSecond = "." + addLeadingZeros(fractionalSeconds, fractionDigits);
  }
  var offset = "";
  var tzOffset = originalDate.getTimezoneOffset();
  if (tzOffset !== 0) {
    var absoluteOffset = Math.abs(tzOffset);
    var hourOffset = addLeadingZeros(toInteger(absoluteOffset / 60), 2);
    var minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
    var sign = tzOffset < 0 ? "+" : "-";
    offset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
  } else {
    offset = "Z";
  }
  return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(second).concat(fractionalSecond).concat(offset);
}
var init_formatRFC3339 = __esm({
  "node_modules/date-fns/esm/formatRFC3339/index.js"() {
    init_toDate();
    init_isValid();
    init_addLeadingZeros();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/formatRFC7231/index.js
function formatRFC7231(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var dayName = days[originalDate.getUTCDay()];
  var dayOfMonth = addLeadingZeros(originalDate.getUTCDate(), 2);
  var monthName = months[originalDate.getUTCMonth()];
  var year = originalDate.getUTCFullYear();
  var hour = addLeadingZeros(originalDate.getUTCHours(), 2);
  var minute = addLeadingZeros(originalDate.getUTCMinutes(), 2);
  var second = addLeadingZeros(originalDate.getUTCSeconds(), 2);
  return "".concat(dayName, ", ").concat(dayOfMonth, " ").concat(monthName, " ").concat(year, " ").concat(hour, ":").concat(minute, ":").concat(second, " GMT");
}
var days, months;
var init_formatRFC7231 = __esm({
  "node_modules/date-fns/esm/formatRFC7231/index.js"() {
    init_toDate();
    init_isValid();
    init_addLeadingZeros();
    days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  }
});

// node_modules/date-fns/esm/formatRelative/index.js
function formatRelative3(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$weekStartsOn, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var baseDate = toDate(dirtyBaseDate);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  var weekStartsOn = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.weekStartsOn) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  if (!locale2.formatRelative) {
    throw new RangeError("locale must contain formatRelative property");
  }
  var diff = differenceInCalendarDays(date, baseDate);
  if (isNaN(diff)) {
    throw new RangeError("Invalid time value");
  }
  var token;
  if (diff < -6) {
    token = "other";
  } else if (diff < -1) {
    token = "lastWeek";
  } else if (diff < 0) {
    token = "yesterday";
  } else if (diff < 1) {
    token = "today";
  } else if (diff < 2) {
    token = "tomorrow";
  } else if (diff < 7) {
    token = "nextWeek";
  } else {
    token = "other";
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var utcBaseDate = subMilliseconds(baseDate, getTimezoneOffsetInMilliseconds(baseDate));
  var formatStr = locale2.formatRelative(token, utcDate, utcBaseDate, {
    locale: locale2,
    weekStartsOn
  });
  return format(date, formatStr, {
    locale: locale2,
    weekStartsOn
  });
}
var init_formatRelative2 = __esm({
  "node_modules/date-fns/esm/formatRelative/index.js"() {
    init_defaultOptions();
    init_differenceInCalendarDays();
    init_format();
    init_defaultLocale();
    init_subMilliseconds();
    init_toDate();
    init_getTimezoneOffsetInMilliseconds();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/fromUnixTime/index.js
function fromUnixTime(dirtyUnixTime) {
  requiredArgs(1, arguments);
  var unixTime = toInteger(dirtyUnixTime);
  return toDate(unixTime * 1e3);
}
var init_fromUnixTime = __esm({
  "node_modules/date-fns/esm/fromUnixTime/index.js"() {
    init_toDate();
    init_toInteger();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDate/index.js
function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}
var init_getDate = __esm({
  "node_modules/date-fns/esm/getDate/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDay/index.js
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}
var init_getDay = __esm({
  "node_modules/date-fns/esm/getDay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDayOfYear/index.js
function getDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = differenceInCalendarDays(date, startOfYear(date));
  var dayOfYear = diff + 1;
  return dayOfYear;
}
var init_getDayOfYear = __esm({
  "node_modules/date-fns/esm/getDayOfYear/index.js"() {
    init_toDate();
    init_startOfYear();
    init_differenceInCalendarDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDaysInMonth/index.js
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth2 = new Date(0);
  lastDayOfMonth2.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth2.setHours(0, 0, 0, 0);
  return lastDayOfMonth2.getDate();
}
var init_getDaysInMonth = __esm({
  "node_modules/date-fns/esm/getDaysInMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isLeapYear/index.js
function isLeapYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var init_isLeapYear = __esm({
  "node_modules/date-fns/esm/isLeapYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDaysInYear/index.js
function getDaysInYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  if (String(new Date(date)) === "Invalid Date") {
    return NaN;
  }
  return isLeapYear(date) ? 366 : 365;
}
var init_getDaysInYear = __esm({
  "node_modules/date-fns/esm/getDaysInYear/index.js"() {
    init_toDate();
    init_isLeapYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDecade/index.js
function getDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var decade = Math.floor(year / 10) * 10;
  return decade;
}
var init_getDecade = __esm({
  "node_modules/date-fns/esm/getDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getDefaultOptions/index.js
function getDefaultOptions2() {
  return assign({}, getDefaultOptions());
}
var init_getDefaultOptions = __esm({
  "node_modules/date-fns/esm/getDefaultOptions/index.js"() {
    init_defaultOptions();
    init_assign();
  }
});

// node_modules/date-fns/esm/getHours/index.js
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}
var init_getHours = __esm({
  "node_modules/date-fns/esm/getHours/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getISODay/index.js
function getISODay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}
var init_getISODay = __esm({
  "node_modules/date-fns/esm/getISODay/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getISOWeek/index.js
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK5) + 1;
}
var MILLISECONDS_IN_WEEK5;
var init_getISOWeek = __esm({
  "node_modules/date-fns/esm/getISOWeek/index.js"() {
    init_toDate();
    init_startOfISOWeek();
    init_startOfISOWeekYear();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK5 = 6048e5;
  }
});

// node_modules/date-fns/esm/getISOWeeksInYear/index.js
function getISOWeeksInYear(dirtyDate) {
  requiredArgs(1, arguments);
  var thisYear = startOfISOWeekYear(dirtyDate);
  var nextYear = startOfISOWeekYear(addWeeks(thisYear, 60));
  var diff = nextYear.valueOf() - thisYear.valueOf();
  return Math.round(diff / MILLISECONDS_IN_WEEK6);
}
var MILLISECONDS_IN_WEEK6;
var init_getISOWeeksInYear = __esm({
  "node_modules/date-fns/esm/getISOWeeksInYear/index.js"() {
    init_startOfISOWeekYear();
    init_addWeeks();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK6 = 6048e5;
  }
});

// node_modules/date-fns/esm/getMilliseconds/index.js
function getMilliseconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var milliseconds2 = date.getMilliseconds();
  return milliseconds2;
}
var init_getMilliseconds = __esm({
  "node_modules/date-fns/esm/getMilliseconds/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getMinutes/index.js
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}
var init_getMinutes = __esm({
  "node_modules/date-fns/esm/getMinutes/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getMonth/index.js
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}
var init_getMonth = __esm({
  "node_modules/date-fns/esm/getMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js
function getOverlappingDaysInIntervals(dirtyIntervalLeft, dirtyIntervalRight) {
  requiredArgs(2, arguments);
  var intervalLeft = dirtyIntervalLeft || {};
  var intervalRight = dirtyIntervalRight || {};
  var leftStartTime = toDate(intervalLeft.start).getTime();
  var leftEndTime = toDate(intervalLeft.end).getTime();
  var rightStartTime = toDate(intervalRight.start).getTime();
  var rightEndTime = toDate(intervalRight.end).getTime();
  if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
    throw new RangeError("Invalid interval");
  }
  var isOverlapping = leftStartTime < rightEndTime && rightStartTime < leftEndTime;
  if (!isOverlapping) {
    return 0;
  }
  var overlapStartDate = rightStartTime < leftStartTime ? leftStartTime : rightStartTime;
  var overlapEndDate = rightEndTime > leftEndTime ? leftEndTime : rightEndTime;
  var differenceInMs = overlapEndDate - overlapStartDate;
  return Math.ceil(differenceInMs / MILLISECONDS_IN_DAY3);
}
var MILLISECONDS_IN_DAY3;
var init_getOverlappingDaysInIntervals = __esm({
  "node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js"() {
    init_toDate();
    init_requiredArgs();
    MILLISECONDS_IN_DAY3 = 24 * 60 * 60 * 1e3;
  }
});

// node_modules/date-fns/esm/getSeconds/index.js
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}
var init_getSeconds = __esm({
  "node_modules/date-fns/esm/getSeconds/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getTime/index.js
function getTime(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}
var init_getTime = __esm({
  "node_modules/date-fns/esm/getTime/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getUnixTime/index.js
function getUnixTime(dirtyDate) {
  requiredArgs(1, arguments);
  return Math.floor(getTime(dirtyDate) / 1e3);
}
var init_getUnixTime = __esm({
  "node_modules/date-fns/esm/getUnixTime/index.js"() {
    init_getTime();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getWeekYear/index.js
function getWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
var init_getWeekYear = __esm({
  "node_modules/date-fns/esm/getWeekYear/index.js"() {
    init_startOfWeek();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/startOfWeekYear/index.js
function startOfWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date = startOfWeek(firstWeek, options);
  return date;
}
var init_startOfWeekYear = __esm({
  "node_modules/date-fns/esm/startOfWeekYear/index.js"() {
    init_getWeekYear();
    init_startOfWeek();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/getWeek/index.js
function getWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK7) + 1;
}
var MILLISECONDS_IN_WEEK7;
var init_getWeek = __esm({
  "node_modules/date-fns/esm/getWeek/index.js"() {
    init_startOfWeek();
    init_startOfWeekYear();
    init_toDate();
    init_requiredArgs();
    MILLISECONDS_IN_WEEK7 = 6048e5;
  }
});

// node_modules/date-fns/esm/getWeekOfMonth/index.js
function getWeekOfMonth(date, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var currentDayOfMonth = getDate(date);
  if (isNaN(currentDayOfMonth))
    return NaN;
  var startWeekDay = getDay(startOfMonth(date));
  var lastDayOfFirstWeek = weekStartsOn - startWeekDay;
  if (lastDayOfFirstWeek <= 0)
    lastDayOfFirstWeek += 7;
  var remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
  return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
}
var init_getWeekOfMonth = __esm({
  "node_modules/date-fns/esm/getWeekOfMonth/index.js"() {
    init_defaultOptions();
    init_getDate();
    init_getDay();
    init_startOfMonth();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/lastDayOfMonth/index.js
function lastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_lastDayOfMonth = __esm({
  "node_modules/date-fns/esm/lastDayOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getWeeksInMonth/index.js
function getWeeksInMonth(date, options) {
  requiredArgs(1, arguments);
  return differenceInCalendarWeeks(lastDayOfMonth(date), startOfMonth(date), options) + 1;
}
var init_getWeeksInMonth = __esm({
  "node_modules/date-fns/esm/getWeeksInMonth/index.js"() {
    init_differenceInCalendarWeeks();
    init_lastDayOfMonth();
    init_startOfMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/getYear/index.js
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}
var init_getYear = __esm({
  "node_modules/date-fns/esm/getYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/hoursToMilliseconds/index.js
function hoursToMilliseconds(hours) {
  requiredArgs(1, arguments);
  return Math.floor(hours * millisecondsInHour);
}
var init_hoursToMilliseconds = __esm({
  "node_modules/date-fns/esm/hoursToMilliseconds/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/hoursToMinutes/index.js
function hoursToMinutes(hours) {
  requiredArgs(1, arguments);
  return Math.floor(hours * minutesInHour);
}
var init_hoursToMinutes = __esm({
  "node_modules/date-fns/esm/hoursToMinutes/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/hoursToSeconds/index.js
function hoursToSeconds(hours) {
  requiredArgs(1, arguments);
  return Math.floor(hours * secondsInHour);
}
var init_hoursToSeconds = __esm({
  "node_modules/date-fns/esm/hoursToSeconds/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/intervalToDuration/index.js
function intervalToDuration(interval) {
  requiredArgs(1, arguments);
  var start = toDate(interval.start);
  var end = toDate(interval.end);
  if (isNaN(start.getTime()))
    throw new RangeError("Start Date is invalid");
  if (isNaN(end.getTime()))
    throw new RangeError("End Date is invalid");
  var duration = {};
  duration.years = Math.abs(differenceInYears(end, start));
  var sign = compareAsc(end, start);
  var remainingMonths = add(start, {
    years: sign * duration.years
  });
  duration.months = Math.abs(differenceInMonths(end, remainingMonths));
  var remainingDays = add(remainingMonths, {
    months: sign * duration.months
  });
  duration.days = Math.abs(differenceInDays(end, remainingDays));
  var remainingHours = add(remainingDays, {
    days: sign * duration.days
  });
  duration.hours = Math.abs(differenceInHours(end, remainingHours));
  var remainingMinutes = add(remainingHours, {
    hours: sign * duration.hours
  });
  duration.minutes = Math.abs(differenceInMinutes(end, remainingMinutes));
  var remainingSeconds = add(remainingMinutes, {
    minutes: sign * duration.minutes
  });
  duration.seconds = Math.abs(differenceInSeconds(end, remainingSeconds));
  return duration;
}
var init_intervalToDuration = __esm({
  "node_modules/date-fns/esm/intervalToDuration/index.js"() {
    init_compareAsc();
    init_add();
    init_differenceInDays();
    init_differenceInHours();
    init_differenceInMinutes();
    init_differenceInMonths();
    init_differenceInSeconds();
    init_differenceInYears();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/intlFormat/index.js
function intlFormat(date, formatOrLocale, localeOptions) {
  var _localeOptions;
  requiredArgs(1, arguments);
  var formatOptions;
  if (isFormatOptions(formatOrLocale)) {
    formatOptions = formatOrLocale;
  } else {
    localeOptions = formatOrLocale;
  }
  return new Intl.DateTimeFormat((_localeOptions = localeOptions) === null || _localeOptions === void 0 ? void 0 : _localeOptions.locale, formatOptions).format(date);
}
function isFormatOptions(opts) {
  return opts !== void 0 && !("locale" in opts);
}
var init_intlFormat = __esm({
  "node_modules/date-fns/esm/intlFormat/index.js"() {
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/intlFormatDistance/index.js
function intlFormatDistance(date, baseDate, options) {
  requiredArgs(2, arguments);
  var value = 0;
  var unit;
  var dateLeft = toDate(date);
  var dateRight = toDate(baseDate);
  if (!(options !== null && options !== void 0 && options.unit)) {
    var diffInSeconds = differenceInSeconds(dateLeft, dateRight);
    if (Math.abs(diffInSeconds) < secondsInMinute) {
      value = differenceInSeconds(dateLeft, dateRight);
      unit = "second";
    } else if (Math.abs(diffInSeconds) < secondsInHour) {
      value = differenceInMinutes(dateLeft, dateRight);
      unit = "minute";
    } else if (Math.abs(diffInSeconds) < secondsInDay && Math.abs(differenceInCalendarDays(dateLeft, dateRight)) < 1) {
      value = differenceInHours(dateLeft, dateRight);
      unit = "hour";
    } else if (Math.abs(diffInSeconds) < secondsInWeek && (value = differenceInCalendarDays(dateLeft, dateRight)) && Math.abs(value) < 7) {
      unit = "day";
    } else if (Math.abs(diffInSeconds) < secondsInMonth) {
      value = differenceInCalendarWeeks(dateLeft, dateRight);
      unit = "week";
    } else if (Math.abs(diffInSeconds) < secondsInQuarter) {
      value = differenceInCalendarMonths(dateLeft, dateRight);
      unit = "month";
    } else if (Math.abs(diffInSeconds) < secondsInYear) {
      if (differenceInCalendarQuarters(dateLeft, dateRight) < 4) {
        value = differenceInCalendarQuarters(dateLeft, dateRight);
        unit = "quarter";
      } else {
        value = differenceInCalendarYears(dateLeft, dateRight);
        unit = "year";
      }
    } else {
      value = differenceInCalendarYears(dateLeft, dateRight);
      unit = "year";
    }
  } else {
    unit = options === null || options === void 0 ? void 0 : options.unit;
    if (unit === "second") {
      value = differenceInSeconds(dateLeft, dateRight);
    } else if (unit === "minute") {
      value = differenceInMinutes(dateLeft, dateRight);
    } else if (unit === "hour") {
      value = differenceInHours(dateLeft, dateRight);
    } else if (unit === "day") {
      value = differenceInCalendarDays(dateLeft, dateRight);
    } else if (unit === "week") {
      value = differenceInCalendarWeeks(dateLeft, dateRight);
    } else if (unit === "month") {
      value = differenceInCalendarMonths(dateLeft, dateRight);
    } else if (unit === "quarter") {
      value = differenceInCalendarQuarters(dateLeft, dateRight);
    } else if (unit === "year") {
      value = differenceInCalendarYears(dateLeft, dateRight);
    }
  }
  var rtf = new Intl.RelativeTimeFormat(options === null || options === void 0 ? void 0 : options.locale, {
    localeMatcher: options === null || options === void 0 ? void 0 : options.localeMatcher,
    numeric: (options === null || options === void 0 ? void 0 : options.numeric) || "auto",
    style: options === null || options === void 0 ? void 0 : options.style
  });
  return rtf.format(value, unit);
}
var init_intlFormatDistance = __esm({
  "node_modules/date-fns/esm/intlFormatDistance/index.js"() {
    init_constants();
    init_differenceInCalendarDays();
    init_differenceInCalendarMonths();
    init_differenceInCalendarQuarters();
    init_differenceInCalendarWeeks();
    init_differenceInCalendarYears();
    init_differenceInHours();
    init_differenceInMinutes();
    init_differenceInSeconds();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isAfter/index.js
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
var init_isAfter = __esm({
  "node_modules/date-fns/esm/isAfter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isBefore/index.js
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
var init_isBefore = __esm({
  "node_modules/date-fns/esm/isBefore/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isEqual/index.js
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
var init_isEqual = __esm({
  "node_modules/date-fns/esm/isEqual/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isExists/index.js
function isExists(year, month, day) {
  if (arguments.length < 3) {
    throw new TypeError("3 argument required, but only " + arguments.length + " present");
  }
  var date = new Date(year, month, day);
  return date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;
}
var init_isExists = __esm({
  "node_modules/date-fns/esm/isExists/index.js"() {
  }
});

// node_modules/date-fns/esm/isFirstDayOfMonth/index.js
function isFirstDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDate() === 1;
}
var init_isFirstDayOfMonth = __esm({
  "node_modules/date-fns/esm/isFirstDayOfMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isFriday/index.js
function isFriday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 5;
}
var init_isFriday = __esm({
  "node_modules/date-fns/esm/isFriday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isFuture/index.js
function isFuture(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getTime() > Date.now();
}
var init_isFuture = __esm({
  "node_modules/date-fns/esm/isFuture/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return {
        s: F,
        n: function n() {
          if (i2 >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i2++]
          };
        },
        e: function e2(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s3() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e2(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
var init_createForOfIteratorHelper = __esm({
  "node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js"() {
    init_unsupportedIterableToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
var init_isNativeReflectConstruct = __esm({
  "node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var init_createSuper = __esm({
  "node_modules/@babel/runtime/helpers/esm/createSuper.js"() {
    init_getPrototypeOf();
    init_isNativeReflectConstruct();
    init_possibleConstructorReturn();
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/date-fns/esm/parse/_lib/Setter.js
var TIMEZONE_UNIT_PRIORITY, Setter, ValueSetter, DateToSystemTimezoneSetter;
var init_Setter = __esm({
  "node_modules/date-fns/esm/parse/_lib/Setter.js"() {
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    TIMEZONE_UNIT_PRIORITY = 10;
    Setter = function() {
      function Setter2() {
        _classCallCheck(this, Setter2);
        _defineProperty(this, "priority", void 0);
        _defineProperty(this, "subPriority", 0);
      }
      _createClass(Setter2, [{
        key: "validate",
        value: function validate(_utcDate, _options) {
          return true;
        }
      }]);
      return Setter2;
    }();
    ValueSetter = function(_Setter) {
      _inherits(ValueSetter2, _Setter);
      var _super = _createSuper(ValueSetter2);
      function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
        var _this;
        _classCallCheck(this, ValueSetter2);
        _this = _super.call(this);
        _this.value = value;
        _this.validateValue = validateValue;
        _this.setValue = setValue;
        _this.priority = priority;
        if (subPriority) {
          _this.subPriority = subPriority;
        }
        return _this;
      }
      _createClass(ValueSetter2, [{
        key: "validate",
        value: function validate(utcDate, options) {
          return this.validateValue(utcDate, this.value, options);
        }
      }, {
        key: "set",
        value: function set2(utcDate, flags, options) {
          return this.setValue(utcDate, flags, this.value, options);
        }
      }]);
      return ValueSetter2;
    }(Setter);
    DateToSystemTimezoneSetter = function(_Setter2) {
      _inherits(DateToSystemTimezoneSetter2, _Setter2);
      var _super2 = _createSuper(DateToSystemTimezoneSetter2);
      function DateToSystemTimezoneSetter2() {
        var _this2;
        _classCallCheck(this, DateToSystemTimezoneSetter2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
        _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
        return _this2;
      }
      _createClass(DateToSystemTimezoneSetter2, [{
        key: "set",
        value: function set2(date, flags) {
          if (flags.timestampIsSet) {
            return date;
          }
          var convertedDate = new Date(0);
          convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
          convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
          return convertedDate;
        }
      }]);
      return DateToSystemTimezoneSetter2;
    }(Setter);
  }
});

// node_modules/date-fns/esm/parse/_lib/Parser.js
var Parser;
var init_Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    init_Setter();
    Parser = function() {
      function Parser2() {
        _classCallCheck(this, Parser2);
        _defineProperty(this, "incompatibleTokens", void 0);
        _defineProperty(this, "priority", void 0);
        _defineProperty(this, "subPriority", void 0);
      }
      _createClass(Parser2, [{
        key: "run",
        value: function run(dateString, token, match2, options) {
          var result = this.parse(dateString, token, match2, options);
          if (!result) {
            return null;
          }
          return {
            setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
            rest: result.rest
          };
        }
      }, {
        key: "validate",
        value: function validate(_utcDate, _value, _options) {
          return true;
        }
      }]);
      return Parser2;
    }();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js
var EraParser;
var init_EraParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    EraParser = function(_Parser) {
      _inherits(EraParser2, _Parser);
      var _super = _createSuper(EraParser2);
      function EraParser2() {
        var _this;
        _classCallCheck(this, EraParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 140);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
        return _this;
      }
      _createClass(EraParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "G":
            case "GG":
            case "GGG":
              return match2.era(dateString, {
                width: "abbreviated"
              }) || match2.era(dateString, {
                width: "narrow"
              });
            case "GGGGG":
              return match2.era(dateString, {
                width: "narrow"
              });
            case "GGGG":
            default:
              return match2.era(dateString, {
                width: "wide"
              }) || match2.era(dateString, {
                width: "abbreviated"
              }) || match2.era(dateString, {
                width: "narrow"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          flags.era = value;
          date.setUTCFullYear(value, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return EraParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/constants.js
var numericPatterns, timezonePatterns;
var init_constants2 = __esm({
  "node_modules/date-fns/esm/parse/_lib/constants.js"() {
    numericPatterns = {
      month: /^(1[0-2]|0?\d)/,
      date: /^(3[0-1]|[0-2]?\d)/,
      dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
      week: /^(5[0-3]|[0-4]?\d)/,
      hour23h: /^(2[0-3]|[0-1]?\d)/,
      hour24h: /^(2[0-4]|[0-1]?\d)/,
      hour11h: /^(1[0-1]|0?\d)/,
      hour12h: /^(1[0-2]|0?\d)/,
      minute: /^[0-5]?\d/,
      second: /^[0-5]?\d/,
      singleDigit: /^\d/,
      twoDigits: /^\d{1,2}/,
      threeDigits: /^\d{1,3}/,
      fourDigits: /^\d{1,4}/,
      anyDigitsSigned: /^-?\d+/,
      singleDigitSigned: /^-?\d/,
      twoDigitsSigned: /^-?\d{1,2}/,
      threeDigitsSigned: /^-?\d{1,3}/,
      fourDigitsSigned: /^-?\d{1,4}/
    };
    timezonePatterns = {
      basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
      basic: /^([+-])(\d{2})(\d{2})|Z/,
      basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
      extended: /^([+-])(\d{2}):(\d{2})|Z/,
      extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };
  }
});

// node_modules/date-fns/esm/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var init_utils = __esm({
  "node_modules/date-fns/esm/parse/_lib/utils.js"() {
    init_constants();
    init_constants2();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js
var YearParser;
var init_YearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    YearParser = function(_Parser) {
      _inherits(YearParser2, _Parser);
      var _super = _createSuper(YearParser2);
      function YearParser2() {
        var _this;
        _classCallCheck(this, YearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(YearParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback3 = function valueCallback4(year) {
            return {
              year,
              isTwoDigitYear: token === "yy"
            };
          };
          switch (token) {
            case "y":
              return mapValue(parseNDigits(4, dateString), valueCallback3);
            case "yo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "year"
              }), valueCallback3);
            default:
              return mapValue(parseNDigits(token.length, dateString), valueCallback3);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          var currentYear = date.getUTCFullYear();
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
            date.setUTCHours(0, 0, 0, 0);
            return date;
          }
          var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date.setUTCFullYear(year, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return YearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js
var LocalWeekYearParser;
var init_LocalWeekYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    init_getUTCWeekYear();
    init_startOfUTCWeek();
    LocalWeekYearParser = function(_Parser) {
      _inherits(LocalWeekYearParser2, _Parser);
      var _super = _createSuper(LocalWeekYearParser2);
      function LocalWeekYearParser2() {
        var _this;
        _classCallCheck(this, LocalWeekYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
        return _this;
      }
      _createClass(LocalWeekYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback3 = function valueCallback4(year) {
            return {
              year,
              isTwoDigitYear: token === "YY"
            };
          };
          switch (token) {
            case "Y":
              return mapValue(parseNDigits(4, dateString), valueCallback3);
            case "Yo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "year"
              }), valueCallback3);
            default:
              return mapValue(parseNDigits(token.length, dateString), valueCallback3);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value.isTwoDigitYear || value.year > 0;
        }
      }, {
        key: "set",
        value: function set2(date, flags, value, options) {
          var currentYear = getUTCWeekYear(date, options);
          if (value.isTwoDigitYear) {
            var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
            date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
            date.setUTCHours(0, 0, 0, 0);
            return startOfUTCWeek(date, options);
          }
          var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
          date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek(date, options);
        }
      }]);
      return LocalWeekYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js
var ISOWeekYearParser;
var init_ISOWeekYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    init_startOfUTCISOWeek();
    ISOWeekYearParser = function(_Parser) {
      _inherits(ISOWeekYearParser2, _Parser);
      var _super = _createSuper(ISOWeekYearParser2);
      function ISOWeekYearParser2() {
        var _this;
        _classCallCheck(this, ISOWeekYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ISOWeekYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          if (token === "R") {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token.length, dateString);
        }
      }, {
        key: "set",
        value: function set2(_date, _flags, value) {
          var firstWeekOfYear = new Date(0);
          firstWeekOfYear.setUTCFullYear(value, 0, 4);
          firstWeekOfYear.setUTCHours(0, 0, 0, 0);
          return startOfUTCISOWeek(firstWeekOfYear);
        }
      }]);
      return ISOWeekYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js
var ExtendedYearParser;
var init_ExtendedYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    ExtendedYearParser = function(_Parser) {
      _inherits(ExtendedYearParser2, _Parser);
      var _super = _createSuper(ExtendedYearParser2);
      function ExtendedYearParser2() {
        var _this;
        _classCallCheck(this, ExtendedYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 130);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ExtendedYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          if (token === "u") {
            return parseNDigitsSigned(4, dateString);
          }
          return parseNDigitsSigned(token.length, dateString);
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCFullYear(value, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return ExtendedYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js
var QuarterParser;
var init_QuarterParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    QuarterParser = function(_Parser) {
      _inherits(QuarterParser2, _Parser);
      var _super = _createSuper(QuarterParser2);
      function QuarterParser2() {
        var _this;
        _classCallCheck(this, QuarterParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(QuarterParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "Q":
            case "QQ":
              return parseNDigits(token.length, dateString);
            case "Qo":
              return match2.ordinalNumber(dateString, {
                unit: "quarter"
              });
            case "QQQ":
              return match2.quarter(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQQ":
              return match2.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "QQQQ":
            default:
              return match2.quarter(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.quarter(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth((value - 1) * 3, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return QuarterParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js
var StandAloneQuarterParser;
var init_StandAloneQuarterParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    StandAloneQuarterParser = function(_Parser) {
      _inherits(StandAloneQuarterParser2, _Parser);
      var _super = _createSuper(StandAloneQuarterParser2);
      function StandAloneQuarterParser2() {
        var _this;
        _classCallCheck(this, StandAloneQuarterParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 120);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(StandAloneQuarterParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "q":
            case "qq":
              return parseNDigits(token.length, dateString);
            case "qo":
              return match2.ordinalNumber(dateString, {
                unit: "quarter"
              });
            case "qqq":
              return match2.quarter(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqqq":
              return match2.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "qqqq":
            default:
              return match2.quarter(dateString, {
                width: "wide",
                context: "standalone"
              }) || match2.quarter(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.quarter(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 4;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth((value - 1) * 3, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneQuarterParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js
var MonthParser;
var init_MonthParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_utils();
    init_Parser();
    init_constants2();
    MonthParser = function(_Parser) {
      _inherits(MonthParser2, _Parser);
      var _super = _createSuper(MonthParser2);
      function MonthParser2() {
        var _this;
        _classCallCheck(this, MonthParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        return _this;
      }
      _createClass(MonthParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback3 = function valueCallback4(value) {
            return value - 1;
          };
          switch (token) {
            case "M":
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
            case "MM":
              return mapValue(parseNDigits(2, dateString), valueCallback3);
            case "Mo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "month"
              }), valueCallback3);
            case "MMM":
              return match2.month(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMMM":
              return match2.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "MMMM":
            default:
              return match2.month(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.month(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth(value, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return MonthParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js
var StandAloneMonthParser;
var init_StandAloneMonthParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    StandAloneMonthParser = function(_Parser) {
      _inherits(StandAloneMonthParser2, _Parser);
      var _super = _createSuper(StandAloneMonthParser2);
      function StandAloneMonthParser2() {
        var _this;
        _classCallCheck(this, StandAloneMonthParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 110);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(StandAloneMonthParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback3 = function valueCallback4(value) {
            return value - 1;
          };
          switch (token) {
            case "L":
              return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
            case "LL":
              return mapValue(parseNDigits(2, dateString), valueCallback3);
            case "Lo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "month"
              }), valueCallback3);
            case "LLL":
              return match2.month(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLLL":
              return match2.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "LLLL":
            default:
              return match2.month(dateString, {
                width: "wide",
                context: "standalone"
              }) || match2.month(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.month(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth(value, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneMonthParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCWeek/index.js
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var init_setUTCWeek = __esm({
  "node_modules/date-fns/esm/_lib/setUTCWeek/index.js"() {
    init_toInteger();
    init_toDate();
    init_getUTCWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js
var LocalWeekParser;
var init_LocalWeekParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    init_setUTCWeek();
    init_startOfUTCWeek();
    LocalWeekParser = function(_Parser) {
      _inherits(LocalWeekParser2, _Parser);
      var _super = _createSuper(LocalWeekParser2);
      function LocalWeekParser2() {
        var _this;
        _classCallCheck(this, LocalWeekParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
        return _this;
      }
      _createClass(LocalWeekParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "w":
              return parseNumericPattern(numericPatterns.week, dateString);
            case "wo":
              return match2.ordinalNumber(dateString, {
                unit: "week"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          return startOfUTCWeek(setUTCWeek(date, value, options), options);
        }
      }]);
      return LocalWeekParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var init_setUTCISOWeek = __esm({
  "node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js"() {
    init_toInteger();
    init_toDate();
    init_getUTCISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js
var ISOWeekParser;
var init_ISOWeekParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    init_setUTCISOWeek();
    init_startOfUTCISOWeek();
    ISOWeekParser = function(_Parser) {
      _inherits(ISOWeekParser2, _Parser);
      var _super = _createSuper(ISOWeekParser2);
      function ISOWeekParser2() {
        var _this;
        _classCallCheck(this, ISOWeekParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 100);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ISOWeekParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "I":
              return parseNumericPattern(numericPatterns.week, dateString);
            case "Io":
              return match2.ordinalNumber(dateString, {
                unit: "week"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 53;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          return startOfUTCISOWeek(setUTCISOWeek(date, value));
        }
      }]);
      return ISOWeekParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js
var DAYS_IN_MONTH, DAYS_IN_MONTH_LEAP_YEAR, DateParser;
var init_DateParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_utils();
    init_Parser();
    init_constants2();
    DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    DateParser = function(_Parser) {
      _inherits(DateParser2, _Parser);
      var _super = _createSuper(DateParser2);
      function DateParser2() {
        var _this;
        _classCallCheck(this, DateParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(DateParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "d":
              return parseNumericPattern(numericPatterns.date, dateString);
            case "do":
              return match2.ordinalNumber(dateString, {
                unit: "date"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(date, value) {
          var year = date.getUTCFullYear();
          var isLeapYear2 = isLeapYearIndex(year);
          var month = date.getUTCMonth();
          if (isLeapYear2) {
            return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
          } else {
            return value >= 1 && value <= DAYS_IN_MONTH[month];
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCDate(value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DateParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js
var DayOfYearParser;
var init_DayOfYearParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    DayOfYearParser = function(_Parser) {
      _inherits(DayOfYearParser2, _Parser);
      var _super = _createSuper(DayOfYearParser2);
      function DayOfYearParser2() {
        var _this;
        _classCallCheck(this, DayOfYearParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(DayOfYearParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "D":
            case "DD":
              return parseNumericPattern(numericPatterns.dayOfYear, dateString);
            case "Do":
              return match2.ordinalNumber(dateString, {
                unit: "date"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(date, value) {
          var year = date.getUTCFullYear();
          var isLeapYear2 = isLeapYearIndex(year);
          if (isLeapYear2) {
            return value >= 1 && value <= 366;
          } else {
            return value >= 1 && value <= 365;
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMonth(0, value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DayOfYearParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCDay/index.js
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var init_setUTCDay = __esm({
  "node_modules/date-fns/esm/_lib/setUTCDay/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_toInteger();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js
var DayParser;
var init_DayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_setUTCDay();
    DayParser = function(_Parser) {
      _inherits(DayParser2, _Parser);
      var _super = _createSuper(DayParser2);
      function DayParser2() {
        var _this;
        _classCallCheck(this, DayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(DayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "E":
            case "EE":
            case "EEE":
              return match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEE":
              return match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEEEE":
              return match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "EEEE":
            default:
              return match2.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return DayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js
var LocalDayParser;
var init_LocalDayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    init_setUTCDay();
    LocalDayParser = function(_Parser) {
      _inherits(LocalDayParser2, _Parser);
      var _super = _createSuper(LocalDayParser2);
      function LocalDayParser2() {
        var _this;
        _classCallCheck(this, LocalDayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
        return _this;
      }
      _createClass(LocalDayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2, options) {
          var valueCallback3 = function valueCallback4(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token) {
            case "e":
            case "ee":
              return mapValue(parseNDigits(token.length, dateString), valueCallback3);
            case "eo":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "day"
              }), valueCallback3);
            case "eee":
              return match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeee":
              return match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeeeee":
              return match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "eeee":
            default:
              return match2.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return LocalDayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js
var StandAloneLocalDayParser;
var init_StandAloneLocalDayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    init_setUTCDay();
    StandAloneLocalDayParser = function(_Parser) {
      _inherits(StandAloneLocalDayParser2, _Parser);
      var _super = _createSuper(StandAloneLocalDayParser2);
      function StandAloneLocalDayParser2() {
        var _this;
        _classCallCheck(this, StandAloneLocalDayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
        return _this;
      }
      _createClass(StandAloneLocalDayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2, options) {
          var valueCallback3 = function valueCallback4(value) {
            var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
          };
          switch (token) {
            case "c":
            case "cc":
              return mapValue(parseNDigits(token.length, dateString), valueCallback3);
            case "co":
              return mapValue(match2.ordinalNumber(dateString, {
                unit: "day"
              }), valueCallback3);
            case "ccc":
              return match2.day(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "ccccc":
              return match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "cccccc":
              return match2.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
            case "cccc":
            default:
              return match2.day(dateString, {
                width: "wide",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "short",
                context: "standalone"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "standalone"
              });
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 6;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value, options) {
          date = setUTCDay(date, value, options);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return StandAloneLocalDayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/_lib/setUTCISODay/index.js
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var init_setUTCISODay = __esm({
  "node_modules/date-fns/esm/_lib/setUTCISODay/index.js"() {
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js
var ISODayParser;
var init_ISODayParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    init_setUTCISODay();
    ISODayParser = function(_Parser) {
      _inherits(ISODayParser2, _Parser);
      var _super = _createSuper(ISODayParser2);
      function ISODayParser2() {
        var _this;
        _classCallCheck(this, ISODayParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 90);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
        return _this;
      }
      _createClass(ISODayParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          var valueCallback3 = function valueCallback4(value) {
            if (value === 0) {
              return 7;
            }
            return value;
          };
          switch (token) {
            case "i":
            case "ii":
              return parseNDigits(token.length, dateString);
            case "io":
              return match2.ordinalNumber(dateString, {
                unit: "day"
              });
            case "iii":
              return mapValue(match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
            case "iiiii":
              return mapValue(match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
            case "iiiiii":
              return mapValue(match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
            case "iiii":
            default:
              return mapValue(match2.day(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "short",
                context: "formatting"
              }) || match2.day(dateString, {
                width: "narrow",
                context: "formatting"
              }), valueCallback3);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 7;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date = setUTCISODay(date, value);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
      }]);
      return ISODayParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js
var AMPMParser;
var init_AMPMParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    AMPMParser = function(_Parser) {
      _inherits(AMPMParser2, _Parser);
      var _super = _createSuper(AMPMParser2);
      function AMPMParser2() {
        var _this;
        _classCallCheck(this, AMPMParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass(AMPMParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "a":
            case "aa":
            case "aaa":
              return match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaaa":
              return match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "aaaa":
            default:
              return match2.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return AMPMParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js
var AMPMMidnightParser;
var init_AMPMMidnightParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    AMPMMidnightParser = function(_Parser) {
      _inherits(AMPMMidnightParser2, _Parser);
      var _super = _createSuper(AMPMMidnightParser2);
      function AMPMMidnightParser2() {
        var _this;
        _classCallCheck(this, AMPMMidnightParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass(AMPMMidnightParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "b":
            case "bb":
            case "bbb":
              return match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbbb":
              return match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "bbbb":
            default:
              return match2.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return AMPMMidnightParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js
var DayPeriodParser;
var init_DayPeriodParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    DayPeriodParser = function(_Parser) {
      _inherits(DayPeriodParser2, _Parser);
      var _super = _createSuper(DayPeriodParser2);
      function DayPeriodParser2() {
        var _this;
        _classCallCheck(this, DayPeriodParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 80);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
        return _this;
      }
      _createClass(DayPeriodParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "B":
            case "BB":
            case "BBB":
              return match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBBB":
              return match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
            case "BBBB":
            default:
              return match2.dayPeriod(dateString, {
                width: "wide",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "abbreviated",
                context: "formatting"
              }) || match2.dayPeriod(dateString, {
                width: "narrow",
                context: "formatting"
              });
          }
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
          return date;
        }
      }]);
      return DayPeriodParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js
var Hour1to12Parser;
var init_Hour1to12Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    Hour1to12Parser = function(_Parser) {
      _inherits(Hour1to12Parser2, _Parser);
      var _super = _createSuper(Hour1to12Parser2);
      function Hour1to12Parser2() {
        var _this;
        _classCallCheck(this, Hour1to12Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
        return _this;
      }
      _createClass(Hour1to12Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "h":
              return parseNumericPattern(numericPatterns.hour12h, dateString);
            case "ho":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 12;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          var isPM = date.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date.setUTCHours(value + 12, 0, 0, 0);
          } else if (!isPM && value === 12) {
            date.setUTCHours(0, 0, 0, 0);
          } else {
            date.setUTCHours(value, 0, 0, 0);
          }
          return date;
        }
      }]);
      return Hour1to12Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js
var Hour0to23Parser;
var init_Hour0to23Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    Hour0to23Parser = function(_Parser) {
      _inherits(Hour0to23Parser2, _Parser);
      var _super = _createSuper(Hour0to23Parser2);
      function Hour0to23Parser2() {
        var _this;
        _classCallCheck(this, Hour0to23Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
        return _this;
      }
      _createClass(Hour0to23Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "H":
              return parseNumericPattern(numericPatterns.hour23h, dateString);
            case "Ho":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 23;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCHours(value, 0, 0, 0);
          return date;
        }
      }]);
      return Hour0to23Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js
var Hour0To11Parser;
var init_Hour0To11Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    Hour0To11Parser = function(_Parser) {
      _inherits(Hour0To11Parser2, _Parser);
      var _super = _createSuper(Hour0To11Parser2);
      function Hour0To11Parser2() {
        var _this;
        _classCallCheck(this, Hour0To11Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
        return _this;
      }
      _createClass(Hour0To11Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "K":
              return parseNumericPattern(numericPatterns.hour11h, dateString);
            case "Ko":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 11;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          var isPM = date.getUTCHours() >= 12;
          if (isPM && value < 12) {
            date.setUTCHours(value + 12, 0, 0, 0);
          } else {
            date.setUTCHours(value, 0, 0, 0);
          }
          return date;
        }
      }]);
      return Hour0To11Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js
var Hour1To24Parser;
var init_Hour1To24Parser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    Hour1To24Parser = function(_Parser) {
      _inherits(Hour1To24Parser2, _Parser);
      var _super = _createSuper(Hour1To24Parser2);
      function Hour1To24Parser2() {
        var _this;
        _classCallCheck(this, Hour1To24Parser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 70);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
        return _this;
      }
      _createClass(Hour1To24Parser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "k":
              return parseNumericPattern(numericPatterns.hour24h, dateString);
            case "ko":
              return match2.ordinalNumber(dateString, {
                unit: "hour"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 1 && value <= 24;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          var hours = value <= 24 ? value % 24 : value;
          date.setUTCHours(hours, 0, 0, 0);
          return date;
        }
      }]);
      return Hour1To24Parser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js
var MinuteParser;
var init_MinuteParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    MinuteParser = function(_Parser) {
      _inherits(MinuteParser2, _Parser);
      var _super = _createSuper(MinuteParser2);
      function MinuteParser2() {
        var _this;
        _classCallCheck(this, MinuteParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 60);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass(MinuteParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "m":
              return parseNumericPattern(numericPatterns.minute, dateString);
            case "mo":
              return match2.ordinalNumber(dateString, {
                unit: "minute"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMinutes(value, 0, 0);
          return date;
        }
      }]);
      return MinuteParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js
var SecondParser;
var init_SecondParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    SecondParser = function(_Parser) {
      _inherits(SecondParser2, _Parser);
      var _super = _createSuper(SecondParser2);
      function SecondParser2() {
        var _this;
        _classCallCheck(this, SecondParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 50);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass(SecondParser2, [{
        key: "parse",
        value: function parse2(dateString, token, match2) {
          switch (token) {
            case "s":
              return parseNumericPattern(numericPatterns.second, dateString);
            case "so":
              return match2.ordinalNumber(dateString, {
                unit: "second"
              });
            default:
              return parseNDigits(token.length, dateString);
          }
        }
      }, {
        key: "validate",
        value: function validate(_date, value) {
          return value >= 0 && value <= 59;
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCSeconds(value, 0);
          return date;
        }
      }]);
      return SecondParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js
var FractionOfSecondParser;
var init_FractionOfSecondParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    FractionOfSecondParser = function(_Parser) {
      _inherits(FractionOfSecondParser2, _Parser);
      var _super = _createSuper(FractionOfSecondParser2);
      function FractionOfSecondParser2() {
        var _this;
        _classCallCheck(this, FractionOfSecondParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 30);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
        return _this;
      }
      _createClass(FractionOfSecondParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          var valueCallback3 = function valueCallback4(value) {
            return Math.floor(value * Math.pow(10, -token.length + 3));
          };
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        }
      }, {
        key: "set",
        value: function set2(date, _flags, value) {
          date.setUTCMilliseconds(value);
          return date;
        }
      }]);
      return FractionOfSecondParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js
var ISOTimezoneWithZParser;
var init_ISOTimezoneWithZParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    ISOTimezoneWithZParser = function(_Parser) {
      _inherits(ISOTimezoneWithZParser2, _Parser);
      var _super = _createSuper(ISOTimezoneWithZParser2);
      function ISOTimezoneWithZParser2() {
        var _this;
        _classCallCheck(this, ISOTimezoneWithZParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]);
        return _this;
      }
      _createClass(ISOTimezoneWithZParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          switch (token) {
            case "X":
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "XX":
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "XXXX":
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "XXXXX":
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "XXX":
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          if (flags.timestampIsSet) {
            return date;
          }
          return new Date(date.getTime() - value);
        }
      }]);
      return ISOTimezoneWithZParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js
var ISOTimezoneParser;
var init_ISOTimezoneParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_constants2();
    init_utils();
    ISOTimezoneParser = function(_Parser) {
      _inherits(ISOTimezoneParser2, _Parser);
      var _super = _createSuper(ISOTimezoneParser2);
      function ISOTimezoneParser2() {
        var _this;
        _classCallCheck(this, ISOTimezoneParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 10);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]);
        return _this;
      }
      _createClass(ISOTimezoneParser2, [{
        key: "parse",
        value: function parse2(dateString, token) {
          switch (token) {
            case "x":
              return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
            case "xx":
              return parseTimezonePattern(timezonePatterns.basic, dateString);
            case "xxxx":
              return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
            case "xxxxx":
              return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
            case "xxx":
            default:
              return parseTimezonePattern(timezonePatterns.extended, dateString);
          }
        }
      }, {
        key: "set",
        value: function set2(date, flags, value) {
          if (flags.timestampIsSet) {
            return date;
          }
          return new Date(date.getTime() - value);
        }
      }]);
      return ISOTimezoneParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js
var TimestampSecondsParser;
var init_TimestampSecondsParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    TimestampSecondsParser = function(_Parser) {
      _inherits(TimestampSecondsParser2, _Parser);
      var _super = _createSuper(TimestampSecondsParser2);
      function TimestampSecondsParser2() {
        var _this;
        _classCallCheck(this, TimestampSecondsParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 40);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
        return _this;
      }
      _createClass(TimestampSecondsParser2, [{
        key: "parse",
        value: function parse2(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set2(_date, _flags, value) {
          return [new Date(value * 1e3), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampSecondsParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js
var TimestampMillisecondsParser;
var init_TimestampMillisecondsParser = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_createSuper();
    init_defineProperty();
    init_Parser();
    init_utils();
    TimestampMillisecondsParser = function(_Parser) {
      _inherits(TimestampMillisecondsParser2, _Parser);
      var _super = _createSuper(TimestampMillisecondsParser2);
      function TimestampMillisecondsParser2() {
        var _this;
        _classCallCheck(this, TimestampMillisecondsParser2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "priority", 20);
        _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
        return _this;
      }
      _createClass(TimestampMillisecondsParser2, [{
        key: "parse",
        value: function parse2(dateString) {
          return parseAnyDigitsSigned(dateString);
        }
      }, {
        key: "set",
        value: function set2(_date, _flags, value) {
          return [new Date(value), {
            timestampIsSet: true
          }];
        }
      }]);
      return TimestampMillisecondsParser2;
    }(Parser);
  }
});

// node_modules/date-fns/esm/parse/_lib/parsers/index.js
var parsers;
var init_parsers = __esm({
  "node_modules/date-fns/esm/parse/_lib/parsers/index.js"() {
    init_EraParser();
    init_YearParser();
    init_LocalWeekYearParser();
    init_ISOWeekYearParser();
    init_ExtendedYearParser();
    init_QuarterParser();
    init_StandAloneQuarterParser();
    init_MonthParser();
    init_StandAloneMonthParser();
    init_LocalWeekParser();
    init_ISOWeekParser();
    init_DateParser();
    init_DayOfYearParser();
    init_DayParser();
    init_LocalDayParser();
    init_StandAloneLocalDayParser();
    init_ISODayParser();
    init_AMPMParser();
    init_AMPMMidnightParser();
    init_DayPeriodParser();
    init_Hour1to12Parser();
    init_Hour0to23Parser();
    init_Hour0To11Parser();
    init_Hour1To24Parser();
    init_MinuteParser();
    init_SecondParser();
    init_FractionOfSecondParser();
    init_ISOTimezoneWithZParser();
    init_ISOTimezoneParser();
    init_TimestampSecondsParser();
    init_TimestampMillisecondsParser();
    parsers = {
      G: new EraParser(),
      y: new YearParser(),
      Y: new LocalWeekYearParser(),
      R: new ISOWeekYearParser(),
      u: new ExtendedYearParser(),
      Q: new QuarterParser(),
      q: new StandAloneQuarterParser(),
      M: new MonthParser(),
      L: new StandAloneMonthParser(),
      w: new LocalWeekParser(),
      I: new ISOWeekParser(),
      d: new DateParser(),
      D: new DayOfYearParser(),
      E: new DayParser(),
      e: new LocalDayParser(),
      c: new StandAloneLocalDayParser(),
      i: new ISODayParser(),
      a: new AMPMParser(),
      b: new AMPMMidnightParser(),
      B: new DayPeriodParser(),
      h: new Hour1to12Parser(),
      H: new Hour0to23Parser(),
      K: new Hour0To11Parser(),
      k: new Hour1To24Parser(),
      m: new MinuteParser(),
      s: new SecondParser(),
      S: new FractionOfSecondParser(),
      X: new ISOTimezoneWithZParser(),
      x: new ISOTimezoneParser(),
      t: new TimestampSecondsParser(),
      T: new TimestampMillisecondsParser()
    };
  }
});

// node_modules/date-fns/esm/parse/index.js
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale_default;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp2).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters_default) {
      var longFormatter = longFormatters_default[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp2);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale2.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp2)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString2(token);
        }
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object")
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a3, b2) {
    return b2 - a3;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a3, b2) {
      return b2.subPriority - a3.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString2(input) {
  return input.match(escapedStringRegExp2)[1].replace(doubleQuoteRegExp2, "'");
}
var formattingTokensRegExp2, longFormattingTokensRegExp2, escapedStringRegExp2, doubleQuoteRegExp2, notWhitespaceRegExp, unescapedLatinCharacterRegExp2;
var init_parse = __esm({
  "node_modules/date-fns/esm/parse/index.js"() {
    init_typeof();
    init_createForOfIteratorHelper();
    init_defaultLocale();
    init_subMilliseconds();
    init_toDate();
    init_assign();
    init_longFormatters();
    init_getTimezoneOffsetInMilliseconds();
    init_protectedTokens();
    init_toInteger();
    init_requiredArgs();
    init_Setter();
    init_parsers();
    init_defaultOptions();
    formattingTokensRegExp2 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    longFormattingTokensRegExp2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp2 = /^'([^]*?)'?$/;
    doubleQuoteRegExp2 = /''/g;
    notWhitespaceRegExp = /\S/;
    unescapedLatinCharacterRegExp2 = /[a-zA-Z]/;
  }
});

// node_modules/date-fns/esm/isMatch/index.js
function isMatch(dateString, formatString, options) {
  requiredArgs(2, arguments);
  return isValid(parse(dateString, formatString, new Date(), options));
}
var init_isMatch = __esm({
  "node_modules/date-fns/esm/isMatch/index.js"() {
    init_parse();
    init_isValid();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isMonday/index.js
function isMonday(date) {
  requiredArgs(1, arguments);
  return toDate(date).getDay() === 1;
}
var init_isMonday = __esm({
  "node_modules/date-fns/esm/isMonday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isPast/index.js
function isPast(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getTime() < Date.now();
}
var init_isPast = __esm({
  "node_modules/date-fns/esm/isPast/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfHour/index.js
function startOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMinutes(0, 0, 0);
  return date;
}
var init_startOfHour = __esm({
  "node_modules/date-fns/esm/startOfHour/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameHour/index.js
function isSameHour(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfHour = startOfHour(dirtyDateLeft);
  var dateRightStartOfHour = startOfHour(dirtyDateRight);
  return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
}
var init_isSameHour = __esm({
  "node_modules/date-fns/esm/isSameHour/index.js"() {
    init_startOfHour();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameWeek/index.js
function isSameWeek(dirtyDateLeft, dirtyDateRight, options) {
  requiredArgs(2, arguments);
  var dateLeftStartOfWeek = startOfWeek(dirtyDateLeft, options);
  var dateRightStartOfWeek = startOfWeek(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}
var init_isSameWeek = __esm({
  "node_modules/date-fns/esm/isSameWeek/index.js"() {
    init_startOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameISOWeek/index.js
function isSameISOWeek(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  return isSameWeek(dirtyDateLeft, dirtyDateRight, {
    weekStartsOn: 1
  });
}
var init_isSameISOWeek = __esm({
  "node_modules/date-fns/esm/isSameISOWeek/index.js"() {
    init_isSameWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameISOWeekYear/index.js
function isSameISOWeekYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfYear = startOfISOWeekYear(dirtyDateLeft);
  var dateRightStartOfYear = startOfISOWeekYear(dirtyDateRight);
  return dateLeftStartOfYear.getTime() === dateRightStartOfYear.getTime();
}
var init_isSameISOWeekYear = __esm({
  "node_modules/date-fns/esm/isSameISOWeekYear/index.js"() {
    init_startOfISOWeekYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameMinute/index.js
function isSameMinute(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfMinute = startOfMinute(dirtyDateLeft);
  var dateRightStartOfMinute = startOfMinute(dirtyDateRight);
  return dateLeftStartOfMinute.getTime() === dateRightStartOfMinute.getTime();
}
var init_isSameMinute = __esm({
  "node_modules/date-fns/esm/isSameMinute/index.js"() {
    init_startOfMinute();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameMonth/index.js
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
var init_isSameMonth = __esm({
  "node_modules/date-fns/esm/isSameMonth/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameQuarter/index.js
function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
  var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}
var init_isSameQuarter = __esm({
  "node_modules/date-fns/esm/isSameQuarter/index.js"() {
    init_startOfQuarter();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfSecond/index.js
function startOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMilliseconds(0);
  return date;
}
var init_startOfSecond = __esm({
  "node_modules/date-fns/esm/startOfSecond/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameSecond/index.js
function isSameSecond(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfSecond = startOfSecond(dirtyDateLeft);
  var dateRightStartOfSecond = startOfSecond(dirtyDateRight);
  return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
}
var init_isSameSecond = __esm({
  "node_modules/date-fns/esm/isSameSecond/index.js"() {
    init_startOfSecond();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isSameYear/index.js
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
var init_isSameYear = __esm({
  "node_modules/date-fns/esm/isSameYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisHour/index.js
function isThisHour(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameHour(Date.now(), dirtyDate);
}
var init_isThisHour = __esm({
  "node_modules/date-fns/esm/isThisHour/index.js"() {
    init_isSameHour();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisISOWeek/index.js
function isThisISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameISOWeek(dirtyDate, Date.now());
}
var init_isThisISOWeek = __esm({
  "node_modules/date-fns/esm/isThisISOWeek/index.js"() {
    init_isSameISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisMinute/index.js
function isThisMinute(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameMinute(Date.now(), dirtyDate);
}
var init_isThisMinute = __esm({
  "node_modules/date-fns/esm/isThisMinute/index.js"() {
    init_isSameMinute();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisMonth/index.js
function isThisMonth(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameMonth(Date.now(), dirtyDate);
}
var init_isThisMonth = __esm({
  "node_modules/date-fns/esm/isThisMonth/index.js"() {
    init_isSameMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisQuarter/index.js
function isThisQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameQuarter(Date.now(), dirtyDate);
}
var init_isThisQuarter = __esm({
  "node_modules/date-fns/esm/isThisQuarter/index.js"() {
    init_isSameQuarter();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisSecond/index.js
function isThisSecond(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameSecond(Date.now(), dirtyDate);
}
var init_isThisSecond = __esm({
  "node_modules/date-fns/esm/isThisSecond/index.js"() {
    init_isSameSecond();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisWeek/index.js
function isThisWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  return isSameWeek(dirtyDate, Date.now(), options);
}
var init_isThisWeek = __esm({
  "node_modules/date-fns/esm/isThisWeek/index.js"() {
    init_isSameWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThisYear/index.js
function isThisYear(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameYear(dirtyDate, Date.now());
}
var init_isThisYear = __esm({
  "node_modules/date-fns/esm/isThisYear/index.js"() {
    init_isSameYear();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isThursday/index.js
function isThursday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 4;
}
var init_isThursday = __esm({
  "node_modules/date-fns/esm/isThursday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isToday/index.js
function isToday(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, Date.now());
}
var init_isToday = __esm({
  "node_modules/date-fns/esm/isToday/index.js"() {
    init_isSameDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isTomorrow/index.js
function isTomorrow(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, addDays(Date.now(), 1));
}
var init_isTomorrow = __esm({
  "node_modules/date-fns/esm/isTomorrow/index.js"() {
    init_addDays();
    init_isSameDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isTuesday/index.js
function isTuesday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 2;
}
var init_isTuesday = __esm({
  "node_modules/date-fns/esm/isTuesday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isWednesday/index.js
function isWednesday(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getDay() === 3;
}
var init_isWednesday = __esm({
  "node_modules/date-fns/esm/isWednesday/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/isWithinInterval/index.js
function isWithinInterval(dirtyDate, interval) {
  requiredArgs(2, arguments);
  var time = toDate(dirtyDate).getTime();
  var startTime = toDate(interval.start).getTime();
  var endTime = toDate(interval.end).getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  return time >= startTime && time <= endTime;
}
var init_isWithinInterval = __esm({
  "node_modules/date-fns/esm/isWithinInterval/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subDays/index.js
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
var init_subDays = __esm({
  "node_modules/date-fns/esm/subDays/index.js"() {
    init_addDays();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/isYesterday/index.js
function isYesterday(dirtyDate) {
  requiredArgs(1, arguments);
  return isSameDay(dirtyDate, subDays(Date.now(), 1));
}
var init_isYesterday = __esm({
  "node_modules/date-fns/esm/isYesterday/index.js"() {
    init_isSameDay();
    init_subDays();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfDecade/index.js
function lastDayOfDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var decade = 9 + Math.floor(year / 10) * 10;
  date.setFullYear(decade + 1, 0, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_lastDayOfDecade = __esm({
  "node_modules/date-fns/esm/lastDayOfDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfWeek/index.js
function lastDayOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setHours(0, 0, 0, 0);
  date.setDate(date.getDate() + diff);
  return date;
}
var init_lastDayOfWeek = __esm({
  "node_modules/date-fns/esm/lastDayOfWeek/index.js"() {
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/lastDayOfISOWeek/index.js
function lastDayOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return lastDayOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
var init_lastDayOfISOWeek = __esm({
  "node_modules/date-fns/esm/lastDayOfISOWeek/index.js"() {
    init_lastDayOfWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfISOWeekYear/index.js
function lastDayOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year + 1, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  date.setDate(date.getDate() - 1);
  return date;
}
var init_lastDayOfISOWeekYear = __esm({
  "node_modules/date-fns/esm/lastDayOfISOWeekYear/index.js"() {
    init_getISOWeekYear();
    init_startOfISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfQuarter/index.js
function lastDayOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date.setMonth(month, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_lastDayOfQuarter = __esm({
  "node_modules/date-fns/esm/lastDayOfQuarter/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lastDayOfYear/index.js
function lastDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_lastDayOfYear = __esm({
  "node_modules/date-fns/esm/lastDayOfYear/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/lightFormat/index.js
function lightFormat(dirtyDate, formatStr) {
  requiredArgs(2, arguments);
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var tokens = formatStr.match(formattingTokensRegExp3);
  if (!tokens)
    return "";
  var result = tokens.map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString3(substring);
    }
    var formatter = lightFormatters_default[firstCharacter];
    if (formatter) {
      return formatter(utcDate, substring);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp3)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString3(input) {
  var matches = input.match(escapedStringRegExp3);
  if (!matches) {
    return input;
  }
  return matches[1].replace(doubleQuoteRegExp3, "'");
}
var formattingTokensRegExp3, escapedStringRegExp3, doubleQuoteRegExp3, unescapedLatinCharacterRegExp3;
var init_lightFormat = __esm({
  "node_modules/date-fns/esm/lightFormat/index.js"() {
    init_toDate();
    init_lightFormatters();
    init_getTimezoneOffsetInMilliseconds();
    init_isValid();
    init_subMilliseconds();
    init_requiredArgs();
    formattingTokensRegExp3 = /(\w)\1*|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp3 = /^'([^]*?)'?$/;
    doubleQuoteRegExp3 = /''/g;
    unescapedLatinCharacterRegExp3 = /[a-zA-Z]/;
  }
});

// node_modules/date-fns/esm/milliseconds/index.js
function milliseconds(_ref) {
  var years = _ref.years, months2 = _ref.months, weeks = _ref.weeks, days2 = _ref.days, hours = _ref.hours, minutes = _ref.minutes, seconds = _ref.seconds;
  requiredArgs(1, arguments);
  var totalDays = 0;
  if (years)
    totalDays += years * daysInYear2;
  if (months2)
    totalDays += months2 * (daysInYear2 / 12);
  if (weeks)
    totalDays += weeks * 7;
  if (days2)
    totalDays += days2;
  var totalSeconds = totalDays * 24 * 60 * 60;
  if (hours)
    totalSeconds += hours * 60 * 60;
  if (minutes)
    totalSeconds += minutes * 60;
  if (seconds)
    totalSeconds += seconds;
  return Math.round(totalSeconds * 1e3);
}
var daysInYear2;
var init_milliseconds = __esm({
  "node_modules/date-fns/esm/milliseconds/index.js"() {
    init_requiredArgs();
    daysInYear2 = 365.2425;
  }
});

// node_modules/date-fns/esm/millisecondsToHours/index.js
function millisecondsToHours(milliseconds2) {
  requiredArgs(1, arguments);
  var hours = milliseconds2 / millisecondsInHour;
  return Math.floor(hours);
}
var init_millisecondsToHours = __esm({
  "node_modules/date-fns/esm/millisecondsToHours/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/millisecondsToMinutes/index.js
function millisecondsToMinutes(milliseconds2) {
  requiredArgs(1, arguments);
  var minutes = milliseconds2 / millisecondsInMinute;
  return Math.floor(minutes);
}
var init_millisecondsToMinutes = __esm({
  "node_modules/date-fns/esm/millisecondsToMinutes/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/millisecondsToSeconds/index.js
function millisecondsToSeconds(milliseconds2) {
  requiredArgs(1, arguments);
  var seconds = milliseconds2 / millisecondsInSecond;
  return Math.floor(seconds);
}
var init_millisecondsToSeconds = __esm({
  "node_modules/date-fns/esm/millisecondsToSeconds/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/minutesToHours/index.js
function minutesToHours(minutes) {
  requiredArgs(1, arguments);
  var hours = minutes / minutesInHour;
  return Math.floor(hours);
}
var init_minutesToHours = __esm({
  "node_modules/date-fns/esm/minutesToHours/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/minutesToMilliseconds/index.js
function minutesToMilliseconds(minutes) {
  requiredArgs(1, arguments);
  return Math.floor(minutes * millisecondsInMinute);
}
var init_minutesToMilliseconds = __esm({
  "node_modules/date-fns/esm/minutesToMilliseconds/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/minutesToSeconds/index.js
function minutesToSeconds(minutes) {
  requiredArgs(1, arguments);
  return Math.floor(minutes * secondsInMinute);
}
var init_minutesToSeconds = __esm({
  "node_modules/date-fns/esm/minutesToSeconds/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/monthsToQuarters/index.js
function monthsToQuarters(months2) {
  requiredArgs(1, arguments);
  var quarters = months2 / monthsInQuarter;
  return Math.floor(quarters);
}
var init_monthsToQuarters = __esm({
  "node_modules/date-fns/esm/monthsToQuarters/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/monthsToYears/index.js
function monthsToYears(months2) {
  requiredArgs(1, arguments);
  var years = months2 / monthsInYear;
  return Math.floor(years);
}
var init_monthsToYears = __esm({
  "node_modules/date-fns/esm/monthsToYears/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/nextDay/index.js
function nextDay(date, day) {
  requiredArgs(2, arguments);
  var delta = day - getDay(date);
  if (delta <= 0)
    delta += 7;
  return addDays(date, delta);
}
var init_nextDay = __esm({
  "node_modules/date-fns/esm/nextDay/index.js"() {
    init_addDays();
    init_getDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextFriday/index.js
function nextFriday(date) {
  requiredArgs(1, arguments);
  return nextDay(date, 5);
}
var init_nextFriday = __esm({
  "node_modules/date-fns/esm/nextFriday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextMonday/index.js
function nextMonday(date) {
  requiredArgs(1, arguments);
  return nextDay(date, 1);
}
var init_nextMonday = __esm({
  "node_modules/date-fns/esm/nextMonday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextSaturday/index.js
function nextSaturday(date) {
  requiredArgs(1, arguments);
  return nextDay(date, 6);
}
var init_nextSaturday = __esm({
  "node_modules/date-fns/esm/nextSaturday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextSunday/index.js
function nextSunday(date) {
  requiredArgs(1, arguments);
  return nextDay(date, 0);
}
var init_nextSunday = __esm({
  "node_modules/date-fns/esm/nextSunday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextThursday/index.js
function nextThursday(date) {
  requiredArgs(1, arguments);
  return nextDay(date, 4);
}
var init_nextThursday = __esm({
  "node_modules/date-fns/esm/nextThursday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextTuesday/index.js
function nextTuesday(date) {
  requiredArgs(1, arguments);
  return nextDay(date, 2);
}
var init_nextTuesday = __esm({
  "node_modules/date-fns/esm/nextTuesday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/nextWednesday/index.js
function nextWednesday(date) {
  requiredArgs(1, arguments);
  return nextDay(date, 3);
}
var init_nextWednesday = __esm({
  "node_modules/date-fns/esm/nextWednesday/index.js"() {
    init_nextDay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/parseISO/index.js
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset);
}
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function isLeapYearIndex2(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex2(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex2(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
var patterns, dateRegex, timeRegex, timezoneRegex, daysInMonths;
var init_parseISO = __esm({
  "node_modules/date-fns/esm/parseISO/index.js"() {
    init_constants();
    init_requiredArgs();
    init_toInteger();
    patterns = {
      dateTimeDelimiter: /[T ]/,
      timeZoneDelimiter: /[Z ]/i,
      timezone: /([Z+-].*)$/
    };
    dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
    timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
    timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
    daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  }
});

// node_modules/date-fns/esm/parseJSON/index.js
function parseJSON(argument) {
  requiredArgs(1, arguments);
  if (typeof argument === "string") {
    var parts = argument.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1), +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1), +parts[6], +((parts[7] || "0") + "00").substring(0, 3)));
    }
    return new Date(NaN);
  }
  return toDate(argument);
}
var init_parseJSON = __esm({
  "node_modules/date-fns/esm/parseJSON/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/previousDay/index.js
function previousDay(date, day) {
  requiredArgs(2, arguments);
  var delta = getDay(date) - day;
  if (delta <= 0)
    delta += 7;
  return subDays(date, delta);
}
var init_previousDay = __esm({
  "node_modules/date-fns/esm/previousDay/index.js"() {
    init_requiredArgs();
    init_getDay();
    init_subDays();
  }
});

// node_modules/date-fns/esm/previousFriday/index.js
function previousFriday(date) {
  requiredArgs(1, arguments);
  return previousDay(date, 5);
}
var init_previousFriday = __esm({
  "node_modules/date-fns/esm/previousFriday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousMonday/index.js
function previousMonday(date) {
  requiredArgs(1, arguments);
  return previousDay(date, 1);
}
var init_previousMonday = __esm({
  "node_modules/date-fns/esm/previousMonday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousSaturday/index.js
function previousSaturday(date) {
  requiredArgs(1, arguments);
  return previousDay(date, 6);
}
var init_previousSaturday = __esm({
  "node_modules/date-fns/esm/previousSaturday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousSunday/index.js
function previousSunday(date) {
  requiredArgs(1, arguments);
  return previousDay(date, 0);
}
var init_previousSunday = __esm({
  "node_modules/date-fns/esm/previousSunday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousThursday/index.js
function previousThursday(date) {
  requiredArgs(1, arguments);
  return previousDay(date, 4);
}
var init_previousThursday = __esm({
  "node_modules/date-fns/esm/previousThursday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousTuesday/index.js
function previousTuesday(date) {
  requiredArgs(1, arguments);
  return previousDay(date, 2);
}
var init_previousTuesday = __esm({
  "node_modules/date-fns/esm/previousTuesday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/previousWednesday/index.js
function previousWednesday(date) {
  requiredArgs(1, arguments);
  return previousDay(date, 3);
}
var init_previousWednesday = __esm({
  "node_modules/date-fns/esm/previousWednesday/index.js"() {
    init_requiredArgs();
    init_previousDay();
  }
});

// node_modules/date-fns/esm/quartersToMonths/index.js
function quartersToMonths(quarters) {
  requiredArgs(1, arguments);
  return Math.floor(quarters * monthsInQuarter);
}
var init_quartersToMonths = __esm({
  "node_modules/date-fns/esm/quartersToMonths/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/quartersToYears/index.js
function quartersToYears(quarters) {
  requiredArgs(1, arguments);
  var years = quarters / quartersInYear;
  return Math.floor(years);
}
var init_quartersToYears = __esm({
  "node_modules/date-fns/esm/quartersToYears/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/roundToNearestMinutes/index.js
function roundToNearestMinutes(dirtyDate, options) {
  var _options$nearestTo;
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only none provided present");
  }
  var nearestTo = toInteger((_options$nearestTo = options === null || options === void 0 ? void 0 : options.nearestTo) !== null && _options$nearestTo !== void 0 ? _options$nearestTo : 1);
  if (nearestTo < 1 || nearestTo > 30) {
    throw new RangeError("`options.nearestTo` must be between 1 and 30");
  }
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  var minutes = date.getMinutes() + seconds / 60;
  var roundingMethod = getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod);
  var roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;
  var remainderMinutes = minutes % nearestTo;
  var addedMinutes = Math.round(remainderMinutes / nearestTo) * nearestTo;
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), roundedMinutes + addedMinutes);
}
var init_roundToNearestMinutes = __esm({
  "node_modules/date-fns/esm/roundToNearestMinutes/index.js"() {
    init_toDate();
    init_roundingMethods();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/secondsToHours/index.js
function secondsToHours(seconds) {
  requiredArgs(1, arguments);
  var hours = seconds / secondsInHour;
  return Math.floor(hours);
}
var init_secondsToHours = __esm({
  "node_modules/date-fns/esm/secondsToHours/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/secondsToMilliseconds/index.js
function secondsToMilliseconds(seconds) {
  requiredArgs(1, arguments);
  return seconds * millisecondsInSecond;
}
var init_secondsToMilliseconds = __esm({
  "node_modules/date-fns/esm/secondsToMilliseconds/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/secondsToMinutes/index.js
function secondsToMinutes(seconds) {
  requiredArgs(1, arguments);
  var minutes = seconds / secondsInMinute;
  return Math.floor(minutes);
}
var init_secondsToMinutes = __esm({
  "node_modules/date-fns/esm/secondsToMinutes/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/setMonth/index.js
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
var init_setMonth = __esm({
  "node_modules/date-fns/esm/setMonth/index.js"() {
    init_toInteger();
    init_toDate();
    init_getDaysInMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/set/index.js
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (_typeof(values) !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate(dirtyDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = setMonth(date, values.month);
  }
  if (values.date != null) {
    date.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds(toInteger(values.milliseconds));
  }
  return date;
}
var init_set = __esm({
  "node_modules/date-fns/esm/set/index.js"() {
    init_typeof();
    init_toDate();
    init_setMonth();
    init_toInteger();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setDate/index.js
function setDate(dirtyDate, dirtyDayOfMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = toInteger(dirtyDayOfMonth);
  date.setDate(dayOfMonth);
  return date;
}
var init_setDate = __esm({
  "node_modules/date-fns/esm/setDate/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setDay/index.js
function setDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var delta = 7 - weekStartsOn;
  var diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date, diff);
}
var init_setDay = __esm({
  "node_modules/date-fns/esm/setDay/index.js"() {
    init_addDays();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/setDayOfYear/index.js
function setDayOfYear(dirtyDate, dirtyDayOfYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dayOfYear = toInteger(dirtyDayOfYear);
  date.setMonth(0);
  date.setDate(dayOfYear);
  return date;
}
var init_setDayOfYear = __esm({
  "node_modules/date-fns/esm/setDayOfYear/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setDefaultOptions/index.js
function setDefaultOptions2(newOptions) {
  requiredArgs(1, arguments);
  var result = {};
  var defaultOptions2 = getDefaultOptions();
  for (var property in defaultOptions2) {
    if (Object.prototype.hasOwnProperty.call(defaultOptions2, property)) {
      ;
      result[property] = defaultOptions2[property];
    }
  }
  for (var _property in newOptions) {
    if (Object.prototype.hasOwnProperty.call(newOptions, _property)) {
      if (newOptions[_property] === void 0) {
        delete result[_property];
      } else {
        ;
        result[_property] = newOptions[_property];
      }
    }
  }
  setDefaultOptions(result);
}
var init_setDefaultOptions = __esm({
  "node_modules/date-fns/esm/setDefaultOptions/index.js"() {
    init_defaultOptions();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setHours/index.js
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}
var init_setHours = __esm({
  "node_modules/date-fns/esm/setHours/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setISODay/index.js
function setISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = getISODay(date);
  var diff = day - currentDay;
  return addDays(date, diff);
}
var init_setISODay = __esm({
  "node_modules/date-fns/esm/setISODay/index.js"() {
    init_toInteger();
    init_toDate();
    init_addDays();
    init_getISODay();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setISOWeek/index.js
function setISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getISOWeek(date) - isoWeek;
  date.setDate(date.getDate() - diff * 7);
  return date;
}
var init_setISOWeek = __esm({
  "node_modules/date-fns/esm/setISOWeek/index.js"() {
    init_toInteger();
    init_toDate();
    init_getISOWeek();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setMilliseconds/index.js
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var milliseconds2 = toInteger(dirtyMilliseconds);
  date.setMilliseconds(milliseconds2);
  return date;
}
var init_setMilliseconds = __esm({
  "node_modules/date-fns/esm/setMilliseconds/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setMinutes/index.js
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}
var init_setMinutes = __esm({
  "node_modules/date-fns/esm/setMinutes/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setQuarter/index.js
function setQuarter(dirtyDate, dirtyQuarter) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var quarter = toInteger(dirtyQuarter);
  var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
  var diff = quarter - oldQuarter;
  return setMonth(date, date.getMonth() + diff * 3);
}
var init_setQuarter = __esm({
  "node_modules/date-fns/esm/setQuarter/index.js"() {
    init_toInteger();
    init_toDate();
    init_setMonth();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setSeconds/index.js
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}
var init_setSeconds = __esm({
  "node_modules/date-fns/esm/setSeconds/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/setWeek/index.js
function setWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getWeek(date, options) - week;
  date.setDate(date.getDate() - diff * 7);
  return date;
}
var init_setWeek = __esm({
  "node_modules/date-fns/esm/setWeek/index.js"() {
    init_getWeek();
    init_toDate();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/setWeekYear/index.js
function setWeekYear(dirtyDate, dirtyWeekYear, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var date = toDate(dirtyDate);
  var weekYear = toInteger(dirtyWeekYear);
  var diff = differenceInCalendarDays(date, startOfWeekYear(date, options));
  var firstWeek = new Date(0);
  firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  date = startOfWeekYear(firstWeek, options);
  date.setDate(date.getDate() + diff);
  return date;
}
var init_setWeekYear = __esm({
  "node_modules/date-fns/esm/setWeekYear/index.js"() {
    init_differenceInCalendarDays();
    init_startOfWeekYear();
    init_toDate();
    init_toInteger();
    init_requiredArgs();
    init_defaultOptions();
  }
});

// node_modules/date-fns/esm/setYear/index.js
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
var init_setYear = __esm({
  "node_modules/date-fns/esm/setYear/index.js"() {
    init_toInteger();
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfDecade/index.js
function startOfDecade(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var decade = Math.floor(year / 10) * 10;
  date.setFullYear(decade, 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfDecade = __esm({
  "node_modules/date-fns/esm/startOfDecade/index.js"() {
    init_toDate();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/startOfToday/index.js
function startOfToday() {
  return startOfDay(Date.now());
}
var init_startOfToday = __esm({
  "node_modules/date-fns/esm/startOfToday/index.js"() {
    init_startOfDay();
  }
});

// node_modules/date-fns/esm/startOfTomorrow/index.js
function startOfTomorrow() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day + 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfTomorrow = __esm({
  "node_modules/date-fns/esm/startOfTomorrow/index.js"() {
  }
});

// node_modules/date-fns/esm/startOfYesterday/index.js
function startOfYesterday() {
  var now = new Date();
  var year = now.getFullYear();
  var month = now.getMonth();
  var day = now.getDate();
  var date = new Date(0);
  date.setFullYear(year, month, day - 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
var init_startOfYesterday = __esm({
  "node_modules/date-fns/esm/startOfYesterday/index.js"() {
  }
});

// node_modules/date-fns/esm/subMonths/index.js
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
var init_subMonths = __esm({
  "node_modules/date-fns/esm/subMonths/index.js"() {
    init_toInteger();
    init_addMonths();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/sub/index.js
function sub(date, duration) {
  requiredArgs(2, arguments);
  if (!duration || _typeof(duration) !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months2 = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days2 = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var dateWithoutMonths = subMonths(date, months2 + years * 12);
  var dateWithoutDays = subDays(dateWithoutMonths, days2 + weeks * 7);
  var minutestoSub = minutes + hours * 60;
  var secondstoSub = seconds + minutestoSub * 60;
  var mstoSub = secondstoSub * 1e3;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}
var init_sub = __esm({
  "node_modules/date-fns/esm/sub/index.js"() {
    init_typeof();
    init_subDays();
    init_subMonths();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subBusinessDays/index.js
function subBusinessDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addBusinessDays(dirtyDate, -amount);
}
var init_subBusinessDays = __esm({
  "node_modules/date-fns/esm/subBusinessDays/index.js"() {
    init_addBusinessDays();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subHours/index.js
function subHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addHours(dirtyDate, -amount);
}
var init_subHours = __esm({
  "node_modules/date-fns/esm/subHours/index.js"() {
    init_addHours();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subMinutes/index.js
function subMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMinutes(dirtyDate, -amount);
}
var init_subMinutes = __esm({
  "node_modules/date-fns/esm/subMinutes/index.js"() {
    init_addMinutes();
    init_requiredArgs();
    init_toInteger();
  }
});

// node_modules/date-fns/esm/subQuarters/index.js
function subQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addQuarters(dirtyDate, -amount);
}
var init_subQuarters = __esm({
  "node_modules/date-fns/esm/subQuarters/index.js"() {
    init_toInteger();
    init_addQuarters();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subSeconds/index.js
function subSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addSeconds(dirtyDate, -amount);
}
var init_subSeconds = __esm({
  "node_modules/date-fns/esm/subSeconds/index.js"() {
    init_toInteger();
    init_addSeconds();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subWeeks/index.js
function subWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addWeeks(dirtyDate, -amount);
}
var init_subWeeks = __esm({
  "node_modules/date-fns/esm/subWeeks/index.js"() {
    init_toInteger();
    init_addWeeks();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/subYears/index.js
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
var init_subYears = __esm({
  "node_modules/date-fns/esm/subYears/index.js"() {
    init_toInteger();
    init_addYears();
    init_requiredArgs();
  }
});

// node_modules/date-fns/esm/weeksToDays/index.js
function weeksToDays(weeks) {
  requiredArgs(1, arguments);
  return Math.floor(weeks * daysInWeek);
}
var init_weeksToDays = __esm({
  "node_modules/date-fns/esm/weeksToDays/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/yearsToMonths/index.js
function yearsToMonths(years) {
  requiredArgs(1, arguments);
  return Math.floor(years * monthsInYear);
}
var init_yearsToMonths = __esm({
  "node_modules/date-fns/esm/yearsToMonths/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/yearsToQuarters/index.js
function yearsToQuarters(years) {
  requiredArgs(1, arguments);
  return Math.floor(years * quartersInYear);
}
var init_yearsToQuarters = __esm({
  "node_modules/date-fns/esm/yearsToQuarters/index.js"() {
    init_requiredArgs();
    init_constants();
  }
});

// node_modules/date-fns/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  add: () => add,
  addBusinessDays: () => addBusinessDays,
  addDays: () => addDays,
  addHours: () => addHours,
  addISOWeekYears: () => addISOWeekYears,
  addMilliseconds: () => addMilliseconds,
  addMinutes: () => addMinutes,
  addMonths: () => addMonths,
  addQuarters: () => addQuarters,
  addSeconds: () => addSeconds,
  addWeeks: () => addWeeks,
  addYears: () => addYears,
  areIntervalsOverlapping: () => areIntervalsOverlapping,
  clamp: () => clamp,
  closestIndexTo: () => closestIndexTo,
  closestTo: () => closestTo,
  compareAsc: () => compareAsc,
  compareDesc: () => compareDesc,
  daysInWeek: () => daysInWeek,
  daysInYear: () => daysInYear,
  daysToWeeks: () => daysToWeeks,
  differenceInBusinessDays: () => differenceInBusinessDays,
  differenceInCalendarDays: () => differenceInCalendarDays,
  differenceInCalendarISOWeekYears: () => differenceInCalendarISOWeekYears,
  differenceInCalendarISOWeeks: () => differenceInCalendarISOWeeks,
  differenceInCalendarMonths: () => differenceInCalendarMonths,
  differenceInCalendarQuarters: () => differenceInCalendarQuarters,
  differenceInCalendarWeeks: () => differenceInCalendarWeeks,
  differenceInCalendarYears: () => differenceInCalendarYears,
  differenceInDays: () => differenceInDays,
  differenceInHours: () => differenceInHours,
  differenceInISOWeekYears: () => differenceInISOWeekYears,
  differenceInMilliseconds: () => differenceInMilliseconds,
  differenceInMinutes: () => differenceInMinutes,
  differenceInMonths: () => differenceInMonths,
  differenceInQuarters: () => differenceInQuarters,
  differenceInSeconds: () => differenceInSeconds,
  differenceInWeeks: () => differenceInWeeks,
  differenceInYears: () => differenceInYears,
  eachDayOfInterval: () => eachDayOfInterval,
  eachHourOfInterval: () => eachHourOfInterval,
  eachMinuteOfInterval: () => eachMinuteOfInterval,
  eachMonthOfInterval: () => eachMonthOfInterval,
  eachQuarterOfInterval: () => eachQuarterOfInterval,
  eachWeekOfInterval: () => eachWeekOfInterval,
  eachWeekendOfInterval: () => eachWeekendOfInterval,
  eachWeekendOfMonth: () => eachWeekendOfMonth,
  eachWeekendOfYear: () => eachWeekendOfYear,
  eachYearOfInterval: () => eachYearOfInterval,
  endOfDay: () => endOfDay,
  endOfDecade: () => endOfDecade,
  endOfHour: () => endOfHour,
  endOfISOWeek: () => endOfISOWeek,
  endOfISOWeekYear: () => endOfISOWeekYear,
  endOfMinute: () => endOfMinute,
  endOfMonth: () => endOfMonth,
  endOfQuarter: () => endOfQuarter,
  endOfSecond: () => endOfSecond,
  endOfToday: () => endOfToday,
  endOfTomorrow: () => endOfTomorrow,
  endOfWeek: () => endOfWeek,
  endOfYear: () => endOfYear,
  endOfYesterday: () => endOfYesterday,
  format: () => format,
  formatDistance: () => formatDistance3,
  formatDistanceStrict: () => formatDistanceStrict,
  formatDistanceToNow: () => formatDistanceToNow,
  formatDistanceToNowStrict: () => formatDistanceToNowStrict,
  formatDuration: () => formatDuration,
  formatISO: () => formatISO,
  formatISO9075: () => formatISO9075,
  formatISODuration: () => formatISODuration,
  formatRFC3339: () => formatRFC3339,
  formatRFC7231: () => formatRFC7231,
  formatRelative: () => formatRelative3,
  fromUnixTime: () => fromUnixTime,
  getDate: () => getDate,
  getDay: () => getDay,
  getDayOfYear: () => getDayOfYear,
  getDaysInMonth: () => getDaysInMonth,
  getDaysInYear: () => getDaysInYear,
  getDecade: () => getDecade,
  getDefaultOptions: () => getDefaultOptions2,
  getHours: () => getHours,
  getISODay: () => getISODay,
  getISOWeek: () => getISOWeek,
  getISOWeekYear: () => getISOWeekYear,
  getISOWeeksInYear: () => getISOWeeksInYear,
  getMilliseconds: () => getMilliseconds,
  getMinutes: () => getMinutes,
  getMonth: () => getMonth,
  getOverlappingDaysInIntervals: () => getOverlappingDaysInIntervals,
  getQuarter: () => getQuarter,
  getSeconds: () => getSeconds,
  getTime: () => getTime,
  getUnixTime: () => getUnixTime,
  getWeek: () => getWeek,
  getWeekOfMonth: () => getWeekOfMonth,
  getWeekYear: () => getWeekYear,
  getWeeksInMonth: () => getWeeksInMonth,
  getYear: () => getYear,
  hoursToMilliseconds: () => hoursToMilliseconds,
  hoursToMinutes: () => hoursToMinutes,
  hoursToSeconds: () => hoursToSeconds,
  intervalToDuration: () => intervalToDuration,
  intlFormat: () => intlFormat,
  intlFormatDistance: () => intlFormatDistance,
  isAfter: () => isAfter,
  isBefore: () => isBefore,
  isDate: () => isDate,
  isEqual: () => isEqual,
  isExists: () => isExists,
  isFirstDayOfMonth: () => isFirstDayOfMonth,
  isFriday: () => isFriday,
  isFuture: () => isFuture,
  isLastDayOfMonth: () => isLastDayOfMonth,
  isLeapYear: () => isLeapYear,
  isMatch: () => isMatch,
  isMonday: () => isMonday,
  isPast: () => isPast,
  isSameDay: () => isSameDay,
  isSameHour: () => isSameHour,
  isSameISOWeek: () => isSameISOWeek,
  isSameISOWeekYear: () => isSameISOWeekYear,
  isSameMinute: () => isSameMinute,
  isSameMonth: () => isSameMonth,
  isSameQuarter: () => isSameQuarter,
  isSameSecond: () => isSameSecond,
  isSameWeek: () => isSameWeek,
  isSameYear: () => isSameYear,
  isSaturday: () => isSaturday,
  isSunday: () => isSunday,
  isThisHour: () => isThisHour,
  isThisISOWeek: () => isThisISOWeek,
  isThisMinute: () => isThisMinute,
  isThisMonth: () => isThisMonth,
  isThisQuarter: () => isThisQuarter,
  isThisSecond: () => isThisSecond,
  isThisWeek: () => isThisWeek,
  isThisYear: () => isThisYear,
  isThursday: () => isThursday,
  isToday: () => isToday,
  isTomorrow: () => isTomorrow,
  isTuesday: () => isTuesday,
  isValid: () => isValid,
  isWednesday: () => isWednesday,
  isWeekend: () => isWeekend,
  isWithinInterval: () => isWithinInterval,
  isYesterday: () => isYesterday,
  lastDayOfDecade: () => lastDayOfDecade,
  lastDayOfISOWeek: () => lastDayOfISOWeek,
  lastDayOfISOWeekYear: () => lastDayOfISOWeekYear,
  lastDayOfMonth: () => lastDayOfMonth,
  lastDayOfQuarter: () => lastDayOfQuarter,
  lastDayOfWeek: () => lastDayOfWeek,
  lastDayOfYear: () => lastDayOfYear,
  lightFormat: () => lightFormat,
  max: () => max,
  maxTime: () => maxTime,
  milliseconds: () => milliseconds,
  millisecondsInHour: () => millisecondsInHour,
  millisecondsInMinute: () => millisecondsInMinute,
  millisecondsInSecond: () => millisecondsInSecond,
  millisecondsToHours: () => millisecondsToHours,
  millisecondsToMinutes: () => millisecondsToMinutes,
  millisecondsToSeconds: () => millisecondsToSeconds,
  min: () => min,
  minTime: () => minTime,
  minutesInHour: () => minutesInHour,
  minutesToHours: () => minutesToHours,
  minutesToMilliseconds: () => minutesToMilliseconds,
  minutesToSeconds: () => minutesToSeconds,
  monthsInQuarter: () => monthsInQuarter,
  monthsInYear: () => monthsInYear,
  monthsToQuarters: () => monthsToQuarters,
  monthsToYears: () => monthsToYears,
  nextDay: () => nextDay,
  nextFriday: () => nextFriday,
  nextMonday: () => nextMonday,
  nextSaturday: () => nextSaturday,
  nextSunday: () => nextSunday,
  nextThursday: () => nextThursday,
  nextTuesday: () => nextTuesday,
  nextWednesday: () => nextWednesday,
  parse: () => parse,
  parseISO: () => parseISO,
  parseJSON: () => parseJSON,
  previousDay: () => previousDay,
  previousFriday: () => previousFriday,
  previousMonday: () => previousMonday,
  previousSaturday: () => previousSaturday,
  previousSunday: () => previousSunday,
  previousThursday: () => previousThursday,
  previousTuesday: () => previousTuesday,
  previousWednesday: () => previousWednesday,
  quartersInYear: () => quartersInYear,
  quartersToMonths: () => quartersToMonths,
  quartersToYears: () => quartersToYears,
  roundToNearestMinutes: () => roundToNearestMinutes,
  secondsInDay: () => secondsInDay,
  secondsInHour: () => secondsInHour,
  secondsInMinute: () => secondsInMinute,
  secondsInMonth: () => secondsInMonth,
  secondsInQuarter: () => secondsInQuarter,
  secondsInWeek: () => secondsInWeek,
  secondsInYear: () => secondsInYear,
  secondsToHours: () => secondsToHours,
  secondsToMilliseconds: () => secondsToMilliseconds,
  secondsToMinutes: () => secondsToMinutes,
  set: () => set,
  setDate: () => setDate,
  setDay: () => setDay,
  setDayOfYear: () => setDayOfYear,
  setDefaultOptions: () => setDefaultOptions2,
  setHours: () => setHours,
  setISODay: () => setISODay,
  setISOWeek: () => setISOWeek,
  setISOWeekYear: () => setISOWeekYear,
  setMilliseconds: () => setMilliseconds,
  setMinutes: () => setMinutes,
  setMonth: () => setMonth,
  setQuarter: () => setQuarter,
  setSeconds: () => setSeconds,
  setWeek: () => setWeek,
  setWeekYear: () => setWeekYear,
  setYear: () => setYear,
  startOfDay: () => startOfDay,
  startOfDecade: () => startOfDecade,
  startOfHour: () => startOfHour,
  startOfISOWeek: () => startOfISOWeek,
  startOfISOWeekYear: () => startOfISOWeekYear,
  startOfMinute: () => startOfMinute,
  startOfMonth: () => startOfMonth,
  startOfQuarter: () => startOfQuarter,
  startOfSecond: () => startOfSecond,
  startOfToday: () => startOfToday,
  startOfTomorrow: () => startOfTomorrow,
  startOfWeek: () => startOfWeek,
  startOfWeekYear: () => startOfWeekYear,
  startOfYear: () => startOfYear,
  startOfYesterday: () => startOfYesterday,
  sub: () => sub,
  subBusinessDays: () => subBusinessDays,
  subDays: () => subDays,
  subHours: () => subHours,
  subISOWeekYears: () => subISOWeekYears,
  subMilliseconds: () => subMilliseconds,
  subMinutes: () => subMinutes,
  subMonths: () => subMonths,
  subQuarters: () => subQuarters,
  subSeconds: () => subSeconds,
  subWeeks: () => subWeeks,
  subYears: () => subYears,
  toDate: () => toDate,
  weeksToDays: () => weeksToDays,
  yearsToMonths: () => yearsToMonths,
  yearsToQuarters: () => yearsToQuarters
});
var init_esm = __esm({
  "node_modules/date-fns/esm/index.js"() {
    init_add();
    init_addBusinessDays();
    init_addDays();
    init_addHours();
    init_addISOWeekYears();
    init_addMilliseconds();
    init_addMinutes();
    init_addMonths();
    init_addQuarters();
    init_addSeconds();
    init_addWeeks();
    init_addYears();
    init_areIntervalsOverlapping();
    init_clamp();
    init_closestIndexTo();
    init_closestTo();
    init_compareAsc();
    init_compareDesc();
    init_daysToWeeks();
    init_differenceInBusinessDays();
    init_differenceInCalendarDays();
    init_differenceInCalendarISOWeekYears();
    init_differenceInCalendarISOWeeks();
    init_differenceInCalendarMonths();
    init_differenceInCalendarQuarters();
    init_differenceInCalendarWeeks();
    init_differenceInCalendarYears();
    init_differenceInDays();
    init_differenceInHours();
    init_differenceInISOWeekYears();
    init_differenceInMilliseconds();
    init_differenceInMinutes();
    init_differenceInMonths();
    init_differenceInQuarters();
    init_differenceInSeconds();
    init_differenceInWeeks();
    init_differenceInYears();
    init_eachDayOfInterval();
    init_eachHourOfInterval();
    init_eachMinuteOfInterval();
    init_eachMonthOfInterval();
    init_eachQuarterOfInterval();
    init_eachWeekOfInterval();
    init_eachWeekendOfInterval();
    init_eachWeekendOfMonth();
    init_eachWeekendOfYear();
    init_eachYearOfInterval();
    init_endOfDay();
    init_endOfDecade();
    init_endOfHour();
    init_endOfISOWeek();
    init_endOfISOWeekYear();
    init_endOfMinute();
    init_endOfMonth();
    init_endOfQuarter();
    init_endOfSecond();
    init_endOfToday();
    init_endOfTomorrow();
    init_endOfWeek();
    init_endOfYear();
    init_endOfYesterday();
    init_format();
    init_formatDistance2();
    init_formatDistanceStrict();
    init_formatDistanceToNow();
    init_formatDistanceToNowStrict();
    init_formatDuration();
    init_formatISO();
    init_formatISO9075();
    init_formatISODuration();
    init_formatRFC3339();
    init_formatRFC7231();
    init_formatRelative2();
    init_fromUnixTime();
    init_getDate();
    init_getDay();
    init_getDayOfYear();
    init_getDaysInMonth();
    init_getDaysInYear();
    init_getDecade();
    init_getDefaultOptions();
    init_getHours();
    init_getISODay();
    init_getISOWeek();
    init_getISOWeekYear();
    init_getISOWeeksInYear();
    init_getMilliseconds();
    init_getMinutes();
    init_getMonth();
    init_getOverlappingDaysInIntervals();
    init_getQuarter();
    init_getSeconds();
    init_getTime();
    init_getUnixTime();
    init_getWeek();
    init_getWeekOfMonth();
    init_getWeekYear();
    init_getWeeksInMonth();
    init_getYear();
    init_hoursToMilliseconds();
    init_hoursToMinutes();
    init_hoursToSeconds();
    init_intervalToDuration();
    init_intlFormat();
    init_intlFormatDistance();
    init_isAfter();
    init_isBefore();
    init_isDate();
    init_isEqual();
    init_isExists();
    init_isFirstDayOfMonth();
    init_isFriday();
    init_isFuture();
    init_isLastDayOfMonth();
    init_isLeapYear();
    init_isMatch();
    init_isMonday();
    init_isPast();
    init_isSameDay();
    init_isSameHour();
    init_isSameISOWeek();
    init_isSameISOWeekYear();
    init_isSameMinute();
    init_isSameMonth();
    init_isSameQuarter();
    init_isSameSecond();
    init_isSameWeek();
    init_isSameYear();
    init_isSaturday();
    init_isSunday();
    init_isThisHour();
    init_isThisISOWeek();
    init_isThisMinute();
    init_isThisMonth();
    init_isThisQuarter();
    init_isThisSecond();
    init_isThisWeek();
    init_isThisYear();
    init_isThursday();
    init_isToday();
    init_isTomorrow();
    init_isTuesday();
    init_isValid();
    init_isWednesday();
    init_isWeekend();
    init_isWithinInterval();
    init_isYesterday();
    init_lastDayOfDecade();
    init_lastDayOfISOWeek();
    init_lastDayOfISOWeekYear();
    init_lastDayOfMonth();
    init_lastDayOfQuarter();
    init_lastDayOfWeek();
    init_lastDayOfYear();
    init_lightFormat();
    init_max();
    init_milliseconds();
    init_millisecondsToHours();
    init_millisecondsToMinutes();
    init_millisecondsToSeconds();
    init_min();
    init_minutesToHours();
    init_minutesToMilliseconds();
    init_minutesToSeconds();
    init_monthsToQuarters();
    init_monthsToYears();
    init_nextDay();
    init_nextFriday();
    init_nextMonday();
    init_nextSaturday();
    init_nextSunday();
    init_nextThursday();
    init_nextTuesday();
    init_nextWednesday();
    init_parse();
    init_parseISO();
    init_parseJSON();
    init_previousDay();
    init_previousFriday();
    init_previousMonday();
    init_previousSaturday();
    init_previousSunday();
    init_previousThursday();
    init_previousTuesday();
    init_previousWednesday();
    init_quartersToMonths();
    init_quartersToYears();
    init_roundToNearestMinutes();
    init_secondsToHours();
    init_secondsToMilliseconds();
    init_secondsToMinutes();
    init_set();
    init_setDate();
    init_setDay();
    init_setDayOfYear();
    init_setDefaultOptions();
    init_setHours();
    init_setISODay();
    init_setISOWeek();
    init_setISOWeekYear();
    init_setMilliseconds();
    init_setMinutes();
    init_setMonth();
    init_setQuarter();
    init_setSeconds();
    init_setWeek();
    init_setWeekYear();
    init_setYear();
    init_startOfDay();
    init_startOfDecade();
    init_startOfHour();
    init_startOfISOWeek();
    init_startOfISOWeekYear();
    init_startOfMinute();
    init_startOfMonth();
    init_startOfQuarter();
    init_startOfSecond();
    init_startOfToday();
    init_startOfTomorrow();
    init_startOfWeek();
    init_startOfWeekYear();
    init_startOfYear();
    init_startOfYesterday();
    init_sub();
    init_subBusinessDays();
    init_subDays();
    init_subHours();
    init_subISOWeekYears();
    init_subMilliseconds();
    init_subMinutes();
    init_subMonths();
    init_subQuarters();
    init_subSeconds();
    init_subWeeks();
    init_subYears();
    init_toDate();
    init_weeksToDays();
    init_yearsToMonths();
    init_yearsToQuarters();
    init_constants();
  }
});

// node_modules/@daohaus/utils/src/utils/dates.js
var require_dates = __commonJS({
  "node_modules/@daohaus/utils/src/utils/dates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatDistanceToNowFromSeconds = exports.formatLongDateFromSeconds = exports.formatDateFromSeconds = exports.formatShortDateTimeFromSeconds = exports.formatDateTimeFromSeconds = void 0;
    var date_fns_1 = (init_esm(), __toCommonJS(esm_exports));
    var formatDateTimeFromSeconds = (seconds) => {
      if (!seconds) {
        return;
      }
      return (0, date_fns_1.format)(new Date(Number(seconds) * 1e3), "h:mm aaa MMMM do y");
    };
    exports.formatDateTimeFromSeconds = formatDateTimeFromSeconds;
    var formatShortDateTimeFromSeconds = (seconds) => {
      if (!seconds) {
        return;
      }
      return (0, date_fns_1.format)(new Date(Number(seconds) * 1e3), "MMMM do, p");
    };
    exports.formatShortDateTimeFromSeconds = formatShortDateTimeFromSeconds;
    var formatDateFromSeconds = (seconds) => {
      if (!seconds) {
        return;
      }
      return (0, date_fns_1.format)(new Date(Number(seconds) * 1e3), "M / dd / yy");
    };
    exports.formatDateFromSeconds = formatDateFromSeconds;
    var formatLongDateFromSeconds = (seconds) => {
      if (!seconds) {
        return;
      }
      return (0, date_fns_1.format)(new Date(Number(seconds) * 1e3), "MMMM dd, yyyy");
    };
    exports.formatLongDateFromSeconds = formatLongDateFromSeconds;
    var formatDistanceToNowFromSeconds = (seconds) => {
      if (!seconds) {
        return;
      }
      return (0, date_fns_1.formatDistanceToNow)(new Date(Number(seconds) * 1e3), {
        addSuffix: true
      });
    };
    exports.formatDistanceToNowFromSeconds = formatDistanceToNowFromSeconds;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/version.js
var require_version = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.9.3";
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var version_js_1 = require_version();
    var BaseError = class extends Error {
      constructor(shortMessage, args = {}) {
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: abitype@${version_js_1.version}`
        ].join("\n");
        super(message);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiTypeError"
        });
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
    };
    exports.BaseError = BaseError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/narrow.js
var require_narrow = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/narrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.narrow = void 0;
    function narrow(value) {
      return value;
    }
    exports.narrow = narrow;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/regex.js
var require_regex = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTupleRegex = exports.integerRegex = exports.bytesRegex = exports.execTyped = void 0;
    function execTyped(regex, string) {
      const match2 = regex.exec(string);
      return match2?.groups;
    }
    exports.execTyped = execTyped;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    exports.isTupleRegex = /^\(.+?\).*?$/;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js
var require_formatAbiParameter = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParameter = void 0;
    var regex_js_1 = require_regex();
    var tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    function formatAbiParameter(abiParameter) {
      let type = abiParameter.type;
      if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
        type = "(";
        const length = abiParameter.components.length;
        for (let i2 = 0; i2 < length; i2++) {
          const component = abiParameter.components[i2];
          type += formatAbiParameter(component);
          if (i2 < length - 1)
            type += ", ";
        }
        const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ""}`;
        return formatAbiParameter({
          ...abiParameter,
          type
        });
      }
      if ("indexed" in abiParameter && abiParameter.indexed)
        type = `${type} indexed`;
      if (abiParameter.name)
        return `${type} ${abiParameter.name}`;
      return type;
    }
    exports.formatAbiParameter = formatAbiParameter;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js
var require_formatAbiParameters = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParameters = void 0;
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    function formatAbiParameters(abiParameters) {
      let params = "";
      const length = abiParameters.length;
      for (let i2 = 0; i2 < length; i2++) {
        const abiParameter = abiParameters[i2];
        params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
        if (i2 !== length - 1)
          params += ", ";
      }
      return params;
    }
    exports.formatAbiParameters = formatAbiParameters;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js
var require_formatAbiItem2 = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiItem = void 0;
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    function formatAbiItem(abiItem) {
      if (abiItem.type === "function")
        return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})` : ""}`;
      else if (abiItem.type === "event")
        return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "error")
        return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "constructor")
        return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
      else if (abiItem.type === "fallback")
        return "fallback()";
      return "receive() external payable";
    }
    exports.formatAbiItem = formatAbiItem;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbi.js
var require_formatAbi = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbi = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem2();
    function formatAbi(abi) {
      const signatures = [];
      const length = abi.length;
      for (let i2 = 0; i2 < length; i2++) {
        const abiItem = abi[i2];
        const signature = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
        signatures.push(signature);
      }
      return signatures;
    }
    exports.formatAbi = formatAbi;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js
var require_signatures = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.functionModifiers = exports.eventModifiers = exports.modifiers = exports.isReceiveSignature = exports.isFallbackSignature = exports.execConstructorSignature = exports.isConstructorSignature = exports.execStructSignature = exports.isStructSignature = exports.execFunctionSignature = exports.isFunctionSignature = exports.execEventSignature = exports.isEventSignature = exports.execErrorSignature = exports.isErrorSignature = void 0;
    var regex_js_1 = require_regex();
    var errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isErrorSignature(signature) {
      return errorSignatureRegex.test(signature);
    }
    exports.isErrorSignature = isErrorSignature;
    function execErrorSignature(signature) {
      return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
    }
    exports.execErrorSignature = execErrorSignature;
    var eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isEventSignature(signature) {
      return eventSignatureRegex.test(signature);
    }
    exports.isEventSignature = isEventSignature;
    function execEventSignature(signature) {
      return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
    }
    exports.execEventSignature = execEventSignature;
    var functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
    function isFunctionSignature(signature) {
      return functionSignatureRegex.test(signature);
    }
    exports.isFunctionSignature = isFunctionSignature;
    function execFunctionSignature(signature) {
      return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
    }
    exports.execFunctionSignature = execFunctionSignature;
    var structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
    function isStructSignature(signature) {
      return structSignatureRegex.test(signature);
    }
    exports.isStructSignature = isStructSignature;
    function execStructSignature(signature) {
      return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
    }
    exports.execStructSignature = execStructSignature;
    var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
    function isConstructorSignature(signature) {
      return constructorSignatureRegex.test(signature);
    }
    exports.isConstructorSignature = isConstructorSignature;
    function execConstructorSignature(signature) {
      return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
    }
    exports.execConstructorSignature = execConstructorSignature;
    var fallbackSignatureRegex = /^fallback\(\)$/;
    function isFallbackSignature(signature) {
      return fallbackSignatureRegex.test(signature);
    }
    exports.isFallbackSignature = isFallbackSignature;
    var receiveSignatureRegex = /^receive\(\) external payable$/;
    function isReceiveSignature(signature) {
      return receiveSignatureRegex.test(signature);
    }
    exports.isReceiveSignature = isReceiveSignature;
    exports.modifiers = /* @__PURE__ */ new Set([
      "memory",
      "indexed",
      "storage",
      "calldata"
    ]);
    exports.eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
    exports.functionModifiers = /* @__PURE__ */ new Set([
      "calldata",
      "memory",
      "storage"
    ]);
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js
var require_abiItem = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownSolidityTypeError = exports.UnknownTypeError = exports.InvalidAbiItemError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiItemError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Failed to parse ABI item.", {
          details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
          docsPath: "/api/human.html#parseabiitem-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiItemError"
        });
      }
    };
    exports.InvalidAbiItemError = InvalidAbiItemError;
    var UnknownTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [
            `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownTypeError"
        });
      }
    };
    exports.UnknownTypeError = UnknownTypeError;
    var UnknownSolidityTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [`Type "${type}" is not a valid ABI type.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSolidityTypeError"
        });
      }
    };
    exports.UnknownSolidityTypeError = UnknownSolidityTypeError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js
var require_abiParameter = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Failed to parse ABI parameter.", {
          details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameter-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParameterError"
        });
      }
    };
    exports.InvalidAbiParameterError = InvalidAbiParameterError;
    var InvalidAbiParametersError = class extends errors_js_1.BaseError {
      constructor({ params }) {
        super("Failed to parse ABI parameters.", {
          details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameters-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParametersError"
        });
      }
    };
    exports.InvalidAbiParametersError = InvalidAbiParametersError;
    var InvalidParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Invalid ABI parameter.", {
          details: param
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParameterError"
        });
      }
    };
    exports.InvalidParameterError = InvalidParameterError;
    var SolidityProtectedKeywordError = class extends errors_js_1.BaseError {
      constructor({ param, name }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SolidityProtectedKeywordError"
        });
      }
    };
    exports.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
    var InvalidModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidModifierError"
        });
      }
    };
    exports.InvalidModifierError = InvalidModifierError;
    var InvalidFunctionModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidFunctionModifierError"
        });
      }
    };
    exports.InvalidFunctionModifierError = InvalidFunctionModifierError;
    var InvalidAbiTypeParameterError = class extends errors_js_1.BaseError {
      constructor({ abiParameter }) {
        super("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiTypeParameterError"
        });
      }
    };
    exports.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/signature.js
var require_signature = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStructSignatureError = exports.UnknownSignatureError = exports.InvalidSignatureError = void 0;
    var errors_js_1 = require_errors();
    var InvalidSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature, type }) {
        super(`Invalid ${type} signature.`, {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSignatureError"
        });
      }
    };
    exports.InvalidSignatureError = InvalidSignatureError;
    var UnknownSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Unknown signature.", {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSignatureError"
        });
      }
    };
    exports.UnknownSignatureError = UnknownSignatureError;
    var InvalidStructSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStructSignatureError"
        });
      }
    };
    exports.InvalidStructSignatureError = InvalidStructSignatureError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/struct.js
var require_struct = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = void 0;
    var errors_js_1 = require_errors();
    var CircularReferenceError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Circular reference detected.", {
          metaMessages: [`Struct "${type}" is a circular reference.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CircularReferenceError"
        });
      }
    };
    exports.CircularReferenceError = CircularReferenceError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js
var require_splitParameters = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidParenthesisError = void 0;
    var errors_js_1 = require_errors();
    var InvalidParenthesisError = class extends errors_js_1.BaseError {
      constructor({ current, depth }) {
        super("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParenthesisError"
        });
      }
    };
    exports.InvalidParenthesisError = InvalidParenthesisError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js
var require_cache2 = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parameterCache = exports.getParameterCacheKey = void 0;
    function getParameterCacheKey(param, type) {
      if (type)
        return `${type}:${param}`;
      return param;
    }
    exports.getParameterCacheKey = getParameterCacheKey;
    exports.parameterCache = /* @__PURE__ */ new Map([
      ["address", { type: "address" }],
      ["bool", { type: "bool" }],
      ["bytes", { type: "bytes" }],
      ["bytes32", { type: "bytes32" }],
      ["int", { type: "int256" }],
      ["int256", { type: "int256" }],
      ["string", { type: "string" }],
      ["uint", { type: "uint256" }],
      ["uint8", { type: "uint8" }],
      ["uint16", { type: "uint16" }],
      ["uint24", { type: "uint24" }],
      ["uint32", { type: "uint32" }],
      ["uint64", { type: "uint64" }],
      ["uint96", { type: "uint96" }],
      ["uint112", { type: "uint112" }],
      ["uint160", { type: "uint160" }],
      ["uint192", { type: "uint192" }],
      ["uint256", { type: "uint256" }],
      ["address owner", { type: "address", name: "owner" }],
      ["address to", { type: "address", name: "to" }],
      ["bool approved", { type: "bool", name: "approved" }],
      ["bytes _data", { type: "bytes", name: "_data" }],
      ["bytes data", { type: "bytes", name: "data" }],
      ["bytes signature", { type: "bytes", name: "signature" }],
      ["bytes32 hash", { type: "bytes32", name: "hash" }],
      ["bytes32 r", { type: "bytes32", name: "r" }],
      ["bytes32 root", { type: "bytes32", name: "root" }],
      ["bytes32 s", { type: "bytes32", name: "s" }],
      ["string name", { type: "string", name: "name" }],
      ["string symbol", { type: "string", name: "symbol" }],
      ["string tokenURI", { type: "string", name: "tokenURI" }],
      ["uint tokenId", { type: "uint256", name: "tokenId" }],
      ["uint8 v", { type: "uint8", name: "v" }],
      ["uint256 balance", { type: "uint256", name: "balance" }],
      ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
      ["uint256 value", { type: "uint256", name: "value" }],
      [
        "event:address indexed from",
        { type: "address", name: "from", indexed: true }
      ],
      ["event:address indexed to", { type: "address", name: "to", indexed: true }],
      [
        "event:uint indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ],
      [
        "event:uint256 indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ]
    ]);
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js
var require_utils = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;
    var regex_js_1 = require_regex();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var splitParameters_js_1 = require_splitParameters();
    var cache_js_1 = require_cache2();
    var signatures_js_1 = require_signatures();
    function parseSignature(signature, structs = {}) {
      if ((0, signatures_js_1.isFunctionSignature)(signature)) {
        const match2 = (0, signatures_js_1.execFunctionSignature)(signature);
        if (!match2)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "function" });
        const inputParams = splitParameters(match2.parameters);
        const inputs = [];
        const inputLength = inputParams.length;
        for (let i2 = 0; i2 < inputLength; i2++) {
          inputs.push(parseAbiParameter(inputParams[i2], {
            modifiers: signatures_js_1.functionModifiers,
            structs,
            type: "function"
          }));
        }
        const outputs = [];
        if (match2.returns) {
          const outputParams = splitParameters(match2.returns);
          const outputLength = outputParams.length;
          for (let i2 = 0; i2 < outputLength; i2++) {
            outputs.push(parseAbiParameter(outputParams[i2], {
              modifiers: signatures_js_1.functionModifiers,
              structs,
              type: "function"
            }));
          }
        }
        return {
          name: match2.name,
          type: "function",
          stateMutability: match2.stateMutability ?? "nonpayable",
          inputs,
          outputs
        };
      }
      if ((0, signatures_js_1.isEventSignature)(signature)) {
        const match2 = (0, signatures_js_1.execEventSignature)(signature);
        if (!match2)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "event" });
        const params = splitParameters(match2.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i2 = 0; i2 < length; i2++) {
          abiParameters.push(parseAbiParameter(params[i2], {
            modifiers: signatures_js_1.eventModifiers,
            structs,
            type: "event"
          }));
        }
        return { name: match2.name, type: "event", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isErrorSignature)(signature)) {
        const match2 = (0, signatures_js_1.execErrorSignature)(signature);
        if (!match2)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "error" });
        const params = splitParameters(match2.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i2 = 0; i2 < length; i2++) {
          abiParameters.push(parseAbiParameter(params[i2], { structs, type: "error" }));
        }
        return { name: match2.name, type: "error", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isConstructorSignature)(signature)) {
        const match2 = (0, signatures_js_1.execConstructorSignature)(signature);
        if (!match2)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "constructor" });
        const params = splitParameters(match2.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i2 = 0; i2 < length; i2++) {
          abiParameters.push(parseAbiParameter(params[i2], { structs, type: "constructor" }));
        }
        return {
          type: "constructor",
          stateMutability: match2.stateMutability ?? "nonpayable",
          inputs: abiParameters
        };
      }
      if ((0, signatures_js_1.isFallbackSignature)(signature))
        return { type: "fallback" };
      if ((0, signatures_js_1.isReceiveSignature)(signature))
        return {
          type: "receive",
          stateMutability: "payable"
        };
      throw new signature_js_1.UnknownSignatureError({ signature });
    }
    exports.parseSignature = parseSignature;
    var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var dynamicIntegerRegex = /^u?int$/;
    function parseAbiParameter(param, options) {
      const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
      if (cache_js_1.parameterCache.has(parameterCacheKey))
        return cache_js_1.parameterCache.get(parameterCacheKey);
      const isTuple = regex_js_1.isTupleRegex.test(param);
      const match2 = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
      if (!match2)
        throw new abiParameter_js_1.InvalidParameterError({ param });
      if (match2.name && isSolidityKeyword(match2.name))
        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match2.name });
      const name = match2.name ? { name: match2.name } : {};
      const indexed = match2.modifier === "indexed" ? { indexed: true } : {};
      const structs = options?.structs ?? {};
      let type;
      let components = {};
      if (isTuple) {
        type = "tuple";
        const params = splitParameters(match2.type);
        const components_ = [];
        const length = params.length;
        for (let i2 = 0; i2 < length; i2++) {
          components_.push(parseAbiParameter(params[i2], { structs }));
        }
        components = { components: components_ };
      } else if (match2.type in structs) {
        type = "tuple";
        components = { components: structs[match2.type] };
      } else if (dynamicIntegerRegex.test(match2.type)) {
        type = `${match2.type}256`;
      } else {
        type = match2.type;
        if (!(options?.type === "struct") && !isSolidityType(type))
          throw new abiItem_js_1.UnknownSolidityTypeError({ type });
      }
      if (match2.modifier) {
        if (!options?.modifiers?.has?.(match2.modifier))
          throw new abiParameter_js_1.InvalidModifierError({
            param,
            type: options?.type,
            modifier: match2.modifier
          });
        if (signatures_js_1.functionModifiers.has(match2.modifier) && !isValidDataLocation(type, !!match2.array))
          throw new abiParameter_js_1.InvalidFunctionModifierError({
            param,
            type: options?.type,
            modifier: match2.modifier
          });
      }
      const abiParameter = {
        type: `${type}${match2.array ?? ""}`,
        ...name,
        ...indexed,
        ...components
      };
      cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
    function splitParameters(params, result = [], current = "", depth = 0) {
      if (params === "") {
        if (current === "")
          return result;
        if (depth !== 0)
          throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
        result.push(current.trim());
        return result;
      }
      const length = params.length;
      for (let i2 = 0; i2 < length; i2++) {
        const char = params[i2];
        const tail = params.slice(i2 + 1);
        switch (char) {
          case ",":
            return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
          case "(":
            return splitParameters(tail, result, `${current}${char}`, depth + 1);
          case ")":
            return splitParameters(tail, result, `${current}${char}`, depth - 1);
          default:
            return splitParameters(tail, result, `${current}${char}`, depth);
        }
      }
      return [];
    }
    exports.splitParameters = splitParameters;
    function isSolidityType(type) {
      return type === "address" || type === "bool" || type === "function" || type === "string" || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);
    }
    exports.isSolidityType = isSolidityType;
    var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    function isSolidityKeyword(name) {
      return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);
    }
    exports.isSolidityKeyword = isSolidityKeyword;
    function isValidDataLocation(type, isArray) {
      return isArray || type === "bytes" || type === "string" || type === "tuple";
    }
    exports.isValidDataLocation = isValidDataLocation;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js
var require_structs = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseStructs = void 0;
    var regex_js_1 = require_regex();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var struct_js_1 = require_struct();
    var signatures_js_1 = require_signatures();
    var utils_js_1 = require_utils();
    function parseStructs(signatures) {
      const shallowStructs = {};
      const signaturesLength = signatures.length;
      for (let i2 = 0; i2 < signaturesLength; i2++) {
        const signature = signatures[i2];
        if (!(0, signatures_js_1.isStructSignature)(signature))
          continue;
        const match2 = (0, signatures_js_1.execStructSignature)(signature);
        if (!match2)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "struct" });
        const properties = match2.properties.split(";");
        const components = [];
        const propertiesLength = properties.length;
        for (let k2 = 0; k2 < propertiesLength; k2++) {
          const property = properties[k2];
          const trimmed = property.trim();
          if (!trimmed)
            continue;
          const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
            type: "struct"
          });
          components.push(abiParameter);
        }
        if (!components.length)
          throw new signature_js_1.InvalidStructSignatureError({ signature });
        shallowStructs[match2.name] = components;
      }
      const resolvedStructs = {};
      const entries = Object.entries(shallowStructs);
      const entriesLength = entries.length;
      for (let i2 = 0; i2 < entriesLength; i2++) {
        const [name, parameters] = entries[i2];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
      }
      return resolvedStructs;
    }
    exports.parseStructs = parseStructs;
    var typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
      const components = [];
      const length = abiParameters.length;
      for (let i2 = 0; i2 < length; i2++) {
        const abiParameter = abiParameters[i2];
        const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
        if (isTuple)
          components.push(abiParameter);
        else {
          const match2 = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
          if (!match2?.type)
            throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter });
          const { array, type } = match2;
          if (type in structs) {
            if (ancestors.has(type))
              throw new struct_js_1.CircularReferenceError({ type });
            components.push({
              ...abiParameter,
              type: `tuple${array ?? ""}`,
              components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
            });
          } else {
            if ((0, utils_js_1.isSolidityType)(type))
              components.push(abiParameter);
            else
              throw new abiItem_js_1.UnknownTypeError({ type });
          }
        }
      }
      return components;
    }
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbi.js
var require_parseAbi = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbi = void 0;
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    function parseAbi(signatures) {
      const structs = (0, structs_js_1.parseStructs)(signatures);
      const abi = [];
      const length = signatures.length;
      for (let i2 = 0; i2 < length; i2++) {
        const signature = signatures[i2];
        if ((0, signatures_js_1.isStructSignature)(signature))
          continue;
        abi.push((0, utils_js_1.parseSignature)(signature, structs));
      }
      return abi;
    }
    exports.parseAbi = parseAbi;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js
var require_parseAbiItem = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiItem = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    function parseAbiItem(signature) {
      let abiItem;
      if (typeof signature === "string")
        abiItem = (0, utils_js_1.parseSignature)(signature);
      else {
        const structs = (0, structs_js_1.parseStructs)(signature);
        const length = signature.length;
        for (let i2 = 0; i2 < length; i2++) {
          const signature_ = signature[i2];
          if ((0, signatures_js_1.isStructSignature)(signature_))
            continue;
          abiItem = (0, utils_js_1.parseSignature)(signature_, structs);
          break;
        }
      }
      if (!abiItem)
        throw new index_js_1.InvalidAbiItemError({ signature });
      return abiItem;
    }
    exports.parseAbiItem = parseAbiItem;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js
var require_parseAbiParameter = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameter = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    function parseAbiParameter(param) {
      let abiParameter;
      if (typeof param === "string")
        abiParameter = (0, utils_js_1.parseAbiParameter)(param, {
          modifiers: signatures_js_1.modifiers
        });
      else {
        const structs = (0, structs_js_1.parseStructs)(param);
        const length = param.length;
        for (let i2 = 0; i2 < length; i2++) {
          const signature = param[i2];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          abiParameter = (0, utils_js_1.parseAbiParameter)(signature, { modifiers: signatures_js_1.modifiers, structs });
          break;
        }
      }
      if (!abiParameter)
        throw new index_js_1.InvalidAbiParameterError({ param });
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js
var require_parseAbiParameters = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameters = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    function parseAbiParameters(params) {
      const abiParameters = [];
      if (typeof params === "string") {
        const parameters = (0, utils_js_1.splitParameters)(params);
        const length = parameters.length;
        for (let i2 = 0; i2 < length; i2++) {
          abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i2], { modifiers: signatures_js_1.modifiers }));
        }
      } else {
        const structs = (0, structs_js_1.parseStructs)(params);
        const length = params.length;
        for (let i2 = 0; i2 < length; i2++) {
          const signature = params[i2];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          const parameters = (0, utils_js_1.splitParameters)(signature);
          const length2 = parameters.length;
          for (let k2 = 0; k2 < length2; k2++) {
            abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k2], { modifiers: signatures_js_1.modifiers, structs }));
          }
        }
      }
      if (abiParameters.length === 0)
        throw new index_js_1.InvalidAbiParametersError({ params });
      return abiParameters;
    }
    exports.parseAbiParameters = parseAbiParameters;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = void 0;
    var errors_js_1 = require_errors();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return errors_js_1.BaseError;
    } });
    var narrow_js_1 = require_narrow();
    Object.defineProperty(exports, "narrow", { enumerable: true, get: function() {
      return narrow_js_1.narrow;
    } });
    var formatAbi_js_1 = require_formatAbi();
    Object.defineProperty(exports, "formatAbi", { enumerable: true, get: function() {
      return formatAbi_js_1.formatAbi;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem2();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    Object.defineProperty(exports, "formatAbiParameter", { enumerable: true, get: function() {
      return formatAbiParameter_js_1.formatAbiParameter;
    } });
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    Object.defineProperty(exports, "formatAbiParameters", { enumerable: true, get: function() {
      return formatAbiParameters_js_1.formatAbiParameters;
    } });
    var parseAbi_js_1 = require_parseAbi();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return parseAbi_js_1.parseAbi;
    } });
    var parseAbiItem_js_1 = require_parseAbiItem();
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return parseAbiItem_js_1.parseAbiItem;
    } });
    var parseAbiParameter_js_1 = require_parseAbiParameter();
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return parseAbiParameter_js_1.parseAbiParameter;
    } });
    var parseAbiParameters_js_1 = require_parseAbiParameters();
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return parseAbiParameters_js_1.parseAbiParameters;
    } });
    var abiItem_js_1 = require_abiItem();
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abiItem_js_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "UnknownSolidityTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownSolidityTypeError;
    } });
    var abiParameter_js_1 = require_abiParameter();
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abiParameter_js_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParameterError;
    } });
    var signature_js_1 = require_signature();
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return signature_js_1.UnknownSignatureError;
    } });
    var splitParameters_js_1 = require_splitParameters();
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return splitParameters_js_1.InvalidParenthesisError;
    } });
    var struct_js_1 = require_struct();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return struct_js_1.CircularReferenceError;
    } });
  }
});

// node_modules/viem/dist/cjs/errors/log.js
var require_log = __commonJS({
  "node_modules/viem/dist/cjs/errors/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterTypeNotSupportedError = void 0;
    var base_js_1 = require_base();
    var FilterTypeNotSupportedError = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FilterTypeNotSupportedError"
        });
      }
    };
    exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError;
  }
});

// node_modules/viem/dist/cjs/utils/hash/getEventSelector.js
var require_getEventSelector = __commonJS({
  "node_modules/viem/dist/cjs/utils/hash/getEventSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventSelector = void 0;
    var hashFunction_js_1 = require_hashFunction();
    var getEventSelector = (event) => {
      if (typeof event === "string")
        return (0, hashFunction_js_1.hashFunction)(event);
      return (0, hashFunction_js_1.hashAbiItem)(event);
    };
    exports.getEventSelector = getEventSelector;
  }
});

// node_modules/viem/dist/cjs/utils/abi/encodeEventTopics.js
var require_encodeEventTopics = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/encodeEventTopics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeEventTopics = void 0;
    var abi_js_1 = require_abi();
    var log_js_1 = require_log();
    var toBytes_js_1 = require_toBytes();
    var getEventSelector_js_1 = require_getEventSelector();
    var keccak256_js_1 = require_keccak256();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeEventTopics({ abi, eventName, args }) {
      let abiItem = abi[0];
      if (eventName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: eventName
        });
        if (!abiItem)
          throw new abi_js_1.AbiEventNotFoundError(eventName, {
            docsPath: "/docs/contract/encodeEventTopics"
          });
      }
      if (abiItem.type !== "event")
        throw new abi_js_1.AbiEventNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeEventTopics"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getEventSelector_js_1.getEventSelector)(definition);
      let topics = [];
      if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x2) => args[x2.name]) ?? [] : [];
        if (args_.length > 0) {
          topics = indexedInputs?.map((param, i2) => Array.isArray(args_[i2]) ? args_[i2].map((_, j) => encodeArg({ param, value: args_[i2][j] })) : args_[i2] ? encodeArg({ param, value: args_[i2] }) : null) ?? [];
        }
      }
      return [signature, ...topics];
    }
    exports.encodeEventTopics = encodeEventTopics;
    function encodeArg({ param, value }) {
      if (param.type === "string" || param.type === "bytes")
        return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
      if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new log_js_1.FilterTypeNotSupportedError(param.type);
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
    }
  }
});

// node_modules/viem/dist/cjs/utils/filters/createFilterRequestScope.js
var require_createFilterRequestScope = __commonJS({
  "node_modules/viem/dist/cjs/utils/filters/createFilterRequestScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFilterRequestScope = void 0;
    function createFilterRequestScope(client, { method }) {
      const requestMap = {};
      if (client.transport.type === "fallback")
        client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
          if (status === "success" && method === method_)
            requestMap[id] = transport.request;
        });
      return (id) => requestMap[id] || client.request;
    }
    exports.createFilterRequestScope = createFilterRequestScope;
  }
});

// node_modules/viem/dist/cjs/actions/public/createContractEventFilter.js
var require_createContractEventFilter = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/createContractEventFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createContractEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
        abi,
        args,
        eventName
      }) : void 0;
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            topics
          }
        ]
      });
      return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict,
        type: "event"
      };
    }
    exports.createContractEventFilter = createContractEventFilter;
  }
});

// node_modules/viem/dist/cjs/utils/errors/getContractError.js
var require_getContractError = __commonJS({
  "node_modules/viem/dist/cjs/utils/errors/getContractError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContractError = void 0;
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    var EXECUTION_REVERTED_ERROR_CODE = 3;
    function getContractError(err, { abi, address, args, docsPath, functionName, sender }) {
      const { code, data, message, shortMessage } = err instanceof contract_js_1.RawContractError ? err : err instanceof base_js_1.BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
      let cause = err;
      if (err instanceof abi_js_1.AbiDecodingZeroDataError) {
        cause = new contract_js_1.ContractFunctionZeroDataError({ functionName });
      } else if (code === EXECUTION_REVERTED_ERROR_CODE && (data || message || shortMessage)) {
        cause = new contract_js_1.ContractFunctionRevertedError({
          abi,
          data: typeof data === "object" ? data.data : data,
          functionName,
          message: shortMessage ?? message
        });
      }
      return new contract_js_1.ContractFunctionExecutionError(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender
      });
    }
    exports.getContractError = getContractError;
  }
});

// node_modules/viem/dist/cjs/errors/account.js
var require_account = __commonJS({
  "node_modules/viem/dist/cjs/errors/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountNotFoundError = void 0;
    var base_js_1 = require_base();
    var AccountNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath } = {}) {
        super([
          "Could not find an Account to execute with this Action.",
          "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
        ].join("\n"), {
          docsPath,
          docsSlug: "account"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AccountNotFoundError"
        });
      }
    };
    exports.AccountNotFoundError = AccountNotFoundError;
  }
});

// node_modules/viem/dist/cjs/errors/estimateGas.js
var require_estimateGas = __commonJS({
  "node_modules/viem/dist/cjs/errors/estimateGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EstimateGasExecutionError = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var transaction_js_1 = require_transaction();
    var EstimateGasExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Estimate Gas Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EstimateGasExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.EstimateGasExecutionError = EstimateGasExecutionError;
  }
});

// node_modules/viem/dist/cjs/utils/errors/getEstimateGasError.js
var require_getEstimateGasError = __commonJS({
  "node_modules/viem/dist/cjs/utils/errors/getEstimateGasError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEstimateGasError = void 0;
    var estimateGas_js_1 = require_estimateGas();
    var getNodeError_js_1 = require_getNodeError();
    function getEstimateGasError(err, { docsPath, ...args }) {
      let cause = err;
      if ((0, getNodeError_js_1.containsNodeError)(err))
        cause = (0, getNodeError_js_1.getNodeError)(err, args);
      return new estimateGas_js_1.EstimateGasExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getEstimateGasError = getEstimateGasError;
  }
});

// node_modules/viem/dist/cjs/errors/block.js
var require_block = __commonJS({
  "node_modules/viem/dist/cjs/errors/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockNotFoundError = void 0;
    var base_js_1 = require_base();
    var BlockNotFoundError = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber }) {
        let identifier = "Block";
        if (blockHash)
          identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
          identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BlockNotFoundError"
        });
      }
    };
    exports.BlockNotFoundError = BlockNotFoundError;
  }
});

// node_modules/viem/dist/cjs/utils/formatters/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/viem/dist/cjs/utils/formatters/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransaction = exports.formatTransaction = exports.transactionType = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    exports.transactionType = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559"
    };
    function formatTransaction(transaction) {
      const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : void 0,
        gas: transaction.gas ? BigInt(transaction.gas) : void 0,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
        maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : void 0,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
        type: transaction.type ? exports.transactionType[transaction.type] : void 0,
        typeHex: transaction.type ? transaction.type : void 0,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        v: transaction.v ? BigInt(transaction.v) : void 0
      };
      if (transaction_.type === "legacy") {
        delete transaction_["accessList"];
        delete transaction_["maxFeePerGas"];
        delete transaction_["maxPriorityFeePerGas"];
      }
      if (transaction_.type === "eip2930") {
        delete transaction_["maxFeePerGas"];
        delete transaction_["maxPriorityFeePerGas"];
      }
      return transaction_;
    }
    exports.formatTransaction = formatTransaction;
    exports.defineTransaction = (0, formatter_js_1.defineFormatter)("transaction", formatTransaction);
  }
});

// node_modules/viem/dist/cjs/utils/formatters/block.js
var require_block2 = __commonJS({
  "node_modules/viem/dist/cjs/utils/formatters/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineBlock = exports.formatBlock = void 0;
    var formatter_js_1 = require_formatter();
    var transaction_js_1 = require_transaction2();
    function formatBlock(block) {
      const transactions = block.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        return (0, transaction_js_1.formatTransaction)(transaction);
      });
      return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : void 0,
        timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
        transactions,
        totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
      };
    }
    exports.formatBlock = formatBlock;
    exports.defineBlock = (0, formatter_js_1.defineFormatter)("block", formatBlock);
  }
});

// node_modules/viem/dist/cjs/actions/public/getBlock.js
var require_getBlock = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlock = void 0;
    var block_js_1 = require_block();
    var toHex_js_1 = require_toHex();
    var block_js_2 = require_block2();
    async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
      const blockTag = blockTag_ ?? "latest";
      const includeTransactions = includeTransactions_ ?? false;
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let block = null;
      if (blockHash) {
        block = await client.request({
          method: "eth_getBlockByHash",
          params: [blockHash, includeTransactions]
        });
      } else {
        block = await client.request({
          method: "eth_getBlockByNumber",
          params: [blockNumberHex || blockTag, includeTransactions]
        });
      }
      if (!block)
        throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
      const format2 = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
      return format2(block);
    }
    exports.getBlock = getBlock;
  }
});

// node_modules/viem/dist/cjs/actions/public/getGasPrice.js
var require_getGasPrice = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getGasPrice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGasPrice = void 0;
    async function getGasPrice(client) {
      const gasPrice = await client.request({
        method: "eth_gasPrice"
      });
      return BigInt(gasPrice);
    }
    exports.getGasPrice = getGasPrice;
  }
});

// node_modules/viem/dist/cjs/actions/public/getTransactionCount.js
var require_getTransactionCount = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getTransactionCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
      const count = await client.request({
        method: "eth_getTransactionCount",
        params: [address, blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag]
      });
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getTransactionCount = getTransactionCount;
  }
});

// node_modules/viem/dist/cjs/utils/transaction/prepareRequest.js
var require_prepareRequest = __commonJS({
  "node_modules/viem/dist/cjs/utils/transaction/prepareRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var estimateGas_js_1 = require_estimateGas2();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var account_js_1 = require_account();
    var base_js_1 = require_base();
    var assertRequest_js_1 = require_assertRequest();
    async function prepareRequest(client, args) {
      const { account: account_, chain = client.chain, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError();
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const block = await (0, getBlock_js_1.getBlock)(client, { blockTag: "latest" });
      const request = { ...args, from: account.address };
      if (typeof nonce === "undefined")
        request.nonce = await (0, getTransactionCount_js_1.getTransactionCount)(client, {
          address: account.address,
          blockTag: "pending"
        });
      if (typeof block.baseFeePerGas === "bigint" && typeof gasPrice === "undefined") {
        let defaultPriorityFee = 1500000000n;
        if (typeof chain?.fees?.defaultPriorityFee !== "undefined") {
          defaultPriorityFee = typeof chain.fees.defaultPriorityFee === "bigint" ? chain.fees.defaultPriorityFee : await chain.fees.defaultPriorityFee({
            block,
            request
          });
        }
        if (typeof maxFeePerGas === "undefined") {
          request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultPriorityFee;
          request.maxFeePerGas = block.baseFeePerGas * 120n / 100n + request.maxPriorityFeePerGas;
        } else {
          if (typeof maxPriorityFeePerGas === "undefined" && maxFeePerGas < defaultPriorityFee)
            throw new base_js_1.BaseError("`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).");
          request.maxFeePerGas = maxFeePerGas;
          request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultPriorityFee;
        }
      } else if (typeof gasPrice === "undefined") {
        if (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined")
          throw new base_js_1.BaseError("Chain does not support EIP-1559 fees.");
        request.gasPrice = await (0, getGasPrice_js_1.getGasPrice)(client) * 120n / 100n;
      }
      if (typeof gas === "undefined")
        request.gas = await (0, estimateGas_js_1.estimateGas)(client, {
          ...request,
          account: { address: account.address, type: "json-rpc" }
        });
      (0, assertRequest_js_1.assertRequest)(request);
      return request;
    }
    exports.prepareRequest = prepareRequest;
  }
});

// node_modules/viem/dist/cjs/actions/public/estimateGas.js
var require_estimateGas2 = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/estimateGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var prepareRequest_js_1 = require_prepareRequest();
    async function estimateGas(client, args) {
      const account_ = args.account ?? client.account;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/public/estimateGas"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await (0, prepareRequest_js_1.prepareRequest)(client, args) : args;
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        (0, assertRequest_js_1.assertRequest)(args);
        const format2 = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format2({
          ...(0, extract_js_1.extract)(rest, { format: format2 }),
          from: account.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        const balance = await client.request({
          method: "eth_estimateGas",
          params: block ? [request, block] : [request]
        });
        return BigInt(balance);
      } catch (err) {
        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports.estimateGas = estimateGas;
  }
});

// node_modules/viem/dist/cjs/actions/public/estimateContractGas.js
var require_estimateContractGas = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/estimateContractGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateContractGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var estimateGas_js_1 = require_estimateGas2();
    async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const gas = await (0, estimateGas_js_1.estimateGas)(client, {
          data,
          to: address,
          ...request
        });
        return gas;
      } catch (err) {
        const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : void 0;
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/estimateContractGas",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.estimateContractGas = estimateContractGas;
  }
});

// node_modules/viem/dist/cjs/actions/public/readContract.js
var require_readContract = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/readContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readContract = void 0;
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var call_js_1 = require_call();
    async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, call_js_1.call)(client, {
          data: calldata,
          to: address,
          ...callRequest
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/readContract",
          functionName
        });
      }
    }
    exports.readContract = readContract;
  }
});

// node_modules/viem/dist/cjs/actions/public/simulateContract.js
var require_simulateContract = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/simulateContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simulateContract = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var call_js_1 = require_call();
    async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
      const account = callRequest.account ? (0, parseAccount_js_1.parseAccount)(callRequest.account) : void 0;
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, call_js_1.call)(client, {
          batch: false,
          data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
          to: address,
          ...callRequest
        });
        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
        return {
          result,
          request: {
            abi,
            address,
            args,
            dataSuffix,
            functionName,
            ...callRequest
          }
        };
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/simulateContract",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.simulateContract = simulateContract;
  }
});

// node_modules/viem/dist/cjs/utils/observe.js
var require_observe = __commonJS({
  "node_modules/viem/dist/cjs/utils/observe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = exports.cleanupCache = exports.listenersCache = void 0;
    exports.listenersCache = /* @__PURE__ */ new Map();
    exports.cleanupCache = /* @__PURE__ */ new Map();
    var callbackCount = 0;
    function observe(observerId, callbacks, fn) {
      const callbackId = ++callbackCount;
      const getListeners = () => exports.listenersCache.get(observerId) || [];
      const unsubscribe = () => {
        const listeners2 = getListeners();
        exports.listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
      };
      const unwatch = () => {
        const cleanup2 = exports.cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup2)
          cleanup2();
        unsubscribe();
      };
      const listeners = getListeners();
      exports.listenersCache.set(observerId, [
        ...listeners,
        { id: callbackId, fns: callbacks }
      ]);
      if (listeners && listeners.length > 0)
        return unwatch;
      const emit = {};
      for (const key in callbacks) {
        emit[key] = (...args) => {
          const listeners2 = getListeners();
          if (listeners2.length === 0)
            return;
          listeners2.forEach((listener) => listener.fns[key]?.(...args));
        };
      }
      const cleanup = fn(emit);
      if (typeof cleanup === "function")
        exports.cleanupCache.set(observerId, cleanup);
      return unwatch;
    }
    exports.observe = observe;
  }
});

// node_modules/viem/dist/cjs/utils/wait.js
var require_wait = __commonJS({
  "node_modules/viem/dist/cjs/utils/wait.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wait = void 0;
    async function wait(time) {
      return new Promise((res) => setTimeout(res, time));
    }
    exports.wait = wait;
  }
});

// node_modules/viem/dist/cjs/utils/poll.js
var require_poll = __commonJS({
  "node_modules/viem/dist/cjs/utils/poll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poll = void 0;
    var wait_js_1 = require_wait();
    function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
      let active = true;
      const unwatch = () => active = false;
      const watch = async () => {
        let data;
        if (emitOnBegin)
          data = await fn({ unpoll: unwatch });
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, wait_js_1.wait)(initialWait);
        const poll2 = async () => {
          if (!active)
            return;
          await fn({ unpoll: unwatch });
          await (0, wait_js_1.wait)(interval);
          poll2();
        };
        poll2();
      };
      watch();
      return unwatch;
    }
    exports.poll = poll;
  }
});

// node_modules/viem/dist/cjs/utils/promise/withCache.js
var require_withCache = __commonJS({
  "node_modules/viem/dist/cjs/utils/promise/withCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = void 0;
    exports.promiseCache = /* @__PURE__ */ new Map();
    exports.responseCache = /* @__PURE__ */ new Map();
    function getCache(cacheKey) {
      const buildCache = (cacheKey2, cache) => ({
        clear: () => cache.delete(cacheKey2),
        get: () => cache.get(cacheKey2),
        set: (data) => cache.set(cacheKey2, data)
      });
      const promise = buildCache(cacheKey, exports.promiseCache);
      const response = buildCache(cacheKey, exports.responseCache);
      return {
        clear: () => {
          promise.clear();
          response.clear();
        },
        promise,
        response
      };
    }
    exports.getCache = getCache;
    async function withCache(fn, { cacheKey, cacheTime = Infinity }) {
      const cache = getCache(cacheKey);
      const response = cache.response.get();
      if (response && cacheTime > 0) {
        const age = new Date().getTime() - response.created.getTime();
        if (age < cacheTime)
          return response.data;
      }
      let promise = cache.promise.get();
      if (!promise) {
        promise = fn();
        cache.promise.set(promise);
      }
      try {
        const data = await promise;
        cache.response.set({ created: new Date(), data });
        return data;
      } finally {
        cache.promise.clear();
      }
    }
    exports.withCache = withCache;
  }
});

// node_modules/viem/dist/cjs/actions/public/getBlockNumber.js
var require_getBlockNumber = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getBlockNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockNumber = exports.getBlockNumberCache = void 0;
    var withCache_js_1 = require_withCache();
    var cacheKey = (id) => `blockNumber.${id}`;
    function getBlockNumberCache(id) {
      return (0, withCache_js_1.getCache)(cacheKey(id));
    }
    exports.getBlockNumberCache = getBlockNumberCache;
    async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
      const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
        method: "eth_blockNumber"
      }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
      return BigInt(blockNumberHex);
    }
    exports.getBlockNumber = getBlockNumber;
  }
});

// node_modules/viem/dist/cjs/utils/abi/decodeEventLog.js
var require_decodeEventLog = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/decodeEventLog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeEventLog = void 0;
    var abi_js_1 = require_abi();
    var getEventSelector_js_1 = require_getEventSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var docsPath = "/docs/contract/decodeEventLog";
    function decodeEventLog({ abi, data, strict: strict_, topics }) {
      const strict = strict_ ?? true;
      const [signature, ...argTopics] = topics;
      if (!signature)
        throw new abi_js_1.AbiEventSignatureEmptyTopicsError({
          docsPath
        });
      const abiItem = abi.find((x2) => x2.type === "event" && signature === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x2)));
      if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
        throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {
          docsPath
        });
      const { name, inputs } = abiItem;
      const isUnnamed = inputs?.some((x2) => !("name" in x2 && x2.name));
      let args = isUnnamed ? [] : {};
      const indexedInputs = inputs.filter((x2) => "indexed" in x2 && x2.indexed);
      if (argTopics.length > 0) {
        for (let i2 = 0; i2 < indexedInputs.length; i2++) {
          const param = indexedInputs[i2];
          const topic = argTopics[i2];
          if (!topic)
            throw new abi_js_1.DecodeLogTopicsMismatch({
              abiItem,
              param
            });
          args[param.name || i2] = decodeTopic({ param, value: topic });
        }
      }
      const nonIndexedInputs = inputs.filter((x2) => !("indexed" in x2 && x2.indexed));
      if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") {
          try {
            const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
              if (isUnnamed)
                args = [...args, ...decodedData];
              else {
                for (let i2 = 0; i2 < nonIndexedInputs.length; i2++) {
                  args[nonIndexedInputs[i2].name] = decodedData[i2];
                }
              }
            }
          } catch (err) {
            if (strict) {
              if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError)
                throw new abi_js_1.DecodeLogDataMismatch({
                  abiItem,
                  data: err.data,
                  params: err.params,
                  size: err.size
                });
              throw err;
            }
          }
        } else if (strict) {
          throw new abi_js_1.DecodeLogDataMismatch({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
          });
        }
      }
      return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : void 0
      };
    }
    exports.decodeEventLog = decodeEventLog;
    function decodeTopic({ param, value }) {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return value;
      const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
      return decodedArg[0];
    }
  }
});

// node_modules/viem/dist/cjs/utils/formatters/log.js
var require_log2 = __commonJS({
  "node_modules/viem/dist/cjs/utils/formatters/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLog = void 0;
    function formatLog(log, { args, eventName } = {}) {
      return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? { args, eventName } : {}
      };
    }
    exports.formatLog = formatLog;
  }
});

// node_modules/viem/dist/cjs/actions/public/getFilterChanges.js
var require_getFilterChanges = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getFilterChanges.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterChanges = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log2();
    async function getFilterChanges(_client, { filter }) {
      const strict = "strict" in filter && filter.strict;
      const logs = await filter.request({
        method: "eth_getFilterChanges",
        params: [filter.id]
      });
      return logs.map((log) => {
        if (typeof log === "string")
          return log;
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterChanges = getFilterChanges;
  }
});

// node_modules/viem/dist/cjs/actions/public/getLogs.js
var require_getLogs = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getLogs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var log_js_1 = require_log2();
    async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
      const strict = strict_ ?? false;
      const events = events_ ?? (event ? [event] : void 0);
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      let logs;
      if (blockHash) {
        logs = await client.request({
          method: "eth_getLogs",
          params: [{ address, topics, blockHash }]
        });
      } else {
        logs = await client.request({
          method: "eth_getLogs",
          params: [
            {
              address,
              topics,
              fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
              toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock
            }
          ]
        });
      }
      return logs.map((log) => {
        try {
          const { eventName, args: args2 } = events ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: events,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args: args2, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if (strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getLogs = getLogs;
  }
});

// node_modules/viem/dist/cjs/actions/public/uninstallFilter.js
var require_uninstallFilter = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/uninstallFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uninstallFilter = void 0;
    async function uninstallFilter(_client, { filter }) {
      return filter.request({
        method: "eth_uninstallFilter",
        params: [filter.id]
      });
    }
    exports.uninstallFilter = uninstallFilter;
  }
});

// node_modules/viem/dist/cjs/actions/public/watchContractEvent.js
var require_watchContractEvent = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/watchContractEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchContractEvent = void 0;
    var getAbiItem_js_1 = require_getAbiItem();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var abi_js_1 = require_abi();
    var index_js_1 = require_cjs2();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollContractEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchContractEvent",
          address,
          args,
          batch,
          client.uid,
          eventName,
          pollingInterval
        ]);
        const strict = strict_ ?? false;
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, createContractEventFilter_js_1.createContractEventFilter)(client, {
                  abi,
                  address,
                  args,
                  eventName,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
              } else {
                const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client);
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getLogs_js_1.getLogs)(client, {
                    address,
                    args,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber,
                    event: (0, getAbiItem_js_1.getAbiItem)({
                      abi,
                      name: eventName
                    })
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                logs.forEach((log) => emit.onLogs([log]));
            } catch (err) {
              if (filter && err instanceof index_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
            unwatch();
          };
        });
      };
      const subscribeContractEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const topics = eventName ? (0, index_js_1.encodeEventTopics)({
              abi,
              eventName,
              args
            }) : [];
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName: eventName2, args: args2 } = (0, index_js_1.decodeEventLog)({
                    abi,
                    data: log.data,
                    topics: log.topics,
                    strict: strict_
                  });
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: args2,
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName2;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof index_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName2 = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
                  }
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollContractEvent() : subscribeContractEvent();
    }
    exports.watchContractEvent = watchContractEvent;
  }
});

// node_modules/viem/dist/cjs/utils/errors/getTransactionError.js
var require_getTransactionError = __commonJS({
  "node_modules/viem/dist/cjs/utils/errors/getTransactionError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionError = void 0;
    var transaction_js_1 = require_transaction();
    var getNodeError_js_1 = require_getNodeError();
    function getTransactionError(err, { docsPath, ...args }) {
      let cause = err;
      if ((0, getNodeError_js_1.containsNodeError)(err))
        cause = (0, getNodeError_js_1.getNodeError)(err, args);
      return new transaction_js_1.TransactionExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getTransactionError = getTransactionError;
  }
});

// node_modules/viem/dist/cjs/actions/public/getChainId.js
var require_getChainId = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getChainId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChainId = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getChainId(client) {
      const chainIdHex = await client.request({
        method: "eth_chainId"
      });
      return (0, fromHex_js_1.hexToNumber)(chainIdHex);
    }
    exports.getChainId = getChainId;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/sendTransaction.js
var require_sendTransaction = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/sendTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var chain_js_1 = require_chain2();
    var getTransactionError_js_1 = require_getTransactionError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var prepareRequest_js_1 = require_prepareRequest();
    var getChainId_js_1 = require_getChainId();
    async function sendTransaction(client, args) {
      const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/sendTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        let chainId;
        if (chain !== null) {
          chainId = await (0, getChainId_js_1.getChainId)(client);
          (0, chain_js_1.assertCurrentChain)({
            currentChainId: chainId,
            chain
          });
        }
        if (account.type === "local") {
          const request2 = await (0, prepareRequest_js_1.prepareRequest)(client, {
            account,
            accessList,
            chain,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
            ...rest
          });
          if (!chainId)
            chainId = await (0, getChainId_js_1.getChainId)(client);
          const serializer = chain?.serializers?.transaction;
          const signedRequest = await account.signTransaction({
            ...request2,
            chainId
          }, { serializer });
          return await client.request({
            method: "eth_sendRawTransaction",
            params: [signedRequest]
          });
        }
        const format2 = chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format2({
          ...(0, extract_js_1.extract)(rest, { format: format2 }),
          accessList,
          data,
          from: account.address,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        return await client.request({
          method: "eth_sendTransaction",
          params: [request]
        });
      } catch (err) {
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
          ...args,
          account,
          chain: args.chain || void 0
        });
      }
    }
    exports.sendTransaction = sendTransaction;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/writeContract.js
var require_writeContract = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/writeContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeContract = void 0;
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var sendTransaction_js_1 = require_sendTransaction();
    async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      const hash = await (0, sendTransaction_js_1.sendTransaction)(client, {
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request
      });
      return hash;
    }
    exports.writeContract = writeContract;
  }
});

// node_modules/viem/dist/cjs/actions/getContract.js
var require_getContract = __commonJS({
  "node_modules/viem/dist/cjs/actions/getContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventParameters = exports.getFunctionParameters = exports.getContract = void 0;
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var writeContract_js_1 = require_writeContract();
    function getContract({ abi, address, publicClient, walletClient }) {
      const hasPublicClient = publicClient !== void 0 && publicClient !== null;
      const hasWalletClient = walletClient !== void 0 && walletClient !== null;
      const contract = {};
      let hasReadFunction = false;
      let hasWriteFunction = false;
      let hasEvent = false;
      for (const item of abi) {
        if (item.type === "function")
          if (item.stateMutability === "view" || item.stateMutability === "pure")
            hasReadFunction = true;
          else
            hasWriteFunction = true;
        else if (item.type === "event")
          hasEvent = true;
        if (hasReadFunction && hasWriteFunction && hasEvent)
          break;
      }
      if (hasPublicClient) {
        if (hasReadFunction)
          contract.read = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, readContract_js_1.readContract)(publicClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasWriteFunction)
          contract.simulate = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, simulateContract_js_1.simulateContract)(publicClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasEvent) {
          contract.createEventFilter = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x2) => x2.type === "event" && x2.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, createContractEventFilter_js_1.createContractEventFilter)(publicClient, {
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
          contract.watchEvent = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x2) => x2.type === "event" && x2.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, watchContractEvent_js_1.watchContractEvent)(publicClient, {
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
        }
      }
      if (hasWalletClient) {
        if (hasWriteFunction)
          contract.write = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, writeContract_js_1.writeContract)(walletClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
      }
      if (hasPublicClient || hasWalletClient) {
        if (hasWriteFunction)
          contract.estimateGas = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                const client = publicClient ?? walletClient;
                return (0, estimateContractGas_js_1.estimateContractGas)(client, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options,
                  account: options.account ?? walletClient.account
                });
              };
            }
          });
      }
      contract.address = address;
      contract.abi = abi;
      return contract;
    }
    exports.getContract = getContract;
    function getFunctionParameters(values) {
      const hasArgs = values.length && Array.isArray(values[0]);
      const args = hasArgs ? values[0] : [];
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getFunctionParameters = getFunctionParameters;
    function getEventParameters(values, abiEvent) {
      let hasArgs = false;
      if (Array.isArray(values[0]))
        hasArgs = true;
      else if (values.length === 1) {
        hasArgs = abiEvent.inputs.some((x2) => x2.indexed);
      } else if (values.length === 2) {
        hasArgs = true;
      }
      const args = hasArgs ? values[0] : void 0;
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getEventParameters = getEventParameters;
  }
});

// node_modules/viem/dist/cjs/accounts/utils/publicKeyToAddress.js
var require_publicKeyToAddress = __commonJS({
  "node_modules/viem/dist/cjs/accounts/utils/publicKeyToAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = void 0;
    var getAddress_js_1 = require_getAddress();
    var keccak256_js_1 = require_keccak256();
    function publicKeyToAddress(publicKey) {
      const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
      return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
    }
    exports.publicKeyToAddress = publicKeyToAddress;
  }
});

// node_modules/viem/dist/cjs/utils/accounts.js
var require_accounts = __commonJS({
  "node_modules/viem/dist/cjs/utils/accounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = exports.parseAccount = void 0;
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
  }
});

// node_modules/viem/dist/cjs/utils/uid.js
var require_uid = __commonJS({
  "node_modules/viem/dist/cjs/utils/uid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uid = void 0;
    var size = 256;
    var index = size;
    var buffer;
    function uid(length = 11) {
      if (!buffer || index + length > size * 2) {
        buffer = "";
        index = 0;
        for (let i2 = 0; i2 < size; i2++) {
          buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
        }
      }
      return buffer.substring(index, index++ + length);
    }
    exports.uid = uid;
  }
});

// node_modules/viem/dist/cjs/clients/createClient.js
var require_createClient = __commonJS({
  "node_modules/viem/dist/cjs/clients/createClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createClient = void 0;
    var accounts_js_1 = require_accounts();
    var uid_js_1 = require_uid();
    function createClient(parameters) {
      const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
      const chain = parameters.chain;
      const account = parameters.account ? (0, accounts_js_1.parseAccount)(parameters.account) : void 0;
      const { config, request, value } = parameters.transport({
        chain,
        pollingInterval
      });
      const transport = { ...config, ...value };
      const client = {
        account,
        batch,
        cacheTime,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport,
        type,
        uid: (0, uid_js_1.uid)()
      };
      function extend(base) {
        return (extendFn) => {
          const extended = extendFn(base);
          for (const key2 in client)
            delete extended[key2];
          const combined = { ...base, ...extended };
          return Object.assign(combined, { extend: extend(combined) });
        };
      }
      return Object.assign(client, { extend: extend(client) });
    }
    exports.createClient = createClient;
  }
});

// node_modules/viem/dist/cjs/utils/promise/withRetry.js
var require_withRetry = __commonJS({
  "node_modules/viem/dist/cjs/utils/promise/withRetry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withRetry = void 0;
    var wait_js_1 = require_wait();
    function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
      return new Promise((resolve, reject) => {
        const attemptRetry = async ({ count = 0 } = {}) => {
          const retry = async ({ error }) => {
            const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
            if (delay)
              await (0, wait_js_1.wait)(delay);
            attemptRetry({ count: count + 1 });
          };
          try {
            const data = await fn();
            resolve(data);
          } catch (err) {
            if (count < retryCount && await shouldRetry({ count, error: err }))
              return retry({ error: err });
            reject(err);
          }
        };
        attemptRetry();
      });
    }
    exports.withRetry = withRetry;
  }
});

// node_modules/viem/dist/cjs/utils/buildRequest.js
var require_buildRequest = __commonJS({
  "node_modules/viem/dist/cjs/utils/buildRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildRequest = exports.isDeterministicError = void 0;
    var base_js_1 = require_base();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    var withRetry_js_1 = require_withRetry();
    var isDeterministicError = (error) => {
      if ("code" in error)
        return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
      if (error instanceof request_js_1.HttpRequestError && error.status)
        return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
      return false;
    };
    exports.isDeterministicError = isDeterministicError;
    function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
      return async (args) => (0, withRetry_js_1.withRetry)(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            case rpc_js_1.ParseRpcError.code:
              throw new rpc_js_1.ParseRpcError(err);
            case rpc_js_1.InvalidRequestRpcError.code:
              throw new rpc_js_1.InvalidRequestRpcError(err);
            case rpc_js_1.MethodNotFoundRpcError.code:
              throw new rpc_js_1.MethodNotFoundRpcError(err);
            case rpc_js_1.InvalidParamsRpcError.code:
              throw new rpc_js_1.InvalidParamsRpcError(err);
            case rpc_js_1.InternalRpcError.code:
              throw new rpc_js_1.InternalRpcError(err);
            case rpc_js_1.InvalidInputRpcError.code:
              throw new rpc_js_1.InvalidInputRpcError(err);
            case rpc_js_1.ResourceNotFoundRpcError.code:
              throw new rpc_js_1.ResourceNotFoundRpcError(err);
            case rpc_js_1.ResourceUnavailableRpcError.code:
              throw new rpc_js_1.ResourceUnavailableRpcError(err);
            case rpc_js_1.TransactionRejectedRpcError.code:
              throw new rpc_js_1.TransactionRejectedRpcError(err);
            case rpc_js_1.MethodNotSupportedRpcError.code:
              throw new rpc_js_1.MethodNotSupportedRpcError(err);
            case rpc_js_1.LimitExceededRpcError.code:
              throw new rpc_js_1.LimitExceededRpcError(err);
            case rpc_js_1.JsonRpcVersionUnsupportedError.code:
              throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
            case rpc_js_1.UserRejectedRequestError.code:
              throw new rpc_js_1.UserRejectedRequestError(err);
            case rpc_js_1.UnauthorizedProviderError.code:
              throw new rpc_js_1.UnauthorizedProviderError(err);
            case rpc_js_1.UnsupportedProviderMethodError.code:
              throw new rpc_js_1.UnsupportedProviderMethodError(err);
            case rpc_js_1.ProviderDisconnectedError.code:
              throw new rpc_js_1.ProviderDisconnectedError(err);
            case rpc_js_1.ChainDisconnectedError.code:
              throw new rpc_js_1.ChainDisconnectedError(err);
            case rpc_js_1.SwitchChainError.code:
              throw new rpc_js_1.SwitchChainError(err);
            default:
              if (err_ instanceof base_js_1.BaseError)
                throw err_;
              throw new rpc_js_1.UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof request_js_1.HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => !(0, exports.isDeterministicError)(error)
      });
    }
    exports.buildRequest = buildRequest;
  }
});

// node_modules/viem/dist/cjs/clients/transports/createTransport.js
var require_createTransport = __commonJS({
  "node_modules/viem/dist/cjs/clients/transports/createTransport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransport = void 0;
    var buildRequest_js_1 = require_buildRequest();
    function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
      return {
        config: { key, name, request, retryCount, retryDelay, timeout, type },
        request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay }),
        value
      };
    }
    exports.createTransport = createTransport;
  }
});

// node_modules/viem/dist/cjs/clients/transports/custom.js
var require_custom = __commonJS({
  "node_modules/viem/dist/cjs/clients/transports/custom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.custom = void 0;
    var createTransport_js_1 = require_createTransport();
    function custom(provider, config = {}) {
      const { key = "custom", name = "Custom Provider", retryDelay } = config;
      return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
        key,
        name,
        request: provider.request.bind(provider),
        retryCount: config.retryCount ?? defaultRetryCount,
        retryDelay,
        type: "custom"
      });
    }
    exports.custom = custom;
  }
});

// node_modules/viem/dist/cjs/clients/transports/fallback.js
var require_fallback = __commonJS({
  "node_modules/viem/dist/cjs/clients/transports/fallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rankTransports = exports.fallback = void 0;
    var buildRequest_js_1 = require_buildRequest();
    var wait_js_1 = require_wait();
    var createTransport_js_1 = require_createTransport();
    function fallback(transports_, config = {}) {
      const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
      return ({ chain, pollingInterval = 4e3, timeout }) => {
        let transports = transports_;
        let onResponse = () => {
        };
        const transport = (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const fetch2 = async (i2 = 0) => {
              const transport2 = transports[i2]({ chain, retryCount: 0, timeout });
              try {
                const response = await transport2.request({
                  method,
                  params
                });
                onResponse({
                  method,
                  params,
                  response,
                  transport: transport2,
                  status: "success"
                });
                return response;
              } catch (err) {
                onResponse({
                  error: err,
                  method,
                  params,
                  transport: transport2,
                  status: "error"
                });
                if ((0, buildRequest_js_1.isDeterministicError)(err))
                  throw err;
                if (i2 === transports.length - 1)
                  throw err;
                return fetch2(i2 + 1);
              }
            };
            return fetch2();
          },
          retryCount,
          retryDelay,
          type: "fallback"
        }, {
          onResponse: (fn) => onResponse = fn,
          transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
        });
        if (rank) {
          const rankOptions = typeof rank === "object" ? rank : {};
          rankTransports({
            chain,
            interval: rankOptions.interval ?? pollingInterval,
            onTransports: (transports_2) => transports = transports_2,
            sampleCount: rankOptions.sampleCount,
            timeout: rankOptions.timeout,
            transports,
            weights: rankOptions.weights
          });
        }
        return transport;
      };
    }
    exports.fallback = fallback;
    function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
      const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
      const samples = [];
      const rankTransports_ = async () => {
        const sample = await Promise.all(transports.map(async (transport) => {
          const transport_ = transport({ chain, retryCount: 0, timeout });
          const start = Date.now();
          let end;
          let success;
          try {
            await transport_.request({ method: "net_listening" });
            success = 1;
          } catch {
            success = 0;
          } finally {
            end = Date.now();
          }
          const latency = end - start;
          return { latency, success };
        }));
        samples.push(sample);
        if (samples.length > sampleCount)
          samples.shift();
        const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
        const scores = transports.map((_, i2) => {
          const latencies = samples.map((sample2) => sample2[i2].latency);
          const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
          const latencyScore = 1 - meanLatency / maxLatency;
          const successes = samples.map((sample2) => sample2[i2].success);
          const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
          if (stabilityScore === 0)
            return [0, i2];
          return [
            latencyWeight * latencyScore + stabilityWeight * stabilityScore,
            i2
          ];
        }).sort((a3, b2) => b2[0] - a3[0]);
        onTransports(scores.map(([, i2]) => transports[i2]));
        await (0, wait_js_1.wait)(interval);
        rankTransports_();
      };
      rankTransports_();
    }
    exports.rankTransports = rankTransports;
  }
});

// node_modules/viem/dist/cjs/errors/transport.js
var require_transport = __commonJS({
  "node_modules/viem/dist/cjs/errors/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlRequiredError = void 0;
    var base_js_1 = require_base();
    var UrlRequiredError = class extends base_js_1.BaseError {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
        });
      }
    };
    exports.UrlRequiredError = UrlRequiredError;
  }
});

// node_modules/viem/dist/cjs/utils/promise/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/viem/dist/cjs/utils/promise/withTimeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    function withTimeout(fn, { errorInstance, timeout, signal }) {
      return new Promise((resolve, reject) => {
        ;
        (async () => {
          let timeoutId;
          try {
            const controller = new AbortController();
            if (timeout > 0) {
              timeoutId = setTimeout(() => {
                if (signal) {
                  controller.abort();
                } else {
                  reject(errorInstance);
                }
              }, timeout);
            }
            resolve(await fn({ signal: controller?.signal }));
          } catch (err) {
            if (err.name === "AbortError")
              reject(errorInstance);
            reject(err);
          } finally {
            clearTimeout(timeoutId);
          }
        })();
      });
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/viem/dist/cjs/utils/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/viem/dist/cjs/utils/rpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rpc = exports.getSocket = void 0;
    var request_js_1 = require_request();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var withTimeout_js_1 = require_withTimeout();
    var stringify_js_1 = require_stringify();
    var id = 0;
    async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
          const response2 = await fetch(url, {
            ...fetchOptions,
            body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map((body2) => ({
              jsonrpc: "2.0",
              id: id++,
              ...body2
            }))) : (0, stringify_js_1.stringify)({ jsonrpc: "2.0", id: id++, ...body }),
            headers: {
              ...headers,
              "Content-Type": "application/json"
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : void 0)
          });
          return response2;
        }, {
          errorInstance: new request_js_1.TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (!response.ok) {
          throw new request_js_1.HttpRequestError({
            body,
            details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof request_js_1.HttpRequestError)
          throw err;
        if (err instanceof request_js_1.TimeoutError)
          throw err;
        throw new request_js_1.HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    var sockets = /* @__PURE__ */ new Map();
    async function getSocket(url_) {
      const url = new URL(url_);
      const urlKey = url.toString();
      let socket = sockets.get(urlKey);
      if (socket)
        return socket;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: urlKey,
        fn: async () => {
          let WebSocket = await import("./browser-VSZKQ24D.js");
          if (WebSocket.default?.constructor)
            WebSocket = WebSocket.default;
          else
            WebSocket = WebSocket.WebSocket;
          const webSocket2 = new WebSocket(url);
          const requests = /* @__PURE__ */ new Map();
          const subscriptions = /* @__PURE__ */ new Map();
          const onMessage = ({ data }) => {
            const message = JSON.parse(data);
            const isSubscription = message.method === "eth_subscription";
            const id2 = isSubscription ? message.params.subscription : message.id;
            const cache = isSubscription ? subscriptions : requests;
            const callback = cache.get(id2);
            if (callback)
              callback({ data });
            if (!isSubscription)
              cache.delete(id2);
          };
          const onClose = () => {
            sockets.delete(urlKey);
            webSocket2.removeEventListener("close", onClose);
            webSocket2.removeEventListener("message", onMessage);
          };
          webSocket2.addEventListener("close", onClose);
          webSocket2.addEventListener("message", onMessage);
          if (webSocket2.readyState === WebSocket.CONNECTING) {
            await new Promise((resolve, reject) => {
              if (!webSocket2)
                return;
              webSocket2.onopen = resolve;
              webSocket2.onerror = reject;
            });
          }
          socket = Object.assign(webSocket2, {
            requests,
            subscriptions
          });
          sockets.set(urlKey, socket);
          return [socket];
        }
      });
      const [_, [socket_]] = await schedule();
      return socket_;
    }
    exports.getSocket = getSocket;
    function webSocket(socket, { body, onResponse }) {
      if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
        throw new request_js_1.WebSocketRequestError({
          body,
          url: socket.url,
          details: "Socket is closed."
        });
      const id_ = id++;
      const callback = ({ data }) => {
        const message = JSON.parse(data);
        if (typeof message.id === "number" && id_ !== message.id)
          return;
        onResponse?.(message);
        if (body.method === "eth_subscribe" && typeof message.result === "string") {
          socket.subscriptions.set(message.result, callback);
        }
        if (body.method === "eth_unsubscribe") {
          socket.subscriptions.delete(body.params?.[0]);
        }
      };
      socket.requests.set(id_, callback);
      socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
      return socket;
    }
    async function webSocketAsync(socket, { body, timeout = 1e4 }) {
      return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {
        body,
        onResponse
      })), {
        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),
        timeout
      });
    }
    exports.rpc = {
      http,
      webSocket,
      webSocketAsync
    };
  }
});

// node_modules/viem/dist/cjs/clients/transports/http.js
var require_http = __commonJS({
  "node_modules/viem/dist/cjs/clients/transports/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function http(url, config = {}) {
      const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const { batchSize = 1e3, wait = 0 } = typeof batch === "object" ? batch : {};
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
              id: `${url}`,
              wait,
              shouldSplitBatch(requests) {
                return requests.length > batchSize;
              },
              fn: (body2) => rpc_js_1.rpc.http(url_, {
                body: body2,
                fetchOptions,
                timeout
              })
            });
            const fn = async (body2) => batch ? schedule(body2) : [await rpc_js_1.rpc.http(url_, { body: body2, fetchOptions, timeout })];
            const [{ error, result }] = await fn(body);
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "http"
        }, {
          url
        });
      };
    }
    exports.http = http;
  }
});

// node_modules/viem/dist/cjs/utils/ens/errors.js
var require_errors2 = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNullUniversalResolverError = void 0;
    var solidity_js_1 = require_solidity();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    function isNullUniversalResolverError(err, callType) {
      if (!(err instanceof base_js_1.BaseError))
        return false;
      const cause = err.walk((e2) => e2 instanceof contract_js_1.ContractFunctionRevertedError);
      if (!(cause instanceof contract_js_1.ContractFunctionRevertedError))
        return false;
      if (cause.data?.errorName === "ResolverNotFound")
        return true;
      if (cause.data?.errorName === "ResolverWildcardNotSupported")
        return true;
      if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
        return true;
      if (callType === "reverse" && cause.reason === solidity_js_1.panicReasons[50])
        return true;
      return false;
    }
    exports.isNullUniversalResolverError = isNullUniversalResolverError;
  }
});

// node_modules/viem/dist/cjs/utils/regex.js
var require_regex2 = __commonJS({
  "node_modules/viem/dist/cjs/utils/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;
    exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  }
});

// node_modules/viem/dist/cjs/utils/typedData.js
var require_typedData = __commonJS({
  "node_modules/viem/dist/cjs/utils/typedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTypedData = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var size_js_1 = require_size();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    function validateTypedData({ domain, message, primaryType, types: types_ }) {
      const types = types_;
      const validateData = (struct, value_) => {
        for (const param of struct) {
          const { name, type: type_ } = param;
          const type = type_;
          const value = value_[name];
          const integerMatch = type.match(regex_js_1.integerRegex);
          if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
            const [_type, base, size_] = integerMatch;
            (0, toHex_js_1.numberToHex)(value, {
              signed: base === "int",
              size: parseInt(size_) / 8
            });
          }
          if (type === "address" && typeof value === "string" && !(0, isAddress_js_1.isAddress)(value))
            throw new address_js_1.InvalidAddressError({ address: value });
          const bytesMatch = type.match(regex_js_1.bytesRegex);
          if (bytesMatch) {
            const [_type, size_] = bytesMatch;
            if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))
              throw new abi_js_1.BytesSizeMismatchError({
                expectedSize: parseInt(size_),
                givenSize: (0, size_js_1.size)(value)
              });
          }
          const struct2 = types[type];
          if (struct2)
            validateData(struct2, value);
        }
      };
      if (types["EIP712Domain"] && domain)
        validateData(types["EIP712Domain"], domain);
      if (primaryType !== "EIP712Domain") {
        const type = types[primaryType];
        validateData(type, message);
      }
    }
    exports.validateTypedData = validateTypedData;
  }
});

// node_modules/viem/dist/cjs/utils/abi/decodeFunctionData.js
var require_decodeFunctionData = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/decodeFunctionData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    function decodeFunctionData({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      const description = abi.find((x2) => x2.type === "function" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x2)));
      if (!description)
        throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeFunctionData"
        });
      return {
        functionName: description.name,
        args: "inputs" in description && description.inputs && description.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4)) : void 0
      };
    }
    exports.decodeFunctionData = decodeFunctionData;
  }
});

// node_modules/viem/dist/cjs/utils/abi/encodeDeployData.js
var require_encodeDeployData = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/encodeDeployData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var docsPath = "/docs/contract/encodeDeployData";
    function encodeDeployData({ abi, args, bytecode }) {
      if (!args || args.length === 0)
        return bytecode;
      const description = abi.find((x2) => "type" in x2 && x2.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
      return (0, concat_js_1.concatHex)([bytecode, data]);
    }
    exports.encodeDeployData = encodeDeployData;
  }
});

// node_modules/viem/dist/cjs/utils/abi/encodeErrorResult.js
var require_encodeErrorResult = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/encodeErrorResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeErrorResult = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeErrorResult";
    function encodeErrorResult({ abi, errorName, args }) {
      let abiItem = abi[0];
      if (errorName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: errorName
        });
        if (!abiItem)
          throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath });
      }
      if (abiItem.type !== "error")
        throw new abi_js_1.AbiErrorNotFoundError(void 0, { docsPath });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      let data = "0x";
      if (args && args.length > 0) {
        if (!abiItem.inputs)
          throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath });
        data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
      }
      return (0, concat_js_1.concatHex)([signature, data]);
    }
    exports.encodeErrorResult = encodeErrorResult;
  }
});

// node_modules/viem/dist/cjs/utils/abi/encodeFunctionResult.js
var require_encodeFunctionResult = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/encodeFunctionResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeFunctionResult";
    function encodeFunctionResult({ abi, functionName, result }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionResult"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionResult"
        });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
      let values = Array.isArray(result) ? result : [result];
      if (abiItem.outputs.length === 0 && !values[0])
        values = [];
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
    }
    exports.encodeFunctionResult = encodeFunctionResult;
  }
});

// node_modules/viem/dist/cjs/utils/abi/encodePacked.js
var require_encodePacked = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/encodePacked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodePacked = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    function encodePacked(types, values) {
      if (types.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: types.length,
          givenLength: values.length
        });
      const data = [];
      for (let i2 = 0; i2 < types.length; i2++) {
        const type = types[i2];
        const value = values[i2];
        data.push(encode(type, value));
      }
      return (0, concat_js_1.concat)(data);
    }
    exports.encodePacked = encodePacked;
    function encode(type, value, isArray = false) {
      if (type === "address") {
        const address = value;
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        return (0, pad_js_1.pad)(address.toLowerCase(), {
          size: isArray ? 32 : null
        });
      }
      if (type === "string")
        return (0, toHex_js_1.stringToHex)(value);
      if (type === "bytes")
        return value;
      if (type === "bool")
        return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
      const intMatch = type.match(regex_js_1.integerRegex);
      if (intMatch) {
        const [_type, baseType, bits = "256"] = intMatch;
        const size = parseInt(bits) / 8;
        return (0, toHex_js_1.numberToHex)(value, {
          size: isArray ? 32 : size,
          signed: baseType === "int"
        });
      }
      const bytesMatch = type.match(regex_js_1.bytesRegex);
      if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (parseInt(size) !== (value.length - 2) / 2)
          throw new abi_js_1.BytesSizeMismatchError({
            expectedSize: parseInt(size),
            givenSize: (value.length - 2) / 2
          });
        return (0, pad_js_1.pad)(value, { dir: "right", size: isArray ? 32 : null });
      }
      const arrayMatch = type.match(regex_js_1.arrayRegex);
      if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i2 = 0; i2 < value.length; i2++) {
          data.push(encode(childType, value[i2], true));
        }
        if (data.length === 0)
          return "0x";
        return (0, concat_js_1.concat)(data);
      }
      throw new abi_js_1.UnsupportedPackedAbiType(type);
    }
  }
});

// node_modules/viem/dist/cjs/utils/data/isBytes.js
var require_isBytes = __commonJS({
  "node_modules/viem/dist/cjs/utils/data/isBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytes = void 0;
    function isBytes(value) {
      if (!value)
        return false;
      if (typeof value !== "object")
        return false;
      if (!("BYTES_PER_ELEMENT" in value))
        return false;
      return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
  }
});

// node_modules/viem/dist/cjs/utils/encoding/toRlp.js
var require_toRlp = __commonJS({
  "node_modules/viem/dist/cjs/utils/encoding/toRlp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToRlp = exports.toRlp = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function toRlp(hexOrBytes, to_) {
      const to = to_ || "hex";
      return format2(bytesToRlp(parse2(hexOrBytes)), to);
    }
    exports.toRlp = toRlp;
    function parse2(hexOrBytes) {
      if (Array.isArray(hexOrBytes))
        return hexOrBytes.map(parse2);
      return typeof hexOrBytes === "string" ? (0, toBytes_js_1.toBytes)(hexOrBytes) : hexOrBytes;
    }
    function format2(bytes, type = "bytes") {
      return type === "hex" ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;
    }
    function bytesToRlp(bytes) {
      if (Array.isArray(bytes)) {
        const encoded = (0, concat_js_1.concat)(bytes.map(bytesToRlp));
        return new Uint8Array([...encodeLength(encoded.length, 192), ...encoded]);
      }
      if (bytes.length === 1 && bytes[0] < 128)
        return bytes;
      return new Uint8Array([...encodeLength(bytes.length, 128), ...bytes]);
    }
    exports.bytesToRlp = bytesToRlp;
    function encodeLength(length, offset) {
      if (length < 56)
        return [offset + length];
      return [(0, toBytes_js_1.toBytes)(length).length + offset + 55, ...(0, toBytes_js_1.toBytes)(length)];
    }
  }
});

// node_modules/viem/dist/cjs/utils/address/getContractAddress.js
var require_getContractAddress = __commonJS({
  "node_modules/viem/dist/cjs/utils/address/getContractAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = void 0;
    var concat_js_1 = require_concat();
    var isBytes_js_1 = require_isBytes();
    var pad_js_1 = require_pad();
    var slice_js_1 = require_slice();
    var toBytes_js_1 = require_toBytes();
    var toRlp_js_1 = require_toRlp();
    var keccak256_js_1 = require_keccak256();
    var getAddress_js_1 = require_getAddress();
    function getContractAddress(opts) {
      if (opts.opcode === "CREATE2")
        return getCreate2Address(opts);
      return getCreateAddress(opts);
    }
    exports.getContractAddress = getContractAddress;
    function getCreateAddress(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
      if (nonce[0] === 0)
        nonce = new Uint8Array([]);
      return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], "bytes")).slice(26)}`);
    }
    exports.getCreateAddress = getCreateAddress;
    function getCreate2Address(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
        size: 32
      });
      const bytecodeHash = (0, toBytes_js_1.toBytes)((0, keccak256_js_1.keccak256)((0, isBytes_js_1.isBytes)(opts.bytecode) ? opts.bytecode : (0, toBytes_js_1.toBytes)(opts.bytecode)));
      return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)("0xff"), from, salt, bytecodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address;
  }
});

// node_modules/viem/dist/cjs/utils/formatters/transactionReceipt.js
var require_transactionReceipt = __commonJS({
  "node_modules/viem/dist/cjs/utils/formatters/transactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransactionReceipt = exports.formatTransactionReceipt = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    var log_js_1 = require_log2();
    var transaction_js_1 = require_transaction2();
    var statuses = {
      "0x0": "reverted",
      "0x1": "success"
    };
    function formatTransactionReceipt(transactionReceipt) {
      return {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
        contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
        gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
        logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log)) : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex) : null,
        status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
        type: transactionReceipt.type ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type : null
      };
    }
    exports.formatTransactionReceipt = formatTransactionReceipt;
    exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)("transactionReceipt", formatTransactionReceipt);
  }
});

// node_modules/viem/dist/cjs/utils/encoding/fromBytes.js
var require_fromBytes = __commonJS({
  "node_modules/viem/dist/cjs/utils/encoding/fromBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.fromBytes = void 0;
    var encoding_js_1 = require_encoding();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function fromBytes(bytes, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return bytesToNumber(bytes, opts);
      if (to === "bigint")
        return bytesToBigint(bytes, opts);
      if (to === "boolean")
        return bytesToBool(bytes, opts);
      if (to === "string")
        return bytesToString(bytes, opts);
      return (0, toHex_js_1.bytesToHex)(bytes, opts);
    }
    exports.fromBytes = fromBytes;
    function bytesToBigint(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToBigInt)(hex);
    }
    exports.bytesToBigint = bytesToBigint;
    function bytesToBool(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes);
      }
      if (bytes.length > 1 || bytes[0] > 1)
        throw new encoding_js_1.InvalidBytesBooleanError(bytes);
      return Boolean(bytes[0]);
    }
    exports.bytesToBool = bytesToBool;
    function bytesToNumber(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToNumber)(hex);
    }
    exports.bytesToNumber = bytesToNumber;
    function bytesToString(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
      }
      return new TextDecoder().decode(bytes);
    }
    exports.bytesToString = bytesToString;
  }
});

// node_modules/viem/dist/cjs/utils/encoding/fromRlp.js
var require_fromRlp = __commonJS({
  "node_modules/viem/dist/cjs/utils/encoding/fromRlp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromRlp = void 0;
    var encoding_js_1 = require_encoding();
    var fromBytes_js_1 = require_fromBytes();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function fromRlp(value, to) {
      const bytes = parse2(value);
      const [data, consumed] = rlpToBytes(bytes);
      if (consumed < bytes.length)
        throw new encoding_js_1.DataLengthTooLongError({
          consumed,
          length: bytes.length
        });
      return format2(data, to);
    }
    exports.fromRlp = fromRlp;
    function parse2(value) {
      if (typeof value === "string") {
        if (value.length > 3 && value.length % 2 !== 0)
          throw new encoding_js_1.InvalidHexValueError(value);
        return (0, toBytes_js_1.hexToBytes)(value);
      }
      return value;
    }
    function format2(bytes, to) {
      if (Array.isArray(bytes))
        return bytes.map((b2) => format2(b2, to));
      return to === "hex" ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;
    }
    function rlpToBytes(bytes, offset = 0) {
      if (bytes.length === 0)
        return [new Uint8Array([]), 0];
      const prefix = bytes[offset];
      if (prefix <= 127)
        return [new Uint8Array([bytes[offset]]), 1];
      if (prefix <= 183) {
        const length2 = prefix - 128;
        const offset_ = offset + 1;
        if (offset_ + length2 > bytes.length)
          throw new encoding_js_1.DataLengthTooShortError({
            length: offset_ + length2,
            dataLength: bytes.length
          });
        return [bytes.slice(offset_, offset_ + length2), 1 + length2];
      }
      if (prefix <= 191) {
        const lengthOfLength2 = prefix - 183;
        const offset_ = offset + 1;
        const length2 = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset_, offset_ + lengthOfLength2));
        if (offset_ + lengthOfLength2 + length2 > bytes.length)
          throw new encoding_js_1.DataLengthTooShortError({
            length: lengthOfLength2 + length2,
            dataLength: bytes.length - lengthOfLength2
          });
        return [
          bytes.slice(offset_ + lengthOfLength2, offset_ + lengthOfLength2 + length2),
          1 + lengthOfLength2 + length2
        ];
      }
      let lengthOfLength = 0;
      let length = prefix - 192;
      if (prefix > 247) {
        lengthOfLength = prefix - 247;
        length = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset + 1, offset + 1 + lengthOfLength));
      }
      let nextOffset = offset + 1 + lengthOfLength;
      if (nextOffset > bytes.length)
        throw new encoding_js_1.DataLengthTooShortError({
          length: nextOffset,
          dataLength: bytes.length
        });
      const consumed = 1 + lengthOfLength + length;
      const result = [];
      while (nextOffset < offset + consumed) {
        const decoded = rlpToBytes(bytes, nextOffset);
        result.push(decoded[0]);
        nextOffset += decoded[1];
        if (nextOffset > offset + consumed)
          throw new encoding_js_1.OffsetOutOfBoundsError({
            nextOffset,
            offset: offset + consumed
          });
      }
      return [result, consumed];
    }
  }
});

// node_modules/viem/dist/cjs/utils/hash/isHash.js
var require_isHash = __commonJS({
  "node_modules/viem/dist/cjs/utils/hash/isHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHash = void 0;
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function isHash(hash) {
      return (0, isHex_js_1.isHex)(hash) && (0, size_js_1.size)(hash) === 32;
    }
    exports.isHash = isHash;
  }
});

// node_modules/viem/dist/cjs/utils/signature/hashTypedData.js
var require_hashTypedData = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/hashTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTypedData = void 0;
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var concat_js_1 = require_concat();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var typedData_js_1 = require_typedData();
    function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
      const domain = typeof domain_ === "undefined" ? {} : domain_;
      const types = {
        EIP712Domain: [
          typeof domain?.name === "string" && { name: "name", type: "string" },
          domain?.version && { name: "version", type: "string" },
          typeof domain?.chainId === "number" && {
            name: "chainId",
            type: "uint256"
          },
          domain?.verifyingContract && {
            name: "verifyingContract",
            type: "address"
          },
          domain?.salt && { name: "salt", type: "bytes32" }
        ].filter(Boolean),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      const parts = ["0x1901"];
      if (domain)
        parts.push(hashDomain({
          domain,
          types
        }));
      if (primaryType !== "EIP712Domain") {
        parts.push(hashStruct({
          data: message,
          primaryType,
          types
        }));
      }
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
    }
    exports.hashTypedData = hashTypedData;
    function hashDomain({ domain, types }) {
      return hashStruct({
        data: domain,
        primaryType: "EIP712Domain",
        types
      });
    }
    function hashStruct({ data, primaryType, types }) {
      const encoded = encodeData({
        data,
        primaryType,
        types
      });
      return (0, keccak256_js_1.keccak256)(encoded);
    }
    function encodeData({ data, primaryType, types }) {
      const encodedTypes = [{ type: "bytes32" }];
      const encodedValues = [hashType({ primaryType, types })];
      for (const field of types[primaryType]) {
        const [type, value] = encodeField({
          types,
          name: field.name,
          type: field.type,
          value: data[field.name]
        });
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
    }
    function hashType({ primaryType, types }) {
      const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
      return (0, keccak256_js_1.keccak256)(encodedHashType);
    }
    function encodeType({ primaryType, types }) {
      let result = "";
      const unsortedDeps = findTypeDependencies({ primaryType, types });
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        result += `${type}(${types[type].map(({ name, type: t2 }) => `${t2} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
      const match2 = primaryType_.match(/^\w*/u);
      const primaryType = match2?.[0];
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies({ primaryType: field.type, types }, results);
      }
      return results;
    }
    function encodeField({ types, name, type, value }) {
      if (types[type] !== void 0) {
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types }))
        ];
      }
      if (type === "bytes") {
        const prepend = value.length % 2 ? "0" : "";
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)(value)];
      }
      if (type === "string")
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
      if (type.lastIndexOf("]") === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField({
          name,
          type: parsedType,
          types,
          value: item
        }));
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v]) => v)))
        ];
      }
      return [{ type }, value];
    }
  }
});

// node_modules/viem/dist/cjs/utils/signature/recoverPublicKey.js
var require_recoverPublicKey = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/recoverPublicKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverPublicKey = void 0;
    var isHex_js_1 = require_isHex();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function recoverPublicKey({ hash, signature }) {
      const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
      const hashHex = (0, isHex_js_1.isHex)(hash) ? hash : (0, toHex_js_1.toHex)(hash);
      let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
      if (v === 0 || v === 1)
        v += 27;
      const { secp256k1 } = await import("./secp256k1-6N5ICTEW.js");
      const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
      return `0x${publicKey}`;
    }
    exports.recoverPublicKey = recoverPublicKey;
  }
});

// node_modules/viem/dist/cjs/utils/signature/recoverAddress.js
var require_recoverAddress = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/recoverAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverAddress = void 0;
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    async function recoverAddress({ hash, signature }) {
      return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash, signature }));
    }
    exports.recoverAddress = recoverAddress;
  }
});

// node_modules/viem/dist/cjs/utils/signature/hashMessage.js
var require_hashMessage = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/hashMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashMessage = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    function hashMessage(message, to_) {
      const messageBytes = (() => {
        if (typeof message === "string")
          return (0, toBytes_js_1.stringToBytes)(message);
        if (message.raw instanceof Uint8Array)
          return message.raw;
        return (0, toBytes_js_1.toBytes)(message.raw);
      })();
      const prefixBytes = (0, toBytes_js_1.stringToBytes)(`Ethereum Signed Message:
${messageBytes.length}`);
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
    }
    exports.hashMessage = hashMessage;
  }
});

// node_modules/viem/dist/cjs/utils/signature/recoverMessageAddress.js
var require_recoverMessageAddress = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/recoverMessageAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverMessageAddress = void 0;
    var hashMessage_js_1 = require_hashMessage();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverMessageAddress({ message, signature }) {
      return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
    }
    exports.recoverMessageAddress = recoverMessageAddress;
  }
});

// node_modules/viem/dist/cjs/utils/signature/recoverTypedDataAddress.js
var require_recoverTypedDataAddress = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/recoverTypedDataAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedDataAddress = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverTypedDataAddress({ domain, message, primaryType, signature, types }) {
      return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashTypedData_js_1.hashTypedData)({
          domain,
          message,
          primaryType,
          types
        }),
        signature
      });
    }
    exports.recoverTypedDataAddress = recoverTypedDataAddress;
  }
});

// node_modules/viem/dist/cjs/utils/signature/verifyMessage.js
var require_verifyMessage = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/verifyMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    async function verifyMessage({ address, message, signature }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
    }
    exports.verifyMessage = verifyMessage;
  }
});

// node_modules/viem/dist/cjs/utils/signature/verifyTypedData.js
var require_verifyTypedData = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/verifyTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    async function verifyTypedData({ address, domain, message, primaryType, signature, types }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types
      }));
    }
    exports.verifyTypedData = verifyTypedData;
  }
});

// node_modules/viem/dist/cjs/utils/transaction/getSerializedTransactionType.js
var require_getSerializedTransactionType = __commonJS({
  "node_modules/viem/dist/cjs/utils/transaction/getSerializedTransactionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSerializedTransactionType = void 0;
    var transaction_js_1 = require_transaction();
    var slice_js_1 = require_slice();
    var fromHex_js_1 = require_fromHex();
    function getSerializedTransactionType(serializedTransaction) {
      const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
      if (serializedType === "0x02")
        return "eip1559";
      if (serializedType === "0x01")
        return "eip2930";
      if (serializedType !== "0x" && (0, fromHex_js_1.hexToNumber)(serializedType) >= 192)
        return "legacy";
      throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
    }
    exports.getSerializedTransactionType = getSerializedTransactionType;
  }
});

// node_modules/viem/dist/cjs/utils/transaction/getTransactionType.js
var require_getTransactionType = __commonJS({
  "node_modules/viem/dist/cjs/utils/transaction/getTransactionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionType = void 0;
    var transaction_js_1 = require_transaction();
    function getTransactionType(transaction) {
      if (transaction.type)
        return transaction.type;
      if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
        return "eip1559";
      if (typeof transaction.gasPrice !== "undefined") {
        if (typeof transaction.accessList !== "undefined")
          return "eip2930";
        return "legacy";
      }
      throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
    }
    exports.getTransactionType = getTransactionType;
  }
});

// node_modules/viem/dist/cjs/utils/transaction/assertTransaction.js
var require_assertTransaction = __commonJS({
  "node_modules/viem/dist/cjs/utils/transaction/assertTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var node_js_1 = require_node();
    var isAddress_js_1 = require_isAddress();
    function assertTransactionEIP1559(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports.assertTransactionEIP1559 = assertTransactionEIP1559;
    function assertTransactionEIP2930(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
    }
    exports.assertTransactionEIP2930 = assertTransactionEIP2930;
    function assertTransactionLegacy(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof chainId !== "undefined" && chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
      if (accessList)
        throw new base_js_1.BaseError("`accessList` is not a valid Legacy Transaction attribute.");
    }
    exports.assertTransactionLegacy = assertTransactionLegacy;
  }
});

// node_modules/viem/dist/cjs/utils/transaction/parseTransaction.js
var require_parseTransaction = __commonJS({
  "node_modules/viem/dist/cjs/utils/transaction/parseTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseTransaction = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var fromRlp_js_1 = require_fromRlp();
    var isHash_js_1 = require_isHash();
    var assertTransaction_js_1 = require_assertTransaction();
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    function parseTransaction(serializedTransaction) {
      const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
      if (type === "eip1559")
        return parseTransactionEIP1559(serializedTransaction);
      if (type === "eip2930")
        return parseTransactionEIP2930(serializedTransaction);
      return parseTransactionLegacy(serializedTransaction);
    }
    exports.parseTransaction = parseTransaction;
    function parseTransactionEIP1559(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
      const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s3] = transactionArray;
      if (!(transactionArray.length === 9 || transactionArray.length === 12))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 9 ? {
              v,
              r,
              s: s3
            } : {}
          },
          serializedTransaction,
          type: "eip1559"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip1559"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
      if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionEIP2930(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
      const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s3] = transactionArray;
      if (!(transactionArray.length === 8 || transactionArray.length === 11))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 8 ? {
              v,
              r,
              s: s3
            } : {}
          },
          serializedTransaction,
          type: "eip2930"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip2930"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionLegacy(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, "hex");
      const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s3] = transactionArray;
      if (!(transactionArray.length === 6 || transactionArray.length === 9))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            ...transactionArray.length > 6 ? {
              v: chainIdOrV_,
              r,
              s: s3
            } : {}
          },
          serializedTransaction,
          type: "legacy"
        });
      const transaction = {
        type: "legacy"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      if (transactionArray.length === 6)
        return transaction;
      const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== "0x" ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_) : 0n;
      if (s3 === "0x" && r === "0x") {
        if (chainIdOrV > 0)
          transaction.chainId = Number(chainIdOrV);
        return transaction;
      }
      const v = chainIdOrV;
      const chainId = Number((v - 35n) / 2n);
      if (chainId > 0)
        transaction.chainId = chainId;
      else if (v !== 27n && v !== 28n)
        throw new transaction_js_1.InvalidLegacyVError({ v });
      transaction.v = v;
      transaction.s = s3;
      transaction.r = r;
      return transaction;
    }
    function parseAccessList(accessList_) {
      const accessList = [];
      for (let i2 = 0; i2 < accessList_.length; i2++) {
        const [address, storageKeys] = accessList_[i2];
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        accessList.push({
          address,
          storageKeys: storageKeys.map((key) => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))
        });
      }
      return accessList;
    }
    function parseEIP155Signature(transactionArray) {
      const signature = transactionArray.slice(-3);
      const v = signature[0] === "0x" || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
      return {
        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
        v,
        yParity: v === 27n ? 0 : 1
      };
    }
  }
});

// node_modules/viem/dist/cjs/utils/transaction/serializeAccessList.js
var require_serializeAccessList = __commonJS({
  "node_modules/viem/dist/cjs/utils/transaction/serializeAccessList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeAccessList = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction();
    var isAddress_js_1 = require_isAddress();
    function serializeAccessList(accessList) {
      if (!accessList || accessList.length === 0)
        return [];
      const serializedAccessList = [];
      for (let i2 = 0; i2 < accessList.length; i2++) {
        const { address, storageKeys } = accessList[i2];
        for (let j = 0; j < storageKeys.length; j++) {
          if (storageKeys[j].length - 2 !== 64) {
            throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
          }
        }
        if (!(0, isAddress_js_1.isAddress)(address)) {
          throw new address_js_1.InvalidAddressError({ address });
        }
        serializedAccessList.push([address, storageKeys]);
      }
      return serializedAccessList;
    }
    exports.serializeAccessList = serializeAccessList;
  }
});

// node_modules/viem/dist/cjs/utils/transaction/serializeTransaction.js
var require_serializeTransaction = __commonJS({
  "node_modules/viem/dist/cjs/utils/transaction/serializeTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeTransaction = void 0;
    var transaction_js_1 = require_transaction();
    var concat_js_1 = require_concat();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var assertTransaction_js_1 = require_assertTransaction();
    var getTransactionType_js_1 = require_getTransactionType();
    var serializeAccessList_js_1 = require_serializeAccessList();
    function serializeTransaction(transaction, signature) {
      const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
      if (type === "eip1559")
        return serializeTransactionEIP1559(transaction, signature);
      if (type === "eip2930")
        return serializeTransactionEIP2930(transaction, signature);
      return serializeTransactionLegacy(transaction, signature);
    }
    exports.serializeTransaction = serializeTransaction;
    function serializeTransactionEIP1559(transaction, signature) {
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature)
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      return (0, concat_js_1.concatHex)([
        "0x02",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionEIP2930(transaction, signature) {
      const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature)
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), signature.r, signature.s);
      return (0, concat_js_1.concatHex)([
        "0x01",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionLegacy(transaction, signature) {
      const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      let serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x"
      ];
      if (signature) {
        let v = 27n + (signature.v === 27n ? 0n : 1n);
        if (chainId > 0)
          v = BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
        else if (signature.v !== v)
          throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(v),
          signature.r,
          signature.s
        ];
      } else if (chainId > 0) {
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(chainId),
          "0x",
          "0x"
        ];
      }
      return (0, toRlp_js_1.toRlp)(serializedTransaction);
    }
  }
});

// node_modules/viem/dist/cjs/utils/unit/parseUnits.js
var require_parseUnits = __commonJS({
  "node_modules/viem/dist/cjs/utils/unit/parseUnits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseUnits = void 0;
    function parseUnits(value, decimals) {
      let [integer, fraction = "0"] = value.split(".");
      const negative = integer.startsWith("-");
      if (negative)
        integer = integer.slice(1);
      fraction = fraction.replace(/(0+)$/, "");
      if (decimals === 0) {
        if (Math.round(Number(`.${fraction}`)) === 1)
          integer = `${BigInt(integer) + 1n}`;
        fraction = "";
      } else if (fraction.length > decimals) {
        const [left, unit, right] = [
          fraction.slice(0, decimals - 1),
          fraction.slice(decimals - 1, decimals),
          fraction.slice(decimals)
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9)
          fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
        else
          fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
          fraction = fraction.slice(1);
          integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
      } else {
        fraction = fraction.padEnd(decimals, "0");
      }
      return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
    }
    exports.parseUnits = parseUnits;
  }
});

// node_modules/viem/dist/cjs/utils/unit/parseEther.js
var require_parseEther = __commonJS({
  "node_modules/viem/dist/cjs/utils/unit/parseEther.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEther = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseEther(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
    }
    exports.parseEther = parseEther;
  }
});

// node_modules/viem/dist/cjs/utils/unit/parseGwei.js
var require_parseGwei = __commonJS({
  "node_modules/viem/dist/cjs/utils/unit/parseGwei.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGwei = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseGwei(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
    }
    exports.parseGwei = parseGwei;
  }
});

// node_modules/viem/dist/cjs/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/viem/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatHex = exports.concatBytes = exports.concat = exports.extractFunctionParts = exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.isAddressEqual = exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.stringify = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.buildRequest = void 0;
    exports.getEventSelector = exports.defineFormatter = exports.getTransactionError = exports.getEstimateGasError = exports.getContractError = exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = void 0;
    exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.prepareRequest = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.keccak256 = exports.isHash = exports.getFunctionSelector = void 0;
    var buildRequest_js_1 = require_buildRequest();
    Object.defineProperty(exports, "buildRequest", { enumerable: true, get: function() {
      return buildRequest_js_1.buildRequest;
    } });
    var ccip_js_1 = require_ccip();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var chain_js_1 = require_chain2();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return chain_js_1.assertCurrentChain;
    } });
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return chain_js_1.defineChain;
    } });
    Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
      return chain_js_1.getChainContractAddress;
    } });
    var regex_js_1 = require_regex2();
    Object.defineProperty(exports, "arrayRegex", { enumerable: true, get: function() {
      return regex_js_1.arrayRegex;
    } });
    Object.defineProperty(exports, "bytesRegex", { enumerable: true, get: function() {
      return regex_js_1.bytesRegex;
    } });
    Object.defineProperty(exports, "integerRegex", { enumerable: true, get: function() {
      return regex_js_1.integerRegex;
    } });
    var rpc_js_1 = require_rpc2();
    Object.defineProperty(exports, "getSocket", { enumerable: true, get: function() {
      return rpc_js_1.getSocket;
    } });
    Object.defineProperty(exports, "rpc", { enumerable: true, get: function() {
      return rpc_js_1.rpc;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    Object.defineProperty(exports, "formatAbiItemWithArgs", { enumerable: true, get: function() {
      return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    Object.defineProperty(exports, "formatAbiParams", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiParams;
    } });
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var extractFunctionParts_js_1 = require_extractFunctionParts();
    Object.defineProperty(exports, "extractFunctionName", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionName;
    } });
    Object.defineProperty(exports, "extractFunctionParams", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParams;
    } });
    Object.defineProperty(exports, "extractFunctionType", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionType;
    } });
    Object.defineProperty(exports, "extractFunctionParts", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParts;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var block_js_1 = require_block2();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_1.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_1.formatBlock;
    } });
    var transaction_js_1 = require_transaction2();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_1.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_1.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_1.transactionType;
    } });
    var log_js_1 = require_log2();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_1.formatLog;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    var extract_js_1 = require_extract();
    Object.defineProperty(exports, "extract", { enumerable: true, get: function() {
      return extract_js_1.extract;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigint;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getNodeError_js_1 = require_getNodeError();
    Object.defineProperty(exports, "containsNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.containsNodeError;
    } });
    Object.defineProperty(exports, "getNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.getNodeError;
    } });
    var getCallError_js_1 = require_getCallError();
    Object.defineProperty(exports, "getCallError", { enumerable: true, get: function() {
      return getCallError_js_1.getCallError;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    Object.defineProperty(exports, "getEstimateGasError", { enumerable: true, get: function() {
      return getEstimateGasError_js_1.getEstimateGasError;
    } });
    var getTransactionError_js_1 = require_getTransactionError();
    Object.defineProperty(exports, "getTransactionError", { enumerable: true, get: function() {
      return getTransactionError_js_1.getTransactionError;
    } });
    var formatter_js_1 = require_formatter();
    Object.defineProperty(exports, "defineFormatter", { enumerable: true, get: function() {
      return formatter_js_1.defineFormatter;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var prepareRequest_js_1 = require_prepareRequest();
    Object.defineProperty(exports, "prepareRequest", { enumerable: true, get: function() {
      return prepareRequest_js_1.prepareRequest;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
  }
});

// node_modules/viem/dist/cjs/utils/ens/encodedLabelToLabelhash.js
var require_encodedLabelToLabelhash = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/encodedLabelToLabelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodedLabelToLabelhash = void 0;
    var index_js_1 = require_utils2();
    function encodedLabelToLabelhash(label) {
      if (label.length !== 66)
        return null;
      if (label.indexOf("[") !== 0)
        return null;
      if (label.indexOf("]") !== 65)
        return null;
      const hash = `0x${label.slice(1, 65)}`;
      if (!(0, index_js_1.isHex)(hash))
        return null;
      return hash;
    }
    exports.encodedLabelToLabelhash = encodedLabelToLabelhash;
  }
});

// node_modules/viem/dist/cjs/utils/ens/namehash.js
var require_namehash = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/namehash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namehash = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function namehash(name) {
      let result = new Uint8Array(32).fill(0);
      if (!name)
        return (0, toHex_js_1.bytesToHex)(result);
      const labels = name.split(".");
      for (let i2 = labels.length - 1; i2 >= 0; i2 -= 1) {
        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i2]);
        const hashed = hashFromEncodedLabel ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel) : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i2]), "bytes");
        result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), "bytes");
      }
      return (0, toHex_js_1.bytesToHex)(result);
    }
    exports.namehash = namehash;
  }
});

// node_modules/viem/dist/cjs/utils/ens/encodeLabelhash.js
var require_encodeLabelhash = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/encodeLabelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeLabelhash = void 0;
    function encodeLabelhash(hash) {
      return `[${hash.slice(2)}]`;
    }
    exports.encodeLabelhash = encodeLabelhash;
  }
});

// node_modules/viem/dist/cjs/utils/ens/labelhash.js
var require_labelhash = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/labelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.labelhash = void 0;
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function labelhash(label) {
      const result = new Uint8Array(32).fill(0);
      if (!label)
        return (0, toHex_js_1.bytesToHex)(result);
      return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
    }
    exports.labelhash = labelhash;
  }
});

// node_modules/viem/dist/cjs/utils/ens/packetToBytes.js
var require_packetToBytes = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/packetToBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.packetToBytes = void 0;
    var toBytes_js_1 = require_toBytes();
    var encodeLabelhash_js_1 = require_encodeLabelhash();
    var labelhash_js_1 = require_labelhash();
    function packetToBytes(packet) {
      const value = packet.replace(/^\.|\.$/gm, "");
      if (value.length === 0)
        return new Uint8Array(1);
      const bytes = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
      let offset = 0;
      const list = value.split(".");
      for (let i2 = 0; i2 < list.length; i2++) {
        let encoded = (0, toBytes_js_1.stringToBytes)(list[i2]);
        if (encoded.byteLength > 255)
          encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i2])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
      }
      if (bytes.byteLength !== offset + 1)
        return bytes.slice(0, offset + 1);
      return bytes;
    }
    exports.packetToBytes = packetToBytes;
  }
});

// node_modules/viem/dist/cjs/actions/ens/getEnsAddress.js
var require_getEnsAddress = __commonJS({
  "node_modules/viem/dist/cjs/actions/ens/getEnsAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAddress = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const functionData = (0, encodeFunctionData_js_1.encodeFunctionData)({
          abi: abis_js_1.addressResolverAbi,
          functionName: "addr",
          ...coinType != null ? { args: [(0, namehash_js_1.namehash)(name), BigInt(coinType)] } : { args: [(0, namehash_js_1.namehash)(name)] }
        });
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)), functionData],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const address = (0, trim_js_1.trim)((0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.addressResolverAbi,
          args: coinType != null ? [(0, namehash_js_1.namehash)(name), BigInt(coinType)] : void 0,
          functionName: "addr",
          data: res[0]
        }));
        if (address === "0x")
          return null;
        if ((0, trim_js_1.trim)(address) === "0x00")
          return null;
        return address;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports.getEnsAddress = getEnsAddress;
  }
});

// node_modules/viem/dist/cjs/errors/ens.js
var require_ens = __commonJS({
  "node_modules/viem/dist/cjs/errors/ens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarInvalidMetadataError = void 0;
    var base_js_1 = require_base();
    var EnsAvatarInvalidMetadataError = class extends base_js_1.BaseError {
      constructor({ data }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: [
            "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
            "",
            `Provided data: ${JSON.stringify(data)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidMetadataError"
        });
      }
    };
    exports.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
    var EnsAvatarInvalidNftUriError = class extends base_js_1.BaseError {
      constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidNftUriError"
        });
      }
    };
    exports.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
    var EnsAvatarUriResolutionError = class extends base_js_1.BaseError {
      constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUriResolutionError"
        });
      }
    };
    exports.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
    var EnsAvatarUnsupportedNamespaceError = class extends base_js_1.BaseError {
      constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUnsupportedNamespaceError"
        });
      }
    };
    exports.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;
  }
});

// node_modules/viem/dist/cjs/utils/ens/avatar/utils.js
var require_utils3 = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/avatar/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = void 0;
    var readContract_js_1 = require_readContract();
    var ens_js_1 = require_ens();
    var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri(uri) {
      try {
        const res = await fetch(uri, { method: "HEAD" });
        if (res.status === 200) {
          const contentType = res.headers.get("content-type");
          return contentType?.startsWith("image/");
        }
        return false;
      } catch (error) {
        if (typeof error === "object" && typeof error.response !== "undefined") {
          return false;
        }
        if (!globalThis.hasOwnProperty("Image"))
          return false;
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            resolve(true);
          };
          img.onerror = () => {
            resolve(false);
          };
          img.src = uri;
        });
      }
    }
    exports.isImageUri = isImageUri;
    function getGateway(custom, defaultGateway) {
      if (!custom)
        return defaultGateway;
      if (custom.endsWith("/"))
        return custom.slice(0, -1);
      return custom;
    }
    exports.getGateway = getGateway;
    function resolveAvatarUri({ uri, gatewayUrls }) {
      const isEncoded = base64Regex.test(uri);
      if (isEncoded)
        return { uri, isOnChain: true, isEncoded };
      const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
      const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
      const networkRegexMatch = uri.match(networkRegex);
      const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
      const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
      const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
      if (uri.startsWith("http") && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave)
          replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return { uri: replacedUri, isOnChain: false, isEncoded: false };
      }
      if ((isIPNS || isIPFS) && target) {
        return {
          uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
          isOnChain: false,
          isEncoded: false
        };
      } else if (protocol === "ar:/" && target) {
        return {
          uri: `${arweaveGateway}/${target}${subtarget || ""}`,
          isOnChain: false,
          isEncoded: false
        };
      }
      let parsedUri = uri.replace(dataURIRegex, "");
      if (parsedUri.startsWith("<svg")) {
        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
      }
      if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
        return {
          uri: parsedUri,
          isOnChain: true,
          isEncoded: false
        };
      }
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.resolveAvatarUri = resolveAvatarUri;
    function getJsonImage(data) {
      if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
      }
      return data.image || data.image_url || data.image_data;
    }
    exports.getJsonImage = getJsonImage;
    async function getMetadataAvatarUri({ gatewayUrls, uri }) {
      try {
        const res = await fetch(uri).then((res2) => res2.json());
        const image = await parseAvatarUri({
          gatewayUrls,
          uri: getJsonImage(res)
        });
        return image;
      } catch {
        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
      }
    }
    exports.getMetadataAvatarUri = getMetadataAvatarUri;
    async function parseAvatarUri({ gatewayUrls, uri }) {
      const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
      if (isOnChain)
        return resolvedURI;
      const isImage = await isImageUri(resolvedURI);
      if (isImage)
        return resolvedURI;
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.parseAvatarUri = parseAvatarUri;
    function parseNftUri(uri_) {
      let uri = uri_;
      if (uri.startsWith("did:nft:")) {
        uri = uri.replace("did:nft:", "").replace(/_/g, "/");
      }
      const [reference, asset_namespace, tokenID] = uri.split("/");
      const [eip_namespace, chainID] = reference.split(":");
      const [erc_namespace, contractAddress] = asset_namespace.split(":");
      if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
      if (!chainID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
      if (!contractAddress)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({
          reason: "Contract address not found"
        });
      if (!tokenID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
      if (!erc_namespace)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
      return {
        chainID: parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress,
        tokenID
      };
    }
    exports.parseNftUri = parseNftUri;
    async function getNftTokenUri(client, { nft }) {
      if (nft.namespace === "erc721") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "tokenURI",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "tokenId", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "tokenURI",
          args: [BigInt(nft.tokenID)]
        });
      }
      if (nft.namespace === "erc1155") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "uri",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "_id", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "uri",
          args: [BigInt(nft.tokenID)]
        });
      }
      throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
    }
    exports.getNftTokenUri = getNftTokenUri;
  }
});

// node_modules/viem/dist/cjs/utils/ens/avatar/parseAvatarRecord.js
var require_parseAvatarRecord = __commonJS({
  "node_modules/viem/dist/cjs/utils/ens/avatar/parseAvatarRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAvatarRecord = void 0;
    var utils_js_1 = require_utils3();
    async function parseAvatarRecord(client, { gatewayUrls, record }) {
      if (/eip155:/i.test(record))
        return parseNftAvatarUri(client, { gatewayUrls, record });
      return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
    }
    exports.parseAvatarRecord = parseAvatarRecord;
    async function parseNftAvatarUri(client, { gatewayUrls, record }) {
      const nft = (0, utils_js_1.parseNftUri)(record);
      const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
      const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
      if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
        const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
      }
      let uriTokenId = nft.tokenID;
      if (nft.namespace === "erc1155")
        uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
      return (0, utils_js_1.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
      });
    }
  }
});

// node_modules/viem/dist/cjs/actions/ens/getEnsText.js
var require_getEnsText = __commonJS({
  "node_modules/viem/dist/cjs/actions/ens/getEnsText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsText = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [
            (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
            (0, encodeFunctionData_js_1.encodeFunctionData)({
              abi: abis_js_1.textResolverAbi,
              functionName: "text",
              args: [(0, namehash_js_1.namehash)(name), key]
            })
          ],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.textResolverAbi,
          functionName: "text",
          data: res[0]
        });
        return record === "" ? null : record;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports.getEnsText = getEnsText;
  }
});

// node_modules/viem/dist/cjs/actions/ens/getEnsAvatar.js
var require_getEnsAvatar = __commonJS({
  "node_modules/viem/dist/cjs/actions/ens/getEnsAvatar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAvatar = void 0;
    var parseAvatarRecord_js_1 = require_parseAvatarRecord();
    var getEnsText_js_1 = require_getEnsText();
    async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
      const record = await (0, getEnsText_js_1.getEnsText)(client, {
        blockNumber,
        blockTag,
        key: "avatar",
        name,
        universalResolverAddress
      });
      if (!record)
        return null;
      try {
        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, { record, gatewayUrls });
      } catch {
        return null;
      }
    }
    exports.getEnsAvatar = getEnsAvatar;
  }
});

// node_modules/viem/dist/cjs/actions/ens/getEnsName.js
var require_getEnsName = __commonJS({
  "node_modules/viem/dist/cjs/actions/ens/getEnsName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsName = void 0;
    var abis_js_1 = require_abis();
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
      try {
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverReverseAbi,
          functionName: "reverse",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(reverseNode))],
          blockNumber,
          blockTag
        });
        return res[0];
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "reverse"))
          return null;
        throw err;
      }
    }
    exports.getEnsName = getEnsName;
  }
});

// node_modules/viem/dist/cjs/actions/ens/getEnsResolver.js
var require_getEnsResolver = __commonJS({
  "node_modules/viem/dist/cjs/actions/ens/getEnsResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsResolver = void 0;
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const [resolverAddress] = await (0, readContract_js_1.readContract)(client, {
        address: universalResolverAddress,
        abi: [
          {
            inputs: [{ type: "bytes" }],
            name: "findResolver",
            outputs: [{ type: "address" }, { type: "bytes32" }],
            stateMutability: "view",
            type: "function"
          }
        ],
        functionName: "findResolver",
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
        blockNumber,
        blockTag
      });
      return resolverAddress;
    }
    exports.getEnsResolver = getEnsResolver;
  }
});

// node_modules/viem/dist/cjs/actions/public/createBlockFilter.js
var require_createBlockFilter = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/createBlockFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBlockFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createBlockFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newBlockFilter"
      });
      const id = await client.request({
        method: "eth_newBlockFilter"
      });
      return { id, request: getRequest(id), type: "block" };
    }
    exports.createBlockFilter = createBlockFilter;
  }
});

// node_modules/viem/dist/cjs/actions/public/createEventFilter.js
var require_createEventFilter = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/createEventFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
      const events = events_ ?? (event ? [event] : void 0);
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            ...topics.length ? { topics } : {}
          }
        ]
      });
      return {
        abi: events,
        args,
        eventName: event ? event.name : void 0,
        fromBlock,
        id,
        request: getRequest(id),
        strict,
        toBlock,
        type: "event"
      };
    }
    exports.createEventFilter = createEventFilter;
  }
});

// node_modules/viem/dist/cjs/actions/public/createPendingTransactionFilter.js
var require_createPendingTransactionFilter = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/createPendingTransactionFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPendingTransactionFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createPendingTransactionFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newPendingTransactionFilter"
      });
      const id = await client.request({
        method: "eth_newPendingTransactionFilter"
      });
      return { id, request: getRequest(id), type: "transaction" };
    }
    exports.createPendingTransactionFilter = createPendingTransactionFilter;
  }
});

// node_modules/viem/dist/cjs/actions/public/getBalance.js
var require_getBalance = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getBalance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const balance = await client.request({
        method: "eth_getBalance",
        params: [address, blockNumberHex || blockTag]
      });
      return BigInt(balance);
    }
    exports.getBalance = getBalance;
  }
});

// node_modules/viem/dist/cjs/actions/public/getBlockTransactionCount.js
var require_getBlockTransactionCount = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getBlockTransactionCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let count;
      if (blockHash) {
        count = await client.request({
          method: "eth_getBlockTransactionCountByHash",
          params: [blockHash]
        });
      } else {
        count = await client.request({
          method: "eth_getBlockTransactionCountByNumber",
          params: [blockNumberHex || blockTag]
        });
      }
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getBlockTransactionCount = getBlockTransactionCount;
  }
});

// node_modules/viem/dist/cjs/actions/public/getBytecode.js
var require_getBytecode = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getBytecode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBytecode = void 0;
    var toHex_js_1 = require_toHex();
    async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const hex = await client.request({
        method: "eth_getCode",
        params: [address, blockNumberHex || blockTag]
      });
      if (hex === "0x")
        return void 0;
      return hex;
    }
    exports.getBytecode = getBytecode;
  }
});

// node_modules/viem/dist/cjs/utils/formatters/feeHistory.js
var require_feeHistory = __commonJS({
  "node_modules/viem/dist/cjs/utils/formatters/feeHistory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatFeeHistory = void 0;
    function formatFeeHistory(feeHistory) {
      return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
      };
    }
    exports.formatFeeHistory = formatFeeHistory;
  }
});

// node_modules/viem/dist/cjs/actions/public/getFeeHistory.js
var require_getFeeHistory = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getFeeHistory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeeHistory = void 0;
    var toHex_js_1 = require_toHex();
    var feeHistory_js_1 = require_feeHistory();
    async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const feeHistory = await client.request({
        method: "eth_feeHistory",
        params: [
          (0, toHex_js_1.numberToHex)(blockCount),
          blockNumberHex || blockTag,
          rewardPercentiles
        ]
      });
      return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
    }
    exports.getFeeHistory = getFeeHistory;
  }
});

// node_modules/viem/dist/cjs/actions/public/getFilterLogs.js
var require_getFilterLogs = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getFilterLogs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log2();
    async function getFilterLogs(_client, { filter }) {
      const strict = filter.strict ?? false;
      const logs = await filter.request({
        method: "eth_getFilterLogs",
        params: [filter.id]
      });
      return logs.map((log) => {
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterLogs = getFilterLogs;
  }
});

// node_modules/viem/dist/cjs/actions/public/getStorageAt.js
var require_getStorageAt = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getStorageAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const data = await client.request({
        method: "eth_getStorageAt",
        params: [address, slot, blockNumberHex || blockTag]
      });
      return data;
    }
    exports.getStorageAt = getStorageAt;
  }
});

// node_modules/viem/dist/cjs/actions/public/getTransaction.js
var require_getTransaction = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransaction = void 0;
    var transaction_js_1 = require_transaction();
    var toHex_js_1 = require_toHex();
    var transaction_js_2 = require_transaction2();
    async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index }) {
      const blockTag = blockTag_ || "latest";
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let transaction = null;
      if (hash) {
        transaction = await client.request({
          method: "eth_getTransactionByHash",
          params: [hash]
        });
      } else if (blockHash) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockHashAndIndex",
          params: [blockHash, (0, toHex_js_1.numberToHex)(index)]
        });
      } else if (blockNumberHex || blockTag) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockNumberAndIndex",
          params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index)]
        });
      }
      if (!transaction)
        throw new transaction_js_1.TransactionNotFoundError({
          blockHash,
          blockNumber,
          blockTag,
          hash,
          index
        });
      const format2 = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
      return format2(transaction);
    }
    exports.getTransaction = getTransaction;
  }
});

// node_modules/viem/dist/cjs/actions/public/getTransactionConfirmations.js
var require_getTransactionConfirmations = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getTransactionConfirmations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionConfirmations = void 0;
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getTransaction_js_1 = require_getTransaction();
    async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
      const [blockNumber, transaction] = await Promise.all([
        (0, getBlockNumber_js_1.getBlockNumber)(client),
        hash ? (0, getTransaction_js_1.getTransaction)(client, { hash }) : void 0
      ]);
      const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
      if (!transactionBlockNumber)
        return 0n;
      return blockNumber - transactionBlockNumber + 1n;
    }
    exports.getTransactionConfirmations = getTransactionConfirmations;
  }
});

// node_modules/viem/dist/cjs/actions/public/getTransactionReceipt.js
var require_getTransactionReceipt = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/getTransactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction();
    var transactionReceipt_js_1 = require_transactionReceipt();
    async function getTransactionReceipt(client, { hash }) {
      const receipt = await client.request({
        method: "eth_getTransactionReceipt",
        params: [hash]
      });
      if (!receipt)
        throw new transaction_js_1.TransactionReceiptNotFoundError({ hash });
      const format2 = client.chain?.formatters?.transactionReceipt?.format || transactionReceipt_js_1.formatTransactionReceipt;
      return format2(receipt);
    }
    exports.getTransactionReceipt = getTransactionReceipt;
  }
});

// node_modules/viem/dist/cjs/actions/public/multicall.js
var require_multicall = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/multicall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicall = void 0;
    var abis_js_1 = require_abis();
    var abi_js_1 = require_abi();
    var contract_js_1 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var getContractError_js_1 = require_getContractError();
    var readContract_js_1 = require_readContract();
    async function multicall(client, args) {
      const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_ } = args;
      const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
      const contracts = contracts_;
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. multicallAddress is required.");
        multicallAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const chunkedCalls = [[]];
      let currentChunk = 0;
      let currentChunkSize = 0;
      for (let i2 = 0; i2 < contracts.length; i2++) {
        const { abi, address, args: args2, functionName } = contracts[i2];
        try {
          const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi,
            args: args2,
            functionName
          });
          currentChunkSize += callData.length;
          if (batchSize > 0 && currentChunkSize > batchSize) {
            currentChunk++;
            currentChunkSize = (callData.length - 2) / 2;
            chunkedCalls[currentChunk] = [];
          }
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData,
              target: address
            }
          ];
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args: args2,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData: "0x",
              target: address
            }
          ];
        }
      }
      const results = await Promise.all(chunkedCalls.map((calls) => (0, readContract_js_1.readContract)(client, {
        abi: abis_js_1.multicall3Abi,
        address: multicallAddress,
        args: [calls],
        blockNumber,
        blockTag,
        functionName: "aggregate3"
      })));
      return results.flat().map(({ returnData, success }, i2) => {
        const calls = chunkedCalls.flat();
        const { callData } = calls[i2];
        const { abi, address, functionName, args: args2 } = contracts[i2];
        try {
          if (callData === "0x")
            throw new abi_js_1.AbiDecodingZeroDataError();
          if (!success)
            throw new contract_js_1.RawContractError({ data: returnData });
          const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi,
            args: args2,
            data: returnData,
            functionName
          });
          return allowFailure ? { result, status: "success" } : result;
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args: args2,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          return { error, result: void 0, status: "failure" };
        }
      });
    }
    exports.multicall = multicall;
  }
});

// node_modules/viem/dist/cjs/constants/contracts.js
var require_contracts2 = __commonJS({
  "node_modules/viem/dist/cjs/constants/contracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.universalSignatureValidatorByteCode = void 0;
    exports.universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils4 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a = (a3) => a3 instanceof Uint8Array;
    var hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex += hexes[bytes[i2]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j = i2 * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e2) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e2}`);
        }
      } else if (u8a(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
      let pad = 0;
      arrays.forEach((a3) => {
        if (!u8a(a3))
          throw new Error("Uint8Array expected");
        r.set(a3, pad);
        pad += a3.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i2 = 0; i2 < b1.length; i2++)
        if (b1[i2] !== b2[i2])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k2 = u8n(hashLen);
      let i2 = 0;
      const reset = () => {
        v.fill(1);
        k2.fill(0);
        i2 = 0;
      };
      const h3 = (...b2) => hmacFn(k2, v, ...b2);
      const reseed = (seed = u8n()) => {
        k2 = h3(u8fr([0]), seed);
        v = h3();
        if (seed.length === 0)
          return;
        k2 = h3(u8fr([1]), seed);
        v = h3();
      };
      const gen = () => {
        if (i2++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h3();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/viem/dist/cjs/utils/data/isBytesEqual.js
var require_isBytesEqual = __commonJS({
  "node_modules/viem/dist/cjs/utils/data/isBytesEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytesEqual = void 0;
    var index_js_1 = require_cjs2();
    var utils_1 = require_utils4();
    function isBytesEqual(a_, b_) {
      const a3 = (0, index_js_1.isHex)(a_) ? (0, index_js_1.toBytes)(a_) : a_;
      const b2 = (0, index_js_1.isHex)(b_) ? (0, index_js_1.toBytes)(b_) : b_;
      return (0, utils_1.equalBytes)(a3, b2);
    }
    exports.isBytesEqual = isBytesEqual;
  }
});

// node_modules/viem/dist/cjs/actions/public/verifyHash.js
var require_verifyHash = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/verifyHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyHash = void 0;
    var abis_js_1 = require_abis();
    var contracts_js_1 = require_contracts2();
    var contract_js_1 = require_contract();
    var isBytesEqual_js_1 = require_isBytesEqual();
    var index_js_1 = require_utils2();
    var call_js_1 = require_call();
    async function verifyHash(client, { address, hash, signature, ...callRequest }) {
      const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);
      try {
        const { data } = await (0, call_js_1.call)(client, {
          data: (0, index_js_1.encodeDeployData)({
            abi: abis_js_1.universalSignatureValidatorAbi,
            args: [address, hash, signatureHex],
            bytecode: contracts_js_1.universalSignatureValidatorByteCode
          }),
          ...callRequest
        });
        return (0, isBytesEqual_js_1.isBytesEqual)(data ?? "0x0", "0x1");
      } catch (error) {
        if (error instanceof contract_js_1.CallExecutionError) {
          return false;
        }
        throw error;
      }
    }
    exports.verifyHash = verifyHash;
  }
});

// node_modules/viem/dist/cjs/actions/public/verifyMessage.js
var require_verifyMessage2 = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/verifyMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var index_js_1 = require_utils2();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyMessage(client, { address, message, signature, ...callRequest }) {
      const hash = (0, index_js_1.hashMessage)(message);
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports.verifyMessage = verifyMessage;
  }
});

// node_modules/viem/dist/cjs/actions/public/verifyTypedData.js
var require_verifyTypedData2 = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/verifyTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
      const hash = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports.verifyTypedData = verifyTypedData;
  }
});

// node_modules/viem/dist/cjs/actions/public/watchBlockNumber.js
var require_watchBlockNumber = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/watchBlockNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlockNumber = void 0;
    var fromHex_js_1 = require_fromHex();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlockNumber_js_1 = require_getBlockNumber();
    function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      let prevBlockNumber;
      const pollBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlockNumber",
          client.uid,
          emitOnBegin,
          emitMissed,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client, { cacheTime: 0 });
            if (prevBlockNumber) {
              if (blockNumber === prevBlockNumber)
                return;
              if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                for (let i2 = prevBlockNumber + 1n; i2 < blockNumber; i2++) {
                  emit.onBlockNumber(i2, prevBlockNumber);
                  prevBlockNumber = i2;
                }
              }
            }
            if (!prevBlockNumber || blockNumber > prevBlockNumber) {
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlockNumber = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
    }
    exports.watchBlockNumber = watchBlockNumber;
  }
});

// node_modules/viem/dist/cjs/actions/public/waitForTransactionReceipt.js
var require_waitForTransactionReceipt = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/waitForTransactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.waitForTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction();
    var observe_js_1 = require_observe();
    var withRetry_js_1 = require_withRetry();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
      const observerId = (0, stringify_js_1.stringify)(["waitForTransactionReceipt", client.uid, hash]);
      let transaction;
      let replacedTransaction;
      let receipt;
      let retrying = false;
      return new Promise((resolve, reject) => {
        if (timeout)
          setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash })), timeout);
        const _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
          const _unwatch = (0, watchBlockNumber_js_1.watchBlockNumber)(client, {
            emitMissed: true,
            emitOnBegin: true,
            poll: true,
            pollingInterval,
            async onBlockNumber(blockNumber_) {
              if (retrying)
                return;
              let blockNumber = blockNumber_;
              const done = (fn) => {
                _unwatch();
                fn();
                _unobserve();
              };
              try {
                if (receipt) {
                  if (blockNumber - receipt.blockNumber + 1n < confirmations)
                    return;
                  done(() => emit.resolve(receipt));
                  return;
                }
                if (!transaction) {
                  retrying = true;
                  await (0, withRetry_js_1.withRetry)(async () => {
                    transaction = await (0, getTransaction_js_1.getTransaction)(client, { hash });
                    if (transaction.blockNumber)
                      blockNumber = transaction.blockNumber;
                  }, {
                    delay: ({ count }) => ~~(1 << count) * 200,
                    retryCount: 6
                  });
                  retrying = false;
                }
                receipt = await (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, { hash });
                if (confirmations > 0 && blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                done(() => emit.resolve(receipt));
              } catch (err) {
                if (transaction && (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {
                  replacedTransaction = transaction;
                  const block = await (0, getBlock_js_1.getBlock)(client, {
                    blockNumber,
                    includeTransactions: true
                  });
                  const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                  if (!replacementTransaction)
                    return;
                  receipt = await (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, {
                    hash: replacementTransaction.hash
                  });
                  if (blockNumber - receipt.blockNumber + 1n < confirmations)
                    return;
                  let reason = "replaced";
                  if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                    reason = "repriced";
                  } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                    reason = "cancelled";
                  }
                  done(() => {
                    emit.onReplaced?.({
                      reason,
                      replacedTransaction,
                      transaction: replacementTransaction,
                      transactionReceipt: receipt
                    });
                    emit.resolve(receipt);
                  });
                } else {
                  done(() => emit.reject(err));
                }
              }
            }
          });
        });
      });
    }
    exports.waitForTransactionReceipt = waitForTransactionReceipt;
  }
});

// node_modules/viem/dist/cjs/actions/public/watchBlocks.js
var require_watchBlocks = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/watchBlocks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlocks = void 0;
    var block_js_1 = require_block2();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const includeTransactions = includeTransactions_ ?? false;
      let prevBlock;
      const pollBlocks = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlocks",
          client.uid,
          emitMissed,
          emitOnBegin,
          includeTransactions,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const block = await (0, getBlock_js_1.getBlock)(client, {
              blockTag,
              includeTransactions
            });
            if (block.number && prevBlock?.number) {
              if (block.number === prevBlock.number)
                return;
              if (block.number - prevBlock.number > 1 && emitMissed) {
                for (let i2 = prevBlock?.number + 1n; i2 < block.number; i2++) {
                  const block2 = await (0, getBlock_js_1.getBlock)(client, {
                    blockNumber: i2,
                    includeTransactions
                  });
                  emit.onBlock(block2, prevBlock);
                  prevBlock = block2;
                }
              }
            }
            if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
              emit.onBlock(block, prevBlock);
              prevBlock = block;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlocks = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const format2 = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
                const block = format2(data.result);
                onBlock(block, prevBlock);
                prevBlock = block;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlocks() : subscribeBlocks();
    }
    exports.watchBlocks = watchBlocks;
  }
});

// node_modules/viem/dist/cjs/actions/public/watchEvent.js
var require_watchEvent = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/watchEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchEvent = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var abi_js_1 = require_abi();
    var rpc_js_1 = require_rpc();
    var index_js_1 = require_utils2();
    var createEventFilter_js_1 = require_createEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchEvent(client, { address, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const strict = strict_ ?? false;
      const pollEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchEvent",
          address,
          args,
          batch,
          client.uid,
          event,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, createEventFilter_js_1.createEventFilter)(client, {
                  address,
                  args,
                  event,
                  events,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
              } else {
                const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client);
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getLogs_js_1.getLogs)(client, {
                    address,
                    args,
                    event,
                    events,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                logs.forEach((log) => emit.onLogs([log]));
            } catch (err) {
              if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
            unwatch();
          };
        });
      };
      const subscribeEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const events_ = events ?? (event ? [event] : void 0);
            let topics = [];
            if (events_) {
              topics = [
                events_.flatMap((event2) => (0, index_js_1.encodeEventTopics)({
                  abi: [event2],
                  eventName: event2.name,
                  args
                }))
              ];
              if (event)
                topics = topics[0];
            }
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName, args: args2 } = (0, index_js_1.decodeEventLog)({
                    abi: events_,
                    data: log.data,
                    topics: log.topics,
                    strict
                  });
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: args2,
                    eventName
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x2) => !("name" in x2 && x2.name));
                  }
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollEvent() : subscribeEvent();
    }
    exports.watchEvent = watchEvent;
  }
});

// node_modules/viem/dist/cjs/actions/public/watchPendingTransactions.js
var require_watchPendingTransactions = __commonJS({
  "node_modules/viem/dist/cjs/actions/public/watchPendingTransactions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchPendingTransactions = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollPendingTransactions = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchPendingTransactions",
          client.uid,
          batch,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
          let filter;
          const unwatch = (0, poll_js_1.poll)(async () => {
            try {
              if (!filter) {
                try {
                  filter = await (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client);
                  return;
                } catch (err) {
                  unwatch();
                  throw err;
                }
              }
              const hashes = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
              if (hashes.length === 0)
                return;
              if (batch)
                emit.onTransactions(hashes);
              else
                hashes.forEach((hash) => emit.onTransactions([hash]));
            } catch (err) {
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
            unwatch();
          };
        });
      };
      const subscribePendingTransactions = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newPendingTransactions"],
              onData(data) {
                if (!active)
                  return;
                const transaction = data.result;
                onTransactions([transaction]);
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
    }
    exports.watchPendingTransactions = watchPendingTransactions;
  }
});

// node_modules/viem/dist/cjs/clients/decorators/public.js
var require_public = __commonJS({
  "node_modules/viem/dist/cjs/clients/decorators/public.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicActions = void 0;
    var getEnsAddress_js_1 = require_getEnsAddress();
    var getEnsAvatar_js_1 = require_getEnsAvatar();
    var getEnsName_js_1 = require_getEnsName();
    var getEnsResolver_js_1 = require_getEnsResolver();
    var getEnsText_js_1 = require_getEnsText();
    var call_js_1 = require_call();
    var createBlockFilter_js_1 = require_createBlockFilter();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var createEventFilter_js_1 = require_createEventFilter();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var estimateGas_js_1 = require_estimateGas2();
    var getBalance_js_1 = require_getBalance();
    var getBlock_js_1 = require_getBlock();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getBlockTransactionCount_js_1 = require_getBlockTransactionCount();
    var getBytecode_js_1 = require_getBytecode();
    var getChainId_js_1 = require_getChainId();
    var getFeeHistory_js_1 = require_getFeeHistory();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getFilterLogs_js_1 = require_getFilterLogs();
    var getGasPrice_js_1 = require_getGasPrice();
    var getLogs_js_1 = require_getLogs();
    var getStorageAt_js_1 = require_getStorageAt();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionConfirmations_js_1 = require_getTransactionConfirmations();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var multicall_js_1 = require_multicall();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var uninstallFilter_js_1 = require_uninstallFilter();
    var verifyMessage_js_1 = require_verifyMessage2();
    var verifyTypedData_js_1 = require_verifyTypedData2();
    var waitForTransactionReceipt_js_1 = require_waitForTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    var watchBlocks_js_1 = require_watchBlocks();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var watchEvent_js_1 = require_watchEvent();
    var watchPendingTransactions_js_1 = require_watchPendingTransactions();
    function publicActions(client) {
      return {
        call: (args) => (0, call_js_1.call)(client, args),
        createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
        createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
        createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
        createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
        estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
        estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
        getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
        getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
        getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
        getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
        getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client, args),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
        getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
        getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
        getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
        getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
        getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
        getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
        getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
        getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
        getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
        getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
        getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
        getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
        getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
        getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
        multicall: (args) => (0, multicall_js_1.multicall)(client, args),
        readContract: (args) => (0, readContract_js_1.readContract)(client, args),
        simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
        verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
        verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
        uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
        watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
        watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
        watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
        watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
        watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args)
      };
    }
    exports.publicActions = publicActions;
  }
});

// node_modules/viem/dist/cjs/clients/createPublicClient.js
var require_createPublicClient = __commonJS({
  "node_modules/viem/dist/cjs/clients/createPublicClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPublicClient = void 0;
    var createClient_js_1 = require_createClient();
    var public_js_1 = require_public();
    function createPublicClient(parameters) {
      const { key = "public", name = "Public Client" } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "publicClient"
      });
      return client.extend(public_js_1.publicActions);
    }
    exports.createPublicClient = createPublicClient;
  }
});

// node_modules/viem/dist/cjs/actions/test/dropTransaction.js
var require_dropTransaction = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/dropTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropTransaction = void 0;
    async function dropTransaction(client, { hash }) {
      await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [hash]
      });
    }
    exports.dropTransaction = dropTransaction;
  }
});

// node_modules/viem/dist/cjs/actions/test/getAutomine.js
var require_getAutomine = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/getAutomine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAutomine = void 0;
    async function getAutomine(client) {
      if (client.mode === "ganache")
        return await client.request({
          method: "eth_mining"
        });
      return await client.request({
        method: `${client.mode}_getAutomine`
      });
    }
    exports.getAutomine = getAutomine;
  }
});

// node_modules/viem/dist/cjs/actions/test/getTxpoolContent.js
var require_getTxpoolContent = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/getTxpoolContent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolContent = void 0;
    async function getTxpoolContent(client) {
      return await client.request({
        method: "txpool_content"
      });
    }
    exports.getTxpoolContent = getTxpoolContent;
  }
});

// node_modules/viem/dist/cjs/actions/test/getTxpoolStatus.js
var require_getTxpoolStatus = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/getTxpoolStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolStatus = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getTxpoolStatus(client) {
      const { pending, queued } = await client.request({
        method: "txpool_status"
      });
      return {
        pending: (0, fromHex_js_1.hexToNumber)(pending),
        queued: (0, fromHex_js_1.hexToNumber)(queued)
      };
    }
    exports.getTxpoolStatus = getTxpoolStatus;
  }
});

// node_modules/viem/dist/cjs/actions/test/impersonateAccount.js
var require_impersonateAccount = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/impersonateAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.impersonateAccount = void 0;
    async function impersonateAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [address]
      });
    }
    exports.impersonateAccount = impersonateAccount;
  }
});

// node_modules/viem/dist/cjs/actions/test/increaseTime.js
var require_increaseTime = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/increaseTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.increaseTime = void 0;
    var toHex_js_1 = require_toHex();
    async function increaseTime(client, { seconds }) {
      return await client.request({
        method: "evm_increaseTime",
        params: [(0, toHex_js_1.numberToHex)(seconds)]
      });
    }
    exports.increaseTime = increaseTime;
  }
});

// node_modules/viem/dist/cjs/actions/test/inspectTxpool.js
var require_inspectTxpool = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/inspectTxpool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inspectTxpool = void 0;
    async function inspectTxpool(client) {
      return await client.request({
        method: "txpool_inspect"
      });
    }
    exports.inspectTxpool = inspectTxpool;
  }
});

// node_modules/viem/dist/cjs/actions/test/mine.js
var require_mine = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/mine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mine = void 0;
    var toHex_js_1 = require_toHex();
    async function mine(client, { blocks, interval }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_mine",
          params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }]
        });
      else
        await client.request({
          method: `${client.mode}_mine`,
          params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)]
        });
    }
    exports.mine = mine;
  }
});

// node_modules/viem/dist/cjs/actions/test/removeBlockTimestampInterval.js
var require_removeBlockTimestampInterval = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/removeBlockTimestampInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeBlockTimestampInterval = void 0;
    async function removeBlockTimestampInterval(client) {
      await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`
      });
    }
    exports.removeBlockTimestampInterval = removeBlockTimestampInterval;
  }
});

// node_modules/viem/dist/cjs/actions/test/reset.js
var require_reset = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/reset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reset = void 0;
    async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
      await client.request({
        method: `${client.mode}_reset`,
        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
      });
    }
    exports.reset = reset;
  }
});

// node_modules/viem/dist/cjs/actions/test/revert.js
var require_revert = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/revert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.revert = void 0;
    async function revert(client, { id }) {
      await client.request({
        method: "evm_revert",
        params: [id]
      });
    }
    exports.revert = revert;
  }
});

// node_modules/viem/dist/cjs/actions/test/sendUnsignedTransaction.js
var require_sendUnsignedTransaction = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/sendUnsignedTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendUnsignedTransaction = void 0;
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    async function sendUnsignedTransaction(client, args) {
      const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const format2 = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
      const request = format2({
        ...(0, extract_js_1.extract)(rest, { format: format2 }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const hash = await client.request({
        method: "eth_sendUnsignedTransaction",
        params: [request]
      });
      return hash;
    }
    exports.sendUnsignedTransaction = sendUnsignedTransaction;
  }
});

// node_modules/viem/dist/cjs/actions/test/setAutomine.js
var require_setAutomine = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setAutomine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAutomine = void 0;
    async function setAutomine(client, enabled) {
      if (client.mode === "ganache") {
        if (enabled)
          await client.request({ method: "miner_start" });
        else
          await client.request({ method: "miner_stop" });
      } else
        await client.request({
          method: "evm_setAutomine",
          params: [enabled]
        });
    }
    exports.setAutomine = setAutomine;
  }
});

// node_modules/viem/dist/cjs/actions/test/setBalance.js
var require_setBalance = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setBalance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function setBalance(client, { address, value }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_setAccountBalance",
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
      else
        await client.request({
          method: `${client.mode}_setBalance`,
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
    }
    exports.setBalance = setBalance;
  }
});

// node_modules/viem/dist/cjs/actions/test/setBlockGasLimit.js
var require_setBlockGasLimit = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setBlockGasLimit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockGasLimit = void 0;
    var toHex_js_1 = require_toHex();
    async function setBlockGasLimit(client, { gasLimit }) {
      await client.request({
        method: "evm_setBlockGasLimit",
        params: [(0, toHex_js_1.numberToHex)(gasLimit)]
      });
    }
    exports.setBlockGasLimit = setBlockGasLimit;
  }
});

// node_modules/viem/dist/cjs/actions/test/setBlockTimestampInterval.js
var require_setBlockTimestampInterval = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setBlockTimestampInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockTimestampInterval = void 0;
    async function setBlockTimestampInterval(client, { interval }) {
      await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [interval]
      });
    }
    exports.setBlockTimestampInterval = setBlockTimestampInterval;
  }
});

// node_modules/viem/dist/cjs/actions/test/setCode.js
var require_setCode = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setCode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCode = void 0;
    async function setCode(client, { address, bytecode }) {
      await client.request({
        method: `${client.mode}_setCode`,
        params: [address, bytecode]
      });
    }
    exports.setCode = setCode;
  }
});

// node_modules/viem/dist/cjs/actions/test/setCoinbase.js
var require_setCoinbase = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setCoinbase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCoinbase = void 0;
    async function setCoinbase(client, { address }) {
      await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [address]
      });
    }
    exports.setCoinbase = setCoinbase;
  }
});

// node_modules/viem/dist/cjs/actions/test/setIntervalMining.js
var require_setIntervalMining = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setIntervalMining.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setIntervalMining = void 0;
    async function setIntervalMining(client, { interval }) {
      await client.request({
        method: "evm_setIntervalMining",
        params: [interval]
      });
    }
    exports.setIntervalMining = setIntervalMining;
  }
});

// node_modules/viem/dist/cjs/actions/test/setLoggingEnabled.js
var require_setLoggingEnabled = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setLoggingEnabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setLoggingEnabled = void 0;
    async function setLoggingEnabled(client, enabled) {
      await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [enabled]
      });
    }
    exports.setLoggingEnabled = setLoggingEnabled;
  }
});

// node_modules/viem/dist/cjs/actions/test/setMinGasPrice.js
var require_setMinGasPrice = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setMinGasPrice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setMinGasPrice = void 0;
    var toHex_js_1 = require_toHex();
    async function setMinGasPrice(client, { gasPrice }) {
      await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [(0, toHex_js_1.numberToHex)(gasPrice)]
      });
    }
    exports.setMinGasPrice = setMinGasPrice;
  }
});

// node_modules/viem/dist/cjs/actions/test/setNextBlockBaseFeePerGas.js
var require_setNextBlockBaseFeePerGas = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setNextBlockBaseFeePerGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockBaseFeePerGas = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
      await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)]
      });
    }
    exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
  }
});

// node_modules/viem/dist/cjs/actions/test/setNextBlockTimestamp.js
var require_setNextBlockTimestamp = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setNextBlockTimestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockTimestamp = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockTimestamp(client, { timestamp }) {
      await client.request({
        method: "evm_setNextBlockTimestamp",
        params: [(0, toHex_js_1.numberToHex)(timestamp)]
      });
    }
    exports.setNextBlockTimestamp = setNextBlockTimestamp;
  }
});

// node_modules/viem/dist/cjs/actions/test/setNonce.js
var require_setNonce = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setNonce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNonce = void 0;
    var toHex_js_1 = require_toHex();
    async function setNonce(client, { address, nonce }) {
      await client.request({
        method: `${client.mode}_setNonce`,
        params: [address, (0, toHex_js_1.numberToHex)(nonce)]
      });
    }
    exports.setNonce = setNonce;
  }
});

// node_modules/viem/dist/cjs/actions/test/setRpcUrl.js
var require_setRpcUrl = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setRpcUrl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setRpcUrl = void 0;
    async function setRpcUrl(client, jsonRpcUrl) {
      await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [jsonRpcUrl]
      });
    }
    exports.setRpcUrl = setRpcUrl;
  }
});

// node_modules/viem/dist/cjs/actions/test/setStorageAt.js
var require_setStorageAt = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/setStorageAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function setStorageAt(client, { address, index, value }) {
      await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
          address,
          typeof index === "number" ? (0, toHex_js_1.numberToHex)(index) : index,
          value
        ]
      });
    }
    exports.setStorageAt = setStorageAt;
  }
});

// node_modules/viem/dist/cjs/actions/test/snapshot.js
var require_snapshot = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/snapshot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.snapshot = void 0;
    async function snapshot(client) {
      return await client.request({
        method: "evm_snapshot"
      });
    }
    exports.snapshot = snapshot;
  }
});

// node_modules/viem/dist/cjs/actions/test/stopImpersonatingAccount.js
var require_stopImpersonatingAccount = __commonJS({
  "node_modules/viem/dist/cjs/actions/test/stopImpersonatingAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stopImpersonatingAccount = void 0;
    async function stopImpersonatingAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [address]
      });
    }
    exports.stopImpersonatingAccount = stopImpersonatingAccount;
  }
});

// node_modules/viem/dist/cjs/clients/decorators/test.js
var require_test = __commonJS({
  "node_modules/viem/dist/cjs/clients/decorators/test.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testActions = void 0;
    var dropTransaction_js_1 = require_dropTransaction();
    var getAutomine_js_1 = require_getAutomine();
    var getTxpoolContent_js_1 = require_getTxpoolContent();
    var getTxpoolStatus_js_1 = require_getTxpoolStatus();
    var impersonateAccount_js_1 = require_impersonateAccount();
    var increaseTime_js_1 = require_increaseTime();
    var inspectTxpool_js_1 = require_inspectTxpool();
    var mine_js_1 = require_mine();
    var removeBlockTimestampInterval_js_1 = require_removeBlockTimestampInterval();
    var reset_js_1 = require_reset();
    var revert_js_1 = require_revert();
    var sendUnsignedTransaction_js_1 = require_sendUnsignedTransaction();
    var setAutomine_js_1 = require_setAutomine();
    var setBalance_js_1 = require_setBalance();
    var setBlockGasLimit_js_1 = require_setBlockGasLimit();
    var setBlockTimestampInterval_js_1 = require_setBlockTimestampInterval();
    var setCode_js_1 = require_setCode();
    var setCoinbase_js_1 = require_setCoinbase();
    var setIntervalMining_js_1 = require_setIntervalMining();
    var setLoggingEnabled_js_1 = require_setLoggingEnabled();
    var setMinGasPrice_js_1 = require_setMinGasPrice();
    var setNextBlockBaseFeePerGas_js_1 = require_setNextBlockBaseFeePerGas();
    var setNextBlockTimestamp_js_1 = require_setNextBlockTimestamp();
    var setNonce_js_1 = require_setNonce();
    var setRpcUrl_js_1 = require_setRpcUrl();
    var setStorageAt_js_1 = require_setStorageAt();
    var snapshot_js_1 = require_snapshot();
    var stopImpersonatingAccount_js_1 = require_stopImpersonatingAccount();
    function testActions({ mode }) {
      return (client_) => {
        const client = client_.extend(() => ({
          mode
        }));
        return {
          dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
          getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
          getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
          getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
          impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
          increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
          inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
          mine: (args) => (0, mine_js_1.mine)(client, args),
          removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
          reset: (args) => (0, reset_js_1.reset)(client, args),
          revert: (args) => (0, revert_js_1.revert)(client, args),
          sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
          setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
          setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
          setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
          setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
          setCode: (args) => (0, setCode_js_1.setCode)(client, args),
          setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
          setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
          setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
          setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
          setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
          setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
          setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
          setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
          setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
          snapshot: () => (0, snapshot_js_1.snapshot)(client),
          stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args)
        };
      };
    }
    exports.testActions = testActions;
  }
});

// node_modules/viem/dist/cjs/clients/createTestClient.js
var require_createTestClient = __commonJS({
  "node_modules/viem/dist/cjs/clients/createTestClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTestClient = void 0;
    var createClient_js_1 = require_createClient();
    var test_js_1 = require_test();
    function createTestClient(parameters) {
      const { key = "test", name = "Test Client", mode } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "testClient"
      });
      return client.extend((config) => ({
        mode,
        ...(0, test_js_1.testActions)({ mode })(config)
      }));
    }
    exports.createTestClient = createTestClient;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/addChain.js
var require_addChain = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/addChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addChain = void 0;
    var toHex_js_1 = require_toHex();
    async function addChain(client, { chain }) {
      const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
      await client.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id),
            chainName: name,
            nativeCurrency,
            rpcUrls: rpcUrls.default.http,
            blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
          }
        ]
      });
    }
    exports.addChain = addChain;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/deployContract.js
var require_deployContract = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/deployContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deployContract = void 0;
    var encodeDeployData_js_1 = require_encodeDeployData();
    var sendTransaction_js_1 = require_sendTransaction();
    function deployContract(walletClient, { abi, args, bytecode, ...request }) {
      const calldata = (0, encodeDeployData_js_1.encodeDeployData)({
        abi,
        args,
        bytecode
      });
      return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
        ...request,
        data: calldata
      });
    }
    exports.deployContract = deployContract;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/getAddresses.js
var require_getAddresses = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/getAddresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function getAddresses(client) {
      const addresses = await client.request({ method: "eth_accounts" });
      return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
    }
    exports.getAddresses = getAddresses;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/getPermissions.js
var require_getPermissions = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/getPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPermissions = void 0;
    async function getPermissions(client) {
      const permissions = await client.request({ method: "wallet_getPermissions" });
      return permissions;
    }
    exports.getPermissions = getPermissions;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/requestAddresses.js
var require_requestAddresses = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/requestAddresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function requestAddresses(client) {
      const addresses = await client.request({ method: "eth_requestAccounts" });
      return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
    }
    exports.requestAddresses = requestAddresses;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/requestPermissions.js
var require_requestPermissions = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/requestPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestPermissions = void 0;
    async function requestPermissions(client, permissions) {
      return client.request({
        method: "wallet_requestPermissions",
        params: [permissions]
      });
    }
    exports.requestPermissions = requestPermissions;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/signMessage.js
var require_signMessage = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/signMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signMessage = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    async function signMessage(client, { account: account_ = client.account, message }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signMessage"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      if (account.type === "local")
        return account.signMessage({ message });
      const message_ = (() => {
        if (typeof message === "string")
          return (0, toHex_js_1.stringToHex)(message);
        if (message.raw instanceof Uint8Array)
          return (0, toHex_js_1.toHex)(message.raw);
        return message.raw;
      })();
      return client.request({
        method: "personal_sign",
        params: [message_, account.address]
      });
    }
    exports.signMessage = signMessage;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/signTypedData.js
var require_signTypedData = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/signTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signTypedData = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify();
    var typedData_js_1 = require_typedData();
    async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTypedData"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const types = {
        EIP712Domain: [
          typeof domain?.name === "string" && { name: "name", type: "string" },
          domain?.version && { name: "version", type: "string" },
          typeof domain?.chainId === "number" && {
            name: "chainId",
            type: "uint256"
          },
          domain?.verifyingContract && {
            name: "verifyingContract",
            type: "address"
          },
          domain?.salt && { name: "salt", type: "bytes32" }
        ].filter(Boolean),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      if (account.type === "local")
        return account.signTypedData({
          domain,
          primaryType,
          types,
          message
        });
      const typedData = (0, stringify_js_1.stringify)({ domain: domain ?? {}, primaryType, types, message }, (_, value) => (0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value);
      return client.request({
        method: "eth_signTypedData_v4",
        params: [account.address, typedData]
      });
    }
    exports.signTypedData = signTypedData;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/switchChain.js
var require_switchChain = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/switchChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchChain = void 0;
    var toHex_js_1 = require_toHex();
    async function switchChain(client, { id }) {
      await client.request({
        method: "wallet_switchEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id)
          }
        ]
      });
    }
    exports.switchChain = switchChain;
  }
});

// node_modules/viem/dist/cjs/actions/wallet/watchAsset.js
var require_watchAsset = __commonJS({
  "node_modules/viem/dist/cjs/actions/wallet/watchAsset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchAsset = void 0;
    async function watchAsset(client, params) {
      const added = await client.request({
        method: "wallet_watchAsset",
        params
      });
      return added;
    }
    exports.watchAsset = watchAsset;
  }
});

// node_modules/viem/dist/cjs/clients/decorators/wallet.js
var require_wallet = __commonJS({
  "node_modules/viem/dist/cjs/clients/decorators/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletActions = void 0;
    var getChainId_js_1 = require_getChainId();
    var addChain_js_1 = require_addChain();
    var deployContract_js_1 = require_deployContract();
    var getAddresses_js_1 = require_getAddresses();
    var getPermissions_js_1 = require_getPermissions();
    var requestAddresses_js_1 = require_requestAddresses();
    var requestPermissions_js_1 = require_requestPermissions();
    var sendTransaction_js_1 = require_sendTransaction();
    var signMessage_js_1 = require_signMessage();
    var signTypedData_js_1 = require_signTypedData();
    var switchChain_js_1 = require_switchChain();
    var watchAsset_js_1 = require_watchAsset();
    var writeContract_js_1 = require_writeContract();
    function walletActions(client) {
      return {
        addChain: (args) => (0, addChain_js_1.addChain)(client, args),
        deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
        getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
        requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
        requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
        sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
        signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
        signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
        switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
        watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
        writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args)
      };
    }
    exports.walletActions = walletActions;
  }
});

// node_modules/viem/dist/cjs/clients/createWalletClient.js
var require_createWalletClient = __commonJS({
  "node_modules/viem/dist/cjs/clients/createWalletClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletClient = void 0;
    var createClient_js_1 = require_createClient();
    var wallet_js_1 = require_wallet();
    function createWalletClient(parameters) {
      const { key = "wallet", name = "Wallet Client", transport } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: "walletClient"
      });
      return client.extend(wallet_js_1.walletActions);
    }
    exports.createWalletClient = createWalletClient;
  }
});

// node_modules/viem/dist/cjs/clients/transports/webSocket.js
var require_webSocket = __commonJS({
  "node_modules/viem/dist/cjs/clients/transports/webSocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.webSocket = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function webSocket(url, config = {}) {
      const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { error, result } = await rpc_js_1.rpc.webSocketAsync(socket, {
              body,
              timeout
            });
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "webSocket"
        }, {
          getSocket() {
            return (0, rpc_js_1.getSocket)(url_);
          },
          async subscribe({ params, onData, onError }) {
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { result: subscriptionId } = await new Promise((resolve, reject) => rpc_js_1.rpc.webSocket(socket, {
              body: {
                method: "eth_subscribe",
                params
              },
              onResponse(response) {
                if (response.error) {
                  reject(response.error);
                  onError?.(response.error);
                  return;
                }
                if (typeof response.id === "number") {
                  resolve(response);
                  return;
                }
                if (response.method !== "eth_subscription")
                  return;
                onData(response.params);
              }
            }));
            return {
              subscriptionId,
              async unsubscribe() {
                return new Promise((resolve) => rpc_js_1.rpc.webSocket(socket, {
                  body: {
                    method: "eth_unsubscribe",
                    params: [subscriptionId]
                  },
                  onResponse: resolve
                }));
              }
            };
          }
        });
      };
    }
    exports.webSocket = webSocket;
  }
});

// node_modules/viem/dist/cjs/constants/address.js
var require_address2 = __commonJS({
  "node_modules/viem/dist/cjs/constants/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroAddress = void 0;
    exports.zeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/viem/dist/cjs/constants/number.js
var require_number = __commonJS({
  "node_modules/viem/dist/cjs/constants/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = void 0;
    exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = void 0;
    exports.maxInt8 = 2n ** (8n - 1n);
    exports.maxInt16 = 2n ** (16n - 1n);
    exports.maxInt24 = 2n ** (24n - 1n);
    exports.maxInt32 = 2n ** (32n - 1n);
    exports.maxInt40 = 2n ** (40n - 1n);
    exports.maxInt48 = 2n ** (48n - 1n);
    exports.maxInt56 = 2n ** (56n - 1n);
    exports.maxInt64 = 2n ** (64n - 1n);
    exports.maxInt72 = 2n ** (72n - 1n);
    exports.maxInt80 = 2n ** (80n - 1n);
    exports.maxInt88 = 2n ** (88n - 1n);
    exports.maxInt96 = 2n ** (96n - 1n);
    exports.maxInt104 = 2n ** (104n - 1n);
    exports.maxInt112 = 2n ** (112n - 1n);
    exports.maxInt120 = 2n ** (120n - 1n);
    exports.maxInt128 = 2n ** (128n - 1n);
    exports.maxInt136 = 2n ** (136n - 1n);
    exports.maxInt144 = 2n ** (144n - 1n);
    exports.maxInt152 = 2n ** (152n - 1n);
    exports.maxInt160 = 2n ** (160n - 1n);
    exports.maxInt168 = 2n ** (168n - 1n);
    exports.maxInt176 = 2n ** (176n - 1n);
    exports.maxInt184 = 2n ** (184n - 1n);
    exports.maxInt192 = 2n ** (192n - 1n);
    exports.maxInt200 = 2n ** (200n - 1n);
    exports.maxInt208 = 2n ** (208n - 1n);
    exports.maxInt216 = 2n ** (216n - 1n);
    exports.maxInt224 = 2n ** (224n - 1n);
    exports.maxInt232 = 2n ** (232n - 1n);
    exports.maxInt240 = 2n ** (240n - 1n);
    exports.maxInt248 = 2n ** (248n - 1n);
    exports.maxInt256 = 2n ** (256n - 1n);
    exports.minInt8 = -(2n ** 8n);
    exports.minInt16 = -(2n ** 16n);
    exports.minInt24 = -(2n ** 24n);
    exports.minInt32 = -(2n ** 32n);
    exports.minInt40 = -(2n ** 40n);
    exports.minInt48 = -(2n ** 48n);
    exports.minInt56 = -(2n ** 56n);
    exports.minInt64 = -(2n ** 64n);
    exports.minInt72 = -(2n ** 72n);
    exports.minInt80 = -(2n ** 80n);
    exports.minInt88 = -(2n ** 88n);
    exports.minInt96 = -(2n ** 96n);
    exports.minInt104 = -(2n ** 104n);
    exports.minInt112 = -(2n ** 112n);
    exports.minInt120 = -(2n ** 120n);
    exports.minInt128 = -(2n ** 128n);
    exports.minInt136 = -(2n ** 136n);
    exports.minInt144 = -(2n ** 144n);
    exports.minInt152 = -(2n ** 152n);
    exports.minInt160 = -(2n ** 160n);
    exports.minInt168 = -(2n ** 168n);
    exports.minInt176 = -(2n ** 176n);
    exports.minInt184 = -(2n ** 184n);
    exports.minInt192 = -(2n ** 192n);
    exports.minInt200 = -(2n ** 200n);
    exports.minInt208 = -(2n ** 208n);
    exports.minInt216 = -(2n ** 216n);
    exports.minInt224 = -(2n ** 224n);
    exports.minInt232 = -(2n ** 232n);
    exports.minInt240 = -(2n ** 240n);
    exports.minInt248 = -(2n ** 248n);
    exports.minInt256 = -(2n ** 256n);
    exports.maxUint8 = 2n ** 8n;
    exports.maxUint16 = 2n ** 16n;
    exports.maxUint24 = 2n ** 24n;
    exports.maxUint32 = 2n ** 32n;
    exports.maxUint40 = 2n ** 40n;
    exports.maxUint48 = 2n ** 48n;
    exports.maxUint56 = 2n ** 56n;
    exports.maxUint64 = 2n ** 64n;
    exports.maxUint72 = 2n ** 72n;
    exports.maxUint80 = 2n ** 80n;
    exports.maxUint88 = 2n ** 88n;
    exports.maxUint96 = 2n ** 96n;
    exports.maxUint104 = 2n ** 104n;
    exports.maxUint112 = 2n ** 112n;
    exports.maxUint120 = 2n ** 120n;
    exports.maxUint128 = 2n ** 128n;
    exports.maxUint136 = 2n ** 136n;
    exports.maxUint144 = 2n ** 144n;
    exports.maxUint152 = 2n ** 152n;
    exports.maxUint160 = 2n ** 160n;
    exports.maxUint168 = 2n ** 168n;
    exports.maxUint176 = 2n ** 176n;
    exports.maxUint184 = 2n ** 184n;
    exports.maxUint192 = 2n ** 192n;
    exports.maxUint200 = 2n ** 200n;
    exports.maxUint208 = 2n ** 208n;
    exports.maxUint216 = 2n ** 216n;
    exports.maxUint224 = 2n ** 224n;
    exports.maxUint232 = 2n ** 232n;
    exports.maxUint240 = 2n ** 240n;
    exports.maxUint248 = 2n ** 248n;
    exports.maxUint256 = 2n ** 256n;
  }
});

// node_modules/viem/dist/cjs/utils/abi/decodeDeployData.js
var require_decodeDeployData = __commonJS({
  "node_modules/viem/dist/cjs/utils/abi/decodeDeployData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var docsPath = "/docs/contract/decodeDeployData";
    function decodeDeployData({ abi, bytecode, data }) {
      if (data === bytecode)
        return { bytecode };
      const description = abi.find((x2) => "type" in x2 && x2.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, "")}`);
      return { args, bytecode };
    }
    exports.decodeDeployData = decodeDeployData;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b2) {
      if (typeof b2 !== "boolean")
        throw new Error(`Expected boolean, not ${b2}`);
    }
    exports.bool = bool;
    function bytes(b2, ...lengths) {
      if (!(b2 instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b2.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min2 = instance.outputLen;
      if (out.length < min2) {
        throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
      }
    }
    exports.output = output;
    var assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    exports.default = assert;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/utils.js
var require_utils5 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a3) => a3 instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex += hexes[bytes[i2]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j = i2 * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
      let pad = 0;
      arrays.forEach((a3) => {
        if (!u8a(a3))
          throw new Error("Uint8Array expected");
        r.set(a3, pad);
        pad += a3.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils5();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h3 = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h3, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer[i2] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils5();
    var Chi = (a3, b2, c2) => a3 & b2 ^ ~a3 & c2;
    var Maj = (a3, b2, c2) => a3 & b2 ^ a3 & c2 ^ b2 & c2;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B: B2, C, D: D2, E: E2, F, G: G2, H: H3 } = this;
        return [A, B2, C, D2, E2, F, G2, H3];
      }
      set(A, B2, C, D2, E2, F, G2, H3) {
        this.A = A | 0;
        this.B = B2 | 0;
        this.C = C | 0;
        this.D = D2 | 0;
        this.E = E2 | 0;
        this.F = F | 0;
        this.G = G2 | 0;
        this.H = H3 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W[i2 - 15];
          const W2 = SHA256_W[i2 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
        }
        let { A, B: B2, C, D: D2, E: E2, F, G: G2, H: H3 } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = (0, utils_js_1.rotr)(E2, 6) ^ (0, utils_js_1.rotr)(E2, 11) ^ (0, utils_js_1.rotr)(E2, 25);
          const T1 = H3 + sigma1 + Chi(E2, F, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B2, C) | 0;
          H3 = G2;
          G2 = F;
          F = E2;
          E2 = D2 + T1 | 0;
          D2 = C;
          C = B2;
          B2 = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B2 = B2 + this.B | 0;
        C = C + this.C | 0;
        D2 = D2 + this.D | 0;
        E2 = E2 + this.E | 0;
        F = F + this.F | 0;
        G2 = G2 + this.G | 0;
        H3 = H3 + this.H | 0;
        this.set(A, B2, C, D2, E2, F, G2, H3);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a3, b2) {
      const result = a3 % b2;
      return result >= _0n ? result : b2 + result;
    }
    exports.mod = mod;
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x2, power, modulo) {
      let res = x2;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a3 = mod(number, modulo);
      let b2 = modulo;
      let x2 = _0n, y3 = _1n, u2 = _1n, v = _0n;
      while (a3 !== _0n) {
        const q2 = b2 / a3;
        const r = b2 % a3;
        const m3 = x2 - u2 * q2;
        const n = y3 - v * q2;
        b2 = a3, a3 = r, x2 = u2, y3 = v, u2 = m3, v = n;
      }
      const gcd = b2;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x2, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q2, S3, Z;
      for (Q2 = P - _1n, S3 = 0; Q2 % _2n === _0n; Q2 /= _2n, S3++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S3 === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q2 + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S3;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q2);
        let x2 = Fp.pow(n, Q1div2);
        let b2 = Fp.pow(n, Q2);
        while (!Fp.eql(b2, Fp.ONE)) {
          if (Fp.eql(b2, Fp.ZERO))
            return Fp.ZERO;
          let m3 = 1;
          for (let t2 = Fp.sqr(b2); m3 < r; m3++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m3 - 1));
          g = Fp.sqr(ge);
          x2 = Fp.mul(x2, ge);
          b2 = Fp.mul(b2, g);
          r = m3;
        }
        return x2;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i2 = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i2, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d3 = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d3);
        d3 = f.sqr(d3);
        power >>= _1n;
      }
      return p;
    }
    exports.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i2) => {
        if (f.is0(num))
          return acc;
        tmp[i2] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i2) => {
        if (f.is0(num))
          return acc;
        tmp[i2] = f.mul(acc, tmp[i2]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x2) => {
        const p = f.pow(x2, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        cmov: (a3, b2, c2) => c2 ? b2 : a3,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c2, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        unsafeLadder(elm, n) {
          let p = c2.ZERO;
          let d3 = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d3);
            d3 = d3.double();
            n >>= _1n;
          }
          return p;
        },
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i2 = 1; i2 < windowSize; i2++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c2.ZERO;
          let f = c2.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod = require_modular();
    var ut = require_utils4();
    var utils_js_1 = require_utils4();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a: a3 } = opts;
      if (endo) {
        if (!Fp.eql(a3, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      Err: class DERErr extends Error {
        constructor(m3 = "") {
          super(m3);
        }
      },
      _parseInt(data) {
        const { Err: E2 } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E2("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E2("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E2("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E2("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E2 } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E2("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E2("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s3, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E2("Invalid signature: left bytes after parsing");
        return { r, s: s3 };
      },
      hexFromSig(sig) {
        const slice = (s4) => Number.parseInt(s4[0], 16) & 8 ? "00" + s4 : s4;
        const h3 = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s3 = slice(h3(sig.s));
        const r = slice(h3(sig.r));
        const shl = s3.length / 2;
        const rhl = r.length / 2;
        const sl = h3(shl);
        const rl = h3(rhl);
        return `30${h3(rhl + shl + 4)}02${rl}${r}02${sl}${s3}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((c2, point, isCompressed) => {
        const a3 = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a3.x), Fp.toBytes(a3.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x2 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y3 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x: x2, y: y3 };
      });
      function weierstrassEquation(x2) {
        const { a: a3, b: b2 } = CURVE;
        const x22 = Fp.sqr(x2);
        const x3 = Fp.mul(x22, x2);
        return Fp.add(Fp.add(x3, Fp.mul(x2, a3)), b2);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        static fromAffine(p) {
          const { x: x2, y: y3 } = p || {};
          if (!p || !Fp.isValid(x2) || !Fp.isValid(y3))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i2) => Fp.eql(i2, Fp.ZERO);
          if (is0(x2) && is0(y3))
            return Point.ZERO;
          return new Point(x2, y3, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point.fromAffine);
        }
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint)
              return;
            throw new Error("bad point: ZERO");
          }
          const { x: x2, y: y3 } = this.toAffine();
          if (!Fp.isValid(x2) || !Fp.isValid(y3))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y3);
          const right = weierstrassEquation(x2);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y: y3 } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y3);
          throw new Error("Field doesn't support isOdd");
        }
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        double() {
          const { a: a3, b: b2 } = CURVE;
          const b3 = Fp.mul(b2, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a3, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a3, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a3, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a3 = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a3, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a3, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a3, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i2) => p.toAffine(toInv[i2])).map(Point.fromAffine);
          });
        }
        multiplyUnsafe(n) {
          const I2 = Point.ZERO;
          if (n === _0n)
            return I2;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I2;
          let k2p = I2;
          let d3 = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d3);
            if (k2 & _1n)
              k2p = k2p.add(d3);
            d3 = d3.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        multiplyAndAddUnsafe(Q2, a3, b2) {
          const G2 = Point.BASE;
          const mul = (P, a4) => a4 === _0n || a4 === _1n || !P.equals(G2) ? P.multiplyUnsafe(a4) : P.multiply(a4);
          const sum = mul(this, a3).add(mul(Q2, b2));
          return sum.is0() ? void 0 : sum;
        }
        toAffine(iz) {
          const { px: x2, py: y3, pz: z2 } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z2);
          const ax = Fp.mul(x2, iz);
          const ay = Fp.mul(y3, iz);
          const zz = Fp.mul(z2, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a3) {
        return mod.mod(a3, CURVE_ORDER);
      }
      function invN(a3) {
        return mod.invert(a3, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(c2, point, isCompressed) {
          const a3 = point.toAffine();
          const x2 = Fp.toBytes(a3.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
          } else {
            return cat(Uint8Array.from([4]), x2, Fp.toBytes(a3.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x2 = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x2))
              throw new Error("Point is not on curve");
            const y22 = weierstrassEquation(x2);
            let y3 = Fp.sqrt(y22);
            const isYOdd = (y3 & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y3 = Fp.neg(y3);
            return { x: x2, y: y3 };
          } else if (len === uncompressedLen && head === 4) {
            const x2 = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y3 = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x: x2, y: y3 };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s3) {
        return isBiggerThanHalfOrder(s3) ? modN(-s3) : s3;
      }
      const slcNum = (b2, from, to) => ut.bytesToNumberBE(b2.slice(from, to));
      class Signature {
        constructor(r, s3, recovery) {
          this.r = r;
          this.s = s3;
          this.recovery = recovery;
          this.assertValidity();
        }
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        static fromDER(hex) {
          const { r, s: s3 } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s3);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s: s3, recovery: rec } = this;
          const h3 = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R2 = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h3 * ir);
          const u2 = modN(s3 * ir);
          const Q2 = Point.BASE.multiplyAndAddUnsafe(R2, u1, u2);
          if (!Q2)
            throw new Error("point at infinify");
          Q2.assertValidity();
          return Q2;
        }
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        randomPrivateKey: () => {
          const rand = CURVE.randomBytes(Fp.BYTES + 8);
          const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);
          return ut.numberToBytesBE(num, CURVE.nByteLength);
        },
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b2 = Point.fromHex(publicB);
        return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k2) => k2 in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d3 = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d3), int2octets(h1int)];
        if (ent != null) {
          const e2 = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e2, Fp.BYTES));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m3 = h1int;
        function k2sig(kBytes) {
          const k2 = bits2int(kBytes);
          if (!isWithinCurveOrder(k2))
            return;
          const ik = invN(k2);
          const q2 = Point.BASE.multiply(k2).toAffine();
          const r = modN(q2.x);
          if (r === _0n)
            return;
          const s3 = modN(ik * modN(m3 + r * d3));
          if (s3 === _0n)
            return;
          let recovery = (q2.x === r ? 0 : 2) | Number(q2.y & _1n);
          let normS = s3;
          if (lowS && isBiggerThanHalfOrder(s3)) {
            normS = normalizeS(s3);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s4 } = sg;
            _sig = new Signature(r2, s4);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s: s3 } = _sig;
        const h3 = bits2int_modN(msgHash);
        const is = invN(s3);
        const u1 = modN(h3 * is);
        const u2 = modN(r * is);
        const R2 = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R2)
          return false;
        const v = modN(R2.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q2 = Fp.ORDER;
      let l = _0n;
      for (let o = q2 - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q2 - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u2, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u2, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u2);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i2 = c1; i2 > _1n; i2--) {
          let tv52 = i2 - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u2, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u2, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y22 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u2);
          let y3 = Fp.cmov(y22, y1, isQR);
          return { isValid: isQR, value: y3 };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u2) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x2, y3;
        tv1 = Fp.sqr(u2);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x2 = Fp.mul(tv1, tv3);
        const { isValid: isValid2, value } = sqrtRatio(tv2, tv6);
        y3 = Fp.mul(tv1, u2);
        y3 = Fp.mul(y3, value);
        x2 = Fp.cmov(x2, tv3, isValid2);
        y3 = Fp.cmov(y3, value, isValid2);
        const e1 = Fp.isOdd(u2) === Fp.isOdd(y3);
        y3 = Fp.cmov(Fp.neg(y3), y3, e1);
        x2 = Fp.div(x2, tv4);
        return { x: x2, y: y3 };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils4();
    function validateDST(dst) {
      if (dst instanceof Uint8Array)
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i2 = length - 1; i2 >= 0; i2--) {
        res[i2] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a3, b2) {
      const arr = new Uint8Array(a3.length);
      for (let i2 = 0; i2 < a3.length; i2++) {
        arr[i2] = a3[i2] ^ b2[i2];
      }
      return arr;
    }
    function isBytes(item) {
      if (!(item instanceof Uint8Array))
        throw new Error("Uint8Array expected");
    }
    function isNum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H3) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255)
        DST = H3((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H3;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b2 = new Array(ell);
      const b_0 = H3((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b2[0] = H3((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i2 = 1; i2 <= ell; i2++) {
        const args = [strxor(b_0, b2[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
        b2[i2] = H3((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b2);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k2, H3) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k2 / 8);
        DST = H3.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H3.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "string",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k: k2, m: m3, hash, expand, DST: _DST } = options;
      isBytes(msg);
      isNum(count);
      const DST = validateDST(_DST);
      const log2p = p.toString(2).length;
      const L2 = Math.ceil((log2p + k2) / 8);
      const len_in_bytes = count * m3 * L2;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k2, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u2 = new Array(count);
      for (let i2 = 0; i2 < count; i2++) {
        const e2 = new Array(m3);
        for (let j = 0; j < m3; j++) {
          const elm_offset = L2 * (j + i2 * m3);
          const tv = prb.subarray(elm_offset, elm_offset + L2);
          e2[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u2[i2] = e2;
      }
      return u2;
    }
    exports.hash_to_field = hash_to_field;
    function isogenyMap(field, map) {
      const COEFF = map.map((i2) => Array.from(i2).reverse());
      return (x2, y3) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x2), i2)));
        x2 = field.div(xNum, xDen);
        y3 = field.mul(y3, field.div(yNum, yDen));
        return { x: x2, y: y3 };
      };
    }
    exports.isogenyMap = isogenyMap;
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        hashToCurve(msg, options) {
          const u2 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u2[0]));
          const u1 = Point.fromAffine(mapToCurve(u2[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        encodeToCurve(msg, options) {
          const u2 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u2[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports.createHasher = createHasher;
  }
});

// node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils5();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i2 = 0; i2 < pad.length; i2++)
          pad[i2] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils5();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports.createCurve = createCurve;
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils5();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var utils_js_1 = require_utils4();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var _shortw_utils_js_1 = require_shortw_utils();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a3, b2) => (a3 + b2 / _2n) / b2;
    function sqrtMod(y3) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y3 * y3 * y3 % P;
      const b3 = b2 * b2 * y3 % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y3))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      b: BigInt(7),
      Fp,
      n: secp256k1N,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k2) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k2, n);
          const c2 = divNearest(-b1 * k2, n);
          let k1 = (0, modular_js_1.mod)(k2 - c1 * a1 - c2 * a22, n);
          let k22 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k22 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k22 = n - k22;
          if (k1 > POW_2_128 || k22 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k2);
          }
          return { k1neg, k1, k2neg, k2: k22 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x2) => typeof x2 === "bigint" && _0n < x2 && x2 < secp256k1P;
    var ge = (x2) => typeof x2 === "bigint" && _0n < x2 && x2 < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c2) => c2.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x2) => (0, modular_js_1.mod)(x2, secp256k1P);
    var modN = (x2) => (0, modular_js_1.mod)(x2, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q2, a3, b2) => Point.BASE.multiplyAndAddUnsafe(Q2, a3, b2);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x2) {
      if (!fe(x2))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x2 * x2);
      const c2 = modP(xx * x2 + BigInt(7));
      let y3 = sqrtMod(c2);
      if (y3 % _2n !== _0n)
        y3 = modP(-y3);
      const p = new Point(x2, y3, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m3 = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d3 } = schnorrGetExtPubKey(privateKey);
      const a3 = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t2 = numTo32b(d3 ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a3)));
      const rand = taggedHash("BIP0340/nonce", t2, px, m3);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k2 } = schnorrGetExtPubKey(k_);
      const e2 = challenge(rx, px, m3);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k2 + e2 * d3)), 32);
      if (!schnorrVerify(sig, m3, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m3 = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s3 = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s3))
          return false;
        const e2 = challenge(numTo32b(r), pointToBytes(P), m3);
        const R2 = GmulAdd(P, s3, modN(-e2));
        if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
      ],
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
      ]
    ].map((i2) => i2.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x: x2, y: y3 } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x2, y3);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/viem/dist/cjs/utils/signature/hexToSignature.js
var require_hexToSignature = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/hexToSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToSignature = void 0;
    var secp256k1_1 = require_secp256k1();
    var toHex_js_1 = require_toHex();
    function hexToSignature(signatureHex) {
      const { r, s: s3 } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
      const v = BigInt(`0x${signatureHex.slice(130)}`);
      return { r: (0, toHex_js_1.numberToHex)(r), s: (0, toHex_js_1.numberToHex)(s3), v };
    }
    exports.hexToSignature = hexToSignature;
  }
});

// node_modules/viem/dist/cjs/utils/signature/signatureToHex.js
var require_signatureToHex = __commonJS({
  "node_modules/viem/dist/cjs/utils/signature/signatureToHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureToHex = void 0;
    var secp256k1_1 = require_secp256k1();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function signatureToHex({ r, s: s3, v }) {
      return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s3)).toCompactHex()}${(0, toHex_js_1.toHex)(v).slice(2)}`;
    }
    exports.signatureToHex = signatureToHex;
  }
});

// node_modules/viem/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/viem/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.zeroAddress = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = void 0;
    exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = void 0;
    exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = void 0;
    exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUriResolutionError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.SwitchChainError = exports.TransactionRejectedRpcError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.BaseError = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = void 0;
    exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hexToSignature = exports.hashTypedData = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = exports.UrlRequiredError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidLegacyVError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = void 0;
    exports.isAddressEqual = exports.isAddress = exports.hashMessage = exports.getFunctionSelector = exports.getEventSelector = exports.getContractError = exports.getAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.encodePacked = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.verifyTypedData = exports.verifyMessage = exports.toRlp = exports.signatureToHex = exports.recoverTypedDataAddress = void 0;
    exports.validateTypedData = exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = exports.prepareRequest = exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = void 0;
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return abitype_1.CircularReferenceError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return abitype_1.InvalidParenthesisError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abitype_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abitype_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return abitype_1.UnknownSignatureError;
    } });
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var getContract_js_1 = require_getContract();
    Object.defineProperty(exports, "getContract", { enumerable: true, get: function() {
      return getContract_js_1.getContract;
    } });
    var createClient_js_1 = require_createClient();
    Object.defineProperty(exports, "createClient", { enumerable: true, get: function() {
      return createClient_js_1.createClient;
    } });
    var custom_js_1 = require_custom();
    Object.defineProperty(exports, "custom", { enumerable: true, get: function() {
      return custom_js_1.custom;
    } });
    var fallback_js_1 = require_fallback();
    Object.defineProperty(exports, "fallback", { enumerable: true, get: function() {
      return fallback_js_1.fallback;
    } });
    var http_js_1 = require_http();
    Object.defineProperty(exports, "http", { enumerable: true, get: function() {
      return http_js_1.http;
    } });
    var createPublicClient_js_1 = require_createPublicClient();
    Object.defineProperty(exports, "createPublicClient", { enumerable: true, get: function() {
      return createPublicClient_js_1.createPublicClient;
    } });
    var createTestClient_js_1 = require_createTestClient();
    Object.defineProperty(exports, "createTestClient", { enumerable: true, get: function() {
      return createTestClient_js_1.createTestClient;
    } });
    var public_js_1 = require_public();
    Object.defineProperty(exports, "publicActions", { enumerable: true, get: function() {
      return public_js_1.publicActions;
    } });
    var test_js_1 = require_test();
    Object.defineProperty(exports, "testActions", { enumerable: true, get: function() {
      return test_js_1.testActions;
    } });
    var wallet_js_1 = require_wallet();
    Object.defineProperty(exports, "walletActions", { enumerable: true, get: function() {
      return wallet_js_1.walletActions;
    } });
    var createTransport_js_1 = require_createTransport();
    Object.defineProperty(exports, "createTransport", { enumerable: true, get: function() {
      return createTransport_js_1.createTransport;
    } });
    var createWalletClient_js_1 = require_createWalletClient();
    Object.defineProperty(exports, "createWalletClient", { enumerable: true, get: function() {
      return createWalletClient_js_1.createWalletClient;
    } });
    var webSocket_js_1 = require_webSocket();
    Object.defineProperty(exports, "webSocket", { enumerable: true, get: function() {
      return webSocket_js_1.webSocket;
    } });
    var abis_js_1 = require_abis();
    Object.defineProperty(exports, "multicall3Abi", { enumerable: true, get: function() {
      return abis_js_1.multicall3Abi;
    } });
    var address_js_1 = require_address2();
    Object.defineProperty(exports, "zeroAddress", { enumerable: true, get: function() {
      return address_js_1.zeroAddress;
    } });
    var unit_js_1 = require_unit();
    Object.defineProperty(exports, "etherUnits", { enumerable: true, get: function() {
      return unit_js_1.etherUnits;
    } });
    Object.defineProperty(exports, "gweiUnits", { enumerable: true, get: function() {
      return unit_js_1.gweiUnits;
    } });
    Object.defineProperty(exports, "weiUnits", { enumerable: true, get: function() {
      return unit_js_1.weiUnits;
    } });
    var number_js_1 = require_number();
    Object.defineProperty(exports, "maxInt8", { enumerable: true, get: function() {
      return number_js_1.maxInt8;
    } });
    Object.defineProperty(exports, "maxInt16", { enumerable: true, get: function() {
      return number_js_1.maxInt16;
    } });
    Object.defineProperty(exports, "maxInt24", { enumerable: true, get: function() {
      return number_js_1.maxInt24;
    } });
    Object.defineProperty(exports, "maxInt32", { enumerable: true, get: function() {
      return number_js_1.maxInt32;
    } });
    Object.defineProperty(exports, "maxInt40", { enumerable: true, get: function() {
      return number_js_1.maxInt40;
    } });
    Object.defineProperty(exports, "maxInt48", { enumerable: true, get: function() {
      return number_js_1.maxInt48;
    } });
    Object.defineProperty(exports, "maxInt56", { enumerable: true, get: function() {
      return number_js_1.maxInt56;
    } });
    Object.defineProperty(exports, "maxInt64", { enumerable: true, get: function() {
      return number_js_1.maxInt64;
    } });
    Object.defineProperty(exports, "maxInt72", { enumerable: true, get: function() {
      return number_js_1.maxInt72;
    } });
    Object.defineProperty(exports, "maxInt80", { enumerable: true, get: function() {
      return number_js_1.maxInt80;
    } });
    Object.defineProperty(exports, "maxInt88", { enumerable: true, get: function() {
      return number_js_1.maxInt88;
    } });
    Object.defineProperty(exports, "maxInt96", { enumerable: true, get: function() {
      return number_js_1.maxInt96;
    } });
    Object.defineProperty(exports, "maxInt104", { enumerable: true, get: function() {
      return number_js_1.maxInt104;
    } });
    Object.defineProperty(exports, "maxInt112", { enumerable: true, get: function() {
      return number_js_1.maxInt112;
    } });
    Object.defineProperty(exports, "maxInt120", { enumerable: true, get: function() {
      return number_js_1.maxInt120;
    } });
    Object.defineProperty(exports, "maxInt128", { enumerable: true, get: function() {
      return number_js_1.maxInt128;
    } });
    Object.defineProperty(exports, "maxInt136", { enumerable: true, get: function() {
      return number_js_1.maxInt136;
    } });
    Object.defineProperty(exports, "maxInt144", { enumerable: true, get: function() {
      return number_js_1.maxInt144;
    } });
    Object.defineProperty(exports, "maxInt152", { enumerable: true, get: function() {
      return number_js_1.maxInt152;
    } });
    Object.defineProperty(exports, "maxInt160", { enumerable: true, get: function() {
      return number_js_1.maxInt160;
    } });
    Object.defineProperty(exports, "maxInt168", { enumerable: true, get: function() {
      return number_js_1.maxInt168;
    } });
    Object.defineProperty(exports, "maxInt176", { enumerable: true, get: function() {
      return number_js_1.maxInt176;
    } });
    Object.defineProperty(exports, "maxInt184", { enumerable: true, get: function() {
      return number_js_1.maxInt184;
    } });
    Object.defineProperty(exports, "maxInt192", { enumerable: true, get: function() {
      return number_js_1.maxInt192;
    } });
    Object.defineProperty(exports, "maxInt200", { enumerable: true, get: function() {
      return number_js_1.maxInt200;
    } });
    Object.defineProperty(exports, "maxInt208", { enumerable: true, get: function() {
      return number_js_1.maxInt208;
    } });
    Object.defineProperty(exports, "maxInt216", { enumerable: true, get: function() {
      return number_js_1.maxInt216;
    } });
    Object.defineProperty(exports, "maxInt224", { enumerable: true, get: function() {
      return number_js_1.maxInt224;
    } });
    Object.defineProperty(exports, "maxInt232", { enumerable: true, get: function() {
      return number_js_1.maxInt232;
    } });
    Object.defineProperty(exports, "maxInt240", { enumerable: true, get: function() {
      return number_js_1.maxInt240;
    } });
    Object.defineProperty(exports, "maxInt248", { enumerable: true, get: function() {
      return number_js_1.maxInt248;
    } });
    Object.defineProperty(exports, "maxInt256", { enumerable: true, get: function() {
      return number_js_1.maxInt256;
    } });
    Object.defineProperty(exports, "maxUint8", { enumerable: true, get: function() {
      return number_js_1.maxUint8;
    } });
    Object.defineProperty(exports, "maxUint16", { enumerable: true, get: function() {
      return number_js_1.maxUint16;
    } });
    Object.defineProperty(exports, "maxUint24", { enumerable: true, get: function() {
      return number_js_1.maxUint24;
    } });
    Object.defineProperty(exports, "maxUint32", { enumerable: true, get: function() {
      return number_js_1.maxUint32;
    } });
    Object.defineProperty(exports, "maxUint40", { enumerable: true, get: function() {
      return number_js_1.maxUint40;
    } });
    Object.defineProperty(exports, "maxUint48", { enumerable: true, get: function() {
      return number_js_1.maxUint48;
    } });
    Object.defineProperty(exports, "maxUint56", { enumerable: true, get: function() {
      return number_js_1.maxUint56;
    } });
    Object.defineProperty(exports, "maxUint64", { enumerable: true, get: function() {
      return number_js_1.maxUint64;
    } });
    Object.defineProperty(exports, "maxUint72", { enumerable: true, get: function() {
      return number_js_1.maxUint72;
    } });
    Object.defineProperty(exports, "maxUint80", { enumerable: true, get: function() {
      return number_js_1.maxUint80;
    } });
    Object.defineProperty(exports, "maxUint88", { enumerable: true, get: function() {
      return number_js_1.maxUint88;
    } });
    Object.defineProperty(exports, "maxUint96", { enumerable: true, get: function() {
      return number_js_1.maxUint96;
    } });
    Object.defineProperty(exports, "maxUint104", { enumerable: true, get: function() {
      return number_js_1.maxUint104;
    } });
    Object.defineProperty(exports, "maxUint112", { enumerable: true, get: function() {
      return number_js_1.maxUint112;
    } });
    Object.defineProperty(exports, "maxUint120", { enumerable: true, get: function() {
      return number_js_1.maxUint120;
    } });
    Object.defineProperty(exports, "maxUint128", { enumerable: true, get: function() {
      return number_js_1.maxUint128;
    } });
    Object.defineProperty(exports, "maxUint136", { enumerable: true, get: function() {
      return number_js_1.maxUint136;
    } });
    Object.defineProperty(exports, "maxUint144", { enumerable: true, get: function() {
      return number_js_1.maxUint144;
    } });
    Object.defineProperty(exports, "maxUint152", { enumerable: true, get: function() {
      return number_js_1.maxUint152;
    } });
    Object.defineProperty(exports, "maxUint160", { enumerable: true, get: function() {
      return number_js_1.maxUint160;
    } });
    Object.defineProperty(exports, "maxUint168", { enumerable: true, get: function() {
      return number_js_1.maxUint168;
    } });
    Object.defineProperty(exports, "maxUint176", { enumerable: true, get: function() {
      return number_js_1.maxUint176;
    } });
    Object.defineProperty(exports, "maxUint184", { enumerable: true, get: function() {
      return number_js_1.maxUint184;
    } });
    Object.defineProperty(exports, "maxUint192", { enumerable: true, get: function() {
      return number_js_1.maxUint192;
    } });
    Object.defineProperty(exports, "maxUint200", { enumerable: true, get: function() {
      return number_js_1.maxUint200;
    } });
    Object.defineProperty(exports, "maxUint208", { enumerable: true, get: function() {
      return number_js_1.maxUint208;
    } });
    Object.defineProperty(exports, "maxUint216", { enumerable: true, get: function() {
      return number_js_1.maxUint216;
    } });
    Object.defineProperty(exports, "maxUint224", { enumerable: true, get: function() {
      return number_js_1.maxUint224;
    } });
    Object.defineProperty(exports, "maxUint232", { enumerable: true, get: function() {
      return number_js_1.maxUint232;
    } });
    Object.defineProperty(exports, "maxUint240", { enumerable: true, get: function() {
      return number_js_1.maxUint240;
    } });
    Object.defineProperty(exports, "maxUint248", { enumerable: true, get: function() {
      return number_js_1.maxUint248;
    } });
    Object.defineProperty(exports, "maxUint256", { enumerable: true, get: function() {
      return number_js_1.maxUint256;
    } });
    Object.defineProperty(exports, "minInt8", { enumerable: true, get: function() {
      return number_js_1.minInt8;
    } });
    Object.defineProperty(exports, "minInt16", { enumerable: true, get: function() {
      return number_js_1.minInt16;
    } });
    Object.defineProperty(exports, "minInt24", { enumerable: true, get: function() {
      return number_js_1.minInt24;
    } });
    Object.defineProperty(exports, "minInt32", { enumerable: true, get: function() {
      return number_js_1.minInt32;
    } });
    Object.defineProperty(exports, "minInt40", { enumerable: true, get: function() {
      return number_js_1.minInt40;
    } });
    Object.defineProperty(exports, "minInt48", { enumerable: true, get: function() {
      return number_js_1.minInt48;
    } });
    Object.defineProperty(exports, "minInt56", { enumerable: true, get: function() {
      return number_js_1.minInt56;
    } });
    Object.defineProperty(exports, "minInt64", { enumerable: true, get: function() {
      return number_js_1.minInt64;
    } });
    Object.defineProperty(exports, "minInt72", { enumerable: true, get: function() {
      return number_js_1.minInt72;
    } });
    Object.defineProperty(exports, "minInt80", { enumerable: true, get: function() {
      return number_js_1.minInt80;
    } });
    Object.defineProperty(exports, "minInt88", { enumerable: true, get: function() {
      return number_js_1.minInt88;
    } });
    Object.defineProperty(exports, "minInt96", { enumerable: true, get: function() {
      return number_js_1.minInt96;
    } });
    Object.defineProperty(exports, "minInt104", { enumerable: true, get: function() {
      return number_js_1.minInt104;
    } });
    Object.defineProperty(exports, "minInt112", { enumerable: true, get: function() {
      return number_js_1.minInt112;
    } });
    Object.defineProperty(exports, "minInt120", { enumerable: true, get: function() {
      return number_js_1.minInt120;
    } });
    Object.defineProperty(exports, "minInt128", { enumerable: true, get: function() {
      return number_js_1.minInt128;
    } });
    Object.defineProperty(exports, "minInt136", { enumerable: true, get: function() {
      return number_js_1.minInt136;
    } });
    Object.defineProperty(exports, "minInt144", { enumerable: true, get: function() {
      return number_js_1.minInt144;
    } });
    Object.defineProperty(exports, "minInt152", { enumerable: true, get: function() {
      return number_js_1.minInt152;
    } });
    Object.defineProperty(exports, "minInt160", { enumerable: true, get: function() {
      return number_js_1.minInt160;
    } });
    Object.defineProperty(exports, "minInt168", { enumerable: true, get: function() {
      return number_js_1.minInt168;
    } });
    Object.defineProperty(exports, "minInt176", { enumerable: true, get: function() {
      return number_js_1.minInt176;
    } });
    Object.defineProperty(exports, "minInt184", { enumerable: true, get: function() {
      return number_js_1.minInt184;
    } });
    Object.defineProperty(exports, "minInt192", { enumerable: true, get: function() {
      return number_js_1.minInt192;
    } });
    Object.defineProperty(exports, "minInt200", { enumerable: true, get: function() {
      return number_js_1.minInt200;
    } });
    Object.defineProperty(exports, "minInt208", { enumerable: true, get: function() {
      return number_js_1.minInt208;
    } });
    Object.defineProperty(exports, "minInt216", { enumerable: true, get: function() {
      return number_js_1.minInt216;
    } });
    Object.defineProperty(exports, "minInt224", { enumerable: true, get: function() {
      return number_js_1.minInt224;
    } });
    Object.defineProperty(exports, "minInt232", { enumerable: true, get: function() {
      return number_js_1.minInt232;
    } });
    Object.defineProperty(exports, "minInt240", { enumerable: true, get: function() {
      return number_js_1.minInt240;
    } });
    Object.defineProperty(exports, "minInt248", { enumerable: true, get: function() {
      return number_js_1.minInt248;
    } });
    Object.defineProperty(exports, "minInt256", { enumerable: true, get: function() {
      return number_js_1.minInt256;
    } });
    var abi_js_1 = require_abi();
    Object.defineProperty(exports, "AbiConstructorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorParamsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingDataSizeInvalidError;
    } });
    Object.defineProperty(exports, "AbiDecodingZeroDataError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingZeroDataError;
    } });
    Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingArrayLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiEncodingLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiErrorInputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorInputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureEmptyTopicsError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionOutputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "DecodeLogTopicsMismatch", { enumerable: true, get: function() {
      return abi_js_1.DecodeLogTopicsMismatch;
    } });
    Object.defineProperty(exports, "InvalidAbiDecodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiDecodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiEncodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiEncodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidArrayError", { enumerable: true, get: function() {
      return abi_js_1.InvalidArrayError;
    } });
    Object.defineProperty(exports, "InvalidDefinitionTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidDefinitionTypeError;
    } });
    var base_js_1 = require_base();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return base_js_1.BaseError;
    } });
    var block_js_1 = require_block();
    Object.defineProperty(exports, "BlockNotFoundError", { enumerable: true, get: function() {
      return block_js_1.BlockNotFoundError;
    } });
    var contract_js_1 = require_contract();
    Object.defineProperty(exports, "CallExecutionError", { enumerable: true, get: function() {
      return contract_js_1.CallExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionExecutionError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionRevertedError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionRevertedError;
    } });
    Object.defineProperty(exports, "ContractFunctionZeroDataError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionZeroDataError;
    } });
    Object.defineProperty(exports, "RawContractError", { enumerable: true, get: function() {
      return contract_js_1.RawContractError;
    } });
    var rpc_js_1 = require_rpc();
    Object.defineProperty(exports, "ChainDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ChainDisconnectedError;
    } });
    Object.defineProperty(exports, "InternalRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InternalRpcError;
    } });
    Object.defineProperty(exports, "InvalidInputRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidInputRpcError;
    } });
    Object.defineProperty(exports, "InvalidParamsRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidParamsRpcError;
    } });
    Object.defineProperty(exports, "InvalidRequestRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidRequestRpcError;
    } });
    Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function() {
      return rpc_js_1.JsonRpcVersionUnsupportedError;
    } });
    Object.defineProperty(exports, "LimitExceededRpcError", { enumerable: true, get: function() {
      return rpc_js_1.LimitExceededRpcError;
    } });
    Object.defineProperty(exports, "MethodNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotFoundRpcError;
    } });
    Object.defineProperty(exports, "MethodNotSupportedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotSupportedRpcError;
    } });
    Object.defineProperty(exports, "ParseRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ParseRpcError;
    } });
    Object.defineProperty(exports, "ProviderDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderDisconnectedError;
    } });
    Object.defineProperty(exports, "ProviderRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderRpcError;
    } });
    Object.defineProperty(exports, "ResourceNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceNotFoundRpcError;
    } });
    Object.defineProperty(exports, "ResourceUnavailableRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceUnavailableRpcError;
    } });
    Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
      return rpc_js_1.RpcError;
    } });
    Object.defineProperty(exports, "TransactionRejectedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.TransactionRejectedRpcError;
    } });
    Object.defineProperty(exports, "SwitchChainError", { enumerable: true, get: function() {
      return rpc_js_1.SwitchChainError;
    } });
    Object.defineProperty(exports, "UnauthorizedProviderError", { enumerable: true, get: function() {
      return rpc_js_1.UnauthorizedProviderError;
    } });
    Object.defineProperty(exports, "UnknownRpcError", { enumerable: true, get: function() {
      return rpc_js_1.UnknownRpcError;
    } });
    Object.defineProperty(exports, "UnsupportedProviderMethodError", { enumerable: true, get: function() {
      return rpc_js_1.UnsupportedProviderMethodError;
    } });
    Object.defineProperty(exports, "UserRejectedRequestError", { enumerable: true, get: function() {
      return rpc_js_1.UserRejectedRequestError;
    } });
    var chain_js_1 = require_chain();
    Object.defineProperty(exports, "ChainDoesNotSupportContract", { enumerable: true, get: function() {
      return chain_js_1.ChainDoesNotSupportContract;
    } });
    Object.defineProperty(exports, "ClientChainNotConfiguredError", { enumerable: true, get: function() {
      return chain_js_1.ClientChainNotConfiguredError;
    } });
    Object.defineProperty(exports, "InvalidChainIdError", { enumerable: true, get: function() {
      return chain_js_1.InvalidChainIdError;
    } });
    var encoding_js_1 = require_encoding();
    Object.defineProperty(exports, "DataLengthTooLongError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooLongError;
    } });
    Object.defineProperty(exports, "DataLengthTooShortError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooShortError;
    } });
    Object.defineProperty(exports, "InvalidBytesBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidBytesBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexValueError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexValueError;
    } });
    Object.defineProperty(exports, "OffsetOutOfBoundsError", { enumerable: true, get: function() {
      return encoding_js_1.OffsetOutOfBoundsError;
    } });
    var ens_js_1 = require_ens();
    Object.defineProperty(exports, "EnsAvatarUriResolutionError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarUriResolutionError;
    } });
    var estimateGas_js_1 = require_estimateGas();
    Object.defineProperty(exports, "EstimateGasExecutionError", { enumerable: true, get: function() {
      return estimateGas_js_1.EstimateGasExecutionError;
    } });
    var node_js_1 = require_node();
    Object.defineProperty(exports, "ExecutionRevertedError", { enumerable: true, get: function() {
      return node_js_1.ExecutionRevertedError;
    } });
    Object.defineProperty(exports, "FeeCapTooHighError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooHighError;
    } });
    Object.defineProperty(exports, "FeeCapTooLowError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooLowError;
    } });
    Object.defineProperty(exports, "InsufficientFundsError", { enumerable: true, get: function() {
      return node_js_1.InsufficientFundsError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooHighError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooHighError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooLowError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooLowError;
    } });
    Object.defineProperty(exports, "NonceMaxValueError", { enumerable: true, get: function() {
      return node_js_1.NonceMaxValueError;
    } });
    Object.defineProperty(exports, "NonceTooHighError", { enumerable: true, get: function() {
      return node_js_1.NonceTooHighError;
    } });
    Object.defineProperty(exports, "NonceTooLowError", { enumerable: true, get: function() {
      return node_js_1.NonceTooLowError;
    } });
    Object.defineProperty(exports, "TipAboveFeeCapError", { enumerable: true, get: function() {
      return node_js_1.TipAboveFeeCapError;
    } });
    Object.defineProperty(exports, "TransactionTypeNotSupportedError", { enumerable: true, get: function() {
      return node_js_1.TransactionTypeNotSupportedError;
    } });
    Object.defineProperty(exports, "UnknownNodeError", { enumerable: true, get: function() {
      return node_js_1.UnknownNodeError;
    } });
    var log_js_1 = require_log();
    Object.defineProperty(exports, "FilterTypeNotSupportedError", { enumerable: true, get: function() {
      return log_js_1.FilterTypeNotSupportedError;
    } });
    var request_js_1 = require_request();
    Object.defineProperty(exports, "HttpRequestError", { enumerable: true, get: function() {
      return request_js_1.HttpRequestError;
    } });
    Object.defineProperty(exports, "RpcRequestError", { enumerable: true, get: function() {
      return request_js_1.RpcRequestError;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return request_js_1.TimeoutError;
    } });
    Object.defineProperty(exports, "WebSocketRequestError", { enumerable: true, get: function() {
      return request_js_1.WebSocketRequestError;
    } });
    var address_js_2 = require_address();
    Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function() {
      return address_js_2.InvalidAddressError;
    } });
    var transaction_js_1 = require_transaction();
    Object.defineProperty(exports, "InvalidLegacyVError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidLegacyVError;
    } });
    Object.defineProperty(exports, "TransactionExecutionError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionExecutionError;
    } });
    Object.defineProperty(exports, "TransactionNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionNotFoundError;
    } });
    Object.defineProperty(exports, "TransactionReceiptNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionReceiptNotFoundError;
    } });
    Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function() {
      return transaction_js_1.WaitForTransactionReceiptTimeoutError;
    } });
    var data_js_1 = require_data();
    Object.defineProperty(exports, "SizeExceedsPaddingSizeError", { enumerable: true, get: function() {
      return data_js_1.SizeExceedsPaddingSizeError;
    } });
    var transport_js_1 = require_transport();
    Object.defineProperty(exports, "UrlRequiredError", { enumerable: true, get: function() {
      return transport_js_1.UrlRequiredError;
    } });
    var labelhash_js_1 = require_labelhash();
    Object.defineProperty(exports, "labelhash", { enumerable: true, get: function() {
      return labelhash_js_1.labelhash;
    } });
    var namehash_js_1 = require_namehash();
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_js_1.namehash;
    } });
    var block_js_2 = require_block2();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_2.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_2.formatBlock;
    } });
    var log_js_2 = require_log2();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_2.formatLog;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeDeployData_js_1 = require_decodeDeployData();
    Object.defineProperty(exports, "decodeDeployData", { enumerable: true, get: function() {
      return decodeDeployData_js_1.decodeDeployData;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var transaction_js_2 = require_transaction2();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_2.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_2.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_2.transactionType;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var hexToSignature_js_1 = require_hexToSignature();
    Object.defineProperty(exports, "hexToSignature", { enumerable: true, get: function() {
      return hexToSignature_js_1.hexToSignature;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var signatureToHex_js_1 = require_signatureToHex();
    Object.defineProperty(exports, "signatureToHex", { enumerable: true, get: function() {
      return signatureToHex_js_1.signatureToHex;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigint;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var ccip_js_1 = require_ccip();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var chain_js_2 = require_chain2();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return chain_js_2.assertCurrentChain;
    } });
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return chain_js_2.defineChain;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var prepareRequest_js_1 = require_prepareRequest();
    Object.defineProperty(exports, "prepareRequest", { enumerable: true, get: function() {
      return prepareRequest_js_1.prepareRequest;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
  }
});

// node_modules/@daohaus/utils/src/utils/viem.js
var require_viem2 = __commonJS({
  "node_modules/@daohaus/utils/src/utils/viem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createViemClient = exports.createTransport = void 0;
    var keychain_utils_1 = require_src();
    var viem_1 = require_cjs2();
    var createTransport = ({ chainId, rpcs = keychain_utils_1.HAUS_RPC, retryCount = 10 }) => {
      const rpc = rpcs[chainId];
      if (!rpc)
        return (0, viem_1.http)();
      return (0, viem_1.http)(rpc, { retryCount });
    };
    exports.createTransport = createTransport;
    var createViemClient = ({ chainId, rpcs = keychain_utils_1.HAUS_RPC }) => {
      const transport = (0, exports.createTransport)({
        chainId,
        rpcs
      });
      return (0, viem_1.createPublicClient)({
        chain: keychain_utils_1.VIEM_CHAINS[chainId],
        transport
      });
    };
    exports.createViemClient = createViemClient;
  }
});

// node_modules/@daohaus/utils/src/utils/gas.js
var require_gas = __commonJS({
  "node_modules/@daohaus/utils/src/utils/gas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fetchFeeData = exports.getUnit = exports.getProcessingGasLimit = exports.getGasCostEstimate = void 0;
    var tslib_1 = require_tslib();
    var viem_1 = require_cjs2();
    var viem_2 = require_viem2();
    var constants_1 = require_constants();
    var getGasCostEstimate = (gasLimit, chainId) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      const feeDataNew = yield fetchFeeData({ chainId });
      return Number((0, exports.getProcessingGasLimit)(gasLimit, chainId)) * Number(feeDataNew.maxFeePerGas || 0);
    });
    exports.getGasCostEstimate = getGasCostEstimate;
    var getProcessingGasLimit = (actionGasEstimate, chainId) => {
      if (chainId === "0xa4b1" || chainId === "0xa") {
        return BigInt(Number(actionGasEstimate) > 0 ? Number(actionGasEstimate) + constants_1.PROCESS_PROPOSAL_GAS_LIMIT_ADDITION + constants_1.L2_ADDITIONAL_GAS : constants_1.PROCESS_PROPOSAL_GAS_LIMIT_ADDITION * constants_1.GAS_BUFFER_MULTIPLIER + constants_1.L2_ADDITIONAL_GAS);
      }
      return BigInt(Number(actionGasEstimate) > 0 ? Number(actionGasEstimate) + constants_1.PROCESS_PROPOSAL_GAS_LIMIT_ADDITION : constants_1.PROCESS_PROPOSAL_GAS_LIMIT_ADDITION * constants_1.GAS_BUFFER_MULTIPLIER);
    };
    exports.getProcessingGasLimit = getProcessingGasLimit;
    function getUnit(unit) {
      if (typeof unit === "number")
        return unit;
      if (unit === "wei")
        return 0;
      return Math.abs(viem_1.weiUnits[unit]);
    }
    exports.getUnit = getUnit;
    function fetchFeeData({ chainId, formatUnits: units = "gwei" }) {
      return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const client = (0, viem_2.createViemClient)({ chainId });
        const block = yield client.getBlock();
        let gasPrice = null;
        try {
          gasPrice = yield client.getGasPrice();
        } catch (e2) {
          console.error(`Failed to get gas price: ${e2}`);
        }
        let lastBaseFeePerGas = null;
        let maxFeePerGas = null;
        let maxPriorityFeePerGas = null;
        if (block === null || block === void 0 ? void 0 : block.baseFeePerGas) {
          lastBaseFeePerGas = block.baseFeePerGas;
          maxPriorityFeePerGas = (0, viem_1.parseGwei)("1");
          maxFeePerGas = block.baseFeePerGas * BigInt(2) + maxPriorityFeePerGas;
        }
        const unit = getUnit(units);
        const formatted = {
          gasPrice: gasPrice ? (0, viem_1.formatUnits)(gasPrice, unit) : null,
          maxFeePerGas: maxFeePerGas ? (0, viem_1.formatUnits)(maxFeePerGas, unit) : null,
          maxPriorityFeePerGas: maxPriorityFeePerGas ? (0, viem_1.formatUnits)(maxPriorityFeePerGas, unit) : null
        };
        return {
          lastBaseFeePerGas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          formatted
        };
      });
    }
    exports.fetchFeeData = fetchFeeData;
  }
});

// node_modules/@daohaus/utils/src/utils/general.js
var require_general2 = __commonJS({
  "node_modules/@daohaus/utils/src/utils/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lowerCaseLootToken = exports.sharesDelegatedToMember = exports.memberUsdValueShare = exports.memberTokenBalanceShare = exports.nowInSeconds = exports.votingPowerPercentage = exports.ZERO_ADDRESS = void 0;
    var viem_1 = require_cjs2();
    exports.ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
    var votingPowerPercentage = (daoTotalShares, memberShares) => {
      if (Number(daoTotalShares) === 0)
        return 0;
      const perc = Number((0, viem_1.formatEther)(BigInt(memberShares))) / Number((0, viem_1.formatEther)(BigInt(daoTotalShares))) * 100;
      return Math.round(perc * 100) / 100;
    };
    exports.votingPowerPercentage = votingPowerPercentage;
    var nowInSeconds = () => new Date().getTime() / 1e3;
    exports.nowInSeconds = nowInSeconds;
    var memberTokenBalanceShare = (tokenBalance, daoTotalShares, daoTotalLoot, memberShares, memberLoot, decimals = 18) => {
      const daoSharesAndLoot = Number((0, viem_1.formatEther)(BigInt(daoTotalShares))) + Number((0, viem_1.formatEther)(BigInt(daoTotalLoot)));
      const sharesAndLoot = Number((0, viem_1.formatEther)(BigInt(memberShares))) + Number((0, viem_1.formatEther)(BigInt(memberLoot)));
      const ratio = sharesAndLoot / daoSharesAndLoot;
      const memberSharesWei = Number(tokenBalance) * ratio;
      return memberSharesWei / Math.pow(10, Number(decimals));
    };
    exports.memberTokenBalanceShare = memberTokenBalanceShare;
    var memberUsdValueShare = (usdValue, daoTotalShares, daoTotalLoot, memberShares, memberLoot) => {
      const daoSharesAndLoot = Number((0, viem_1.formatEther)(BigInt(daoTotalShares))) + Number((0, viem_1.formatEther)(BigInt(daoTotalLoot)));
      if (daoSharesAndLoot === 0)
        return 0;
      const sharesAndLoot = Number((0, viem_1.formatEther)(BigInt(memberShares))) + Number((0, viem_1.formatEther)(BigInt(memberLoot)));
      const ratio = sharesAndLoot / daoSharesAndLoot;
      return Number(usdValue) * ratio;
    };
    exports.memberUsdValueShare = memberUsdValueShare;
    var sharesDelegatedToMember = (delegateShares, memberShares) => {
      const val = Number(delegateShares) - Number(memberShares);
      if (!Number.isSafeInteger(val))
        return BigInt(val).toString();
      return val.toString();
    };
    exports.sharesDelegatedToMember = sharesDelegatedToMember;
    var lowerCaseLootToken = (tokenName) => {
      if (!tokenName)
        return "";
      return tokenName.replace("LOOT", "Loot");
    };
    exports.lowerCaseLootToken = lowerCaseLootToken;
  }
});

// node_modules/@daohaus/utils/src/utils/formatting.js
var require_formatting = __commonJS({
  "node_modules/@daohaus/utils/src/utils/formatting.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJSON = exports.toBigInt = exports.fromWei = exports.handlePluralNoun = exports.charLimit = exports.truncateAddress = void 0;
    var viem_1 = require_cjs2();
    var truncateAddress = (addr) => `${addr.slice(0, 6)}...${addr.slice(-4)}`;
    exports.truncateAddress = truncateAddress;
    var charLimit = (str, limit) => str && str.length > limit ? `${str.slice(0, limit)}...` : str;
    exports.charLimit = charLimit;
    var handlePluralNoun = (noun, count) => count === 1 ? noun.singular : noun.plural;
    exports.handlePluralNoun = handlePluralNoun;
    var fromWei = (amt) => {
      return (0, viem_1.formatEther)(BigInt(amt)).toString();
    };
    exports.fromWei = fromWei;
    var toBigInt = (amt) => {
      if (amt) {
        return BigInt(amt);
      }
    };
    exports.toBigInt = toBigInt;
    var isJSON = (obj) => {
      try {
        JSON.parse(obj);
        return true;
      } catch (e2) {
        return false;
      }
    };
    exports.isJSON = isJSON;
  }
});

// node_modules/@daohaus/utils/src/utils/gnosis.js
var require_gnosis = __commonJS({
  "node_modules/@daohaus/utils/src/utils/gnosis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateGnosisUiLink = void 0;
    var keychain_utils_1 = require_src();
    var generateGnosisUiLink = ({ chainId, address }) => `${keychain_utils_1.ENDPOINTS["GNOSIS_SAFE_UI"][chainId]}:${address}/balances`;
    exports.generateGnosisUiLink = generateGnosisUiLink;
  }
});

// node_modules/@daohaus/utils/src/utils/typeguards.js
var require_typeguards = __commonJS({
  "node_modules/@daohaus/utils/src/utils/typeguards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isLengthOf = exports.isNumberString = exports.isArgType = exports.isObject = exports.isEthAddress = exports.isNumberish = exports.isBoolean = exports.isString = exports.isNumber = exports.isArray = void 0;
    var viem_1 = require_cjs2();
    var isArray = (item) => Array.isArray(item);
    exports.isArray = isArray;
    var isNumber = (item) => typeof item === "number";
    exports.isNumber = isNumber;
    var isString = (item) => typeof item === "string";
    exports.isString = isString;
    var isBoolean = (item) => typeof item === "boolean";
    exports.isBoolean = isBoolean;
    var isNumberish = (item) => (0, exports.isNumber)(item) || (0, exports.isNumberString)(item);
    exports.isNumberish = isNumberish;
    var isEthAddress = (item) => (0, exports.isString)(item) && (0, viem_1.isAddress)(item);
    exports.isEthAddress = isEthAddress;
    var isObject = (item) => {
      if (item instanceof Object)
        return true;
      try {
        if ((0, exports.isString)(item)) {
          JSON.parse(item);
          return true;
        }
        return false;
      } catch (error) {
        return false;
      }
    };
    exports.isObject = isObject;
    var isArgType = (item) => {
      if ((0, exports.isArray)(item)) {
        return item.every(exports.isArgType);
      }
      return (0, exports.isString)(item) || (0, exports.isNumber)(item) || (0, exports.isBoolean)(item) || (0, exports.isObject)(item);
    };
    exports.isArgType = isArgType;
    var isNumberString = (item) => (0, exports.isString)(item) && !isNaN(parseFloat(item)) && isFinite(Number(item));
    exports.isNumberString = isNumberString;
    var isLengthOf = (item, length) => (0, exports.isArray)(item) && item.length === length;
    exports.isLengthOf = isLengthOf;
  }
});

// node_modules/@daohaus/utils/src/utils/encoding.js
var require_encoding2 = __commonJS({
  "node_modules/@daohaus/utils/src/utils/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNonce = exports.encodeFunction = exports.encodeValues = void 0;
    var viem_1 = require_cjs2();
    var encodeValues = (typesArray, valueArray) => {
      return (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)(typesArray.join(",")), valueArray);
    };
    exports.encodeValues = encodeValues;
    var encodeFunction = (abi, fnName, functionArgs) => {
      try {
        if (!abi || !Array.isArray(functionArgs))
          throw new Error("Incorrect params passed to safeEncodeHexFunction in abi.js");
        return (0, viem_1.encodeFunctionData)({
          abi,
          functionName: fnName,
          args: functionArgs
        });
      } catch (error) {
        console.error("error", error);
        return {
          error: true,
          message: "Could not encode transaction data with the values provided"
        };
      }
    };
    exports.encodeFunction = encodeFunction;
    var getNonce = (length = 24) => {
      let text = "";
      const possible = "0123456789";
      for (let i2 = 0; i2 < length; i2++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
      }
      return text;
    };
    exports.getNonce = getNonce;
  }
});

// node_modules/numbro/dist/numbro.min.js
var require_numbro_min = __commonJS({
  "node_modules/numbro/dist/numbro.min.js"(exports, module) {
    !function(e2) {
      if ("object" == typeof exports && "undefined" != typeof module)
        module.exports = e2();
      else if ("function" == typeof define && define.amd)
        define([], e2);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : this).numbro = e2();
      }
    }(function() {
      return function a3(o, u2, c2) {
        function s3(t2, e3) {
          if (!u2[t2]) {
            if (!o[t2]) {
              var r = "function" == typeof __require && __require;
              if (!e3 && r)
                return r(t2, true);
              if (l)
                return l(t2, true);
              var n = new Error("Cannot find module '" + t2 + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i2 = u2[t2] = { exports: {} };
            o[t2][0].call(i2.exports, function(e4) {
              return s3(o[t2][1][e4] || e4);
            }, i2, i2.exports, a3, o, u2, c2);
          }
          return u2[t2].exports;
        }
        for (var l = "function" == typeof __require && __require, e2 = 0; e2 < c2.length; e2++)
          s3(c2[e2]);
        return s3;
      }({ 1: [function(e2, r, t2) {
        !function(e3) {
          "use strict";
          var t3, T2 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, C = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator, U = Math.ceil, R2 = Math.floor, I2 = "[BigNumber Error] ", $ = I2 + "Number primitive has more than 15 significant digits: ", G2 = 1e14, V = 14, q2 = 9007199254740991, Z = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], z2 = 1e7, W = 1e9;
          function H3(e4) {
            var t4 = 0 | e4;
            return 0 < e4 || e4 === t4 ? t4 : t4 - 1;
          }
          function Y2(e4) {
            for (var t4, r2, n = 1, i2 = e4.length, a3 = e4[0] + ""; n < i2; ) {
              for (t4 = e4[n++] + "", r2 = V - t4.length; r2--; t4 = "0" + t4)
                ;
              a3 += t4;
            }
            for (i2 = a3.length; 48 === a3.charCodeAt(--i2); )
              ;
            return a3.slice(0, i2 + 1 || 1);
          }
          function K2(e4, t4) {
            var r2, n, i2 = e4.c, a3 = t4.c, o = e4.s, u2 = t4.s, c2 = e4.e, s3 = t4.e;
            if (!o || !u2)
              return null;
            if (r2 = i2 && !i2[0], n = a3 && !a3[0], r2 || n)
              return r2 ? n ? 0 : -u2 : o;
            if (o != u2)
              return o;
            if (r2 = o < 0, n = c2 == s3, !i2 || !a3)
              return n ? 0 : !i2 ^ r2 ? 1 : -1;
            if (!n)
              return s3 < c2 ^ r2 ? 1 : -1;
            for (u2 = (c2 = i2.length) < (s3 = a3.length) ? c2 : s3, o = 0; o < u2; o++)
              if (i2[o] != a3[o])
                return i2[o] > a3[o] ^ r2 ? 1 : -1;
            return c2 == s3 ? 0 : s3 < c2 ^ r2 ? 1 : -1;
          }
          function J(e4, t4, r2, n) {
            if (e4 < t4 || r2 < e4 || e4 !== R2(e4))
              throw Error(I2 + (n || "Argument") + ("number" == typeof e4 ? e4 < t4 || r2 < e4 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e4));
          }
          function X2(e4) {
            var t4 = e4.c.length - 1;
            return H3(e4.e / V) == t4 && e4.c[t4] % 2 != 0;
          }
          function Q2(e4, t4) {
            return (1 < e4.length ? e4.charAt(0) + "." + e4.slice(1) : e4) + (t4 < 0 ? "e" : "e+") + t4;
          }
          function ee(e4, t4, r2) {
            var n, i2;
            if (t4 < 0) {
              for (i2 = r2 + "."; ++t4; i2 += r2)
                ;
              e4 = i2 + e4;
            } else if (++t4 > (n = e4.length)) {
              for (i2 = r2, t4 -= n; --t4; i2 += r2)
                ;
              e4 += i2;
            } else
              t4 < n && (e4 = e4.slice(0, t4) + "." + e4.slice(t4));
            return e4;
          }
          (t3 = function e4(t4) {
            var v, f, g, r2, s3, m3, o, u2, c2, l, p, n = A.prototype = { constructor: A, toString: null, valueOf: null }, h3 = new A(1), y3 = 20, b2 = 4, d3 = -7, w2 = 21, S3 = -1e7, O2 = 1e7, x2 = false, a3 = 1, N = 0, B2 = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, M3 = "0123456789abcdefghijklmnopqrstuvwxyz";
            function A(e5, t5) {
              var r3, n2, i3, a4, o2, u3, c3, s4, l2 = this;
              if (!(l2 instanceof A))
                return new A(e5, t5);
              if (null == t5) {
                if (e5 && true === e5._isBigNumber)
                  return l2.s = e5.s, void (!e5.c || e5.e > O2 ? l2.c = l2.e = null : e5.e < S3 ? l2.c = [l2.e = 0] : (l2.e = e5.e, l2.c = e5.c.slice()));
                if ((u3 = "number" == typeof e5) && 0 * e5 == 0) {
                  if (l2.s = 1 / e5 < 0 ? (e5 = -e5, -1) : 1, e5 === ~~e5) {
                    for (a4 = 0, o2 = e5; 10 <= o2; o2 /= 10, a4++)
                      ;
                    return void (O2 < a4 ? l2.c = l2.e = null : (l2.e = a4, l2.c = [e5]));
                  }
                  s4 = String(e5);
                } else {
                  if (!T2.test(s4 = String(e5)))
                    return g(l2, s4, u3);
                  l2.s = 45 == s4.charCodeAt(0) ? (s4 = s4.slice(1), -1) : 1;
                }
                -1 < (a4 = s4.indexOf(".")) && (s4 = s4.replace(".", "")), 0 < (o2 = s4.search(/e/i)) ? (a4 < 0 && (a4 = o2), a4 += +s4.slice(o2 + 1), s4 = s4.substring(0, o2)) : a4 < 0 && (a4 = s4.length);
              } else {
                if (J(t5, 2, M3.length, "Base"), 10 == t5)
                  return j(l2 = new A(e5), y3 + l2.e + 1, b2);
                if (s4 = String(e5), u3 = "number" == typeof e5) {
                  if (0 * e5 != 0)
                    return g(l2, s4, u3, t5);
                  if (l2.s = 1 / e5 < 0 ? (s4 = s4.slice(1), -1) : 1, A.DEBUG && 15 < s4.replace(/^0\.0*|\./, "").length)
                    throw Error($ + e5);
                } else
                  l2.s = 45 === s4.charCodeAt(0) ? (s4 = s4.slice(1), -1) : 1;
                for (r3 = M3.slice(0, t5), a4 = o2 = 0, c3 = s4.length; o2 < c3; o2++)
                  if (r3.indexOf(n2 = s4.charAt(o2)) < 0) {
                    if ("." == n2) {
                      if (a4 < o2) {
                        a4 = c3;
                        continue;
                      }
                    } else if (!i3 && (s4 == s4.toUpperCase() && (s4 = s4.toLowerCase()) || s4 == s4.toLowerCase() && (s4 = s4.toUpperCase()))) {
                      i3 = true, o2 = -1, a4 = 0;
                      continue;
                    }
                    return g(l2, String(e5), u3, t5);
                  }
                u3 = false, -1 < (a4 = (s4 = f(s4, t5, 10, l2.s)).indexOf(".")) ? s4 = s4.replace(".", "") : a4 = s4.length;
              }
              for (o2 = 0; 48 === s4.charCodeAt(o2); o2++)
                ;
              for (c3 = s4.length; 48 === s4.charCodeAt(--c3); )
                ;
              if (s4 = s4.slice(o2, ++c3)) {
                if (c3 -= o2, u3 && A.DEBUG && 15 < c3 && (q2 < e5 || e5 !== R2(e5)))
                  throw Error($ + l2.s * e5);
                if ((a4 = a4 - o2 - 1) > O2)
                  l2.c = l2.e = null;
                else if (a4 < S3)
                  l2.c = [l2.e = 0];
                else {
                  if (l2.e = a4, l2.c = [], o2 = (a4 + 1) % V, a4 < 0 && (o2 += V), o2 < c3) {
                    for (o2 && l2.c.push(+s4.slice(0, o2)), c3 -= V; o2 < c3; )
                      l2.c.push(+s4.slice(o2, o2 += V));
                    o2 = V - (s4 = s4.slice(o2)).length;
                  } else
                    o2 -= c3;
                  for (; o2--; s4 += "0")
                    ;
                  l2.c.push(+s4);
                }
              } else
                l2.c = [l2.e = 0];
            }
            function D2(e5, t5, r3, n2) {
              for (var i3, a4, o2 = [0], u3 = 0, c3 = e5.length; u3 < c3; ) {
                for (a4 = o2.length; a4--; o2[a4] *= t5)
                  ;
                for (o2[0] += n2.indexOf(e5.charAt(u3++)), i3 = 0; i3 < o2.length; i3++)
                  o2[i3] > r3 - 1 && (null == o2[i3 + 1] && (o2[i3 + 1] = 0), o2[i3 + 1] += o2[i3] / r3 | 0, o2[i3] %= r3);
              }
              return o2.reverse();
            }
            function E2(e5, t5, r3) {
              var n2, i3, a4, o2, u3 = 0, c3 = e5.length, s4 = t5 % z2, l2 = t5 / z2 | 0;
              for (e5 = e5.slice(); c3--; )
                u3 = ((i3 = s4 * (a4 = e5[c3] % z2) + (n2 = l2 * a4 + (o2 = e5[c3] / z2 | 0) * s4) % z2 * z2 + u3) / r3 | 0) + (n2 / z2 | 0) + l2 * o2, e5[c3] = i3 % r3;
              return u3 && (e5 = [u3].concat(e5)), e5;
            }
            function F(e5, t5, r3, n2) {
              var i3, a4;
              if (r3 != n2)
                a4 = n2 < r3 ? 1 : -1;
              else
                for (i3 = a4 = 0; i3 < r3; i3++)
                  if (e5[i3] != t5[i3]) {
                    a4 = e5[i3] > t5[i3] ? 1 : -1;
                    break;
                  }
              return a4;
            }
            function k2(e5, t5, r3, n2) {
              for (var i3 = 0; r3--; )
                e5[r3] -= i3, i3 = e5[r3] < t5[r3] ? 1 : 0, e5[r3] = i3 * n2 + e5[r3] - t5[r3];
              for (; !e5[0] && 1 < e5.length; e5.splice(0, 1))
                ;
            }
            function i2(e5, t5, r3, n2) {
              var i3, a4, o2, u3, c3;
              if (null == r3 ? r3 = b2 : J(r3, 0, 8), !e5.c)
                return e5.toString();
              if (i3 = e5.c[0], o2 = e5.e, null == t5)
                c3 = Y2(e5.c), c3 = 1 == n2 || 2 == n2 && (o2 <= d3 || w2 <= o2) ? Q2(c3, o2) : ee(c3, o2, "0");
              else if (a4 = (e5 = j(new A(e5), t5, r3)).e, u3 = (c3 = Y2(e5.c)).length, 1 == n2 || 2 == n2 && (t5 <= a4 || a4 <= d3)) {
                for (; u3 < t5; c3 += "0", u3++)
                  ;
                c3 = Q2(c3, a4);
              } else if (t5 -= o2, c3 = ee(c3, a4, "0"), u3 < a4 + 1) {
                if (0 < --t5)
                  for (c3 += "."; t5--; c3 += "0")
                    ;
              } else if (0 < (t5 += a4 - u3))
                for (a4 + 1 == u3 && (c3 += "."); t5--; c3 += "0")
                  ;
              return e5.s < 0 && i3 ? "-" + c3 : c3;
            }
            function _(e5, t5) {
              for (var r3, n2 = 1, i3 = new A(e5[0]); n2 < e5.length; n2++) {
                if (!(r3 = new A(e5[n2])).s) {
                  i3 = r3;
                  break;
                }
                t5.call(i3, r3) && (i3 = r3);
              }
              return i3;
            }
            function L2(e5, t5, r3) {
              for (var n2 = 1, i3 = t5.length; !t5[--i3]; t5.pop())
                ;
              for (i3 = t5[0]; 10 <= i3; i3 /= 10, n2++)
                ;
              return (r3 = n2 + r3 * V - 1) > O2 ? e5.c = e5.e = null : r3 < S3 ? e5.c = [e5.e = 0] : (e5.e = r3, e5.c = t5), e5;
            }
            function j(e5, t5, r3, n2) {
              var i3, a4, o2, u3, c3, s4, l2, f2 = e5.c, g2 = Z;
              if (f2) {
                e: {
                  for (i3 = 1, u3 = f2[0]; 10 <= u3; u3 /= 10, i3++)
                    ;
                  if ((a4 = t5 - i3) < 0)
                    a4 += V, o2 = t5, l2 = (c3 = f2[s4 = 0]) / g2[i3 - o2 - 1] % 10 | 0;
                  else if ((s4 = U((a4 + 1) / V)) >= f2.length) {
                    if (!n2)
                      break e;
                    for (; f2.length <= s4; f2.push(0))
                      ;
                    c3 = l2 = 0, o2 = (a4 %= V) - V + (i3 = 1);
                  } else {
                    for (c3 = u3 = f2[s4], i3 = 1; 10 <= u3; u3 /= 10, i3++)
                      ;
                    l2 = (o2 = (a4 %= V) - V + i3) < 0 ? 0 : c3 / g2[i3 - o2 - 1] % 10 | 0;
                  }
                  if (n2 = n2 || t5 < 0 || null != f2[s4 + 1] || (o2 < 0 ? c3 : c3 % g2[i3 - o2 - 1]), n2 = r3 < 4 ? (l2 || n2) && (0 == r3 || r3 == (e5.s < 0 ? 3 : 2)) : 5 < l2 || 5 == l2 && (4 == r3 || n2 || 6 == r3 && (0 < a4 ? 0 < o2 ? c3 / g2[i3 - o2] : 0 : f2[s4 - 1]) % 10 & 1 || r3 == (e5.s < 0 ? 8 : 7)), t5 < 1 || !f2[0])
                    return f2.length = 0, n2 ? (t5 -= e5.e + 1, f2[0] = g2[(V - t5 % V) % V], e5.e = -t5 || 0) : f2[0] = e5.e = 0, e5;
                  if (0 == a4 ? (f2.length = s4, u3 = 1, s4--) : (f2.length = s4 + 1, u3 = g2[V - a4], f2[s4] = 0 < o2 ? R2(c3 / g2[i3 - o2] % g2[o2]) * u3 : 0), n2)
                    for (; ; ) {
                      if (0 == s4) {
                        for (a4 = 1, o2 = f2[0]; 10 <= o2; o2 /= 10, a4++)
                          ;
                        for (o2 = f2[0] += u3, u3 = 1; 10 <= o2; o2 /= 10, u3++)
                          ;
                        a4 != u3 && (e5.e++, f2[0] == G2 && (f2[0] = 1));
                        break;
                      }
                      if (f2[s4] += u3, f2[s4] != G2)
                        break;
                      f2[s4--] = 0, u3 = 1;
                    }
                  for (a4 = f2.length; 0 === f2[--a4]; f2.pop())
                    ;
                }
                e5.e > O2 ? e5.c = e5.e = null : e5.e < S3 && (e5.c = [e5.e = 0]);
              }
              return e5;
            }
            function P(e5) {
              var t5, r3 = e5.e;
              return null === r3 ? e5.toString() : (t5 = Y2(e5.c), t5 = r3 <= d3 || w2 <= r3 ? Q2(t5, r3) : ee(t5, r3, "0"), e5.s < 0 ? "-" + t5 : t5);
            }
            return A.clone = e4, A.ROUND_UP = 0, A.ROUND_DOWN = 1, A.ROUND_CEIL = 2, A.ROUND_FLOOR = 3, A.ROUND_HALF_UP = 4, A.ROUND_HALF_DOWN = 5, A.ROUND_HALF_EVEN = 6, A.ROUND_HALF_CEIL = 7, A.ROUND_HALF_FLOOR = 8, A.EUCLID = 9, A.config = A.set = function(e5) {
              var t5, r3;
              if (null != e5) {
                if ("object" != typeof e5)
                  throw Error(I2 + "Object expected: " + e5);
                if (e5.hasOwnProperty(t5 = "DECIMAL_PLACES") && (J(r3 = e5[t5], 0, W, t5), y3 = r3), e5.hasOwnProperty(t5 = "ROUNDING_MODE") && (J(r3 = e5[t5], 0, 8, t5), b2 = r3), e5.hasOwnProperty(t5 = "EXPONENTIAL_AT") && ((r3 = e5[t5]) && r3.pop ? (J(r3[0], -W, 0, t5), J(r3[1], 0, W, t5), d3 = r3[0], w2 = r3[1]) : (J(r3, -W, W, t5), d3 = -(w2 = r3 < 0 ? -r3 : r3))), e5.hasOwnProperty(t5 = "RANGE"))
                  if ((r3 = e5[t5]) && r3.pop)
                    J(r3[0], -W, -1, t5), J(r3[1], 1, W, t5), S3 = r3[0], O2 = r3[1];
                  else {
                    if (J(r3, -W, W, t5), !r3)
                      throw Error(I2 + t5 + " cannot be zero: " + r3);
                    S3 = -(O2 = r3 < 0 ? -r3 : r3);
                  }
                if (e5.hasOwnProperty(t5 = "CRYPTO")) {
                  if ((r3 = e5[t5]) !== !!r3)
                    throw Error(I2 + t5 + " not true or false: " + r3);
                  if (r3) {
                    if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                      throw x2 = !r3, Error(I2 + "crypto unavailable");
                    x2 = r3;
                  } else
                    x2 = r3;
                }
                if (e5.hasOwnProperty(t5 = "MODULO_MODE") && (J(r3 = e5[t5], 0, 9, t5), a3 = r3), e5.hasOwnProperty(t5 = "POW_PRECISION") && (J(r3 = e5[t5], 0, W, t5), N = r3), e5.hasOwnProperty(t5 = "FORMAT")) {
                  if ("object" != typeof (r3 = e5[t5]))
                    throw Error(I2 + t5 + " not an object: " + r3);
                  B2 = r3;
                }
                if (e5.hasOwnProperty(t5 = "ALPHABET")) {
                  if ("string" != typeof (r3 = e5[t5]) || /^.$|[+-.\s]|(.).*\1/.test(r3))
                    throw Error(I2 + t5 + " invalid: " + r3);
                  M3 = r3;
                }
              }
              return { DECIMAL_PLACES: y3, ROUNDING_MODE: b2, EXPONENTIAL_AT: [d3, w2], RANGE: [S3, O2], CRYPTO: x2, MODULO_MODE: a3, POW_PRECISION: N, FORMAT: B2, ALPHABET: M3 };
            }, A.isBigNumber = function(e5) {
              if (!e5 || true !== e5._isBigNumber)
                return false;
              if (!A.DEBUG)
                return true;
              var t5, r3, n2 = e5.c, i3 = e5.e, a4 = e5.s;
              e:
                if ("[object Array]" == {}.toString.call(n2)) {
                  if ((1 === a4 || -1 === a4) && -W <= i3 && i3 <= W && i3 === R2(i3)) {
                    if (0 === n2[0]) {
                      if (0 === i3 && 1 === n2.length)
                        return true;
                      break e;
                    }
                    if ((t5 = (i3 + 1) % V) < 1 && (t5 += V), String(n2[0]).length == t5) {
                      for (t5 = 0; t5 < n2.length; t5++)
                        if ((r3 = n2[t5]) < 0 || G2 <= r3 || r3 !== R2(r3))
                          break e;
                      if (0 !== r3)
                        return true;
                    }
                  }
                } else if (null === n2 && null === i3 && (null === a4 || 1 === a4 || -1 === a4))
                  return true;
              throw Error(I2 + "Invalid BigNumber: " + e5);
            }, A.maximum = A.max = function() {
              return _(arguments, n.lt);
            }, A.minimum = A.min = function() {
              return _(arguments, n.gt);
            }, A.random = (r2 = 9007199254740992, s3 = Math.random() * r2 & 2097151 ? function() {
              return R2(Math.random() * r2);
            } : function() {
              return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
            }, function(e5) {
              var t5, r3, n2, i3, a4, o2 = 0, u3 = [], c3 = new A(h3);
              if (null == e5 ? e5 = y3 : J(e5, 0, W), i3 = U(e5 / V), x2)
                if (crypto.getRandomValues) {
                  for (t5 = crypto.getRandomValues(new Uint32Array(i3 *= 2)); o2 < i3; )
                    9e15 <= (a4 = 131072 * t5[o2] + (t5[o2 + 1] >>> 11)) ? (r3 = crypto.getRandomValues(new Uint32Array(2)), t5[o2] = r3[0], t5[o2 + 1] = r3[1]) : (u3.push(a4 % 1e14), o2 += 2);
                  o2 = i3 / 2;
                } else {
                  if (!crypto.randomBytes)
                    throw x2 = false, Error(I2 + "crypto unavailable");
                  for (t5 = crypto.randomBytes(i3 *= 7); o2 < i3; )
                    9e15 <= (a4 = 281474976710656 * (31 & t5[o2]) + 1099511627776 * t5[o2 + 1] + 4294967296 * t5[o2 + 2] + 16777216 * t5[o2 + 3] + (t5[o2 + 4] << 16) + (t5[o2 + 5] << 8) + t5[o2 + 6]) ? crypto.randomBytes(7).copy(t5, o2) : (u3.push(a4 % 1e14), o2 += 7);
                  o2 = i3 / 7;
                }
              if (!x2)
                for (; o2 < i3; )
                  (a4 = s3()) < 9e15 && (u3[o2++] = a4 % 1e14);
              for (i3 = u3[--o2], e5 %= V, i3 && e5 && (a4 = Z[V - e5], u3[o2] = R2(i3 / a4) * a4); 0 === u3[o2]; u3.pop(), o2--)
                ;
              if (o2 < 0)
                u3 = [n2 = 0];
              else {
                for (n2 = -1; 0 === u3[0]; u3.splice(0, 1), n2 -= V)
                  ;
                for (o2 = 1, a4 = u3[0]; 10 <= a4; a4 /= 10, o2++)
                  ;
                o2 < V && (n2 -= V - o2);
              }
              return c3.e = n2, c3.c = u3, c3;
            }), A.sum = function() {
              for (var e5 = 1, t5 = arguments, r3 = new A(t5[0]); e5 < t5.length; )
                r3 = r3.plus(t5[e5++]);
              return r3;
            }, m3 = "0123456789", f = function(e5, t5, r3, n2, i3) {
              var a4, o2, u3, c3, s4, l2, f2, g2, p2 = e5.indexOf("."), d4 = y3, h4 = b2;
              for (0 <= p2 && (c3 = N, N = 0, e5 = e5.replace(".", ""), l2 = (g2 = new A(t5)).pow(e5.length - p2), N = c3, g2.c = D2(ee(Y2(l2.c), l2.e, "0"), 10, r3, m3), g2.e = g2.c.length), u3 = c3 = (f2 = D2(e5, t5, r3, i3 ? (a4 = M3, m3) : (a4 = m3, M3))).length; 0 == f2[--c3]; f2.pop())
                ;
              if (!f2[0])
                return a4.charAt(0);
              if (p2 < 0 ? --u3 : (l2.c = f2, l2.e = u3, l2.s = n2, f2 = (l2 = v(l2, g2, d4, h4, r3)).c, s4 = l2.r, u3 = l2.e), p2 = f2[o2 = u3 + d4 + 1], c3 = r3 / 2, s4 = s4 || o2 < 0 || null != f2[o2 + 1], s4 = h4 < 4 ? (null != p2 || s4) && (0 == h4 || h4 == (l2.s < 0 ? 3 : 2)) : c3 < p2 || p2 == c3 && (4 == h4 || s4 || 6 == h4 && 1 & f2[o2 - 1] || h4 == (l2.s < 0 ? 8 : 7)), o2 < 1 || !f2[0])
                e5 = s4 ? ee(a4.charAt(1), -d4, a4.charAt(0)) : a4.charAt(0);
              else {
                if (f2.length = o2, s4)
                  for (--r3; ++f2[--o2] > r3; )
                    f2[o2] = 0, o2 || (++u3, f2 = [1].concat(f2));
                for (c3 = f2.length; !f2[--c3]; )
                  ;
                for (p2 = 0, e5 = ""; p2 <= c3; e5 += a4.charAt(f2[p2++]))
                  ;
                e5 = ee(e5, u3, a4.charAt(0));
              }
              return e5;
            }, v = function(e5, t5, r3, n2, i3) {
              var a4, o2, u3, c3, s4, l2, f2, g2, p2, d4, h4, v2, m4, y4, b3, w3, S4, O3 = e5.s == t5.s ? 1 : -1, x3 = e5.c, N2 = t5.c;
              if (!(x3 && x3[0] && N2 && N2[0]))
                return new A(e5.s && t5.s && (x3 ? !N2 || x3[0] != N2[0] : N2) ? x3 && 0 == x3[0] || !N2 ? 0 * O3 : O3 / 0 : NaN);
              for (p2 = (g2 = new A(O3)).c = [], O3 = r3 + (o2 = e5.e - t5.e) + 1, i3 || (i3 = G2, o2 = H3(e5.e / V) - H3(t5.e / V), O3 = O3 / V | 0), u3 = 0; N2[u3] == (x3[u3] || 0); u3++)
                ;
              if (N2[u3] > (x3[u3] || 0) && o2--, O3 < 0)
                p2.push(1), c3 = true;
              else {
                for (y4 = x3.length, w3 = N2.length, O3 += 2, 1 < (s4 = R2(i3 / (N2[u3 = 0] + 1))) && (N2 = E2(N2, s4, i3), x3 = E2(x3, s4, i3), w3 = N2.length, y4 = x3.length), m4 = w3, h4 = (d4 = x3.slice(0, w3)).length; h4 < w3; d4[h4++] = 0)
                  ;
                S4 = N2.slice(), S4 = [0].concat(S4), b3 = N2[0], N2[1] >= i3 / 2 && b3++;
                do {
                  if (s4 = 0, (a4 = F(N2, d4, w3, h4)) < 0) {
                    if (v2 = d4[0], w3 != h4 && (v2 = v2 * i3 + (d4[1] || 0)), 1 < (s4 = R2(v2 / b3)))
                      for (i3 <= s4 && (s4 = i3 - 1), f2 = (l2 = E2(N2, s4, i3)).length, h4 = d4.length; 1 == F(l2, d4, f2, h4); )
                        s4--, k2(l2, w3 < f2 ? S4 : N2, f2, i3), f2 = l2.length, a4 = 1;
                    else
                      0 == s4 && (a4 = s4 = 1), f2 = (l2 = N2.slice()).length;
                    if (f2 < h4 && (l2 = [0].concat(l2)), k2(d4, l2, h4, i3), h4 = d4.length, -1 == a4)
                      for (; F(N2, d4, w3, h4) < 1; )
                        s4++, k2(d4, w3 < h4 ? S4 : N2, h4, i3), h4 = d4.length;
                  } else
                    0 === a4 && (s4++, d4 = [0]);
                  p2[u3++] = s4, d4[0] ? d4[h4++] = x3[m4] || 0 : (d4 = [x3[m4]], h4 = 1);
                } while ((m4++ < y4 || null != d4[0]) && O3--);
                c3 = null != d4[0], p2[0] || p2.splice(0, 1);
              }
              if (i3 == G2) {
                for (u3 = 1, O3 = p2[0]; 10 <= O3; O3 /= 10, u3++)
                  ;
                j(g2, r3 + (g2.e = u3 + o2 * V - 1) + 1, n2, c3);
              } else
                g2.e = o2, g2.r = +c3;
              return g2;
            }, o = /^(-?)0([xbo])(?=\w[\w.]*$)/i, u2 = /^([^.]+)\.$/, c2 = /^\.([^.]+)$/, l = /^-?(Infinity|NaN)$/, p = /^\s*\+(?=[\w.])|^\s+|\s+$/g, g = function(e5, t5, r3, n2) {
              var i3, a4 = r3 ? t5 : t5.replace(p, "");
              if (l.test(a4))
                e5.s = isNaN(a4) ? null : a4 < 0 ? -1 : 1;
              else {
                if (!r3 && (a4 = a4.replace(o, function(e6, t6, r4) {
                  return i3 = "x" == (r4 = r4.toLowerCase()) ? 16 : "b" == r4 ? 2 : 8, n2 && n2 != i3 ? e6 : t6;
                }), n2 && (i3 = n2, a4 = a4.replace(u2, "$1").replace(c2, "0.$1")), t5 != a4))
                  return new A(a4, i3);
                if (A.DEBUG)
                  throw Error(I2 + "Not a" + (n2 ? " base " + n2 : "") + " number: " + t5);
                e5.s = null;
              }
              e5.c = e5.e = null;
            }, n.absoluteValue = n.abs = function() {
              var e5 = new A(this);
              return e5.s < 0 && (e5.s = 1), e5;
            }, n.comparedTo = function(e5, t5) {
              return K2(this, new A(e5, t5));
            }, n.decimalPlaces = n.dp = function(e5, t5) {
              var r3, n2, i3;
              if (null != e5)
                return J(e5, 0, W), null == t5 ? t5 = b2 : J(t5, 0, 8), j(new A(this), e5 + this.e + 1, t5);
              if (!(r3 = this.c))
                return null;
              if (n2 = ((i3 = r3.length - 1) - H3(this.e / V)) * V, i3 = r3[i3])
                for (; i3 % 10 == 0; i3 /= 10, n2--)
                  ;
              return n2 < 0 && (n2 = 0), n2;
            }, n.dividedBy = n.div = function(e5, t5) {
              return v(this, new A(e5, t5), y3, b2);
            }, n.dividedToIntegerBy = n.idiv = function(e5, t5) {
              return v(this, new A(e5, t5), 0, 1);
            }, n.exponentiatedBy = n.pow = function(e5, t5) {
              var r3, n2, i3, a4, o2, u3, c3, s4, l2 = this;
              if ((e5 = new A(e5)).c && !e5.isInteger())
                throw Error(I2 + "Exponent not an integer: " + P(e5));
              if (null != t5 && (t5 = new A(t5)), o2 = 14 < e5.e, !l2.c || !l2.c[0] || 1 == l2.c[0] && !l2.e && 1 == l2.c.length || !e5.c || !e5.c[0])
                return s4 = new A(Math.pow(+P(l2), o2 ? 2 - X2(e5) : +P(e5))), t5 ? s4.mod(t5) : s4;
              if (u3 = e5.s < 0, t5) {
                if (t5.c ? !t5.c[0] : !t5.s)
                  return new A(NaN);
                (n2 = !u3 && l2.isInteger() && t5.isInteger()) && (l2 = l2.mod(t5));
              } else {
                if (9 < e5.e && (0 < l2.e || l2.e < -1 || (0 == l2.e ? 1 < l2.c[0] || o2 && 24e7 <= l2.c[1] : l2.c[0] < 8e13 || o2 && l2.c[0] <= 9999975e7)))
                  return a4 = l2.s < 0 && X2(e5) ? -0 : 0, -1 < l2.e && (a4 = 1 / a4), new A(u3 ? 1 / a4 : a4);
                N && (a4 = U(N / V + 2));
              }
              for (c3 = o2 ? (r3 = new A(0.5), u3 && (e5.s = 1), X2(e5)) : (i3 = Math.abs(+P(e5))) % 2, s4 = new A(h3); ; ) {
                if (c3) {
                  if (!(s4 = s4.times(l2)).c)
                    break;
                  a4 ? s4.c.length > a4 && (s4.c.length = a4) : n2 && (s4 = s4.mod(t5));
                }
                if (i3) {
                  if (0 === (i3 = R2(i3 / 2)))
                    break;
                  c3 = i3 % 2;
                } else if (j(e5 = e5.times(r3), e5.e + 1, 1), 14 < e5.e)
                  c3 = X2(e5);
                else {
                  if (0 == (i3 = +P(e5)))
                    break;
                  c3 = i3 % 2;
                }
                l2 = l2.times(l2), a4 ? l2.c && l2.c.length > a4 && (l2.c.length = a4) : n2 && (l2 = l2.mod(t5));
              }
              return n2 ? s4 : (u3 && (s4 = h3.div(s4)), t5 ? s4.mod(t5) : a4 ? j(s4, N, b2, void 0) : s4);
            }, n.integerValue = function(e5) {
              var t5 = new A(this);
              return null == e5 ? e5 = b2 : J(e5, 0, 8), j(t5, t5.e + 1, e5);
            }, n.isEqualTo = n.eq = function(e5, t5) {
              return 0 === K2(this, new A(e5, t5));
            }, n.isFinite = function() {
              return !!this.c;
            }, n.isGreaterThan = n.gt = function(e5, t5) {
              return 0 < K2(this, new A(e5, t5));
            }, n.isGreaterThanOrEqualTo = n.gte = function(e5, t5) {
              return 1 === (t5 = K2(this, new A(e5, t5))) || 0 === t5;
            }, n.isInteger = function() {
              return !!this.c && H3(this.e / V) > this.c.length - 2;
            }, n.isLessThan = n.lt = function(e5, t5) {
              return K2(this, new A(e5, t5)) < 0;
            }, n.isLessThanOrEqualTo = n.lte = function(e5, t5) {
              return -1 === (t5 = K2(this, new A(e5, t5))) || 0 === t5;
            }, n.isNaN = function() {
              return !this.s;
            }, n.isNegative = function() {
              return this.s < 0;
            }, n.isPositive = function() {
              return 0 < this.s;
            }, n.isZero = function() {
              return !!this.c && 0 == this.c[0];
            }, n.minus = function(e5, t5) {
              var r3, n2, i3, a4, o2 = this, u3 = o2.s;
              if (t5 = (e5 = new A(e5, t5)).s, !u3 || !t5)
                return new A(NaN);
              if (u3 != t5)
                return e5.s = -t5, o2.plus(e5);
              var c3 = o2.e / V, s4 = e5.e / V, l2 = o2.c, f2 = e5.c;
              if (!c3 || !s4) {
                if (!l2 || !f2)
                  return l2 ? (e5.s = -t5, e5) : new A(f2 ? o2 : NaN);
                if (!l2[0] || !f2[0])
                  return f2[0] ? (e5.s = -t5, e5) : new A(l2[0] ? o2 : 3 == b2 ? -0 : 0);
              }
              if (c3 = H3(c3), s4 = H3(s4), l2 = l2.slice(), u3 = c3 - s4) {
                for ((i3 = (a4 = u3 < 0) ? (u3 = -u3, l2) : (s4 = c3, f2)).reverse(), t5 = u3; t5--; i3.push(0))
                  ;
                i3.reverse();
              } else
                for (n2 = (a4 = (u3 = l2.length) < (t5 = f2.length)) ? u3 : t5, u3 = t5 = 0; t5 < n2; t5++)
                  if (l2[t5] != f2[t5]) {
                    a4 = l2[t5] < f2[t5];
                    break;
                  }
              if (a4 && (i3 = l2, l2 = f2, f2 = i3, e5.s = -e5.s), 0 < (t5 = (n2 = f2.length) - (r3 = l2.length)))
                for (; t5--; l2[r3++] = 0)
                  ;
              for (t5 = G2 - 1; u3 < n2; ) {
                if (l2[--n2] < f2[n2]) {
                  for (r3 = n2; r3 && !l2[--r3]; l2[r3] = t5)
                    ;
                  --l2[r3], l2[n2] += G2;
                }
                l2[n2] -= f2[n2];
              }
              for (; 0 == l2[0]; l2.splice(0, 1), --s4)
                ;
              return l2[0] ? L2(e5, l2, s4) : (e5.s = 3 == b2 ? -1 : 1, e5.c = [e5.e = 0], e5);
            }, n.modulo = n.mod = function(e5, t5) {
              var r3, n2, i3 = this;
              return e5 = new A(e5, t5), !i3.c || !e5.s || e5.c && !e5.c[0] ? new A(NaN) : !e5.c || i3.c && !i3.c[0] ? new A(i3) : (9 == a3 ? (n2 = e5.s, e5.s = 1, r3 = v(i3, e5, 0, 3), e5.s = n2, r3.s *= n2) : r3 = v(i3, e5, 0, a3), (e5 = i3.minus(r3.times(e5))).c[0] || 1 != a3 || (e5.s = i3.s), e5);
            }, n.multipliedBy = n.times = function(e5, t5) {
              var r3, n2, i3, a4, o2, u3, c3, s4, l2, f2, g2, p2, d4, h4, v2, m4 = this, y4 = m4.c, b3 = (e5 = new A(e5, t5)).c;
              if (!(y4 && b3 && y4[0] && b3[0]))
                return !m4.s || !e5.s || y4 && !y4[0] && !b3 || b3 && !b3[0] && !y4 ? e5.c = e5.e = e5.s = null : (e5.s *= m4.s, y4 && b3 ? (e5.c = [0], e5.e = 0) : e5.c = e5.e = null), e5;
              for (n2 = H3(m4.e / V) + H3(e5.e / V), e5.s *= m4.s, (c3 = y4.length) < (f2 = b3.length) && (d4 = y4, y4 = b3, b3 = d4, i3 = c3, c3 = f2, f2 = i3), i3 = c3 + f2, d4 = []; i3--; d4.push(0))
                ;
              for (h4 = G2, v2 = z2, i3 = f2; 0 <= --i3; ) {
                for (r3 = 0, g2 = b3[i3] % v2, p2 = b3[i3] / v2 | 0, a4 = i3 + (o2 = c3); i3 < a4; )
                  r3 = ((s4 = g2 * (s4 = y4[--o2] % v2) + (u3 = p2 * s4 + (l2 = y4[o2] / v2 | 0) * g2) % v2 * v2 + d4[a4] + r3) / h4 | 0) + (u3 / v2 | 0) + p2 * l2, d4[a4--] = s4 % h4;
                d4[a4] = r3;
              }
              return r3 ? ++n2 : d4.splice(0, 1), L2(e5, d4, n2);
            }, n.negated = function() {
              var e5 = new A(this);
              return e5.s = -e5.s || null, e5;
            }, n.plus = function(e5, t5) {
              var r3, n2 = this, i3 = n2.s;
              if (t5 = (e5 = new A(e5, t5)).s, !i3 || !t5)
                return new A(NaN);
              if (i3 != t5)
                return e5.s = -t5, n2.minus(e5);
              var a4 = n2.e / V, o2 = e5.e / V, u3 = n2.c, c3 = e5.c;
              if (!a4 || !o2) {
                if (!u3 || !c3)
                  return new A(i3 / 0);
                if (!u3[0] || !c3[0])
                  return c3[0] ? e5 : new A(u3[0] ? n2 : 0 * i3);
              }
              if (a4 = H3(a4), o2 = H3(o2), u3 = u3.slice(), i3 = a4 - o2) {
                for ((r3 = 0 < i3 ? (o2 = a4, c3) : (i3 = -i3, u3)).reverse(); i3--; r3.push(0))
                  ;
                r3.reverse();
              }
              for ((i3 = u3.length) - (t5 = c3.length) < 0 && (r3 = c3, c3 = u3, u3 = r3, t5 = i3), i3 = 0; t5; )
                i3 = (u3[--t5] = u3[t5] + c3[t5] + i3) / G2 | 0, u3[t5] = G2 === u3[t5] ? 0 : u3[t5] % G2;
              return i3 && (u3 = [i3].concat(u3), ++o2), L2(e5, u3, o2);
            }, n.precision = n.sd = function(e5, t5) {
              var r3, n2, i3;
              if (null != e5 && e5 !== !!e5)
                return J(e5, 1, W), null == t5 ? t5 = b2 : J(t5, 0, 8), j(new A(this), e5, t5);
              if (!(r3 = this.c))
                return null;
              if (n2 = (i3 = r3.length - 1) * V + 1, i3 = r3[i3]) {
                for (; i3 % 10 == 0; i3 /= 10, n2--)
                  ;
                for (i3 = r3[0]; 10 <= i3; i3 /= 10, n2++)
                  ;
              }
              return e5 && this.e + 1 > n2 && (n2 = this.e + 1), n2;
            }, n.shiftedBy = function(e5) {
              return J(e5, -q2, q2), this.times("1e" + e5);
            }, n.squareRoot = n.sqrt = function() {
              var e5, t5, r3, n2, i3, a4 = this, o2 = a4.c, u3 = a4.s, c3 = a4.e, s4 = y3 + 4, l2 = new A("0.5");
              if (1 !== u3 || !o2 || !o2[0])
                return new A(!u3 || u3 < 0 && (!o2 || o2[0]) ? NaN : o2 ? a4 : 1 / 0);
              if ((r3 = 0 == (u3 = Math.sqrt(+P(a4))) || u3 == 1 / 0 ? (((t5 = Y2(o2)).length + c3) % 2 == 0 && (t5 += "0"), u3 = Math.sqrt(+t5), c3 = H3((c3 + 1) / 2) - (c3 < 0 || c3 % 2), new A(t5 = u3 == 1 / 0 ? "1e" + c3 : (t5 = u3.toExponential()).slice(0, t5.indexOf("e") + 1) + c3)) : new A(u3 + "")).c[0]) {
                for ((u3 = (c3 = r3.e) + s4) < 3 && (u3 = 0); ; )
                  if (i3 = r3, r3 = l2.times(i3.plus(v(a4, i3, s4, 1))), Y2(i3.c).slice(0, u3) === (t5 = Y2(r3.c)).slice(0, u3)) {
                    if (r3.e < c3 && --u3, "9999" != (t5 = t5.slice(u3 - 3, u3 + 1)) && (n2 || "4999" != t5)) {
                      +t5 && (+t5.slice(1) || "5" != t5.charAt(0)) || (j(r3, r3.e + y3 + 2, 1), e5 = !r3.times(r3).eq(a4));
                      break;
                    }
                    if (!n2 && (j(i3, i3.e + y3 + 2, 0), i3.times(i3).eq(a4))) {
                      r3 = i3;
                      break;
                    }
                    s4 += 4, u3 += 4, n2 = 1;
                  }
              }
              return j(r3, r3.e + y3 + 1, b2, e5);
            }, n.toExponential = function(e5, t5) {
              return null != e5 && (J(e5, 0, W), e5++), i2(this, e5, t5, 1);
            }, n.toFixed = function(e5, t5) {
              return null != e5 && (J(e5, 0, W), e5 = e5 + this.e + 1), i2(this, e5, t5);
            }, n.toFormat = function(e5, t5, r3) {
              var n2;
              if (null == r3)
                null != e5 && t5 && "object" == typeof t5 ? (r3 = t5, t5 = null) : e5 && "object" == typeof e5 ? (r3 = e5, e5 = t5 = null) : r3 = B2;
              else if ("object" != typeof r3)
                throw Error(I2 + "Argument not an object: " + r3);
              if (n2 = this.toFixed(e5, t5), this.c) {
                var i3, a4 = n2.split("."), o2 = +r3.groupSize, u3 = +r3.secondaryGroupSize, c3 = r3.groupSeparator || "", s4 = a4[0], l2 = a4[1], f2 = this.s < 0, g2 = f2 ? s4.slice(1) : s4, p2 = g2.length;
                if (u3 && (i3 = o2, o2 = u3, p2 -= u3 = i3), 0 < o2 && 0 < p2) {
                  for (i3 = p2 % o2 || o2, s4 = g2.substr(0, i3); i3 < p2; i3 += o2)
                    s4 += c3 + g2.substr(i3, o2);
                  0 < u3 && (s4 += c3 + g2.slice(i3)), f2 && (s4 = "-" + s4);
                }
                n2 = l2 ? s4 + (r3.decimalSeparator || "") + ((u3 = +r3.fractionGroupSize) ? l2.replace(new RegExp("\\d{" + u3 + "}\\B", "g"), "$&" + (r3.fractionGroupSeparator || "")) : l2) : s4;
              }
              return (r3.prefix || "") + n2 + (r3.suffix || "");
            }, n.toFraction = function(e5) {
              var t5, r3, n2, i3, a4, o2, u3, c3, s4, l2, f2, g2, p2 = this, d4 = p2.c;
              if (null != e5 && (!(u3 = new A(e5)).isInteger() && (u3.c || 1 !== u3.s) || u3.lt(h3)))
                throw Error(I2 + "Argument " + (u3.isInteger() ? "out of range: " : "not an integer: ") + P(u3));
              if (!d4)
                return new A(p2);
              for (t5 = new A(h3), s4 = r3 = new A(h3), n2 = c3 = new A(h3), g2 = Y2(d4), a4 = t5.e = g2.length - p2.e - 1, t5.c[0] = Z[(o2 = a4 % V) < 0 ? V + o2 : o2], e5 = !e5 || 0 < u3.comparedTo(t5) ? 0 < a4 ? t5 : s4 : u3, o2 = O2, O2 = 1 / 0, u3 = new A(g2), c3.c[0] = 0; l2 = v(u3, t5, 0, 1), 1 != (i3 = r3.plus(l2.times(n2))).comparedTo(e5); )
                r3 = n2, n2 = i3, s4 = c3.plus(l2.times(i3 = s4)), c3 = i3, t5 = u3.minus(l2.times(i3 = t5)), u3 = i3;
              return i3 = v(e5.minus(r3), n2, 0, 1), c3 = c3.plus(i3.times(s4)), r3 = r3.plus(i3.times(n2)), c3.s = s4.s = p2.s, f2 = v(s4, n2, a4 *= 2, b2).minus(p2).abs().comparedTo(v(c3, r3, a4, b2).minus(p2).abs()) < 1 ? [s4, n2] : [c3, r3], O2 = o2, f2;
            }, n.toNumber = function() {
              return +P(this);
            }, n.toPrecision = function(e5, t5) {
              return null != e5 && J(e5, 1, W), i2(this, e5, t5, 2);
            }, n.toString = function(e5) {
              var t5, r3 = this, n2 = r3.s, i3 = r3.e;
              return null === i3 ? n2 ? (t5 = "Infinity", n2 < 0 && (t5 = "-" + t5)) : t5 = "NaN" : (t5 = null == e5 ? i3 <= d3 || w2 <= i3 ? Q2(Y2(r3.c), i3) : ee(Y2(r3.c), i3, "0") : 10 === e5 ? ee(Y2((r3 = j(new A(r3), y3 + i3 + 1, b2)).c), r3.e, "0") : (J(e5, 2, M3.length, "Base"), f(ee(Y2(r3.c), i3, "0"), 10, e5, n2, true)), n2 < 0 && r3.c[0] && (t5 = "-" + t5)), t5;
            }, n.valueOf = n.toJSON = function() {
              return P(this);
            }, n._isBigNumber = true, C && (n[Symbol.toStringTag] = "BigNumber", n[Symbol.for("nodejs.util.inspect.custom")] = n.valueOf), null != t4 && A.set(t4), A;
          }()).default = t3.BigNumber = t3, void 0 !== r && r.exports ? r.exports = t3 : (e3 = e3 || ("undefined" != typeof self && self ? self : window)).BigNumber = t3;
        }(this);
      }, {}], 2: [function(e2, t2, r) {
        "use strict";
        t2.exports = { languageTag: "en-US", delimiters: { thousands: ",", decimal: "." }, abbreviations: { thousand: "k", million: "m", billion: "b", trillion: "t" }, spaceSeparated: false, ordinal: function(e3) {
          var t3 = e3 % 10;
          return 1 == ~~(e3 % 100 / 10) ? "th" : 1 == t3 ? "st" : 2 == t3 ? "nd" : 3 == t3 ? "rd" : "th";
        }, bytes: { binarySuffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"], decimalSuffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"] }, currency: { symbol: "$", position: "prefix", code: "USD" }, currencyFormat: { thousandSeparated: true, totalLength: 4, spaceSeparated: true, spaceSeparatedCurrency: true }, formats: { fourDigits: { totalLength: 4, spaceSeparated: true }, fullWithTwoDecimals: { output: "currency", thousandSeparated: true, mantissa: 2 }, fullWithTwoDecimalsNoCurrency: { thousandSeparated: true, mantissa: 2 }, fullWithNoDecimals: { output: "currency", thousandSeparated: true, mantissa: 0 } } };
      }, {}], 3: [function(e2, t2, r) {
        "use strict";
        function I2(e3, t3) {
          return function(e4) {
            if (Array.isArray(e4))
              return e4;
          }(e3) || function(e4, t4) {
            if (!(Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4)))
              return;
            var r2 = [], n2 = true, i3 = false, a4 = void 0;
            try {
              for (var o2, u3 = e4[Symbol.iterator](); !(n2 = (o2 = u3.next()).done) && (r2.push(o2.value), !t4 || r2.length !== t4); n2 = true)
                ;
            } catch (e5) {
              i3 = true, a4 = e5;
            } finally {
              try {
                n2 || null == u3.return || u3.return();
              } finally {
                if (i3)
                  throw a4;
              }
            }
            return r2;
          }(e3, t3) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }();
        }
        var $ = e2("./globalState"), o = e2("./validating"), u2 = e2("./parsing"), i2 = e2("bignumber.js"), G2 = { trillion: Math.pow(10, 12), billion: Math.pow(10, 9), million: Math.pow(10, 6), thousand: Math.pow(10, 3) }, V = { totalLength: 0, characteristic: 0, forceAverage: false, average: false, mantissa: -1, optionalMantissa: true, thousandSeparated: false, spaceSeparated: false, negative: "sign", forceSign: false, roundingFunction: Math.round, spaceSeparatedAbbreviation: false }, n = $.currentBytes(), d3 = n.binarySuffixes, h3 = n.decimalSuffixes, a3 = { general: { scale: 1024, suffixes: h3, marker: "bd" }, binary: { scale: 1024, suffixes: d3, marker: "b" }, decimal: { scale: 1e3, suffixes: h3, marker: "d" } };
        function c2(e3) {
          var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r2 = 2 < arguments.length ? arguments[2] : void 0;
          if ("string" == typeof t3 && (t3 = u2.parseFormat(t3)), !o.validateFormat(t3))
            return "ERROR: invalid format";
          var n2 = t3.prefix || "", i3 = t3.postfix || "", a4 = function(e4, t4, r3) {
            switch (t4.output) {
              case "currency":
                return t4 = s3(t4, $.currentCurrencyDefaultFormat()), function(e5, t5, r4) {
                  var n3 = r4.currentCurrency(), i4 = Object.assign({}, t5), a5 = Object.assign({}, V, i4), o2 = void 0, u3 = "", c3 = !!a5.totalLength || !!a5.forceAverage || a5.average, s4 = i4.currencyPosition || n3.position, l = i4.currencySymbol || n3.symbol, f = void 0 !== a5.spaceSeparatedCurrency ? a5.spaceSeparatedCurrency : a5.spaceSeparated;
                  void 0 === i4.lowPrecision && (i4.lowPrecision = false);
                  f && (u3 = " ");
                  "infix" === s4 && (o2 = u3 + l + u3);
                  var g2 = m3({ instance: e5, providedFormat: i4, state: r4, decimalSeparator: o2 });
                  "prefix" === s4 && (g2 = e5._value < 0 && "sign" === a5.negative ? "-".concat(u3).concat(l).concat(g2.slice(1)) : 0 < e5._value && a5.forceSign ? "+".concat(u3).concat(l).concat(g2.slice(1)) : l + u3 + g2);
                  s4 && "postfix" !== s4 || (u3 = !a5.spaceSeparatedAbbreviation && c3 ? "" : u3, g2 = g2 + u3 + l);
                  return g2;
                }(e4, t4, $);
              case "percent":
                return t4 = s3(t4, $.currentPercentageDefaultFormat()), function(e5, t5, r4, n3) {
                  var i4 = t5.prefixSymbol, a5 = m3({ instance: n3(100 * e5._value), providedFormat: t5, state: r4 }), o2 = Object.assign({}, V, t5);
                  if (i4)
                    return "%".concat(o2.spaceSeparated ? " " : "").concat(a5);
                  return "".concat(a5).concat(o2.spaceSeparated ? " " : "", "%");
                }(e4, t4, $, r3);
              case "byte":
                return t4 = s3(t4, $.currentByteDefaultFormat()), function(e5, t5, r4, n3) {
                  var i4 = t5.base || "binary", a5 = Object.assign({}, V, t5), o2 = r4.currentBytes(), u3 = o2.binarySuffixes, c3 = o2.decimalSuffixes, s4 = { general: { scale: 1024, suffixes: c3 || h3, marker: "bd" }, binary: { scale: 1024, suffixes: u3 || d3, marker: "b" }, decimal: { scale: 1e3, suffixes: c3 || h3, marker: "d" } }[i4], l = v(e5._value, s4.suffixes, s4.scale), f = l.value, g2 = l.suffix, p = m3({ instance: n3(f), providedFormat: t5, state: r4, defaults: r4.currentByteDefaultFormat() });
                  return "".concat(p).concat(a5.spaceSeparated ? " " : "").concat(g2);
                }(e4, t4, $, r3);
              case "time":
                return t4 = s3(t4, $.currentTimeDefaultFormat()), function(e5) {
                  var t5 = Math.floor(e5._value / 60 / 60), r4 = Math.floor((e5._value - 60 * t5 * 60) / 60), n3 = Math.round(e5._value - 60 * t5 * 60 - 60 * r4);
                  return "".concat(t5, ":").concat(r4 < 10 ? "0" : "").concat(r4, ":").concat(n3 < 10 ? "0" : "").concat(n3);
                }(e4);
              case "ordinal":
                return t4 = s3(t4, $.currentOrdinalDefaultFormat()), function(e5, t5, r4) {
                  var n3 = r4.currentOrdinal(), i4 = Object.assign({}, V, t5), a5 = m3({ instance: e5, providedFormat: t5, state: r4 }), o2 = n3(e5._value);
                  return "".concat(a5).concat(i4.spaceSeparated ? " " : "").concat(o2);
                }(e4, t4, $);
              case "number":
              default:
                return m3({ instance: e4, providedFormat: t4, numbro: r3 });
            }
          }(e3, t3, r2);
          return a4 = (a4 = n2 + a4) + i3;
        }
        function v(e3, t3, r2) {
          var n2 = t3[0], i3 = Math.abs(e3);
          if (r2 <= i3) {
            for (var a4 = 1; a4 < t3.length; ++a4) {
              var o2 = Math.pow(r2, a4), u3 = Math.pow(r2, a4 + 1);
              if (o2 <= i3 && i3 < u3) {
                n2 = t3[a4], e3 /= o2;
                break;
              }
            }
            n2 === t3[0] && (e3 /= Math.pow(r2, t3.length - 1), n2 = t3[t3.length - 1]);
          }
          return { value: e3, suffix: n2 };
        }
        function g(e3) {
          for (var t3 = "", r2 = 0; r2 < e3; r2++)
            t3 += "0";
          return t3;
        }
        function q2(e3, t3, r2) {
          var n2 = 2 < arguments.length && void 0 !== r2 ? r2 : Math.round;
          return -1 !== e3.toString().indexOf("e") ? function(e4, t4) {
            var r3 = e4.toString(), n3 = I2(r3.split("e"), 2), i3 = n3[0], a4 = n3[1], o2 = I2(i3.split("."), 2), u3 = o2[0], c3 = o2[1], s4 = void 0 === c3 ? "" : c3;
            if (0 < +a4)
              r3 = u3 + s4 + g(a4 - s4.length);
            else {
              var l = ".";
              l = +u3 < 0 ? "-0".concat(l) : "0".concat(l);
              var f = (g(-a4 - 1) + Math.abs(u3) + s4).substr(0, t4);
              f.length < t4 && (f += g(t4 - f.length)), r3 = l + f;
            }
            return 0 < +a4 && 0 < t4 && (r3 += ".".concat(g(t4))), r3;
          }(e3, t3) : new i2(n2(+"".concat(e3, "e+").concat(t3)) / Math.pow(10, t3)).toFixed(t3);
        }
        function Z(e3, t3, r2, n2, i3) {
          var a4 = n2.currentDelimiters(), o2 = a4.thousands;
          i3 = i3 || a4.decimal;
          var u3 = a4.thousandsSize || 3, c3 = e3.toString(), s4 = c3.split(".")[0], l = c3.split(".")[1], f = t3 < 0 && 0 === s4.indexOf("-");
          r2 && (f && (s4 = s4.slice(1)), function(e4, t4) {
            for (var r3 = [], n3 = 0, i4 = e4; 0 < i4; i4--)
              n3 === t4 && (r3.unshift(i4), n3 = 0), n3++;
            return r3;
          }(s4.length, u3).forEach(function(e4, t4) {
            s4 = s4.slice(0, e4 + t4) + o2 + s4.slice(e4 + t4);
          }), f && (s4 = "-".concat(s4)));
          return c3 = l ? s4 + i3 + l : s4;
        }
        function m3(e3) {
          var t3 = e3.instance, r2 = e3.providedFormat, n2 = e3.state, i3 = void 0 === n2 ? $ : n2, a4 = e3.decimalSeparator, o2 = e3.defaults, u3 = void 0 === o2 ? i3.currentDefaults() : o2, c3 = t3._value;
          if (0 === c3 && i3.hasZeroFormat())
            return i3.getZeroFormat();
          if (!isFinite(c3))
            return c3.toString();
          var s4, l, f, g2, p, d4, h4, v2, m4 = Object.assign({}, V, u3, r2), y3 = m4.totalLength, b2 = y3 ? 0 : m4.characteristic, w2 = m4.optionalCharacteristic, S3 = m4.forceAverage, O2 = m4.lowPrecision, x2 = !!y3 || !!S3 || m4.average, N = y3 ? -1 : x2 && void 0 === r2.mantissa ? 0 : m4.mantissa, B2 = !y3 && (void 0 === r2.optionalMantissa ? -1 === N : m4.optionalMantissa), M3 = m4.trimMantissa, A = m4.thousandSeparated, D2 = m4.spaceSeparated, E2 = m4.negative, F = m4.forceSign, k2 = m4.exponential, _ = m4.roundingFunction, L2 = "";
          if (x2) {
            var j = function(e4) {
              var t4 = e4.value, r3 = e4.forceAverage, n3 = e4.lowPrecision, i4 = void 0 === n3 || n3, a5 = e4.abbreviations, o3 = e4.spaceSeparated, u4 = void 0 !== o3 && o3, c4 = e4.totalLength, s5 = void 0 === c4 ? 0 : c4, l2 = e4.roundingFunction, f2 = void 0 === l2 ? Math.round : l2, g3 = "", p2 = Math.abs(t4), d5 = -1;
              if (r3 && a5[r3] && G2[r3] ? (g3 = a5[r3], t4 /= G2[r3]) : p2 >= G2.trillion || i4 && 1 === f2(p2 / G2.trillion) ? (g3 = a5.trillion, t4 /= G2.trillion) : p2 < G2.trillion && p2 >= G2.billion || i4 && 1 === f2(p2 / G2.billion) ? (g3 = a5.billion, t4 /= G2.billion) : p2 < G2.billion && p2 >= G2.million || i4 && 1 === f2(p2 / G2.million) ? (g3 = a5.million, t4 /= G2.million) : (p2 < G2.million && p2 >= G2.thousand || i4 && 1 === f2(p2 / G2.thousand)) && (g3 = a5.thousand, t4 /= G2.thousand), g3 = g3 && (u4 ? " " : "") + g3, s5) {
                var h5 = t4 < 0, v3 = t4.toString().split(".")[0], m5 = h5 ? v3.length - 1 : v3.length;
                d5 = Math.max(s5 - m5, 0);
              }
              return { value: t4, abbreviation: g3, mantissaPrecision: d5 };
            }({ value: c3, forceAverage: S3, lowPrecision: O2, abbreviations: i3.currentAbbreviations(), spaceSeparated: D2, roundingFunction: _, totalLength: y3 });
            c3 = j.value, L2 += j.abbreviation, y3 && (N = j.mantissaPrecision);
          }
          if (k2) {
            var P = (l = (s4 = { value: c3, characteristicPrecision: b2 }).value, f = s4.characteristicPrecision, g2 = void 0 === f ? 0 : f, p = I2(l.toExponential().split("e"), 2), d4 = p[0], h4 = p[1], v2 = +d4, g2 && 1 < g2 && (v2 *= Math.pow(10, g2 - 1), h4 = 0 <= (h4 -= g2 - 1) ? "+".concat(h4) : h4), { value: v2, abbreviation: "e".concat(h4) });
            c3 = P.value, L2 = P.abbreviation + L2;
          }
          var T2, C, U, R2 = function(e4, t4, r3, n3, i4, a5) {
            if (-1 === n3)
              return e4;
            var o3 = q2(t4, n3, a5), u4 = I2(o3.toString().split("."), 2), c4 = u4[0], s5 = u4[1], l2 = void 0 === s5 ? "" : s5;
            if (l2.match(/^0+$/) && (r3 || i4))
              return c4;
            var f2 = l2.match(/0+$/);
            return i4 && f2 ? "".concat(c4, ".").concat(l2.toString().slice(0, f2.index)) : o3.toString();
          }(c3.toString(), c3, B2, N, M3, _);
          return R2 = Z(R2 = function(e4, t4, r3, n3) {
            var i4 = e4, a5 = I2(i4.toString().split("."), 2), o3 = a5[0], u4 = a5[1];
            if (o3.match(/^-?0$/) && r3)
              return u4 ? "".concat(o3.replace("0", ""), ".").concat(u4) : o3.replace("0", "");
            var c4 = t4 < 0 && 0 === o3.indexOf("-");
            if (c4 && (o3 = o3.slice(1), i4 = i4.slice(1)), o3.length < n3)
              for (var s5 = n3 - o3.length, l2 = 0; l2 < s5; l2++)
                i4 = "0".concat(i4);
            return c4 && (i4 = "-".concat(i4)), i4.toString();
          }(R2, c3, w2, b2), c3, A, i3, a4), (x2 || k2) && (R2 = R2 + L2), (F || c3 < 0) && (T2 = R2, U = E2, R2 = 0 === (C = c3) ? T2 : 0 == +T2 ? T2.replace("-", "") : 0 < C ? "+".concat(T2) : "sign" === U ? T2 : "(".concat(T2.replace("-", ""), ")")), R2;
        }
        function s3(e3, t3) {
          if (!e3)
            return t3;
          var r2 = Object.keys(e3);
          return 1 === r2.length && "output" === r2[0] ? t3 : e3;
        }
        t2.exports = function(n2) {
          return { format: function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return c2.apply(void 0, t3.concat([n2]));
          }, getByteUnit: function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return function(e4) {
              var t4 = a3.general;
              return v(e4._value, t4.suffixes, t4.scale).suffix;
            }.apply(void 0, t3.concat([n2]));
          }, getBinaryByteUnit: function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return function(e4) {
              var t4 = a3.binary;
              return v(e4._value, t4.suffixes, t4.scale).suffix;
            }.apply(void 0, t3.concat([n2]));
          }, getDecimalByteUnit: function() {
            for (var e3 = arguments.length, t3 = new Array(e3), r2 = 0; r2 < e3; r2++)
              t3[r2] = arguments[r2];
            return function(e4) {
              var t4 = a3.decimal;
              return v(e4._value, t4.suffixes, t4.scale).suffix;
            }.apply(void 0, t3.concat([n2]));
          }, formatOrDefault: s3 };
        };
      }, { "./globalState": 4, "./parsing": 8, "./validating": 10, "bignumber.js": 1 }], 4: [function(e2, t2, r) {
        "use strict";
        var i2 = e2("./en-US"), n = e2("./validating"), a3 = e2("./parsing"), o = {}, u2 = void 0, c2 = {}, s3 = null, l = {};
        function f(e3) {
          u2 = e3;
        }
        function g() {
          return c2[u2];
        }
        o.languages = function() {
          return Object.assign({}, c2);
        }, o.currentLanguage = function() {
          return u2;
        }, o.currentBytes = function() {
          return g().bytes || {};
        }, o.currentCurrency = function() {
          return g().currency;
        }, o.currentAbbreviations = function() {
          return g().abbreviations;
        }, o.currentDelimiters = function() {
          return g().delimiters;
        }, o.currentOrdinal = function() {
          return g().ordinal;
        }, o.currentDefaults = function() {
          return Object.assign({}, g().defaults, l);
        }, o.currentOrdinalDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().ordinalFormat);
        }, o.currentByteDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().byteFormat);
        }, o.currentPercentageDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().percentageFormat);
        }, o.currentCurrencyDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().currencyFormat);
        }, o.currentTimeDefaultFormat = function() {
          return Object.assign({}, o.currentDefaults(), g().timeFormat);
        }, o.setDefaults = function(e3) {
          e3 = a3.parseFormat(e3), n.validateFormat(e3) && (l = e3);
        }, o.getZeroFormat = function() {
          return s3;
        }, o.setZeroFormat = function(e3) {
          return s3 = "string" == typeof e3 ? e3 : null;
        }, o.hasZeroFormat = function() {
          return null !== s3;
        }, o.languageData = function(e3) {
          if (e3) {
            if (c2[e3])
              return c2[e3];
            throw new Error('Unknown tag "'.concat(e3, '"'));
          }
          return g();
        }, o.registerLanguage = function(e3) {
          var t3 = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
          if (!n.validateLanguage(e3))
            throw new Error("Invalid language data");
          c2[e3.languageTag] = e3, t3 && f(e3.languageTag);
        }, o.setLanguage = function(e3) {
          var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : i2.languageTag;
          if (!c2[e3]) {
            var r2 = e3.split("-")[0], n2 = Object.keys(c2).find(function(e4) {
              return e4.split("-")[0] === r2;
            });
            return c2[n2] ? void f(n2) : void f(t3);
          }
          f(e3);
        }, o.registerLanguage(i2), u2 = i2.languageTag, t2.exports = o;
      }, { "./en-US": 2, "./parsing": 8, "./validating": 10 }], 5: [function(n, e2, t2) {
        "use strict";
        e2.exports = function(t3) {
          return { loadLanguagesInNode: function(e3) {
            return r = t3, void e3.forEach(function(t4) {
              var e4 = void 0;
              try {
                e4 = n("../languages/".concat(t4));
              } catch (e5) {
                console.error('Unable to load "'.concat(t4, '". No matching language file found.'));
              }
              e4 && r.registerLanguage(e4);
            });
            var r;
          } };
        };
      }, {}], 6: [function(e2, t2, r) {
        "use strict";
        var c2 = e2("bignumber.js");
        function a3(e3, t3, r2) {
          var n = new c2(e3._value), i2 = t3;
          return r2.isNumbro(t3) && (i2 = t3._value), i2 = new c2(i2), e3._value = n.minus(i2).toNumber(), e3;
        }
        t2.exports = function(u2) {
          return { add: function(e3, t3) {
            return n = t3, i2 = u2, a4 = new c2((r2 = e3)._value), o = n, i2.isNumbro(n) && (o = n._value), o = new c2(o), r2._value = a4.plus(o).toNumber(), r2;
            var r2, n, i2, a4, o;
          }, subtract: function(e3, t3) {
            return a3(e3, t3, u2);
          }, multiply: function(e3, t3) {
            return n = t3, i2 = u2, a4 = new c2((r2 = e3)._value), o = n, i2.isNumbro(n) && (o = n._value), o = new c2(o), r2._value = a4.times(o).toNumber(), r2;
            var r2, n, i2, a4, o;
          }, divide: function(e3, t3) {
            return n = t3, i2 = u2, a4 = new c2((r2 = e3)._value), o = n, i2.isNumbro(n) && (o = n._value), o = new c2(o), r2._value = a4.dividedBy(o).toNumber(), r2;
            var r2, n, i2, a4, o;
          }, set: function(e3, t3) {
            return r2 = e3, i2 = n = t3, u2.isNumbro(n) && (i2 = n._value), r2._value = i2, r2;
            var r2, n, i2;
          }, difference: function(e3, t3) {
            return r2 = t3, a3(i2 = (n = u2)(e3._value), r2, n), Math.abs(i2._value);
            var r2, n, i2;
          }, BigNumber: c2 };
        };
      }, { "bignumber.js": 1 }], 7: [function(e2, t2, r) {
        "use strict";
        function i2(e3, t3) {
          for (var r2 = 0; r2 < t3.length; r2++) {
            var n2 = t3[r2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
          }
        }
        var a3 = e2("./globalState"), n = e2("./validating"), o = e2("./loading")(p), u2 = e2("./unformatting"), c2 = e2("./formatting")(p), s3 = e2("./manipulating")(p), l = e2("./parsing"), f = function() {
          function t3(e4) {
            !function(e5, t4) {
              if (!(e5 instanceof t4))
                throw new TypeError("Cannot call a class as a function");
            }(this, t3), this._value = e4;
          }
          var e3, r2, n2;
          return e3 = t3, (r2 = [{ key: "clone", value: function() {
            return p(this._value);
          } }, { key: "format", value: function(e4) {
            var t4 = 0 < arguments.length && void 0 !== e4 ? e4 : {};
            return c2.format(this, t4);
          } }, { key: "formatCurrency", value: function(e4) {
            return "string" == typeof e4 && (e4 = l.parseFormat(e4)), (e4 = c2.formatOrDefault(e4, a3.currentCurrencyDefaultFormat())).output = "currency", c2.format(this, e4);
          } }, { key: "formatTime", value: function(e4) {
            var t4 = 0 < arguments.length && void 0 !== e4 ? e4 : {};
            return t4.output = "time", c2.format(this, t4);
          } }, { key: "binaryByteUnits", value: function() {
            return c2.getBinaryByteUnit(this);
          } }, { key: "decimalByteUnits", value: function() {
            return c2.getDecimalByteUnit(this);
          } }, { key: "byteUnits", value: function() {
            return c2.getByteUnit(this);
          } }, { key: "difference", value: function(e4) {
            return s3.difference(this, e4);
          } }, { key: "add", value: function(e4) {
            return s3.add(this, e4);
          } }, { key: "subtract", value: function(e4) {
            return s3.subtract(this, e4);
          } }, { key: "multiply", value: function(e4) {
            return s3.multiply(this, e4);
          } }, { key: "divide", value: function(e4) {
            return s3.divide(this, e4);
          } }, { key: "set", value: function(e4) {
            return s3.set(this, g(e4));
          } }, { key: "value", value: function() {
            return this._value;
          } }, { key: "valueOf", value: function() {
            return this._value;
          } }]) && i2(e3.prototype, r2), n2 && i2(e3, n2), t3;
        }();
        function g(e3) {
          var t3 = e3;
          return p.isNumbro(e3) ? t3 = e3._value : "string" == typeof e3 ? t3 = p.unformat(e3) : isNaN(e3) && (t3 = NaN), t3;
        }
        function p(e3) {
          return new f(g(e3));
        }
        p.version = "2.3.6", p.isNumbro = function(e3) {
          return e3 instanceof f;
        }, p.language = a3.currentLanguage, p.registerLanguage = a3.registerLanguage, p.setLanguage = a3.setLanguage, p.languages = a3.languages, p.languageData = a3.languageData, p.zeroFormat = a3.setZeroFormat, p.defaultFormat = a3.currentDefaults, p.setDefaults = a3.setDefaults, p.defaultCurrencyFormat = a3.currentCurrencyDefaultFormat, p.validate = n.validate, p.loadLanguagesInNode = o.loadLanguagesInNode, p.unformat = u2.unformat, p.BigNumber = s3.BigNumber, t2.exports = p;
      }, { "./formatting": 3, "./globalState": 4, "./loading": 5, "./manipulating": 6, "./parsing": 8, "./unformatting": 9, "./validating": 10 }], 8: [function(e2, t2, r) {
        "use strict";
        t2.exports = { parseFormat: function(e3) {
          var t3, r2, n, i2, a3, o, u2, c2, s3, l, f, g, p, d3, h3, v, m3, y3, b2, w2, S3, O2, x2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
          return "string" != typeof e3 ? e3 : (r2 = x2, e3 = (n = (t3 = e3).match(/^{([^}]*)}/)) ? (r2.prefix = n[1], t3.slice(n[0].length)) : t3, a3 = x2, function(e4, t4) {
            if (-1 === e4.indexOf("$")) {
              if (-1 === e4.indexOf("%"))
                return -1 !== e4.indexOf("bd") ? (t4.output = "byte", t4.base = "general") : -1 !== e4.indexOf("b") ? (t4.output = "byte", t4.base = "binary") : -1 !== e4.indexOf("d") ? (t4.output = "byte", t4.base = "decimal") : -1 === e4.indexOf(":") ? -1 !== e4.indexOf("o") && (t4.output = "ordinal") : t4.output = "time";
              t4.output = "percent";
            } else
              t4.output = "currency";
          }(e3 = (o = (i2 = e3).match(/{([^}]*)}$/)) ? (a3.postfix = o[1], i2.slice(0, -o[0].length)) : i2, x2), u2 = x2, (c2 = e3.match(/[1-9]+[0-9]*/)) && (u2.totalLength = +c2[0]), s3 = x2, (l = e3.split(".")[0].match(/0+/)) && (s3.characteristic = l[0].length), function(e4, t4) {
            if (-1 !== e4.indexOf(".")) {
              var r3 = e4.split(".")[0];
              t4.optionalCharacteristic = -1 === r3.indexOf("0");
            }
          }(e3, x2), f = x2, -1 !== e3.indexOf("a") && (f.average = true), p = x2, -1 !== (g = e3).indexOf("K") ? p.forceAverage = "thousand" : -1 !== g.indexOf("M") ? p.forceAverage = "million" : -1 !== g.indexOf("B") ? p.forceAverage = "billion" : -1 !== g.indexOf("T") && (p.forceAverage = "trillion"), function(e4, t4) {
            var r3 = e4.split(".")[1];
            if (r3) {
              var n2 = r3.match(/0+/);
              n2 && (t4.mantissa = n2[0].length);
            }
          }(e3, x2), h3 = x2, (d3 = e3).match(/\[\.]/) ? h3.optionalMantissa = true : d3.match(/\./) && (h3.optionalMantissa = false), v = x2, (m3 = e3.split(".")[1]) && (v.trimMantissa = -1 !== m3.indexOf("[")), y3 = x2, -1 !== e3.indexOf(",") && (y3.thousandSeparated = true), b2 = x2, -1 !== e3.indexOf(" ") && (b2.spaceSeparated = true, b2.spaceSeparatedCurrency = true, (b2.average || b2.forceAverage) && (b2.spaceSeparatedAbbreviation = true)), S3 = x2, (w2 = e3).match(/^\+?\([^)]*\)$/) && (S3.negative = "parenthesis"), w2.match(/^\+?-/) && (S3.negative = "sign"), O2 = x2, e3.match(/^\+/) && (O2.forceSign = true), x2);
        } };
      }, {}], 9: [function(g, e2, t2) {
        "use strict";
        var M3 = [{ key: "ZiB", factor: Math.pow(1024, 7) }, { key: "ZB", factor: Math.pow(1e3, 7) }, { key: "YiB", factor: Math.pow(1024, 8) }, { key: "YB", factor: Math.pow(1e3, 8) }, { key: "TiB", factor: Math.pow(1024, 4) }, { key: "TB", factor: Math.pow(1e3, 4) }, { key: "PiB", factor: Math.pow(1024, 5) }, { key: "PB", factor: Math.pow(1e3, 5) }, { key: "MiB", factor: Math.pow(1024, 2) }, { key: "MB", factor: Math.pow(1e3, 2) }, { key: "KiB", factor: Math.pow(1024, 1) }, { key: "KB", factor: Math.pow(1e3, 1) }, { key: "GiB", factor: Math.pow(1024, 3) }, { key: "GB", factor: Math.pow(1e3, 3) }, { key: "EiB", factor: Math.pow(1024, 6) }, { key: "EB", factor: Math.pow(1e3, 6) }, { key: "B", factor: 1 }];
        function A(e3) {
          return e3.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        }
        function p(e3, t3, r, n, i2, a3, o) {
          var u2 = 2 < arguments.length && void 0 !== r ? r : "", c2 = 3 < arguments.length ? n : void 0, s3 = 4 < arguments.length ? i2 : void 0, l = 5 < arguments.length ? a3 : void 0, f = 6 < arguments.length ? o : void 0;
          if ("" !== e3)
            return e3 === s3 ? 0 : function e4(t4, r2, n2, i3, a4, o2, u3) {
              var c3 = 2 < arguments.length && void 0 !== n2 ? n2 : "", s4 = 3 < arguments.length ? i3 : void 0, l2 = 4 < arguments.length ? a4 : void 0, f2 = 5 < arguments.length ? o2 : void 0, g2 = 6 < arguments.length ? u3 : void 0;
              if (!isNaN(+t4))
                return +t4;
              var p2 = "", d3 = t4.replace(/(^[^(]*)\((.*)\)([^)]*$)/, "$1$2$3");
              if (d3 !== t4)
                return -1 * e4(d3, r2, c3, s4, l2, f2, g2);
              for (var h3 = 0; h3 < M3.length; h3++) {
                var v = M3[h3];
                if ((p2 = t4.replace(RegExp("([0-9 ])(".concat(v.key, ")$")), "$1")) !== t4)
                  return e4(p2, r2, c3, s4, l2, f2, g2) * v.factor;
              }
              if ((p2 = t4.replace("%", "")) !== t4)
                return e4(p2, r2, c3, s4, l2, f2, g2) / 100;
              var m3 = parseFloat(t4);
              if (!isNaN(m3)) {
                var y3 = s4(m3);
                if (y3 && "." !== y3 && (p2 = t4.replace(new RegExp("".concat(A(y3), "$")), "")) !== t4)
                  return e4(p2, r2, c3, s4, l2, f2, g2);
                var b2 = {};
                Object.keys(f2).forEach(function(e5) {
                  b2[f2[e5]] = e5;
                });
                for (var w2 = Object.keys(b2).sort().reverse(), S3 = w2.length, O2 = 0; O2 < S3; O2++) {
                  var x2 = w2[O2], N = b2[x2];
                  if ((p2 = t4.replace(x2, "")) !== t4) {
                    var B2 = void 0;
                    switch (N) {
                      case "thousand":
                        B2 = Math.pow(10, 3);
                        break;
                      case "million":
                        B2 = Math.pow(10, 6);
                        break;
                      case "billion":
                        B2 = Math.pow(10, 9);
                        break;
                      case "trillion":
                        B2 = Math.pow(10, 12);
                    }
                    return e4(p2, r2, c3, s4, l2, f2, g2) * B2;
                  }
                }
              }
            }(function(e4, t4, r2) {
              var n2 = 2 < arguments.length && void 0 !== r2 ? r2 : "", i3 = e4.replace(n2, "");
              return i3 = (i3 = i3.replace(new RegExp("([0-9])".concat(A(t4.thousands), "([0-9])"), "g"), "$1$2")).replace(t4.decimal, ".");
            }(e3, t3, u2), t3, u2, c2, s3, l, f);
        }
        e2.exports = { unformat: function(e3, t3) {
          var r, n, i2, a3 = g("./globalState"), o = a3.currentDelimiters(), u2 = a3.currentCurrency().symbol, c2 = a3.currentOrdinal(), s3 = a3.getZeroFormat(), l = a3.currentAbbreviations(), f = void 0;
          if ("string" == typeof e3)
            f = function(e4, t4) {
              if (e4.indexOf(":") && ":" !== t4.thousands) {
                var r2 = e4.split(":");
                if (3 === r2.length) {
                  var n2 = +r2[0], i3 = +r2[1], a4 = +r2[2];
                  return !isNaN(n2) && !isNaN(i3) && !isNaN(a4);
                }
              }
            }(e3, o) ? (r = e3.split(":"), n = +r[0], i2 = +r[1], +r[2] + 60 * i2 + 3600 * n) : p(e3, o, u2, c2, s3, l, t3);
          else {
            if ("number" != typeof e3)
              return;
            f = e3;
          }
          if (void 0 !== f)
            return f;
        } };
      }, { "./globalState": 4 }], 10: [function(e2, t2, r) {
        "use strict";
        function n(e3) {
          return function(e4) {
            if (Array.isArray(e4)) {
              for (var t3 = 0, r2 = new Array(e4.length); t3 < e4.length; t3++)
                r2[t3] = e4[t3];
              return r2;
            }
          }(e3) || function(e4) {
            if (Symbol.iterator in Object(e4) || "[object Arguments]" === Object.prototype.toString.call(e4))
              return Array.from(e4);
          }(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance");
          }();
        }
        function f(e3) {
          return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          })(e3);
        }
        var i2 = e2("./unformatting"), a3 = /^[a-z]{2,3}(-[a-zA-Z]{4})?(-([A-Z]{2}|[0-9]{3}))?$/, g = { output: { type: "string", validValues: ["currency", "percent", "byte", "time", "ordinal", "number"] }, base: { type: "string", validValues: ["decimal", "binary", "general"], restriction: function(e3, t3) {
          return "byte" === t3.output;
        }, message: "`base` must be provided only when the output is `byte`", mandatory: function(e3) {
          return "byte" === e3.output;
        } }, characteristic: { type: "number", restriction: function(e3) {
          return 0 <= e3;
        }, message: "value must be positive" }, prefix: "string", postfix: "string", forceAverage: { type: "string", validValues: ["trillion", "billion", "million", "thousand"] }, average: "boolean", lowPrecision: { type: "boolean", restriction: function(e3, t3) {
          return true === t3.average;
        }, message: "`lowPrecision` must be provided only when the option `average` is set" }, currencyPosition: { type: "string", validValues: ["prefix", "infix", "postfix"] }, currencySymbol: "string", totalLength: { type: "number", restrictions: [{ restriction: function(e3) {
          return 0 <= e3;
        }, message: "value must be positive" }, { restriction: function(e3, t3) {
          return !t3.exponential;
        }, message: "`totalLength` is incompatible with `exponential`" }] }, mantissa: { type: "number", restriction: function(e3) {
          return 0 <= e3;
        }, message: "value must be positive" }, optionalMantissa: "boolean", trimMantissa: "boolean", roundingFunction: "function", optionalCharacteristic: "boolean", thousandSeparated: "boolean", spaceSeparated: "boolean", spaceSeparatedCurrency: "boolean", spaceSeparatedAbbreviation: "boolean", abbreviations: { type: "object", children: { thousand: "string", million: "string", billion: "string", trillion: "string" } }, negative: { type: "string", validValues: ["sign", "parenthesis"] }, forceSign: "boolean", exponential: { type: "boolean" }, prefixSymbol: { type: "boolean", restriction: function(e3, t3) {
          return "percent" === t3.output;
        }, message: "`prefixSymbol` can be provided only when the output is `percent`" } }, o = { languageTag: { type: "string", mandatory: true, restriction: function(e3) {
          return e3.match(a3);
        }, message: "the language tag must follow the BCP 47 specification (see https://tools.ieft.org/html/bcp47)" }, delimiters: { type: "object", children: { thousands: "string", decimal: "string", thousandsSize: "number" }, mandatory: true }, abbreviations: { type: "object", children: { thousand: { type: "string", mandatory: true }, million: { type: "string", mandatory: true }, billion: { type: "string", mandatory: true }, trillion: { type: "string", mandatory: true } }, mandatory: true }, spaceSeparated: "boolean", spaceSeparatedCurrency: "boolean", ordinal: { type: "function", mandatory: true }, bytes: { type: "object", children: { binarySuffixes: "object", decimalSuffixes: "object" } }, currency: { type: "object", children: { symbol: "string", position: "string", code: "string" }, mandatory: true }, defaults: "format", ordinalFormat: "format", byteFormat: "format", percentageFormat: "format", currencyFormat: "format", timeDefaults: "format", formats: { type: "object", children: { fourDigits: { type: "format", mandatory: true }, fullWithTwoDecimals: { type: "format", mandatory: true }, fullWithTwoDecimalsNoCurrency: { type: "format", mandatory: true }, fullWithNoDecimals: { type: "format", mandatory: true } } } };
        function u2(e3) {
          return void 0 !== i2.unformat(e3);
        }
        function p(c3, s3, l, e3) {
          var t3 = 3 < arguments.length && void 0 !== e3 && e3, r2 = Object.keys(c3).map(function(e4) {
            if (!s3[e4])
              return console.error("".concat(l, " Invalid key: ").concat(e4)), false;
            var t4 = c3[e4], r3 = s3[e4];
            if ("string" == typeof r3 && (r3 = { type: r3 }), "format" === r3.type) {
              if (!p(t4, g, "[Validate ".concat(e4, "]"), true))
                return false;
            } else if (f(t4) !== r3.type)
              return console.error("".concat(l, " ").concat(e4, ' type mismatched: "').concat(r3.type, '" expected, "').concat(f(t4), '" provided')), false;
            if (r3.restrictions && r3.restrictions.length)
              for (var n2 = r3.restrictions.length, i3 = 0; i3 < n2; i3++) {
                var a4 = r3.restrictions[i3], o2 = a4.restriction, u3 = a4.message;
                if (!o2(t4, c3))
                  return console.error("".concat(l, " ").concat(e4, " invalid value: ").concat(u3)), false;
              }
            if (r3.restriction && !r3.restriction(t4, c3))
              return console.error("".concat(l, " ").concat(e4, " invalid value: ").concat(r3.message)), false;
            if (r3.validValues && -1 === r3.validValues.indexOf(t4))
              return console.error("".concat(l, " ").concat(e4, " invalid value: must be among ").concat(JSON.stringify(r3.validValues), ', "').concat(t4, '" provided')), false;
            if (r3.children && !p(t4, r3.children, "[Validate ".concat(e4, "]")))
              return false;
            return true;
          });
          return t3 || r2.push.apply(r2, n(Object.keys(s3).map(function(e4) {
            var t4 = s3[e4];
            if ("string" == typeof t4 && (t4 = { type: t4 }), t4.mandatory) {
              var r3 = t4.mandatory;
              if ("function" == typeof r3 && (r3 = r3(c3)), r3 && void 0 === c3[e4])
                return console.error("".concat(l, ' Missing mandatory key "').concat(e4, '"')), false;
            }
            return true;
          }))), r2.reduce(function(e4, t4) {
            return e4 && t4;
          }, true);
        }
        function c2(e3) {
          return p(e3, g, "[Validate format]");
        }
        t2.exports = { validate: function(e3, t3) {
          var r2 = u2(e3), n2 = c2(t3);
          return r2 && n2;
        }, validateFormat: c2, validateInput: u2, validateLanguage: function(e3) {
          return p(e3, o, "[Validate language]");
        } };
      }, { "./unformatting": 9 }] }, {}, [7])(7);
    });
  }
});

// node_modules/@daohaus/utils/src/utils/units.js
var require_units = __commonJS({
  "node_modules/@daohaus/utils/src/utils/units.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readableNumbers = exports.dynamicDecimals = exports.checkHasQuorum = exports.roundedPercentage = exports.percentage = exports.formatShares = exports.formatValueTo = exports.toWholeUnits = exports.toBaseUnits = void 0;
    var tslib_1 = require_tslib();
    var viem_1 = require_cjs2();
    var numbro_1 = tslib_1.__importDefault(require_numbro_min());
    var typeguards_1 = require_typeguards();
    var toBaseUnits = (amount, decimals = 18) => (0, viem_1.parseUnits)(amount, decimals).toString();
    exports.toBaseUnits = toBaseUnits;
    var toWholeUnits = (amount, decimals = 18) => (0, viem_1.formatUnits)(BigInt(amount), decimals).toString();
    exports.toWholeUnits = toWholeUnits;
    var generateNumeral = ({ value, type, decimals }) => {
      if (value === 0)
        return "0";
      const short = type.match(/(short)/i) ? "a" : "";
      const decimalCount = decimals ? "0".repeat(decimals) : "";
      let format2;
      if (type.match(/(exponent)/i)) {
        format2 = `0,0[.]${decimalCount}e`;
        return (0, numbro_1.default)(value).format(format2);
      } else if (type.match(/(percent)/i)) {
        const decimalMatcher = decimals > 0 ? `[.]${decimalCount}` : "";
        format2 = `0${decimalMatcher}%`;
        return (0, numbro_1.default)(value / 100).format(format2);
      } else if (type.match(/(currency)/i)) {
        format2 = `$0[.]${decimalCount}${short}`;
        return (0, numbro_1.default)(value).format(format2);
      } else if (type.match(/(number)/)) {
        format2 = `0,0[.]${decimalCount}${short}`;
        return (0, numbro_1.default)(value).format(format2);
      } else {
        return (0, numbro_1.default)(value).format(type);
      }
    };
    var formatValueTo = ({ value, unit = "", decimals = 4, separator = " ", format: format2 }) => {
      if (typeof value === "string" && (0, typeguards_1.isNumberish)(value)) {
        value = Number(value);
      }
      if (typeof value === "string" && !(0, typeguards_1.isNumberish)(value)) {
        throw new Error(`${value} is not a number`);
      }
      if (value > 0 && value < 1) {
        return unit ? `${value.toFixed(decimals)}${separator}${unit}` : value.toFixed(decimals);
      }
      if (!format2) {
        throw new Error(`must define a format if ${value} is not between 0 and 1`);
      }
      const formatted = generateNumeral({
        value,
        type: format2,
        decimals
      });
      return `${formatted}${separator}${unit}`;
    };
    exports.formatValueTo = formatValueTo;
    var formatShares = (baseAmt) => {
      if (!(0, typeguards_1.isNumberish)(baseAmt)) {
        console.warn("formatShares: baseAmt is not a number", baseAmt);
        return;
      }
      return (0, exports.formatValueTo)({
        value: (0, exports.toWholeUnits)(baseAmt.toString()),
        decimals: 2,
        format: "numberShort",
        separator: ""
      });
    };
    exports.formatShares = formatShares;
    var percentage = (value, total) => {
      return value / total * 100;
    };
    exports.percentage = percentage;
    var roundedPercentage = (value, total) => {
      return Math.round((0, exports.percentage)(value, total));
    };
    exports.roundedPercentage = roundedPercentage;
    var checkHasQuorum = ({ yesVotes, totalShares, quorumPercent }) => {
      return (0, exports.percentage)(yesVotes, totalShares) >= quorumPercent;
    };
    exports.checkHasQuorum = checkHasQuorum;
    var dynamicDecimals = ({ baseUnits, tokenDecimals = 18, extraZeros = 0 }) => {
      const decimals = tokenDecimals - baseUnits.toString().length + 1 + extraZeros;
      return decimals > 0 ? decimals : 0;
    };
    exports.dynamicDecimals = dynamicDecimals;
    exports.readableNumbers = {
      toCurrency: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { format: "currency" }));
      },
      toCurrencyShort: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { format: "currencyShort" }));
      },
      toDollars: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { decimals: 2, format: "currency" }));
      },
      toNumber: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { format: "number" }));
      },
      toNumberShort: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { format: "numberShort" }));
      },
      toPercent: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { decimals: 0, format: "percent" }));
      },
      toPercentDecimals: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { decimals: 2, format: "percentShort" }));
      },
      toExponential: (args) => {
        return (0, exports.formatValueTo)(Object.assign(Object.assign({}, args), { format: "exponential" }));
      },
      toCustomFormat: (args) => {
        return (0, exports.formatValueTo)(args);
      }
    };
  }
});

// node_modules/@daohaus/utils/src/utils/object.js
var require_object = __commonJS({
  "node_modules/@daohaus/utils/src/utils/object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.omit = void 0;
    var omit = (obj, fields) => {
      const newObj = Object.assign({}, obj);
      fields.forEach((field) => delete newObj[field]);
      return newObj;
    };
    exports.omit = omit;
  }
});

// node_modules/@daohaus/utils/src/utils/proposals.js
var require_proposals2 = __commonJS({
  "node_modules/@daohaus/utils/src/utils/proposals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProposalTypeLabel = void 0;
    var constants_1 = require_constants();
    var getProposalTypeLabel = (proposalType, proposalTypes = constants_1.PROPOSAL_TYPE_LABELS) => (proposalTypes === null || proposalTypes === void 0 ? void 0 : proposalTypes[proposalType]) || "Unknown Proposal Type";
    exports.getProposalTypeLabel = getProposalTypeLabel;
  }
});

// node_modules/@daohaus/utils/src/utils/shamanPermission.js
var require_shamanPermission = __commonJS({
  "node_modules/@daohaus/utils/src/utils/shamanPermission.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAdmin = exports.isGovernor = exports.isManager = void 0;
    var isManager = (permissionLevel) => {
      return Number(permissionLevel) === 2 || Number(permissionLevel) === 3 || Number(permissionLevel) === 6 || Number(permissionLevel) === 7;
    };
    exports.isManager = isManager;
    var isGovernor = (permissionLevel) => {
      return Number(permissionLevel) === 4 || Number(permissionLevel) === 5 || Number(permissionLevel) === 6 || Number(permissionLevel) === 7;
    };
    exports.isGovernor = isGovernor;
    var isAdmin = (permissionLevel) => {
      return Number(permissionLevel) === 1 || Number(permissionLevel) === 3 || Number(permissionLevel) === 5 || Number(permissionLevel) === 7;
    };
    exports.isAdmin = isAdmin;
  }
});

// node_modules/@daohaus/utils/src/utils/time.js
var require_time = __commonJS({
  "node_modules/@daohaus/utils/src/utils/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baalTimeToNow = exports.formatPeriods = exports.calcExpiry = exports.unixTimeInSeconds = exports.toSeconds = exports.conversionFns = void 0;
    var date_fns_1 = (init_esm(), __toCommonJS(esm_exports));
    var typeguards_1 = require_typeguards();
    exports.conversionFns = {
      days: (amt) => (0, date_fns_1.hoursToSeconds)(amt * 24),
      hours: (amt) => (0, date_fns_1.hoursToSeconds)(amt),
      minutes: (amt) => (0, date_fns_1.minutesToSeconds)(amt),
      seconds: (amt) => amt
    };
    var toSeconds = (amt, unit) => {
      var _a;
      return (_a = exports.conversionFns[unit]) === null || _a === void 0 ? void 0 : _a.call(exports.conversionFns, amt);
    };
    exports.toSeconds = toSeconds;
    var unixTimeInSeconds = () => {
      return Math.floor(Date.now() / 1e3);
    };
    exports.unixTimeInSeconds = unixTimeInSeconds;
    var calcExpiry = (duration) => {
      return duration > 0 ? (0, exports.unixTimeInSeconds)() + duration : 0;
    };
    exports.calcExpiry = calcExpiry;
    var formatPeriods = (duration) => {
      if (duration) {
        let s3 = Number(duration);
        const d3 = Math.floor(s3 / (3600 * 24));
        s3 -= d3 * 3600 * 24;
        const h3 = Math.floor(s3 / 3600);
        s3 -= h3 * 3600;
        const m3 = Math.floor(s3 / 60);
        s3 -= m3 * 60;
        const tmp = [];
        d3 && tmp.push(`${d3} day${d3 > 1 ? "s" : ""}`);
        (d3 || h3) && h3 && tmp.push(`${h3} hour${h3 > 1 ? "s" : ""}`);
        (d3 || h3 || m3) && m3 && tmp.push(`${m3} minute${m3 > 1 ? "s" : ""}`);
        s3 && tmp.push(`${s3} second${s3 > 1 ? "s" : ""}`);
        return tmp.join(" ");
      }
      return 0;
    };
    exports.formatPeriods = formatPeriods;
    var baalTimeToNow = (time) => {
      if (!(0, typeguards_1.isNumberish)(time)) {
        console.warn("baalTimeToNow: time is not a number or numberish string", time);
        return;
      }
      return (0, date_fns_1.formatDistanceToNowStrict)(new Date(Number(time) * 1e3));
    };
    exports.baalTimeToNow = baalTimeToNow;
  }
});

// node_modules/@daohaus/utils/src/utils/validation.js
var require_validation = __commonJS({
  "node_modules/@daohaus/utils/src/utils/validation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleBaseUnits = exports.ignoreEmpty = exports.ignoreEmptyVal = exports.ValidateField = exports.ValErrMsgs = void 0;
    var typeguards_1 = require_typeguards();
    var units_1 = require_units();
    exports.ValErrMsgs = {
      number: "Field must be a number",
      boolean: "Field must be a boolean",
      array: "Field must be an array",
      ethAddress: "Field must be an Ethereum address",
      url: "Field must be a valid URL",
      email: "Field must be a valid email",
      percent: "Field must be a valid percentage",
      object: "Field must be a valid JSON Object"
    };
    exports.ValidateField = {
      number: (val) => (0, typeguards_1.isNumberish)(val) ? true : exports.ValErrMsgs.number,
      boolean: (val) => (0, typeguards_1.isBoolean)(val) ? true : exports.ValErrMsgs.boolean,
      array: (val) => (0, typeguards_1.isArray)(val) ? true : exports.ValErrMsgs.array,
      ethAddress: (val) => (0, typeguards_1.isEthAddress)(val) ? true : exports.ValErrMsgs.ethAddress,
      url: (val) => (0, typeguards_1.isString)(val) && /[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,24}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/.test(val) ? true : exports.ValErrMsgs.url,
      email: (val) => (0, typeguards_1.isString)(val) && /^[^@]+@[^@]+\.[^@]+$/.test(val) ? true : exports.ValErrMsgs.email,
      percent: (val, range = [0, 100]) => (0, typeguards_1.isNumberish)(val) && Number(val) >= range[0] && Number(val) <= range[1] ? true : exports.ValErrMsgs.percent,
      object: (val) => (0, typeguards_1.isObject)(val) ? true : exports.ValErrMsgs.object
    };
    var ignoreEmptyVal = (val, validator) => val === "" ? true : validator(val);
    exports.ignoreEmptyVal = ignoreEmptyVal;
    var ignoreEmpty = (val, validator) => val === "" ? true : validator(val);
    exports.ignoreEmpty = ignoreEmpty;
    var handleBaseUnits = (val, decimals = 18) => exports.ValidateField.number(val) === true ? (0, units_1.toBaseUnits)(val, decimals) : val;
    exports.handleBaseUnits = handleBaseUnits;
  }
});

// node_modules/@daohaus/utils/src/utils/error.js
var require_error = __commonJS({
  "node_modules/@daohaus/utils/src/utils/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleErrorMessage = void 0;
    var isEthersError = (error) => (error === null || error === void 0 ? void 0 : error.reason) !== void 0 && (error === null || error === void 0 ? void 0 : error.code) !== void 0 && (error === null || error === void 0 ? void 0 : error.method) !== void 0 && (error === null || error === void 0 ? void 0 : error.message) !== void 0;
    var hasMessage = (value) => (value === null || value === void 0 ? void 0 : value.message) !== void 0;
    var isReasonable = (value) => (value === null || value === void 0 ? void 0 : value.reason) !== void 0;
    var handleErrorMessage = ({ error, fallback = "Could not decode error message" }) => {
      if (error instanceof Error && isEthersError(error)) {
        return `Contact Error: ${error.reason}`;
      }
      if (isReasonable(error)) {
        return `Error: ${error.reason}`;
      }
      if (hasMessage(error)) {
        return error.message;
      }
      if (typeof error === "string") {
        return error;
      }
      return fallback;
    };
    exports.handleErrorMessage = handleErrorMessage;
  }
});

// node_modules/@daohaus/utils/src/utils/index.js
var require_utils6 = __commonJS({
  "node_modules/@daohaus/utils/src/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_cache(), exports);
    tslib_1.__exportStar(require_dates(), exports);
    tslib_1.__exportStar(require_gas(), exports);
    tslib_1.__exportStar(require_general2(), exports);
    tslib_1.__exportStar(require_formatting(), exports);
    tslib_1.__exportStar(require_gnosis(), exports);
    tslib_1.__exportStar(require_typeguards(), exports);
    tslib_1.__exportStar(require_encoding2(), exports);
    tslib_1.__exportStar(require_units(), exports);
    tslib_1.__exportStar(require_object(), exports);
    tslib_1.__exportStar(require_proposals2(), exports);
    tslib_1.__exportStar(require_shamanPermission(), exports);
    tslib_1.__exportStar(require_time(), exports);
    tslib_1.__exportStar(require_validation(), exports);
    tslib_1.__exportStar(require_error(), exports);
    tslib_1.__exportStar(require_viem2(), exports);
  }
});

// node_modules/@daohaus/utils/src/index.js
var require_src2 = __commonJS({
  "node_modules/@daohaus/utils/src/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require_tslib();
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
    tslib_1.__exportStar(require_content(), exports);
    tslib_1.__exportStar(require_utils6(), exports);
  }
});

export {
  toDate,
  init_toDate,
  addDays,
  init_addDays,
  addMonths,
  init_addMonths,
  addHours,
  init_addHours,
  startOfWeek,
  init_startOfWeek,
  startOfDay,
  init_startOfDay,
  differenceInCalendarDays,
  init_differenceInCalendarDays,
  addMinutes,
  init_addMinutes,
  addQuarters,
  init_addQuarters,
  addWeeks,
  init_addWeeks,
  addYears,
  init_addYears,
  max,
  init_max,
  min,
  init_min,
  isSameDay,
  init_isSameDay,
  isDate,
  init_isDate,
  isValid,
  init_isValid,
  differenceInCalendarMonths,
  init_differenceInCalendarMonths,
  getQuarter,
  init_getQuarter,
  differenceInCalendarYears,
  init_differenceInCalendarYears,
  endOfDay,
  init_endOfDay,
  endOfMonth,
  init_endOfMonth,
  startOfQuarter,
  init_startOfQuarter,
  startOfMonth,
  init_startOfMonth,
  endOfYear,
  init_endOfYear,
  startOfYear,
  init_startOfYear,
  init_endOfWeek,
  format,
  init_format,
  getDate,
  init_getDate,
  getDay,
  init_getDay,
  getHours,
  init_getHours,
  getISOWeek,
  init_getISOWeek,
  getMinutes,
  init_getMinutes,
  getMonth,
  init_getMonth,
  getSeconds,
  init_getSeconds,
  getTime,
  init_getTime,
  getYear,
  init_getYear,
  isAfter,
  init_isAfter,
  isBefore,
  init_isBefore,
  isEqual,
  init_isEqual,
  _assertThisInitialized,
  init_assertThisInitialized,
  _getPrototypeOf,
  init_getPrototypeOf,
  _isNativeReflectConstruct,
  init_isNativeReflectConstruct,
  parse,
  init_parse,
  isSameMonth,
  init_isSameMonth,
  isSameQuarter,
  init_isSameQuarter,
  isSameYear,
  init_isSameYear,
  isWithinInterval,
  init_isWithinInterval,
  subDays,
  init_subDays,
  parseISO,
  init_parseISO,
  setMonth,
  init_setMonth,
  set,
  init_set,
  setHours,
  init_setHours,
  setMinutes,
  init_setMinutes,
  setQuarter,
  init_setQuarter,
  setSeconds,
  init_setSeconds,
  setYear,
  init_setYear,
  subMonths,
  init_subMonths,
  subQuarters,
  init_subQuarters,
  subWeeks,
  init_subWeeks,
  subYears,
  init_subYears,
  init_esm,
  require_utils4 as require_utils,
  require_secp256k1,
  require_cjs2 as require_cjs,
  require_src2 as require_src
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=chunk-KYOZVWPW.js.map
