import {
  useInfiniteQuery,
  useQuery
} from "./chunk-3AVE6YVB.js";
import {
  require_src2 as require_src5
} from "./chunk-SYS7556B.js";
import {
  require_src
} from "./chunk-R7RRHWOA.js";
import {
  require_src as require_src4
} from "./chunk-YC6YMAXM.js";
import {
  require_src as require_src3
} from "./chunk-KYOZVWPW.js";
import {
  require_jsx_runtime
} from "./chunk-GYNMGCXV.js";
import {
  require_react
} from "./chunk-T5BEU6ZH.js";
import {
  require_src as require_src2
} from "./chunk-EBQ4QPBR.js";
import {
  __toESM
} from "./chunk-LMAYTEU7.js";

// node_modules/@daohaus/moloch-v3-hooks/index.js
var import_moloch_v3_data = __toESM(require_src5());
var import_keychain_utils = __toESM(require_src2());
var import_utils = __toESM(require_src3());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var import_abis = __toESM(require_src());
var import_profile_data = __toESM(require_src4());
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
var check = function(it) {
  return it && it.Math == Math && it;
};
var global$c = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || commonjsGlobal || Function("return this")();
var objectGetOwnPropertyDescriptor = {};
var fails$d = function(exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};
var fails$c = fails$d;
var descriptors = !fails$c(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$b = fails$d;
var functionBindNative = !fails$b(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$1 = functionBindNative;
var call$7 = Function.prototype.call;
var functionCall = NATIVE_BIND$1 ? call$7.bind(call$7) : function() {
  return call$7.apply(call$7, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$1(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var createPropertyDescriptor$3 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND = functionBindNative;
var FunctionPrototype$1 = Function.prototype;
var call$6 = FunctionPrototype$1.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype$1.bind.bind(call$6, call$6);
var functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$6.apply(fn, arguments);
  };
};
var uncurryThis$a = functionUncurryThis;
var toString$2 = uncurryThis$a({}.toString);
var stringSlice$1 = uncurryThis$a("".slice);
var classofRaw$1 = function(it) {
  return stringSlice$1(toString$2(it), 8, -1);
};
var uncurryThis$9 = functionUncurryThis;
var fails$a = fails$d;
var classof$3 = classofRaw$1;
var $Object$4 = Object;
var split = uncurryThis$9("".split);
var indexedObject = fails$a(function() {
  return !$Object$4("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$3(it) == "String" ? split(it, "") : $Object$4(it);
} : $Object$4;
var isNullOrUndefined$2 = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$1 = isNullOrUndefined$2;
var $TypeError$7 = TypeError;
var requireObjectCoercible$2 = function(it) {
  if (isNullOrUndefined$1(it))
    throw $TypeError$7("Can't call method on " + it);
  return it;
};
var IndexedObject$2 = indexedObject;
var requireObjectCoercible$1 = requireObjectCoercible$2;
var toIndexedObject$5 = function(it) {
  return IndexedObject$2(requireObjectCoercible$1(it));
};
var documentAll$2 = typeof document == "object" && document.all;
var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA
};
var $documentAll$1 = documentAll_1;
var documentAll$1 = $documentAll$1.all;
var isCallable$f = $documentAll$1.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$1;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$e = isCallable$f;
var $documentAll = documentAll_1;
var documentAll = $documentAll.all;
var isObject$6 = $documentAll.IS_HTMLDDA ? function(it) {
  return typeof it == "object" ? it !== null : isCallable$e(it) || it === documentAll;
} : function(it) {
  return typeof it == "object" ? it !== null : isCallable$e(it);
};
var global$b = global$c;
var isCallable$d = isCallable$f;
var aFunction = function(argument) {
  return isCallable$d(argument) ? argument : void 0;
};
var getBuiltIn$3 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$b[namespace]) : global$b[namespace] && global$b[namespace][method];
};
var uncurryThis$8 = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$8({}.isPrototypeOf);
var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
var global$a = global$c;
var userAgent = engineUserAgent;
var process$1 = global$a.process;
var Deno = global$a.Deno;
var versions = process$1 && process$1.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match;
var version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match)
      version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION = engineV8Version;
var fails$9 = fails$d;
var global$9 = global$c;
var $String$5 = global$9.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$9(function() {
  var symbol = Symbol();
  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$2 = getBuiltIn$3;
var isCallable$c = isCallable$f;
var isPrototypeOf$1 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$3 = Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn$2("Symbol");
  return isCallable$c($Symbol) && isPrototypeOf$1($Symbol.prototype, $Object$3(it));
};
var $String$4 = String;
var tryToString$1 = function(argument) {
  try {
    return $String$4(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$b = isCallable$f;
var tryToString = tryToString$1;
var $TypeError$6 = TypeError;
var aCallable$3 = function(argument) {
  if (isCallable$b(argument))
    return argument;
  throw $TypeError$6(tryToString(argument) + " is not a function");
};
var aCallable$2 = aCallable$3;
var isNullOrUndefined = isNullOrUndefined$2;
var getMethod$1 = function(V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? void 0 : aCallable$2(func);
};
var call$5 = functionCall;
var isCallable$a = isCallable$f;
var isObject$5 = isObject$6;
var $TypeError$5 = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$a(fn = input.toString) && !isObject$5(val = call$5(fn, input)))
    return val;
  if (isCallable$a(fn = input.valueOf) && !isObject$5(val = call$5(fn, input)))
    return val;
  if (pref !== "string" && isCallable$a(fn = input.toString) && !isObject$5(val = call$5(fn, input)))
    return val;
  throw $TypeError$5("Can't convert object to primitive value");
};
var shared$3 = { exports: {} };
var global$8 = global$c;
var defineProperty$5 = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$5(global$8, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$8[key] = value;
  }
  return value;
};
var global$7 = global$c;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = global$7[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$3.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.32.0",
  mode: "global",
  copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var requireObjectCoercible = requireObjectCoercible$2;
var $Object$2 = Object;
var toObject$4 = function(argument) {
  return $Object$2(requireObjectCoercible(argument));
};
var uncurryThis$7 = functionUncurryThis;
var toObject$3 = toObject$4;
var hasOwnProperty = uncurryThis$7({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject$3(it), key);
};
var uncurryThis$6 = functionUncurryThis;
var id = 0;
var postfix = Math.random();
var toString$1 = uncurryThis$6(1 .toString);
var uid$2 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$1(++id + postfix, 36);
};
var global$6 = global$c;
var shared$2 = shared$3.exports;
var hasOwn$9 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$1 = global$6.Symbol;
var WellKnownSymbolsStore = shared$2("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1["for"] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
var wellKnownSymbol$8 = function(name) {
  if (!hasOwn$9(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$9(Symbol$1, name) ? Symbol$1[name] : createWellKnownSymbol("Symbol." + name);
  }
  return WellKnownSymbolsStore[name];
};
var call$4 = functionCall;
var isObject$4 = isObject$6;
var isSymbol$1 = isSymbol$2;
var getMethod = getMethod$1;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$7 = wellKnownSymbol$8;
var $TypeError$4 = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$7("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$4(input) || isSymbol$1(input))
    return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$4(exoticToPrim, input, pref);
    if (!isObject$4(result) || isSymbol$1(result))
      return result;
    throw $TypeError$4("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$2 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$5 = global$c;
var isObject$3 = isObject$6;
var document$1 = global$5.document;
var EXISTS$1 = isObject$3(document$1) && isObject$3(document$1.createElement);
var documentCreateElement$2 = function(it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};
var DESCRIPTORS$9 = descriptors;
var fails$8 = fails$d;
var createElement = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$9 && !fails$8(function() {
  return Object.defineProperty(createElement("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$8 = descriptors;
var call$3 = functionCall;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$2 = createPropertyDescriptor$3;
var toIndexedObject$4 = toIndexedObject$5;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$8 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$8 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$4(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error) {
    }
  if (hasOwn$8(O, P))
    return createPropertyDescriptor$2(!call$3(propertyIsEnumerableModule$1.f, O, P), O[P]);
};
var objectDefineProperty = {};
var DESCRIPTORS$7 = descriptors;
var fails$7 = fails$d;
var v8PrototypeDefineBug = DESCRIPTORS$7 && fails$7(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var isObject$2 = isObject$6;
var $String$3 = String;
var $TypeError$3 = TypeError;
var anObject$7 = function(argument) {
  if (isObject$2(argument))
    return argument;
  throw $TypeError$3($String$3(argument) + " is not an object");
};
var DESCRIPTORS$6 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$6 = anObject$7;
var toPropertyKey = toPropertyKey$2;
var $TypeError$2 = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$6 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
  anObject$6(O);
  P = toPropertyKey(P);
  anObject$6(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty2(O, P, Attributes) {
  anObject$6(O);
  P = toPropertyKey(P);
  anObject$6(Attributes);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError$2("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$5 = descriptors;
var definePropertyModule$3 = objectDefineProperty;
var createPropertyDescriptor$1 = createPropertyDescriptor$3;
var createNonEnumerableProperty$4 = DESCRIPTORS$5 ? function(object, key, value) {
  return definePropertyModule$3.f(object, key, createPropertyDescriptor$1(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltIn$2 = { exports: {} };
var DESCRIPTORS$4 = descriptors;
var hasOwn$7 = hasOwnProperty_1;
var FunctionPrototype = Function.prototype;
var getDescriptor = DESCRIPTORS$4 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$7(FunctionPrototype, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$4 || DESCRIPTORS$4 && getDescriptor(FunctionPrototype, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$5 = functionUncurryThis;
var isCallable$9 = isCallable$f;
var store$1 = sharedStore;
var functionToString = uncurryThis$5(Function.toString);
if (!isCallable$9(store$1.inspectSource)) {
  store$1.inspectSource = function(it) {
    return functionToString(it);
  };
}
var inspectSource$1 = store$1.inspectSource;
var global$4 = global$c;
var isCallable$8 = isCallable$f;
var WeakMap$1 = global$4.WeakMap;
var weakMapBasicDetection = isCallable$8(WeakMap$1) && /native code/.test(String(WeakMap$1));
var shared$1 = shared$3.exports;
var uid = uid$2;
var keys = shared$1("keys");
var sharedKey$3 = function(key) {
  return keys[key] || (keys[key] = uid(key));
};
var hiddenKeys$4 = {};
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$3 = global$c;
var isObject$1 = isObject$6;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$4;
var hasOwn$6 = hasOwnProperty_1;
var shared = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$3 = hiddenKeys$4;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$1 = global$3.TypeError;
var WeakMap = global$3.WeakMap;
var set;
var get;
var has;
var enforce = function(it) {
  return has(it) ? get(it) : set(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$1(it) || (state = get(it)).type !== TYPE) {
      throw TypeError$1("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared.state) {
  store = shared.state || (shared.state = new WeakMap());
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  set = function(it, metadata) {
    if (store.has(it))
      throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function(it) {
    return store.get(it) || {};
  };
  has = function(it) {
    return store.has(it);
  };
} else {
  STATE = sharedKey$2("state");
  hiddenKeys$3[STATE] = true;
  set = function(it, metadata) {
    if (hasOwn$6(it, STATE))
      throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$3(it, STATE, metadata);
    return metadata;
  };
  get = function(it) {
    return hasOwn$6(it, STATE) ? it[STATE] : {};
  };
  has = function(it) {
    return hasOwn$6(it, STATE);
  };
}
var store;
var STATE;
var internalState = {
  set,
  get,
  has,
  enforce,
  getterFor
};
var uncurryThis$4 = functionUncurryThis;
var fails$6 = fails$d;
var isCallable$7 = isCallable$f;
var hasOwn$5 = hasOwnProperty_1;
var DESCRIPTORS$3 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource = inspectSource$1;
var InternalStateModule$1 = internalState;
var enforceInternalState = InternalStateModule$1.enforce;
var getInternalState$1 = InternalStateModule$1.get;
var $String$2 = String;
var defineProperty$4 = Object.defineProperty;
var stringSlice = uncurryThis$4("".slice);
var replace = uncurryThis$4("".replace);
var join = uncurryThis$4([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS$3 && !fails$6(function() {
  return defineProperty$4(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {
  if (stringSlice($String$2(name), 0, 7) === "Symbol(") {
    name = "[" + replace($String$2(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter)
    name = "get " + name;
  if (options && options.setter)
    name = "set " + name;
  if (!hasOwn$5(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    if (DESCRIPTORS$3)
      defineProperty$4(value, "name", { value: name, configurable: true });
    else
      value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$5(options, "arity") && value.length !== options.arity) {
    defineProperty$4(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$5(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$3)
        defineProperty$4(value, "prototype", { writable: false });
    } else if (value.prototype)
      value.prototype = void 0;
  } catch (error) {
  }
  var state = enforceInternalState(value);
  if (!hasOwn$5(state, "source")) {
    state.source = join(TEMPLATE, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$1(function toString() {
  return isCallable$7(this) && getInternalState$1(this).source || inspectSource(this);
}, "toString");
var isCallable$6 = isCallable$f;
var definePropertyModule$2 = objectDefineProperty;
var makeBuiltIn = makeBuiltIn$2.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$4 = function(O, key, value, options) {
  if (!options)
    options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$6(value))
    makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple)
      O[key] = value;
    else
      defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe)
        delete O[key];
      else if (O[key])
        simple = true;
    } catch (error) {
    }
    if (simple)
      O[key] = value;
    else
      definePropertyModule$2.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
  }
  return O;
};
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor = Math.floor;
var mathTrunc = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};
var trunc2 = mathTrunc;
var toIntegerOrInfinity$2 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2(number);
};
var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
var max = Math.max;
var min$1 = Math.min;
var toAbsoluteIndex$1 = function(index, length) {
  var integer = toIntegerOrInfinity$1(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};
var toIntegerOrInfinity = toIntegerOrInfinity$2;
var min = Math.min;
var toLength$1 = function(argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
};
var toLength = toLength$1;
var lengthOfArrayLike$2 = function(obj) {
  return toLength(obj.length);
};
var toIndexedObject$3 = toIndexedObject$5;
var toAbsoluteIndex = toAbsoluteIndex$1;
var lengthOfArrayLike$1 = lengthOfArrayLike$2;
var createMethod$1 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$3($this);
    var length = lengthOfArrayLike$1(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value)
          return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$1(true),
  indexOf: createMethod$1(false)
};
var uncurryThis$3 = functionUncurryThis;
var hasOwn$4 = hasOwnProperty_1;
var toIndexedObject$2 = toIndexedObject$5;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$2 = hiddenKeys$4;
var push = uncurryThis$3([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject$2(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$4(hiddenKeys$2, key) && hasOwn$4(O, key) && push(result, key);
  while (names.length > i)
    if (hasOwn$4(O, key = names[i++])) {
      ~indexOf(result, key) || push(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$1 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$1);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$1 = getBuiltIn$3;
var uncurryThis$2 = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$5 = anObject$7;
var concat$1 = uncurryThis$2([].concat);
var ownKeys$1 = getBuiltIn$1("Reflect", "ownKeys") || function ownKeys(it) {
  var keys3 = getOwnPropertyNamesModule.f(anObject$5(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
  return getOwnPropertySymbols ? concat$1(keys3, getOwnPropertySymbols(it)) : keys3;
};
var hasOwn$3 = hasOwnProperty_1;
var ownKeys2 = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys3 = ownKeys2(source);
  var defineProperty4 = definePropertyModule$1.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys3.length; i++) {
    var key = keys3[i];
    if (!hasOwn$3(target, key) && !(exceptions && hasOwn$3(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$5 = fails$d;
var isCallable$5 = isCallable$f;
var replacement = /#|\.prototype\./;
var isForced$1 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$5(detection) ? fails$5(detection) : !!detection;
};
var normalize = isForced$1.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = "N";
var POLYFILL = isForced$1.POLYFILL = "P";
var isForced_1 = isForced$1;
var global$2 = global$c;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$4;
var defineBuiltIn$3 = defineBuiltIn$4;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$2;
  } else if (STATIC) {
    target = global$2[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$2[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor2(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$2(sourceProperty, "sham", true);
      }
      defineBuiltIn$3(target, key, sourceProperty, options);
    }
};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$2 = Object.keys || function keys2(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};
var DESCRIPTORS$2 = descriptors;
var uncurryThis$1 = functionUncurryThis;
var call$2 = functionCall;
var fails$4 = fails$d;
var objectKeys$1 = objectKeys$2;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$2 = toObject$4;
var IndexedObject$1 = indexedObject;
var $assign = Object.assign;
var defineProperty$3 = Object.defineProperty;
var concat = uncurryThis$1([].concat);
var objectAssign = !$assign || fails$4(function() {
  if (DESCRIPTORS$2 && $assign({ b: 1 }, $assign(defineProperty$3({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$3(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A = {};
  var B = {};
  var symbol = Symbol();
  var alphabet = "abcdefghijklmnopqrst";
  A[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys$1($assign({}, B)).join("") != alphabet;
}) ? function assign(target, source) {
  var T = toObject$2(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable2 = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject$1(arguments[index++]);
    var keys3 = getOwnPropertySymbols ? concat(objectKeys$1(S), getOwnPropertySymbols(S)) : objectKeys$1(S);
    var length = keys3.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys3[j++];
      if (!DESCRIPTORS$2 || call$2(propertyIsEnumerable2, S, key))
        T[key] = S[key];
    }
  }
  return T;
} : $assign;
var $$2 = _export;
var assign2 = objectAssign;
$$2({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
  assign: assign2
});
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var objectDefineProperties = {};
var DESCRIPTORS$1 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule = objectDefineProperty;
var anObject$4 = anObject$7;
var toIndexedObject$1 = toIndexedObject$5;
var objectKeys = objectKeys$2;
objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$4(O);
  var props = toIndexedObject$1(Properties);
  var keys3 = objectKeys(Properties);
  var length = keys3.length;
  var index = 0;
  var key;
  while (length > index)
    definePropertyModule.f(O, key = keys3[index++], props[key]);
  return O;
};
var getBuiltIn = getBuiltIn$3;
var html$1 = getBuiltIn("document", "documentElement");
var anObject$3 = anObject$7;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys = hiddenKeys$4;
var html = html$1;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$1 = sharedKey$3;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$1("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys[IE_PROTO$1] = true;
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$3(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO$1] = O;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
};
var wellKnownSymbol$6 = wellKnownSymbol$8;
var create$1 = objectCreate;
var defineProperty$2 = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$6("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == void 0) {
  defineProperty$2(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$1(null)
  });
}
var addToUnscopables$1 = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var iterators = {};
var fails$3 = fails$d;
var correctPrototypeGetter = !fails$3(function() {
  function F() {
  }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$2 = hasOwnProperty_1;
var isCallable$4 = isCallable$f;
var toObject$1 = toObject$4;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey("IE_PROTO");
var $Object$1 = Object;
var ObjectPrototype = $Object$1.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function(O) {
  var object = toObject$1(O);
  if (hasOwn$2(object, IE_PROTO))
    return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$4(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof $Object$1 ? ObjectPrototype : null;
};
var fails$2 = fails$d;
var isCallable$3 = isCallable$f;
var isObject = isObject$6;
var getPrototypeOf$1 = objectGetPrototypeOf;
var defineBuiltIn$2 = defineBuiltIn$4;
var wellKnownSymbol$5 = wellKnownSymbol$8;
var ITERATOR$2 = wellKnownSymbol$5("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2;
var PrototypeOfArrayIteratorPrototype;
var arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype$2) || fails$2(function() {
  var test2 = {};
  return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$2 = {};
if (!isCallable$3(IteratorPrototype$2[ITERATOR$2])) {
  defineBuiltIn$2(IteratorPrototype$2, ITERATOR$2, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var defineProperty$1 = objectDefineProperty.f;
var hasOwn$1 = hasOwnProperty_1;
var wellKnownSymbol$4 = wellKnownSymbol$8;
var TO_STRING_TAG$3 = wellKnownSymbol$4("toStringTag");
var setToStringTag$2 = function(target, TAG, STATIC) {
  if (target && !STATIC)
    target = target.prototype;
  if (target && !hasOwn$1(target, TO_STRING_TAG$3)) {
    defineProperty$1(target, TO_STRING_TAG$3, { configurable: true, value: TAG });
  }
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create2 = objectCreate;
var createPropertyDescriptor = createPropertyDescriptor$3;
var setToStringTag$1 = setToStringTag$2;
var Iterators$2 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME + " Iterator";
  IteratorConstructor.prototype = create2(IteratorPrototype$1, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag$1(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$2[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var uncurryThis = functionUncurryThis;
var aCallable$1 = aCallable$3;
var functionUncurryThisAccessor = function(object, key, method) {
  try {
    return uncurryThis(aCallable$1(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) {
  }
};
var isCallable$2 = isCallable$f;
var $String$1 = String;
var $TypeError$1 = TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$2(argument))
    return argument;
  throw $TypeError$1("Can't set " + $String$1(argument) + " as a prototype");
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var anObject$2 = anObject$7;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error) {
  }
  return function setPrototypeOf2(O, proto) {
    anObject$2(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O, proto);
    else
      O.__proto__ = proto;
    return O;
  };
}() : void 0);
var $$1 = _export;
var call$1 = functionCall;
var FunctionName = functionName;
var isCallable$1 = isCallable$f;
var createIteratorConstructor = iteratorCreateConstructor;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$2;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$4;
var defineBuiltIn$1 = defineBuiltIn$4;
var wellKnownSymbol$3 = wellKnownSymbol$8;
var Iterators$1 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$1 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol$3("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME, next);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys3() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$1(CurrentIteratorPrototype[ITERATOR$1])) {
          defineBuiltIn$1(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME$1 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$1(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call$1(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn$1(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$1({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    defineBuiltIn$1(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
  }
  Iterators$1[NAME] = defaultIterator;
  return methods;
};
var createIterResultObject$1 = function(value, done) {
  return { value, done };
};
var toIndexedObject = toIndexedObject$5;
var addToUnscopables = addToUnscopables$1;
var Iterators = iterators;
var InternalStateModule = internalState;
var defineProperty3 = objectDefineProperty.f;
var defineIterator = iteratorDefine;
var createIterResultObject = createIterResultObject$1;
var DESCRIPTORS = descriptors;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    index: 0,
    kind
  });
}, function() {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = void 0;
    return createIterResultObject(void 0, true);
  }
  if (kind == "keys")
    return createIterResultObject(index, false);
  if (kind == "values")
    return createIterResultObject(target[index], false);
  return createIterResultObject([index, target[index]], false);
}, "values");
var values = Iterators.Arguments = Iterators.Array;
addToUnscopables("keys");
addToUnscopables("values");
addToUnscopables("entries");
if (DESCRIPTORS && values.name !== "values")
  try {
    defineProperty3(values, "name", { value: "values" });
  } catch (error) {
  }
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
var global$1 = global$c;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty = createNonEnumerableProperty$4;
var wellKnownSymbol$2 = wellKnownSymbol$8;
var ITERATOR = wellKnownSymbol$2("iterator");
var TO_STRING_TAG$2 = wellKnownSymbol$2("toStringTag");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR] !== ArrayValues)
      try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
    if (!CollectionPrototype[TO_STRING_TAG$2]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
          try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME in DOMIterables) {
  handlePrototype(global$1[COLLECTION_NAME] && global$1[COLLECTION_NAME].prototype, COLLECTION_NAME);
}
var COLLECTION_NAME;
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
var CurrentDaoContext = import_react.default.createContext({
  daoId: void 0,
  daoChain: void 0,
  userAddress: void 0,
  updateFilter: () => void 0,
  getFilter: () => void 0,
  updateOrder: () => void 0,
  getOrder: () => void 0
});
var CurrentDaoProvider = ({
  children,
  targetDao,
  userAddress
}) => {
  const [currentFilters, setFilter] = (0, import_react.useState)({});
  const [currentOrders, setOrder] = (0, import_react.useState)({});
  const updateFilter = (filterKey, filter) => {
    setFilter((prevState) => Object.assign(Object.assign({}, prevState), {
      [filterKey]: filter
    }));
  };
  const updateOrder = (orderKey, order) => {
    setOrder((prevState) => Object.assign(Object.assign({}, prevState), {
      [orderKey]: order
    }));
  };
  const getFilter = (filterKey) => {
    return currentFilters === null || currentFilters === void 0 ? void 0 : currentFilters[filterKey];
  };
  const getOrder = (orderKey) => {
    return currentOrders === null || currentOrders === void 0 ? void 0 : currentOrders[orderKey];
  };
  return (0, import_jsx_runtime.jsx)(CurrentDaoContext.Provider, Object.assign({
    value: {
      daoChain: targetDao === null || targetDao === void 0 ? void 0 : targetDao.daoChain,
      daoId: targetDao === null || targetDao === void 0 ? void 0 : targetDao.daoId,
      proposalId: targetDao === null || targetDao === void 0 ? void 0 : targetDao.proposalId,
      memberAddress: targetDao === null || targetDao === void 0 ? void 0 : targetDao.memberAddress,
      updateFilter,
      getFilter,
      updateOrder,
      getOrder,
      userAddress
    }
  }, {
    children
  }));
};
var useCurrentDao = () => (0, import_react.useContext)(CurrentDaoContext);
var MULTI_DAO_ROUTER = "molochv3/:daoChain/:daoId";
var DaoQueryKeys;
(function(DaoQueryKeys2) {
  DaoQueryKeys2["Dao"] = "dao";
  DaoQueryKeys2["Proposals"] = "proposals";
  DaoQueryKeys2["SingleProposal"] = "singleProposal";
  DaoQueryKeys2["Members"] = "members";
  DaoQueryKeys2["SingleMember"] = "singleMember";
  DaoQueryKeys2["Tokens"] = "tokens";
  DaoQueryKeys2["UserDaos"] = "userDaos";
  DaoQueryKeys2["ConnectedMember"] = "connectedMember";
})(DaoQueryKeys || (DaoQueryKeys = {}));
var daoScopedQueryId = ({
  daoId,
  daoChain,
  domain
}) => {
  return `${daoChain}-${daoId}-${domain}`;
};
var checkContextDefault = (key, defaultValue, contextGetter) => {
  if (!contextGetter)
    return defaultValue;
  const contextValue = contextGetter(key);
  return contextValue || defaultValue;
};
var fetchDao = ({
  daoId,
  daoChain,
  graphApiKeys
}) => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  if (!daoId || !daoChain)
    return;
  try {
    const daoRes = yield (0, import_moloch_v3_data.findDao)({
      networkId: daoChain,
      dao: daoId,
      includeTokens: true,
      graphApiKeys
    });
    return (_a = daoRes === null || daoRes === void 0 ? void 0 : daoRes.data) === null || _a === void 0 ? void 0 : _a.dao;
  } catch (error) {
    console.error(error);
    throw new Error((0, import_utils.handleErrorMessage)({
      error,
      fallback: "Error fetching DAO"
    }));
  }
});
var useDaoData = (props) => {
  const {
    daoId: daoIdOverride,
    daoChain: daoChainOverride,
    graphApiKeys = import_keychain_utils.GRAPH_API_KEYS
  } = props || {};
  const {
    daoId: idFromRouter,
    daoChain: networkFromRouter
  } = (useCurrentDao === null || useCurrentDao === void 0 ? void 0 : useCurrentDao()) || {};
  const daoId = daoIdOverride || idFromRouter;
  const daoChain = daoChainOverride || networkFromRouter;
  const _a = useQuery([daoScopedQueryId({
    daoChain,
    daoId,
    domain: DaoQueryKeys.Dao
  }), {
    daoId,
    daoChain
  }], () => fetchDao({
    daoId,
    daoChain,
    graphApiKeys
  }), {
    enabled: !!daoId && !!daoChain
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  return Object.assign({
    dao: data2,
    error
  }, rest);
};
var fetchMember$1 = ({
  daoId,
  daoChain,
  memberAddress,
  graphApiKeys
}) => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  if (!daoChain || !daoId || !memberAddress)
    return;
  try {
    const res = yield (0, import_moloch_v3_data.findMember)({
      dao: daoId,
      memberAddress,
      networkId: daoChain,
      graphApiKeys
    });
    return (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.member;
  } catch (error) {
    console.error(error);
    throw new Error("Error fetching proposal");
  }
});
var useDaoMember = (props) => {
  const {
    daoChain: daoChainOverride,
    daoId: daoIdOverride,
    memberAddress: memberAddressOverride,
    graphApiKeys = import_keychain_utils.GRAPH_API_KEYS
  } = props || {};
  const {
    memberAddress: memberAddressFromRouter,
    daoChain: networkFromRouter,
    daoId: daoIdFromRouter
  } = useCurrentDao();
  const daoId = daoIdOverride || daoIdFromRouter;
  const daoChain = daoChainOverride || networkFromRouter;
  const memberAddress = memberAddressOverride || memberAddressFromRouter;
  const _a = useQuery([daoScopedQueryId({
    daoId,
    daoChain,
    domain: DaoQueryKeys.SingleMember
  }), {
    daoChain,
    daoId,
    memberAddress
  }], () => fetchMember$1({
    daoId,
    daoChain,
    memberAddress,
    graphApiKeys
  }), {
    enabled: !!daoId && !!daoChain && !!memberAddress
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  return Object.assign({
    member: data2,
    error
  }, rest);
};
var aCallable = aCallable$3;
var toObject = toObject$4;
var IndexedObject = indexedObject;
var lengthOfArrayLike = lengthOfArrayLike$2;
var $TypeError = TypeError;
var createMethod = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O = toObject(that);
    var self2 = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length <= index) {
          throw $TypeError("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index >= 0 : length > index; index += i)
      if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
    return memo;
  };
};
var arrayReduce = {
  left: createMethod(false),
  right: createMethod(true)
};
var fails$1 = fails$d;
var arrayMethodIsStrict$1 = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$1(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var classof$2 = classofRaw$1;
var engineIsNode = typeof process != "undefined" && classof$2(process) == "process";
var $ = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict = arrayMethodIsStrict$1;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
$({ target: "Array", proto: true, forced: FORCED }, {
  reduce: function reduce(callbackfn) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
  }
});
var fetchMembers = ({
  daoId,
  daoChain,
  graphApiKeys,
  filter,
  ordering,
  paging,
  pageParam
}) => __awaiter(void 0, void 0, void 0, function* () {
  if (!daoChain || !daoId)
    return;
  try {
    const res = yield (0, import_moloch_v3_data.listMembers)({
      filter,
      networkId: daoChain,
      ordering,
      paging: pageParam || paging,
      graphApiKeys
    });
    return res;
  } catch (error) {
    throw new Error((0, import_utils.handleErrorMessage)({
      error,
      fallback: "Error fetching proposals"
    }));
  }
});
var useDaoMembers = (props) => {
  const {
    daoId: daoIdOverride,
    daoChain: daoChainOverride,
    graphApiKeys = import_keychain_utils.GRAPH_API_KEYS,
    filter: filterFromProps,
    ordering: orderFromProps = {
      orderBy: "createdAt",
      orderDirection: "desc"
    },
    paging = {
      pageSize: 20,
      offset: 0
    }
  } = props || {};
  const {
    daoId: idFromRouter,
    daoChain: networkFromRouter,
    getFilter,
    updateFilter,
    getOrder,
    updateOrder
  } = (useCurrentDao === null || useCurrentDao === void 0 ? void 0 : useCurrentDao()) || {};
  const daoId = daoIdOverride || idFromRouter;
  const daoChain = daoChainOverride || networkFromRouter;
  const queryId = daoScopedQueryId({
    daoChain,
    daoId,
    domain: DaoQueryKeys.Members
  });
  const [filter, setFilter] = (0, import_react.useState)(checkContextDefault(queryId, filterFromProps || {
    dao: daoId
  }, getFilter));
  const [ordering, setOrdering] = (0, import_react.useState)(checkContextDefault(queryId, orderFromProps, getOrder));
  const _a = useInfiniteQuery([queryId, {
    daoId,
    daoChain,
    filter,
    ordering,
    paging
  }], ({
    pageParam
  }) => fetchMembers({
    daoId,
    daoChain,
    graphApiKeys,
    filter,
    ordering,
    paging,
    pageParam
  }), {
    enabled: !!daoId && !!daoChain && !!paging && !!ordering,
    getNextPageParam: (lastPage) => lastPage === null || lastPage === void 0 ? void 0 : lastPage.nextPaging
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  const allMembers = (0, import_react.useMemo)(() => {
    var _a2;
    return ((_a2 = data2 === null || data2 === void 0 ? void 0 : data2.pages) === null || _a2 === void 0 ? void 0 : _a2.reduce((acc, page) => {
      if (page === null || page === void 0 ? void 0 : page.items) {
        const truthyItems = page.items.filter((item) => !!item);
        return [...acc, ...truthyItems];
      }
      return acc;
    }, [])) || [];
  }, [data2]);
  const filterMembers = (filter2) => {
    if (typeof updateFilter === "function") {
      updateFilter(queryId, filter2);
      setFilter(filter2);
    } else {
      setFilter(filter2);
    }
  };
  const orderMembers = (ordering2) => {
    if (typeof updateOrder === "function") {
      updateOrder(queryId, ordering2);
      setOrdering(ordering2);
    } else {
      setOrdering(ordering2);
    }
  };
  return Object.assign({
    members: allMembers,
    error,
    filter,
    filterMembers,
    data: data2,
    ordering,
    orderMembers
  }, rest);
};
var fetchProposals = ({
  daoId,
  daoChain,
  graphApiKeys,
  filter,
  ordering,
  paging,
  pageParam
}) => __awaiter(void 0, void 0, void 0, function* () {
  if (!daoChain || !daoId)
    return;
  try {
    const res = yield (0, import_moloch_v3_data.listProposals)({
      filter,
      networkId: daoChain,
      ordering,
      paging: pageParam || paging,
      graphApiKeys
    });
    return res;
  } catch (error) {
    throw new Error((0, import_utils.handleErrorMessage)({
      error,
      fallback: "Error fetching proposals"
    }));
  }
});
var useDaoProposals = (props) => {
  const {
    daoId: daoIdOverride,
    daoChain: daoChainOverride,
    graphApiKeys = import_keychain_utils.GRAPH_API_KEYS,
    filter: filterFromProps,
    ordering: orderFromProps = {
      orderBy: "createdAt",
      orderDirection: "desc"
    },
    paging = {
      pageSize: 5,
      offset: 0
    }
  } = props || {};
  const {
    daoId: idFromRouter,
    daoChain: networkFromRouter,
    getFilter,
    updateFilter,
    getOrder,
    updateOrder
  } = (useCurrentDao === null || useCurrentDao === void 0 ? void 0 : useCurrentDao()) || {};
  const daoId = daoIdOverride || idFromRouter;
  const daoChain = daoChainOverride || networkFromRouter;
  const queryId = daoScopedQueryId({
    daoChain,
    daoId,
    domain: DaoQueryKeys.Proposals
  });
  const [filter, setFilter] = (0, import_react.useState)(checkContextDefault(queryId, filterFromProps || {
    dao: daoId
  }, getFilter));
  const [ordering, setOrdering] = (0, import_react.useState)(checkContextDefault(queryId, orderFromProps, getOrder));
  const _a = useInfiniteQuery(["proposals", {
    daoId,
    daoChain,
    filter,
    ordering,
    paging
  }], ({
    pageParam
  }) => fetchProposals({
    daoId,
    daoChain,
    graphApiKeys,
    filter,
    ordering,
    paging,
    pageParam
  }), {
    enabled: !!daoId && !!daoChain && !!paging && !!ordering,
    getNextPageParam: (lastPage) => lastPage === null || lastPage === void 0 ? void 0 : lastPage.nextPaging
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  const allProposals = (0, import_react.useMemo)(() => {
    var _a2;
    return ((_a2 = data2 === null || data2 === void 0 ? void 0 : data2.pages) === null || _a2 === void 0 ? void 0 : _a2.reduce((acc, page) => {
      if (page === null || page === void 0 ? void 0 : page.items) {
        return [...acc, ...page.items];
      }
      return [];
    }, [])) || [];
  }, [data2]);
  const filterProposals = (filter2) => {
    if (typeof updateFilter === "function") {
      updateFilter(queryId, filter2);
      setFilter(filter2);
    } else {
      setFilter(filter2);
    }
  };
  const orderProposals = (ordering2) => {
    if (typeof updateOrder === "function") {
      updateOrder(queryId, ordering2);
      setOrdering(ordering2);
    } else {
      setOrdering(ordering2);
    }
  };
  return Object.assign({
    proposals: allProposals,
    error,
    filter,
    filterProposals,
    data: data2,
    ordering,
    orderProposals
  }, rest);
};
var fetchRecords = ({
  daoId,
  chainId,
  recordType,
  pageSize,
  offset,
  graphApiKeys,
  credentialType
}) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const data2 = yield (0, import_moloch_v3_data.listRecords)({
      networkId: chainId,
      graphApiKeys,
      filter: {
        dao: daoId,
        table: recordType
      },
      paging: {
        pageSize,
        offset
      }
    });
    if (credentialType) {
      return data2.items.filter(
        (item) => {
          var _a;
          return ((_a = item === null || item === void 0 ? void 0 : item.parsedContent) === null || _a === void 0 ? void 0 : _a.credentialIdentifier) === credentialType;
        }
      );
    }
    return data2.items;
  } catch (error) {
    console.error(error);
    throw new Error((0, import_utils.handleErrorMessage)({
      error,
      fallback: "Error fetching records"
    }));
  }
});
var useRecords = ({
  daoId,
  chainId,
  recordType,
  pageSize: _pageSize = 20,
  offset: _offset = 0,
  graphApiKeys: _graphApiKeys = import_keychain_utils.GRAPH_API_KEYS,
  credentialType
}) => {
  const _a = useQuery([credentialType || recordType, {
    daoId,
    chainId
  }], () => fetchRecords({
    daoId,
    chainId,
    recordType,
    pageSize: _pageSize,
    offset: _offset,
    graphApiKeys: _graphApiKeys,
    credentialType
  }), {
    enabled: !!daoId && !!chainId
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  return Object.assign({
    records: data2,
    error
  }, rest);
};
var allNetworks = Object.keys(import_keychain_utils.CONTRACT_KEYCHAINS.V3_FACTORY_ADV_TOKEN);
var useDaosByUser = ({
  userAddress,
  networkIds: _networkIds = allNetworks,
  daoFilter,
  memberFilter,
  graphApiKeys: _graphApiKeys = import_keychain_utils.GRAPH_API_KEYS,
  ordering: _ordering = {
    orderBy: "createdAt",
    orderDirection: "desc"
  }
}) => {
  var _a;
  const _b = useQuery([`daosByUser-${userAddress}`, {
    networkIds: _networkIds,
    daoFilter,
    memberFilter,
    ordering: _ordering
  }], () => (0, import_moloch_v3_data.listDaosByMember)({
    memberAddress: userAddress,
    networkIds: _networkIds,
    daoFilter,
    memberFilter,
    ordering: _ordering,
    graphApiKeys: _graphApiKeys
  }), {
    enabled: !!userAddress,
    keepPreviousData: true
  }), {
    data: data2,
    error
  } = _b, rest = __rest(_b, ["data", "error"]);
  return Object.assign({
    daos: (_a = data2 === null || data2 === void 0 ? void 0 : data2.data) === null || _a === void 0 ? void 0 : _a.daos,
    error
  }, rest);
};
var wellKnownSymbol$1 = wellKnownSymbol$8;
var TO_STRING_TAG$1 = wellKnownSymbol$1("toStringTag");
var test = {};
test[TO_STRING_TAG$1] = "z";
var toStringTagSupport = String(test) === "[object z]";
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable = isCallable$f;
var classofRaw = classofRaw$1;
var wellKnownSymbol = wellKnownSymbol$8;
var TO_STRING_TAG = wellKnownSymbol("toStringTag");
var $Object = Object;
var CORRECT_ARGUMENTS = classofRaw(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error) {
  }
};
var classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
};
var classof = classof$1;
var $String = String;
var toString2 = function(argument) {
  if (classof(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String(argument);
};
var anObject$1 = anObject$7;
var regexpFlags = function() {
  var that = anObject$1(this);
  var result = "";
  if (that.hasIndices)
    result += "d";
  if (that.global)
    result += "g";
  if (that.ignoreCase)
    result += "i";
  if (that.multiline)
    result += "m";
  if (that.dotAll)
    result += "s";
  if (that.unicode)
    result += "u";
  if (that.unicodeSets)
    result += "v";
  if (that.sticky)
    result += "y";
  return result;
};
var call = functionCall;
var hasOwn2 = hasOwnProperty_1;
var isPrototypeOf = objectIsPrototypeOf;
var regExpFlags = regexpFlags;
var RegExpPrototype$1 = RegExp.prototype;
var regexpGetFlags = function(R) {
  var flags = R.flags;
  return flags === void 0 && !("flags" in RegExpPrototype$1) && !hasOwn2(R, "flags") && isPrototypeOf(RegExpPrototype$1, R) ? call(regExpFlags, R) : flags;
};
var PROPER_FUNCTION_NAME = functionName.PROPER;
var defineBuiltIn = defineBuiltIn$4;
var anObject = anObject$7;
var $toString = toString2;
var fails = fails$d;
var getRegExpFlags = regexpGetFlags;
var TO_STRING = "toString";
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];
var NOT_GENERIC = fails(function() {
  return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name != TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn(RegExp.prototype, TO_STRING, function toString3() {
    var R = anObject(this);
    var pattern = $toString(R.source);
    var flags = $toString(getRegExpFlags(R));
    return "/" + pattern + "/" + flags;
  }, { unsafe: true });
}
var fetchTokenData = ({
  tokenAddress,
  userAddress,
  chainId,
  spenderAddress,
  rpcs,
  fetchShape
}) => __awaiter(void 0, void 0, void 0, function* () {
  const client = (0, import_utils.createViemClient)({
    chainId,
    rpcs
  });
  try {
    const decimals = (fetchShape === null || fetchShape === void 0 ? void 0 : fetchShape.decimals) ? yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "decimals"
    }) : null;
    const name = (fetchShape === null || fetchShape === void 0 ? void 0 : fetchShape.name) ? yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "name"
    }) : null;
    const symbol = (fetchShape === null || fetchShape === void 0 ? void 0 : fetchShape.symbol) ? yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "symbol"
    }) : null;
    const totalSupply = (fetchShape === null || fetchShape === void 0 ? void 0 : fetchShape.totalSupply) ? yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "totalSupply"
    }) : null;
    const balance = (fetchShape === null || fetchShape === void 0 ? void 0 : fetchShape.balanceOf) && userAddress ? yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "balanceOf",
      args: [userAddress]
    }) : null;
    const allowance = (fetchShape === null || fetchShape === void 0 ? void 0 : fetchShape.allowance) && userAddress && spenderAddress ? yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "allowance",
      args: [userAddress, spenderAddress]
    }) : null;
    const data2 = {
      decimals,
      name,
      symbol,
      totalSupply: totalSupply ? totalSupply === null || totalSupply === void 0 ? void 0 : totalSupply.toString() : null,
      balance: balance ? balance === null || balance === void 0 ? void 0 : balance.toString() : null,
      allowance: allowance ? allowance === null || allowance === void 0 ? void 0 : allowance.toString() : null,
      isApproved: !!allowance && allowance > 0
    };
    console.log("data", data2);
    return data2;
  } catch (error) {
    console.error(error);
    throw new Error(error === null || error === void 0 ? void 0 : error.message);
  }
});
var useERC20 = ({
  tokenAddress,
  userAddress,
  spenderAddress,
  chainId,
  rpcs,
  cacheTime: _cacheTime = 1e3 * 60 * 20,
  staleTime: _staleTime = 1e3 * 60 * 20,
  fetchShape: _fetchShape = {
    decimals: true,
    name: true,
    symbol: true,
    totalSupply: true,
    balanceOf: true,
    allowance: true
  }
}) => {
  const _a = useQuery([`tokenData-${tokenAddress}`, {
    tokenAddress,
    userAddress,
    chainId,
    spenderAddress
  }], () => fetchTokenData({
    tokenAddress,
    userAddress,
    chainId,
    rpcs,
    spenderAddress,
    fetchShape: _fetchShape
  }), {
    enabled: !!tokenAddress && !!chainId,
    cacheTime: _cacheTime,
    staleTime: _staleTime
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  return Object.assign({
    tokenData: data2,
    error
  }, rest);
};
var fetchProposal = ({
  daoId,
  daoChain,
  proposalId,
  graphApiKeys
}) => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  if (!daoChain || !daoId || !proposalId)
    return;
  try {
    const res = yield (0, import_moloch_v3_data.findProposal)({
      dao: daoId,
      proposalId,
      networkId: daoChain,
      graphApiKeys
    });
    return (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.proposal;
  } catch (error) {
    console.error(error);
    throw new Error("Error fetching proposal");
  }
});
var useDaoProposal = (props) => {
  const {
    daoChain: daoChainOverride,
    daoId: daoIdOverride,
    proposalId: proposalIdOverride,
    graphApiKeys = import_keychain_utils.GRAPH_API_KEYS
  } = props || {};
  const {
    proposalId: propIdFromRouter,
    daoChain: networkFromRouter,
    daoId: daoIdFromRouter
  } = (useCurrentDao === null || useCurrentDao === void 0 ? void 0 : useCurrentDao()) || {};
  const daoId = daoIdOverride || daoIdFromRouter;
  const daoChain = daoChainOverride || networkFromRouter;
  const proposalId = proposalIdOverride || propIdFromRouter;
  const _a = useQuery([daoScopedQueryId({
    daoId,
    daoChain,
    domain: DaoQueryKeys.SingleProposal
  }), {
    daoChain,
    daoId,
    proposalId
  }], () => fetchProposal({
    daoId,
    daoChain,
    proposalId,
    graphApiKeys
  }), {
    enabled: !!daoId && !!daoChain && !!proposalId
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  return Object.assign({
    proposal: data2,
    error
  }, rest);
};
var fetchProfile = ({
  address,
  mainnetRpc
}) => __awaiter(void 0, void 0, void 0, function* () {
  const profile = yield (0, import_profile_data.getProfileForAddress)({
    address,
    rpcUri: mainnetRpc
  });
  return profile;
});
var useProfile = ({
  address,
  mainnetRpc: _mainnetRpc = import_keychain_utils.HAUS_RPC["0x1"]
}) => {
  const _a = useQuery([`globalProfile-${address}`], () => fetchProfile({
    address,
    mainnetRpc: _mainnetRpc
  }), {
    enabled: !!address
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  return Object.assign({
    profile: data2,
    error
  }, rest);
};
var useTraceUpdate = (props) => {
  const prev = (0, import_react.useRef)(props);
  (0, import_react.useEffect)(() => {
    const changedProps = Object.entries(props).reduce((ps, [k, v]) => {
      if (prev.current[k] !== v) {
        ps[k] = [prev.current[k], v];
      }
      return ps;
    }, {});
    if (Object.keys(changedProps).length > 0) {
      console.log("Changed props:", changedProps);
    }
    prev.current = props;
  });
};
var fetchMember = ({
  daoid,
  daochain,
  address,
  graphApiKeys
}) => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  try {
    const res = yield (0, import_moloch_v3_data.findMember)({
      networkId: daochain,
      dao: daoid,
      memberAddress: address.toLowerCase(),
      graphApiKeys
    });
    if ((_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.member) {
      return res.data.member;
    } else {
      console.error("no member found");
      return;
    }
  } catch (error) {
    console.error(error);
    return;
  }
});
var findUserMember = ({
  daoChain,
  daoId,
  memberAddress,
  graphApiKeys
}) => __awaiter(void 0, void 0, void 0, function* () {
  if (!daoChain || !daoId || !memberAddress)
    throw new Error("useConnectedMember requires a daoChain, daoId, and memberAddress");
  const url = (0, import_keychain_utils.getGraphUrl)(daoChain, graphApiKeys);
  if (!url)
    throw new Error("No graph url found for network: " + daoChain);
  try {
    const res = yield fetchMember({
      daoid: daoId,
      daochain: daoChain,
      address: memberAddress,
      graphApiKeys
    });
    if (!res)
      return;
    return res;
  } catch (error) {
    console.error(error);
    throw new Error((0, import_utils.handleErrorMessage)({
      fallback: "Error fetching user member",
      error
    }));
  }
});
var useConnectedMember = (props) => {
  const {
    daoChain: daoChainOverride,
    daoId: daoIdOverride,
    memberAddress: memberAddressOverride,
    graphApiKeys = import_keychain_utils.GRAPH_API_KEYS
  } = props || {};
  const {
    userAddress: memberAddressFromContext,
    daoChain: networkFromContext,
    daoId: daoIdFromContext
  } = (useCurrentDao === null || useCurrentDao === void 0 ? void 0 : useCurrentDao()) || {};
  const daoId = daoIdOverride || daoIdFromContext;
  const daoChain = daoChainOverride || networkFromContext;
  const memberAddress = memberAddressOverride || memberAddressFromContext;
  const queryId = daoScopedQueryId({
    daoId,
    daoChain,
    domain: DaoQueryKeys.ConnectedMember
  });
  const _a = useQuery([queryId, {
    daoChain,
    daoId,
    memberAddress
  }], () => findUserMember({
    daoChain,
    daoId,
    memberAddress,
    graphApiKeys
  }), {
    enabled: !!daoChain && !!daoId && !!memberAddress
  }), {
    data: data2,
    error
  } = _a, rest = __rest(_a, ["data", "error"]);
  return Object.assign(Object.assign({
    connectedMember: data2,
    error
  }, rest), {
    isMember: !!data2
  });
};

export {
  CurrentDaoContext,
  CurrentDaoProvider,
  useCurrentDao,
  MULTI_DAO_ROUTER,
  DaoQueryKeys,
  daoScopedQueryId,
  checkContextDefault,
  fetchDao,
  useDaoData,
  useDaoMember,
  useDaoMembers,
  useDaoProposals,
  useRecords,
  useDaosByUser,
  useERC20,
  useDaoProposal,
  useProfile,
  useTraceUpdate,
  fetchMember,
  useConnectedMember
};
//# sourceMappingURL=chunk-QZP67E6F.js.map
