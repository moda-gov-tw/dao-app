import {
  IEvents,
  JsonRpcProvider,
  encodeIss,
  esm_default,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  generateKeyPair,
  getBigIntRpcId,
  init_esm as init_esm3,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  payloadId,
  require_browser,
  require_cjs as require_cjs5,
  require_cjs2 as require_cjs6,
  require_cjs3 as require_cjs7,
  require_lodash,
  safeJsonParse,
  safeJsonStringify,
  signJWT
} from "./chunk-UOXCO36R.js";
import {
  useConnectedMember,
  useCurrentDao,
  useDaoData,
  useDaoMembers
} from "./chunk-QZP67E6F.js";
import {
  BsCheckCircle
} from "./chunk-IPUOWYW2.js";
import {
  CoreFieldLookup,
  FieldSpacer,
  FormBuilderFactory,
  require_react_is,
  useFormBuilder
} from "./chunk-VAYEHJ7M.js";
import {
  cacheABI,
  fetchABI,
  getCode,
  hashMessage,
  init_lib,
  init_lib10,
  init_lib11,
  init_lib12,
  init_lib13,
  init_lib14,
  init_lib15,
  init_lib16,
  init_lib17,
  init_lib18,
  init_lib19,
  init_lib2,
  init_lib20,
  init_lib21,
  init_lib3,
  init_lib4,
  init_lib5,
  init_lib6,
  init_lib7,
  init_lib8,
  init_lib9,
  init_tx_builder,
  lib_exports,
  lib_exports10,
  lib_exports11,
  lib_exports12,
  lib_exports13,
  lib_exports14,
  lib_exports15,
  lib_exports16,
  lib_exports17,
  lib_exports18,
  lib_exports19,
  lib_exports2,
  lib_exports20,
  lib_exports21,
  lib_exports3,
  lib_exports4,
  lib_exports5,
  lib_exports6,
  lib_exports7,
  lib_exports8,
  lib_exports9,
  recoverAddress,
  require_buffer,
  require_sha3,
  txActionToMetaTx,
  useTxBuilder
} from "./chunk-D5VMCTSK.js";
import {
  require_src2 as require_src4
} from "./chunk-SYS7556B.js";
import {
  require_src
} from "./chunk-R7RRHWOA.js";
import {
  useDHConnect
} from "./chunk-IYRBC5QN.js";
import {
  RELAY_JSONRPC,
  concat,
  detect,
  fromString,
  require_chacha20poly1305,
  require_cjs as require_cjs2,
  require_cjs2 as require_cjs3,
  require_cjs3 as require_cjs4,
  require_decode_uri_component,
  require_events,
  require_filter_obj,
  require_hkdf,
  require_random,
  require_sha256,
  require_split_on_first,
  require_strict_uri_encode,
  require_x25519,
  toString
} from "./chunk-7XBLEUPS.js";
import {
  init_esm as init_esm2
} from "./chunk-M75A2V3Z.js";
import {
  isAddress
} from "./chunk-JP6YUYUV.js";
import {
  AddressDisplay,
  Bold,
  Button,
  Card,
  Checkbox,
  CollapsibleCard,
  DataMd,
  DataSm,
  Dialog,
  DialogContent,
  DialogTrigger,
  ErrorText,
  FieldAlert,
  FieldWrapper,
  H5,
  HighlightInputText,
  Icon$1,
  InputSelect,
  Label$2,
  Loading,
  ParMd,
  ParSm,
  ParXs,
  ShamanPermission,
  TintSecondary,
  Tooltip,
  WrappedCheckbox,
  WrappedInput,
  WrappedInputSelect,
  WrappedSelect,
  WrappedTextArea,
  require_classnames,
  useFormContext,
  useToast,
  useWatch
} from "./chunk-LHJQX32V.js";
import {
  Je,
  at,
  st
} from "./chunk-AS6NKUTQ.js";
import {
  addDays,
  addHours,
  addMinutes,
  addMonths,
  addQuarters,
  addWeeks,
  addYears,
  differenceInCalendarDays,
  differenceInCalendarMonths,
  differenceInCalendarYears,
  endOfDay,
  endOfMonth,
  endOfYear,
  format,
  getDate,
  getDay,
  getHours,
  getISOWeek,
  getMinutes,
  getMonth,
  getQuarter,
  getSeconds,
  getTime,
  getYear,
  init_addDays,
  init_addHours,
  init_addMinutes,
  init_addMonths,
  init_addQuarters,
  init_addWeeks,
  init_addYears,
  init_differenceInCalendarDays,
  init_differenceInCalendarMonths,
  init_differenceInCalendarYears,
  init_endOfDay,
  init_endOfMonth,
  init_endOfWeek,
  init_endOfYear,
  init_esm,
  init_format,
  init_getDate,
  init_getDay,
  init_getHours,
  init_getISOWeek,
  init_getMinutes,
  init_getMonth,
  init_getQuarter,
  init_getSeconds,
  init_getTime,
  init_getYear,
  init_isAfter,
  init_isBefore,
  init_isDate,
  init_isEqual,
  init_isSameDay,
  init_isSameMonth,
  init_isSameQuarter,
  init_isSameYear,
  init_isValid,
  init_isWithinInterval,
  init_max,
  init_min,
  init_parse,
  init_parseISO,
  init_set,
  init_setHours,
  init_setMinutes,
  init_setMonth,
  init_setQuarter,
  init_setSeconds,
  init_setYear,
  init_startOfDay,
  init_startOfMonth,
  init_startOfQuarter,
  init_startOfWeek,
  init_startOfYear,
  init_subDays,
  init_subMonths,
  init_subQuarters,
  init_subWeeks,
  init_subYears,
  init_toDate,
  isAfter,
  isBefore,
  isDate,
  isEqual,
  isSameDay,
  isSameMonth,
  isSameQuarter,
  isSameYear,
  isValid,
  isWithinInterval,
  max,
  min,
  parse,
  parseISO,
  require_src as require_src3,
  set,
  setHours,
  setMinutes,
  setMonth,
  setQuarter,
  setSeconds,
  setYear,
  startOfDay,
  startOfMonth,
  startOfQuarter,
  startOfWeek,
  startOfYear,
  subDays,
  subMonths,
  subQuarters,
  subWeeks,
  subYears,
  toDate
} from "./chunk-KYOZVWPW.js";
import {
  require_react_dom
} from "./chunk-JM7HR6U7.js";
import {
  require_cjs
} from "./chunk-JTBPOENI.js";
import {
  require_jsx_runtime
} from "./chunk-GYNMGCXV.js";
import {
  require_react
} from "./chunk-T5BEU6ZH.js";
import {
  require_src as require_src2
} from "./chunk-EBQ4QPBR.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __reExport,
  __toCommonJS,
  __toESM
} from "./chunk-LMAYTEU7.js";

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style)
        return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i3 = str.lastIndexOf(NEWLINE);
        column = ~i3 ? str.length - i3 : column + str.length;
      }
      function position3() {
        var start2 = { line: lineno, column };
        return function(node2) {
          node2.position = new Position(start2);
          whitespace2();
          return node2;
        };
      }
      function Position(start2) {
        this.start = start2;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      var errorsList = [];
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match2(re4) {
        var m4 = re4.exec(style);
        if (!m4)
          return;
        var str = m4[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m4;
      }
      function whitespace2() {
        match2(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c3;
        rules = rules || [];
        while (c3 = comment()) {
          if (c3 !== false) {
            rules.push(c3);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position3();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1))
          return;
        var i3 = 2;
        while (EMPTY_STRING != style.charAt(i3) && (ASTERISK != style.charAt(i3) || FORWARD_SLASH != style.charAt(i3 + 1))) {
          ++i3;
        }
        i3 += 2;
        if (EMPTY_STRING === style.charAt(i3 - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i3 - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i3);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position3();
        var prop = match2(PROPERTY_REGEX);
        if (!prop)
          return;
        comment();
        if (!match2(COLON_REGEX))
          return error("property missing ':'");
        var val = match2(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim3(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim3(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match2(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim3(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/style-to-object/index.js
var require_style_to_object = __commonJS({
  "node_modules/style-to-object/index.js"(exports, module) {
    var parse10 = require_inline_style_parser();
    function StyleToObject2(style, iterator) {
      var output = null;
      if (!style || typeof style !== "string") {
        return output;
      }
      var declaration;
      var declarations = parse10(style);
      var hasIterator = typeof iterator === "function";
      var property;
      var value;
      for (var i3 = 0, len = declarations.length; i3 < len; i3++) {
        declaration = declarations[i3];
        property = declaration.property;
        value = declaration.value;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }
      return output;
    }
    module.exports = StyleToObject2;
    module.exports.default = StyleToObject2;
  }
});

// node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/debug/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m4 = s * 60;
    var h5 = m4 * 60;
    var d4 = h5 * 24;
    var w6 = d4 * 7;
    var y4 = d4 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse10(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse10(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match2) {
        return;
      }
      var n2 = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y4;
        case "weeks":
        case "week":
        case "w":
          return n2 * w6;
        case "days":
        case "day":
        case "d":
          return n2 * d4;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h5;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m4;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d4) {
        return Math.round(ms2 / d4) + "d";
      }
      if (msAbs >= h5) {
        return Math.round(ms2 / h5) + "h";
      }
      if (msAbs >= m4) {
        return Math.round(ms2 / m4) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d4) {
        return plural(ms2, msAbs, d4, "day");
      }
      if (msAbs >= h5) {
        return plural(ms2, msAbs, h5, "hour");
      }
      if (msAbs >= m4) {
        return plural(ms2, msAbs, m4, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env4) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env4).forEach((key) => {
        createDebug2[key] = env4[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash3 = 0;
        for (let i3 = 0; i3 < namespace.length; i3++) {
          hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i3);
          hash3 |= 0;
        }
        return createDebug2.colors[Math.abs(hash3) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug2.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index2];
              match2 = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match2;
          });
          createDebug2.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug2.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        let i3;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i3 = 0; i3 < len; i3++) {
          if (!split2[i3]) {
            continue;
          }
          namespaces = split2[i3].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug2.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug2.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names.map(toNamespace),
          ...createDebug2.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i3;
        let len;
        for (i3 = 0, len = createDebug2.skips.length; i3 < len; i3++) {
          if (createDebug2.skips[i3].test(name)) {
            return false;
          }
        }
        for (i3 = 0, len = createDebug2.names.length; i3 < len; i3++) {
          if (createDebug2.names[i3].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c3 = "color: " + this.color;
      args.splice(1, 0, c3, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c3);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn3 = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty4 = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray3 = function isArray4(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject2 = function isPlainObject3(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn3.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn3.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn3.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty4 && options.name === "__proto__") {
        defineProperty4(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn3.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend2() {
      var options, name, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i3 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i3 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i3 < length; ++i3) {
        options = arguments[i3];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray3(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray3(src) ? src : [];
                } else {
                  clone = src && isPlainObject2(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/ethers/lib/utils.js
var require_utils = __commonJS({
  "node_modules/ethers/lib/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m4, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m4[k4];
      } });
    } : function(o2, m4, k4, k22) {
      if (k22 === void 0)
        k22 = k4;
      o2[k22] = m4[k4];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v });
    } : function(o2, v) {
      o2["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k4 in mod)
          if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod, k4))
            __createBinding(result, mod, k4);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
    exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;
    var abi_1 = (init_lib10(), __toCommonJS(lib_exports10));
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_1.AbiCoder;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abi_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return abi_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "defaultAbiCoder", { enumerable: true, get: function() {
      return abi_1.defaultAbiCoder;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return abi_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return abi_1.EventFragment;
    } });
    Object.defineProperty(exports, "FormatTypes", { enumerable: true, get: function() {
      return abi_1.FormatTypes;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return abi_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return abi_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return abi_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return abi_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return abi_1.LogDescription;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return abi_1.ParamType;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return abi_1.TransactionDescription;
    } });
    var address_1 = (init_lib6(), __toCommonJS(lib_exports6));
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_1.getAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return address_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return address_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_1.getIcapAddress;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return address_1.isAddress;
    } });
    var base64 = __importStar((init_lib8(), __toCommonJS(lib_exports8)));
    exports.base64 = base64;
    var basex_1 = (init_lib13(), __toCommonJS(lib_exports13));
    Object.defineProperty(exports, "base58", { enumerable: true, get: function() {
      return basex_1.Base58;
    } });
    var bytes_1 = (init_lib2(), __toCommonJS(lib_exports2));
    Object.defineProperty(exports, "arrayify", { enumerable: true, get: function() {
      return bytes_1.arrayify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return bytes_1.concat;
    } });
    Object.defineProperty(exports, "hexConcat", { enumerable: true, get: function() {
      return bytes_1.hexConcat;
    } });
    Object.defineProperty(exports, "hexDataSlice", { enumerable: true, get: function() {
      return bytes_1.hexDataSlice;
    } });
    Object.defineProperty(exports, "hexDataLength", { enumerable: true, get: function() {
      return bytes_1.hexDataLength;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return bytes_1.hexlify;
    } });
    Object.defineProperty(exports, "hexStripZeros", { enumerable: true, get: function() {
      return bytes_1.hexStripZeros;
    } });
    Object.defineProperty(exports, "hexValue", { enumerable: true, get: function() {
      return bytes_1.hexValue;
    } });
    Object.defineProperty(exports, "hexZeroPad", { enumerable: true, get: function() {
      return bytes_1.hexZeroPad;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return bytes_1.isBytes;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return bytes_1.isBytesLike;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return bytes_1.isHexString;
    } });
    Object.defineProperty(exports, "joinSignature", { enumerable: true, get: function() {
      return bytes_1.joinSignature;
    } });
    Object.defineProperty(exports, "zeroPad", { enumerable: true, get: function() {
      return bytes_1.zeroPad;
    } });
    Object.defineProperty(exports, "splitSignature", { enumerable: true, get: function() {
      return bytes_1.splitSignature;
    } });
    Object.defineProperty(exports, "stripZeros", { enumerable: true, get: function() {
      return bytes_1.stripZeros;
    } });
    var hash_1 = (init_lib9(), __toCommonJS(lib_exports9));
    Object.defineProperty(exports, "_TypedDataEncoder", { enumerable: true, get: function() {
      return hash_1._TypedDataEncoder;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return hash_1.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hash_1.hashMessage;
    } });
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return hash_1.id;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return hash_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return hash_1.namehash;
    } });
    var hdnode_1 = (init_lib15(), __toCommonJS(lib_exports15));
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdnode_1.defaultPath;
    } });
    Object.defineProperty(exports, "entropyToMnemonic", { enumerable: true, get: function() {
      return hdnode_1.entropyToMnemonic;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdnode_1.getAccountPath;
    } });
    Object.defineProperty(exports, "HDNode", { enumerable: true, get: function() {
      return hdnode_1.HDNode;
    } });
    Object.defineProperty(exports, "isValidMnemonic", { enumerable: true, get: function() {
      return hdnode_1.isValidMnemonic;
    } });
    Object.defineProperty(exports, "mnemonicToEntropy", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToEntropy;
    } });
    Object.defineProperty(exports, "mnemonicToSeed", { enumerable: true, get: function() {
      return hdnode_1.mnemonicToSeed;
    } });
    var json_wallets_1 = (init_lib17(), __toCommonJS(lib_exports17));
    Object.defineProperty(exports, "getJsonWalletAddress", { enumerable: true, get: function() {
      return json_wallets_1.getJsonWalletAddress;
    } });
    var keccak256_1 = (init_lib4(), __toCommonJS(lib_exports4));
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_1.keccak256;
    } });
    var logger_1 = (init_lib(), __toCommonJS(lib_exports));
    Object.defineProperty(exports, "Logger", { enumerable: true, get: function() {
      return logger_1.Logger;
    } });
    var sha2_1 = (init_lib14(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return sha2_1.computeHmac;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return sha2_1.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_1.sha512;
    } });
    var solidity_1 = (init_lib20(), __toCommonJS(lib_exports20));
    Object.defineProperty(exports, "solidityKeccak256", { enumerable: true, get: function() {
      return solidity_1.keccak256;
    } });
    Object.defineProperty(exports, "solidityPack", { enumerable: true, get: function() {
      return solidity_1.pack;
    } });
    Object.defineProperty(exports, "soliditySha256", { enumerable: true, get: function() {
      return solidity_1.sha256;
    } });
    var random_1 = (init_lib16(), __toCommonJS(lib_exports16));
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_1.randomBytes;
    } });
    Object.defineProperty(exports, "shuffled", { enumerable: true, get: function() {
      return random_1.shuffled;
    } });
    var properties_1 = (init_lib3(), __toCommonJS(lib_exports3));
    Object.defineProperty(exports, "checkProperties", { enumerable: true, get: function() {
      return properties_1.checkProperties;
    } });
    Object.defineProperty(exports, "deepCopy", { enumerable: true, get: function() {
      return properties_1.deepCopy;
    } });
    Object.defineProperty(exports, "defineReadOnly", { enumerable: true, get: function() {
      return properties_1.defineReadOnly;
    } });
    Object.defineProperty(exports, "getStatic", { enumerable: true, get: function() {
      return properties_1.getStatic;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_1.resolveProperties;
    } });
    Object.defineProperty(exports, "shallowCopy", { enumerable: true, get: function() {
      return properties_1.shallowCopy;
    } });
    var RLP = __importStar((init_lib5(), __toCommonJS(lib_exports5)));
    exports.RLP = RLP;
    var signing_key_1 = (init_lib11(), __toCommonJS(lib_exports11));
    Object.defineProperty(exports, "computePublicKey", { enumerable: true, get: function() {
      return signing_key_1.computePublicKey;
    } });
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return signing_key_1.recoverPublicKey;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_1.SigningKey;
    } });
    var strings_1 = (init_lib7(), __toCommonJS(lib_exports7));
    Object.defineProperty(exports, "formatBytes32String", { enumerable: true, get: function() {
      return strings_1.formatBytes32String;
    } });
    Object.defineProperty(exports, "nameprep", { enumerable: true, get: function() {
      return strings_1.nameprep;
    } });
    Object.defineProperty(exports, "parseBytes32String", { enumerable: true, get: function() {
      return strings_1.parseBytes32String;
    } });
    Object.defineProperty(exports, "_toEscapedUtf8String", { enumerable: true, get: function() {
      return strings_1._toEscapedUtf8String;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return strings_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return strings_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return strings_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return strings_1.Utf8ErrorFuncs;
    } });
    var transactions_1 = (init_lib12(), __toCommonJS(lib_exports12));
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return transactions_1.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return transactions_1.computeAddress;
    } });
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return transactions_1.parse;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return transactions_1.recoverAddress;
    } });
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return transactions_1.serialize;
    } });
    Object.defineProperty(exports, "TransactionTypes", { enumerable: true, get: function() {
      return transactions_1.TransactionTypes;
    } });
    var units_1 = (init_lib21(), __toCommonJS(lib_exports21));
    Object.defineProperty(exports, "commify", { enumerable: true, get: function() {
      return units_1.commify;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_1.parseUnits;
    } });
    var wallet_1 = (init_lib18(), __toCommonJS(lib_exports18));
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return wallet_1.verifyMessage;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return wallet_1.verifyTypedData;
    } });
    var web_1 = (init_lib19(), __toCommonJS(lib_exports19));
    Object.defineProperty(exports, "_fetchData", { enumerable: true, get: function() {
      return web_1._fetchData;
    } });
    Object.defineProperty(exports, "fetchJson", { enumerable: true, get: function() {
      return web_1.fetchJson;
    } });
    Object.defineProperty(exports, "poll", { enumerable: true, get: function() {
      return web_1.poll;
    } });
    var sha2_2 = (init_lib14(), __toCommonJS(lib_exports14));
    Object.defineProperty(exports, "SupportedAlgorithm", { enumerable: true, get: function() {
      return sha2_2.SupportedAlgorithm;
    } });
    var strings_2 = (init_lib7(), __toCommonJS(lib_exports7));
    Object.defineProperty(exports, "UnicodeNormalizationForm", { enumerable: true, get: function() {
      return strings_2.UnicodeNormalizationForm;
    } });
    Object.defineProperty(exports, "Utf8ErrorReason", { enumerable: true, get: function() {
      return strings_2.Utf8ErrorReason;
    } });
  }
});

// node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-metadata/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs8 = __commonJS({
  "node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-metadata/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow2(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow2;
    function getFromWindowOrThrow2(name) {
      const res = getFromWindow2(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow2;
    function getDocumentOrThrow2() {
      return getFromWindowOrThrow2("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow2;
    function getDocument2() {
      return getFromWindow2("document");
    }
    exports.getDocument = getDocument2;
    function getNavigatorOrThrow2() {
      return getFromWindowOrThrow2("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow2;
    function getNavigator3() {
      return getFromWindow2("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow2() {
      return getFromWindowOrThrow2("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow2;
    function getLocation3() {
      return getFromWindow2("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow2() {
      return getFromWindowOrThrow2("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow2;
    function getCrypto2() {
      return getFromWindow2("crypto");
    }
    exports.getCrypto = getCrypto2;
    function getLocalStorageOrThrow2() {
      return getFromWindowOrThrow2("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow2;
    function getLocalStorage3() {
      return getFromWindow2("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs9 = __commonJS({
  "node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs8();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e2) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i3 = 0; i3 < links.length; i3++) {
          const link2 = links[i3];
          const rel = link2.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link2.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path2 = loc.pathname.split("/");
                    path2.pop();
                    const finalPath = path2.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i3 = 0; i3 < metaTags.length; i3++) {
          const tag = metaTags[i3];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content3 = tag.getAttribute("content");
            if (content3) {
              return content3;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs10 = __commonJS({
  "node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow2(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow2;
    function getFromWindowOrThrow2(name) {
      const res = getFromWindow2(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow2;
    function getDocumentOrThrow2() {
      return getFromWindowOrThrow2("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow2;
    function getDocument2() {
      return getFromWindow2("document");
    }
    exports.getDocument = getDocument2;
    function getNavigatorOrThrow2() {
      return getFromWindowOrThrow2("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow2;
    function getNavigator3() {
      return getFromWindow2("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow2() {
      return getFromWindowOrThrow2("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow2;
    function getLocation3() {
      return getFromWindow2("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow2() {
      return getFromWindowOrThrow2("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow2;
    function getCrypto2() {
      return getFromWindow2("crypto");
    }
    exports.getCrypto = getCrypto2;
    function getLocalStorageOrThrow2() {
      return getFromWindowOrThrow2("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow2;
    function getLocalStorage3() {
      return getFromWindow2("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/client/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/@walletconnect/client/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number2, base, endian) {
        if (BN4.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN4;
      } else {
        exports2.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e2) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max4(left2, right2) {
        if (left2.cmp(right2) > 0)
          return left2;
        return right2;
      };
      BN4.min = function min4(left2, right2) {
        if (left2.cmp(right2) < 0)
          return left2;
        return right2;
      };
      BN4.prototype._init = function init(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert3(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start2 = 0;
        if (number2[0] === "-") {
          start2++;
        }
        if (base === 16) {
          this._parseHex(number2, start2);
        } else {
          this._parseBase(number2, base, start2);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initArray = function _initArray(number2, base, endian) {
        assert3(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i3 = number2.length - 1, j5 = 0; i3 >= 0; i3 -= 3) {
            w6 = number2[i3] | number2[i3 - 1] << 8 | number2[i3 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j5 = 0; i3 < number2.length; i3 += 3) {
            w6 = number2[i3] | number2[i3 + 1] << 8 | number2[i3 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start2, end2) {
        var r2 = 0;
        var len = Math.min(str.length, end2);
        for (var i3 = start2; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r2 <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r2 |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r2 |= c3 - 17 + 10;
          } else {
            r2 |= c3 & 15;
          }
        }
        return r2;
      }
      BN4.prototype._parseHex = function _parseHex(number2, start2) {
        this.length = Math.ceil((number2.length - start2) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j5, w6;
        var off = 0;
        for (i3 = number2.length - 6, j5 = 0; i3 >= start2; i3 -= 6) {
          w6 = parseHex(number2, i3, i3 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j5++;
          }
        }
        if (i3 + 6 !== start2) {
          w6 = parseHex(number2, start2, i3 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start2, end2, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end2);
        for (var i3 = start2; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r2 *= mul;
          if (c3 >= 49) {
            r2 += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r2 += c3 - 17 + 10;
          } else {
            r2 += c3;
          }
        }
        return r2;
      }
      BN4.prototype._parseBase = function _parseBase(number2, base, start2) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start2;
        var mod = total % limbLen;
        var end2 = Math.min(total, total - mod) + start2;
        var word = 0;
        for (var i3 = start2; i3 < end2; i3 += limbLen) {
          word = parseBase(number2, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i3, number2.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r2 = new BN4(null);
        this.copy(r2);
        return r2;
      };
      BN4.prototype._expand = function _expand(size2) {
        while (this.length < size2) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString7(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w6 = this.words[i3];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r2 = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i3;
        var q4 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q4.isZero(); i3++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[reqLength - i3 - 1] = b4;
          }
        } else {
          for (i3 = 0; !q4.isZero(); i3++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[i3] = b4;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w6) {
          var t2 = w6;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t2 = w6;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b4 = this._zeroBits(this.words[i3]);
          r2 += b4;
          if (b4 !== 26)
            break;
        }
        return r2;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or3(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i3 = 0; i3 < b4.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a2;
        var b4;
        if (this.length > num.length) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        for (var i3 = 0; i3 < b4.length; i3++) {
          this.words[i3] = a2.words[i3] ^ b4.words[i3];
        }
        if (this !== a2) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b4;
        if (this.length > num.length) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b4.length; i3++) {
          r2 = (a2.words[i3] | 0) + (b4.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i3 < a2.length; i3++) {
          r2 = (a2.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        return this;
      };
      BN4.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b4;
        if (cmp > 0) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b4.length; i3++) {
          r2 = (a2.words[i3] | 0) - (b4.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        for (; carry !== 0 && i3 < a2.length; i3++) {
          r2 = (a2.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        if (carry === 0 && i3 < a2.length && a2 !== this) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r2 = a2 * b4;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1; k4 < len; k4++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j5 = Math.max(0, k4 - self2.length + 1); j5 <= maxJ; j5++) {
            var i3 = k4 - j5 | 0;
            a2 = self2.words[i3] | 0;
            b4 = num.words[j5] | 0;
            r2 = a2 * b4 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k4] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k4] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b4 = num.words;
        var o2 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w22;
        o2[3] = w32;
        o2[4] = w42;
        o2[5] = w52;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c3 !== 0) {
          o2[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k4 = 0; k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j5 = Math.max(0, k4 - self2.length + 1); j5 <= maxJ; j5++) {
            var i3 = k4 - j5;
            var a2 = self2.words[i3] | 0;
            var b4 = num.words[j5] | 0;
            var r2 = a2 * b4;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k4] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k4] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y4) {
        this.x = x6;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N6) {
        var t2 = new Array(N6);
        var l2 = BN4.prototype._countBits(N6) - 1;
        for (var i3 = 0; i3 < N6; i3++) {
          t2[i3] = this.revBin(i3, l2, N6);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x6, l2, N6) {
        if (x6 === 0 || x6 === N6 - 1)
          return x6;
        var rb = 0;
        for (var i3 = 0; i3 < l2; i3++) {
          rb |= (x6 & 1) << l2 - i3 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N6) {
        for (var i3 = 0; i3 < N6; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N6, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N6);
        for (var s = 1; s < N6; s <<= 1) {
          var l2 = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p6 = 0; p6 < N6; p6 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s; j5++) {
              var re4 = rtws[p6 + j5];
              var ie4 = itws[p6 + j5];
              var ro = rtws[p6 + j5 + s];
              var io = itws[p6 + j5 + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j5] = re4 + ro;
              itws[p6 + j5] = ie4 + io;
              rtws[p6 + j5 + s] = re4 - ro;
              itws[p6 + j5 + s] = ie4 - io;
              if (j5 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m4) {
        var N6 = Math.max(m4, n2) | 1;
        var odd = N6 & 1;
        var i3 = 0;
        for (N6 = N6 / 2 | 0; N6; N6 = N6 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N6) {
        if (N6 <= 1)
          return;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var t2 = rws[i3];
          rws[i3] = rws[N6 - i3 - 1];
          rws[N6 - i3 - 1] = t2;
          t2 = iws[i3];
          iws[i3] = -iws[N6 - i3 - 1];
          iws[N6 - i3 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var w6 = Math.round(ws2[2 * i3 + 1] / N6) * 8192 + Math.round(ws2[2 * i3] / N6) + carry;
          ws2[i3] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws2[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N6; ++i3) {
          rws[i3] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N6) {
        var ph = new Array(N6);
        for (var i3 = 0; i3 < N6; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y4, out) {
        var N6 = 2 * this.guessLen13b(x6.length, y4.length);
        var rbt = this.makeRBT(N6);
        var _6 = this.stub(N6);
        var rws = new Array(N6);
        var rwst = new Array(N6);
        var iwst = new Array(N6);
        var nrws = new Array(N6);
        var nrwst = new Array(N6);
        var niwst = new Array(N6);
        var rmws = out.words;
        rmws.length = N6;
        this.convert13b(x6.words, x6.length, rws, N6);
        this.convert13b(y4.words, y4.length, nrws, N6);
        this.transform(rws, _6, rwst, iwst, N6, rbt);
        this.transform(nrws, _6, nrwst, niwst, N6, rbt);
        for (var i3 = 0; i3 < N6; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N6);
        this.transform(rwst, iwst, rmws, _6, N6, rbt);
        this.conjugate(rmws, _6, N6);
        this.normalize13b(rmws, N6);
        out.negative = x6.negative ^ y4.negative;
        out.length = x6.length + y4.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w6 = (this.words[i3] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN4(1);
        var res = this;
        for (var i3 = 0; i3 < w6.length; i3++, res = res.sqr()) {
          if (w6[i3] !== 0)
            break;
        }
        if (++i3 < w6.length) {
          for (var q4 = res.sqr(); i3 < w6.length; i3++, q4 = q4.sqr()) {
            if (w6[i3] === 0)
              continue;
            res = res.mul(q4);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i3;
        if (r2 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r2;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s] = this.words[i3];
          }
          for (i3 = 0; i3 < s; i3++) {
            this.words[i3] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h5 -= s;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i3 = 0; i3 < s; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h5); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s)
          return false;
        var w6 = this.words[s];
        return !!(w6 & q4);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
        var len = num.length + shift2;
        var i3;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w6 = (this.words[i3 + shift2] | 0) + carry;
          var right2 = (num.words[i3] | 0) * mul;
          w6 -= right2 & 67108863;
          carry = (w6 >> 26) - (right2 / 67108864 | 0);
          this.words[i3 + shift2] = w6 & 67108863;
        }
        for (; i3 < this.length - shift2; i3++) {
          w6 = (this.words[i3 + shift2] | 0) + carry;
          carry = w6 >> 26;
          this.words[i3 + shift2] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w6 = -(this.words[i3] | 0) + carry;
          carry = w6 >> 26;
          this.words[i3] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift2 = this.length - num.length;
        var a2 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift2 = 26 - bhiBits;
        if (shift2 !== 0) {
          b4 = b4.ushln(shift2);
          a2.iushln(shift2);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m4 = a2.length - b4.length;
        var q4;
        if (mode !== "mod") {
          q4 = new BN4(null);
          q4.length = m4 + 1;
          q4.words = new Array(q4.length);
          for (var i3 = 0; i3 < q4.length; i3++) {
            q4.words[i3] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b4, 1, m4);
        if (diff.negative === 0) {
          a2 = diff;
          if (q4) {
            q4.words[m4] = 1;
          }
        }
        for (var j5 = m4 - 1; j5 >= 0; j5--) {
          var qj = (a2.words[b4.length + j5] | 0) * 67108864 + (a2.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b4, qj, j5);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b4, 1, j5);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q4) {
            q4.words[j5] = qj;
          }
        }
        if (q4) {
          q4.strip();
        }
        a2.strip();
        if (mode !== "div" && shift2 !== 0) {
          a2.iushrn(shift2);
        }
        return {
          div: q4 || null,
          mod: a2
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p6 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w6 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var x6 = this;
        var y4 = p6.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p6);
        } else {
          x6 = x6.clone();
        }
        var A2 = new BN4(1);
        var B4 = new BN4(0);
        var C4 = new BN4(0);
        var D4 = new BN4(1);
        var g5 = 0;
        while (x6.isEven() && y4.isEven()) {
          x6.iushrn(1);
          y4.iushrn(1);
          ++g5;
        }
        var yp = y4.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i3 = 0, im = 1; (x6.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x6.iushrn(i3);
            while (i3-- > 0) {
              if (A2.isOdd() || B4.isOdd()) {
                A2.iadd(yp);
                B4.isub(xp);
              }
              A2.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y4.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x6.cmp(y4) >= 0) {
            x6.isub(y4);
            A2.isub(C4);
            B4.isub(D4);
          } else {
            y4.isub(x6);
            C4.isub(A2);
            D4.isub(B4);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y4.iushln(g5)
        };
      };
      BN4.prototype._invmp = function _invmp(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var a2 = this;
        var b4 = p6.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p6);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b4.clone();
        while (a2.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a2.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a2.cmp(b4) >= 0) {
            a2.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a2);
            x22.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b4 = num.clone();
        a2.negative = 0;
        b4.negative = 0;
        for (var shift2 = 0; a2.isEven() && b4.isEven(); shift2++) {
          a2.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r2 = a2.cmp(b4);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b4;
            b4 = t2;
          } else if (r2 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a2.isub(b4);
        } while (true);
        return b4.iushln(shift2);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q4;
          return this;
        }
        var carry = q4;
        for (var i3 = s; carry !== 0 && i3 < this.length; i3++) {
          var w6 = this.words[i3] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i3] = w6;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a2 = this.words[i3] | 0;
          var b4 = num.words[i3] | 0;
          if (a2 === b4)
            continue;
          if (a2 < b4) {
            res = -1;
          } else if (a2 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt5(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt6(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN4(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          r2.strip();
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next2 = input.words[i3] | 0;
          input.words[i3 - 10] = (next2 & mask) << 4 | prev >>> 22;
          prev = next2;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w6 = num.words[i3] | 0;
          lo += w6 * 977;
          num.words[i3] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN4._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert3(a2.negative === 0, "red works only with positives");
        assert3(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b4) {
        assert3((a2.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a2.red && a2.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b4) {
        this._verify2(a2, b4);
        return this.imod(a2.imul(b4));
      };
      Red.prototype.mul = function mul(a2, b4) {
        this._verify2(a2, b4);
        return this.imod(a2.mul(b4));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q4 = this.m.subn(1);
        var s = 0;
        while (!q4.isZero() && q4.andln(1) === 0) {
          s++;
          q4.iushrn(1);
        }
        assert3(!q4.isZero());
        var one3 = new BN4(1).toRed(this);
        var nOne = one3.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN4(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c3 = this.pow(z3, q4);
        var r2 = this.pow(a2, q4.addn(1).iushrn(1));
        var t2 = this.pow(a2, q4);
        var m4 = s;
        while (t2.cmp(one3) !== 0) {
          var tmp = t2;
          for (var i3 = 0; tmp.cmp(one3) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert3(i3 < m4);
          var b4 = this.pow(c3, new BN4(1).iushln(m4 - i3 - 1));
          r2 = r2.redMul(b4);
          c3 = b4.redSqr();
          t2 = t2.redMul(c3);
          m4 = i3;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a2;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start2 = num.bitLength() % 26;
        if (start2 === 0) {
          start2 = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j5 = start2 - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start2 = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b4) {
        if (a2.isZero() || b4.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b4);
        var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t2.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b4) {
        if (a2.isZero() || b4.isZero())
          return new BN4(0)._forceRed(this);
        var t2 = a2.mul(b4);
        var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t2.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    module.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString7 = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString7.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    var isTypedArray2 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/@walletconnect/client/node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/@walletconnect/client/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray3 = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray3 ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b4) => Number(a2) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse10(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse10;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys5 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys5.sort(options.sort);
      }
      return keys5.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x6) => x6.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash3] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse10(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode2(hash3, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash3 = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash3}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/bn.js/lib/bn.js
var require_bn2 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number2, base, endian) {
        if (BN4.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN4;
      } else {
        exports2.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e2) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max4(left2, right2) {
        if (left2.cmp(right2) > 0)
          return left2;
        return right2;
      };
      BN4.min = function min4(left2, right2) {
        if (left2.cmp(right2) < 0)
          return left2;
        return right2;
      };
      BN4.prototype._init = function init(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert3(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start2 = 0;
        if (number2[0] === "-") {
          start2++;
        }
        if (base === 16) {
          this._parseHex(number2, start2);
        } else {
          this._parseBase(number2, base, start2);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initArray = function _initArray(number2, base, endian) {
        assert3(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i3 = number2.length - 1, j5 = 0; i3 >= 0; i3 -= 3) {
            w6 = number2[i3] | number2[i3 - 1] << 8 | number2[i3 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j5 = 0; i3 < number2.length; i3 += 3) {
            w6 = number2[i3] | number2[i3 + 1] << 8 | number2[i3 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start2, end2) {
        var r2 = 0;
        var len = Math.min(str.length, end2);
        for (var i3 = start2; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r2 <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r2 |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r2 |= c3 - 17 + 10;
          } else {
            r2 |= c3 & 15;
          }
        }
        return r2;
      }
      BN4.prototype._parseHex = function _parseHex(number2, start2) {
        this.length = Math.ceil((number2.length - start2) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j5, w6;
        var off = 0;
        for (i3 = number2.length - 6, j5 = 0; i3 >= start2; i3 -= 6) {
          w6 = parseHex(number2, i3, i3 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j5++;
          }
        }
        if (i3 + 6 !== start2) {
          w6 = parseHex(number2, start2, i3 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start2, end2, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end2);
        for (var i3 = start2; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r2 *= mul;
          if (c3 >= 49) {
            r2 += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r2 += c3 - 17 + 10;
          } else {
            r2 += c3;
          }
        }
        return r2;
      }
      BN4.prototype._parseBase = function _parseBase(number2, base, start2) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start2;
        var mod = total % limbLen;
        var end2 = Math.min(total, total - mod) + start2;
        var word = 0;
        for (var i3 = start2; i3 < end2; i3 += limbLen) {
          word = parseBase(number2, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i3, number2.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r2 = new BN4(null);
        this.copy(r2);
        return r2;
      };
      BN4.prototype._expand = function _expand(size2) {
        while (this.length < size2) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString7(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w6 = this.words[i3];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r2 = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i3;
        var q4 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q4.isZero(); i3++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[reqLength - i3 - 1] = b4;
          }
        } else {
          for (i3 = 0; !q4.isZero(); i3++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[i3] = b4;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w6) {
          var t2 = w6;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t2 = w6;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b4 = this._zeroBits(this.words[i3]);
          r2 += b4;
          if (b4 !== 26)
            break;
        }
        return r2;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or3(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i3 = 0; i3 < b4.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a2;
        var b4;
        if (this.length > num.length) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        for (var i3 = 0; i3 < b4.length; i3++) {
          this.words[i3] = a2.words[i3] ^ b4.words[i3];
        }
        if (this !== a2) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b4;
        if (this.length > num.length) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b4.length; i3++) {
          r2 = (a2.words[i3] | 0) + (b4.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i3 < a2.length; i3++) {
          r2 = (a2.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        return this;
      };
      BN4.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b4;
        if (cmp > 0) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b4.length; i3++) {
          r2 = (a2.words[i3] | 0) - (b4.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        for (; carry !== 0 && i3 < a2.length; i3++) {
          r2 = (a2.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        if (carry === 0 && i3 < a2.length && a2 !== this) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r2 = a2 * b4;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1; k4 < len; k4++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j5 = Math.max(0, k4 - self2.length + 1); j5 <= maxJ; j5++) {
            var i3 = k4 - j5 | 0;
            a2 = self2.words[i3] | 0;
            b4 = num.words[j5] | 0;
            r2 = a2 * b4 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k4] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k4] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b4 = num.words;
        var o2 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w22;
        o2[3] = w32;
        o2[4] = w42;
        o2[5] = w52;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c3 !== 0) {
          o2[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k4 = 0; k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j5 = Math.max(0, k4 - self2.length + 1); j5 <= maxJ; j5++) {
            var i3 = k4 - j5;
            var a2 = self2.words[i3] | 0;
            var b4 = num.words[j5] | 0;
            var r2 = a2 * b4;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k4] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k4] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y4) {
        this.x = x6;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N6) {
        var t2 = new Array(N6);
        var l2 = BN4.prototype._countBits(N6) - 1;
        for (var i3 = 0; i3 < N6; i3++) {
          t2[i3] = this.revBin(i3, l2, N6);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x6, l2, N6) {
        if (x6 === 0 || x6 === N6 - 1)
          return x6;
        var rb = 0;
        for (var i3 = 0; i3 < l2; i3++) {
          rb |= (x6 & 1) << l2 - i3 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N6) {
        for (var i3 = 0; i3 < N6; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N6, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N6);
        for (var s = 1; s < N6; s <<= 1) {
          var l2 = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p6 = 0; p6 < N6; p6 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s; j5++) {
              var re4 = rtws[p6 + j5];
              var ie4 = itws[p6 + j5];
              var ro = rtws[p6 + j5 + s];
              var io = itws[p6 + j5 + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j5] = re4 + ro;
              itws[p6 + j5] = ie4 + io;
              rtws[p6 + j5 + s] = re4 - ro;
              itws[p6 + j5 + s] = ie4 - io;
              if (j5 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m4) {
        var N6 = Math.max(m4, n2) | 1;
        var odd = N6 & 1;
        var i3 = 0;
        for (N6 = N6 / 2 | 0; N6; N6 = N6 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N6) {
        if (N6 <= 1)
          return;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var t2 = rws[i3];
          rws[i3] = rws[N6 - i3 - 1];
          rws[N6 - i3 - 1] = t2;
          t2 = iws[i3];
          iws[i3] = -iws[N6 - i3 - 1];
          iws[N6 - i3 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var w6 = Math.round(ws2[2 * i3 + 1] / N6) * 8192 + Math.round(ws2[2 * i3] / N6) + carry;
          ws2[i3] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws2[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N6; ++i3) {
          rws[i3] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N6) {
        var ph = new Array(N6);
        for (var i3 = 0; i3 < N6; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y4, out) {
        var N6 = 2 * this.guessLen13b(x6.length, y4.length);
        var rbt = this.makeRBT(N6);
        var _6 = this.stub(N6);
        var rws = new Array(N6);
        var rwst = new Array(N6);
        var iwst = new Array(N6);
        var nrws = new Array(N6);
        var nrwst = new Array(N6);
        var niwst = new Array(N6);
        var rmws = out.words;
        rmws.length = N6;
        this.convert13b(x6.words, x6.length, rws, N6);
        this.convert13b(y4.words, y4.length, nrws, N6);
        this.transform(rws, _6, rwst, iwst, N6, rbt);
        this.transform(nrws, _6, nrwst, niwst, N6, rbt);
        for (var i3 = 0; i3 < N6; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N6);
        this.transform(rwst, iwst, rmws, _6, N6, rbt);
        this.conjugate(rmws, _6, N6);
        this.normalize13b(rmws, N6);
        out.negative = x6.negative ^ y4.negative;
        out.length = x6.length + y4.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w6 = (this.words[i3] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN4(1);
        var res = this;
        for (var i3 = 0; i3 < w6.length; i3++, res = res.sqr()) {
          if (w6[i3] !== 0)
            break;
        }
        if (++i3 < w6.length) {
          for (var q4 = res.sqr(); i3 < w6.length; i3++, q4 = q4.sqr()) {
            if (w6[i3] === 0)
              continue;
            res = res.mul(q4);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i3;
        if (r2 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r2;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s] = this.words[i3];
          }
          for (i3 = 0; i3 < s; i3++) {
            this.words[i3] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h5 -= s;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i3 = 0; i3 < s; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h5); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s)
          return false;
        var w6 = this.words[s];
        return !!(w6 & q4);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
        var len = num.length + shift2;
        var i3;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w6 = (this.words[i3 + shift2] | 0) + carry;
          var right2 = (num.words[i3] | 0) * mul;
          w6 -= right2 & 67108863;
          carry = (w6 >> 26) - (right2 / 67108864 | 0);
          this.words[i3 + shift2] = w6 & 67108863;
        }
        for (; i3 < this.length - shift2; i3++) {
          w6 = (this.words[i3 + shift2] | 0) + carry;
          carry = w6 >> 26;
          this.words[i3 + shift2] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w6 = -(this.words[i3] | 0) + carry;
          carry = w6 >> 26;
          this.words[i3] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift2 = this.length - num.length;
        var a2 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift2 = 26 - bhiBits;
        if (shift2 !== 0) {
          b4 = b4.ushln(shift2);
          a2.iushln(shift2);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m4 = a2.length - b4.length;
        var q4;
        if (mode !== "mod") {
          q4 = new BN4(null);
          q4.length = m4 + 1;
          q4.words = new Array(q4.length);
          for (var i3 = 0; i3 < q4.length; i3++) {
            q4.words[i3] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b4, 1, m4);
        if (diff.negative === 0) {
          a2 = diff;
          if (q4) {
            q4.words[m4] = 1;
          }
        }
        for (var j5 = m4 - 1; j5 >= 0; j5--) {
          var qj = (a2.words[b4.length + j5] | 0) * 67108864 + (a2.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b4, qj, j5);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b4, 1, j5);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q4) {
            q4.words[j5] = qj;
          }
        }
        if (q4) {
          q4.strip();
        }
        a2.strip();
        if (mode !== "div" && shift2 !== 0) {
          a2.iushrn(shift2);
        }
        return {
          div: q4 || null,
          mod: a2
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p6 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w6 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var x6 = this;
        var y4 = p6.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p6);
        } else {
          x6 = x6.clone();
        }
        var A2 = new BN4(1);
        var B4 = new BN4(0);
        var C4 = new BN4(0);
        var D4 = new BN4(1);
        var g5 = 0;
        while (x6.isEven() && y4.isEven()) {
          x6.iushrn(1);
          y4.iushrn(1);
          ++g5;
        }
        var yp = y4.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i3 = 0, im = 1; (x6.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x6.iushrn(i3);
            while (i3-- > 0) {
              if (A2.isOdd() || B4.isOdd()) {
                A2.iadd(yp);
                B4.isub(xp);
              }
              A2.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y4.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x6.cmp(y4) >= 0) {
            x6.isub(y4);
            A2.isub(C4);
            B4.isub(D4);
          } else {
            y4.isub(x6);
            C4.isub(A2);
            D4.isub(B4);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y4.iushln(g5)
        };
      };
      BN4.prototype._invmp = function _invmp(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var a2 = this;
        var b4 = p6.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p6);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b4.clone();
        while (a2.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a2.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a2.cmp(b4) >= 0) {
            a2.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a2);
            x22.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b4 = num.clone();
        a2.negative = 0;
        b4.negative = 0;
        for (var shift2 = 0; a2.isEven() && b4.isEven(); shift2++) {
          a2.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r2 = a2.cmp(b4);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b4;
            b4 = t2;
          } else if (r2 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a2.isub(b4);
        } while (true);
        return b4.iushln(shift2);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q4;
          return this;
        }
        var carry = q4;
        for (var i3 = s; carry !== 0 && i3 < this.length; i3++) {
          var w6 = this.words[i3] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i3] = w6;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a2 = this.words[i3] | 0;
          var b4 = num.words[i3] | 0;
          if (a2 === b4)
            continue;
          if (a2 < b4) {
            res = -1;
          } else if (a2 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt5(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt6(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN4(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          r2.strip();
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next2 = input.words[i3] | 0;
          input.words[i3 - 10] = (next2 & mask) << 4 | prev >>> 22;
          prev = next2;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w6 = num.words[i3] | 0;
          lo += w6 * 977;
          num.words[i3] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN4._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert3(a2.negative === 0, "red works only with positives");
        assert3(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b4) {
        assert3((a2.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a2.red && a2.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b4) {
        this._verify2(a2, b4);
        return this.imod(a2.imul(b4));
      };
      Red.prototype.mul = function mul(a2, b4) {
        this._verify2(a2, b4);
        return this.imod(a2.mul(b4));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q4 = this.m.subn(1);
        var s = 0;
        while (!q4.isZero() && q4.andln(1) === 0) {
          s++;
          q4.iushrn(1);
        }
        assert3(!q4.isZero());
        var one3 = new BN4(1).toRed(this);
        var nOne = one3.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN4(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c3 = this.pow(z3, q4);
        var r2 = this.pow(a2, q4.addn(1).iushrn(1));
        var t2 = this.pow(a2, q4);
        var m4 = s;
        while (t2.cmp(one3) !== 0) {
          var tmp = t2;
          for (var i3 = 0; tmp.cmp(one3) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert3(i3 < m4);
          var b4 = this.pow(c3, new BN4(1).iushln(m4 - i3 - 1));
          r2 = r2.redMul(b4);
          c3 = b4.redSqr();
          t2 = t2.redMul(c3);
          m4 = i3;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a2;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start2 = num.bitLength() % 26;
        if (start2 === 0) {
          start2 = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j5 = start2 - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start2 = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b4) {
        if (a2.isZero() || b4.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b4);
        var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t2.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b4) {
        if (a2.isZero() || b4.isZero())
          return new BN4(0)._forceRed(this);
        var t2 = a2.mul(b4);
        var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t2.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/query-string/index.js
var require_query_string2 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray3 = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray3 ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b4) => Number(a2) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse10(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse10;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys5 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys5.sort(options.sort);
      }
      return keys5.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x6) => x6.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash3] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse10(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode2(hash3, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash3 = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash3}`;
    };
  }
});

// node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/@walletconnect/socket-transport/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@walletconnect/iso-crypto/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/@walletconnect/iso-crypto/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN4(number2, base, endian) {
        if (BN4.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number2 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN4;
      } else {
        exports2.BN = BN4;
      }
      BN4.BN = BN4;
      BN4.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e2) {
      }
      BN4.isBN = function isBN(num) {
        if (num instanceof BN4) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN4.wordSize && Array.isArray(num.words);
      };
      BN4.max = function max4(left2, right2) {
        if (left2.cmp(right2) > 0)
          return left2;
        return right2;
      };
      BN4.min = function min4(left2, right2) {
        if (left2.cmp(right2) < 0)
          return left2;
        return right2;
      };
      BN4.prototype._init = function init(number2, base, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert3(base === (base | 0) && base >= 2 && base <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start2 = 0;
        if (number2[0] === "-") {
          start2++;
        }
        if (base === 16) {
          this._parseHex(number2, start2);
        } else {
          this._parseBase(number2, base, start2);
        }
        if (number2[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initNumber = function _initNumber(number2, base, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN4.prototype._initArray = function _initArray(number2, base, endian) {
        assert3(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j5, w6;
        var off = 0;
        if (endian === "be") {
          for (i3 = number2.length - 1, j5 = 0; i3 >= 0; i3 -= 3) {
            w6 = number2[i3] | number2[i3 - 1] << 8 | number2[i3 - 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        } else if (endian === "le") {
          for (i3 = 0, j5 = 0; i3 < number2.length; i3 += 3) {
            w6 = number2[i3] | number2[i3 + 1] << 8 | number2[i3 + 2] << 16;
            this.words[j5] |= w6 << off & 67108863;
            this.words[j5 + 1] = w6 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j5++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start2, end2) {
        var r2 = 0;
        var len = Math.min(str.length, end2);
        for (var i3 = start2; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r2 <<= 4;
          if (c3 >= 49 && c3 <= 54) {
            r2 |= c3 - 49 + 10;
          } else if (c3 >= 17 && c3 <= 22) {
            r2 |= c3 - 17 + 10;
          } else {
            r2 |= c3 & 15;
          }
        }
        return r2;
      }
      BN4.prototype._parseHex = function _parseHex(number2, start2) {
        this.length = Math.ceil((number2.length - start2) / 6);
        this.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          this.words[i3] = 0;
        }
        var j5, w6;
        var off = 0;
        for (i3 = number2.length - 6, j5 = 0; i3 >= start2; i3 -= 6) {
          w6 = parseHex(number2, i3, i3 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j5++;
          }
        }
        if (i3 + 6 !== start2) {
          w6 = parseHex(number2, start2, i3 + 6);
          this.words[j5] |= w6 << off & 67108863;
          this.words[j5 + 1] |= w6 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start2, end2, mul) {
        var r2 = 0;
        var len = Math.min(str.length, end2);
        for (var i3 = start2; i3 < len; i3++) {
          var c3 = str.charCodeAt(i3) - 48;
          r2 *= mul;
          if (c3 >= 49) {
            r2 += c3 - 49 + 10;
          } else if (c3 >= 17) {
            r2 += c3 - 17 + 10;
          } else {
            r2 += c3;
          }
        }
        return r2;
      }
      BN4.prototype._parseBase = function _parseBase(number2, base, start2) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number2.length - start2;
        var mod = total % limbLen;
        var end2 = Math.min(total, total - mod) + start2;
        var word = 0;
        for (var i3 = start2; i3 < end2; i3 += limbLen) {
          word = parseBase(number2, i3, i3 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i3, number2.length, base);
          for (i3 = 0; i3 < mod; i3++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN4.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i3 = 0; i3 < this.length; i3++) {
          dest.words[i3] = this.words[i3];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN4.prototype.clone = function clone() {
        var r2 = new BN4(null);
        this.copy(r2);
        return r2;
      };
      BN4.prototype._expand = function _expand(size2) {
        while (this.length < size2) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN4.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN4.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN4.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN4.prototype.toString = function toString7(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i3 = 0; i3 < this.length; i3++) {
            var w6 = this.words[i3];
            var word = ((w6 << off | carry) & 16777215).toString(16);
            carry = w6 >>> 24 - off & 16777215;
            if (carry !== 0 || i3 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i3--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c3 = this.clone();
          c3.negative = 0;
          while (!c3.isZero()) {
            var r2 = c3.modn(groupBase).toString(base);
            c3 = c3.idivn(groupBase);
            if (!c3.isZero()) {
              out = zeros[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN4.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN4.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN4.prototype.toBuffer = function toBuffer(endian, length) {
        assert3(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN4.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN4.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b4, i3;
        var q4 = this.clone();
        if (!littleEndian) {
          for (i3 = 0; i3 < reqLength - byteLength; i3++) {
            res[i3] = 0;
          }
          for (i3 = 0; !q4.isZero(); i3++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[reqLength - i3 - 1] = b4;
          }
        } else {
          for (i3 = 0; !q4.isZero(); i3++) {
            b4 = q4.andln(255);
            q4.iushrn(8);
            res[i3] = b4;
          }
          for (; i3 < reqLength; i3++) {
            res[i3] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN4.prototype._countBits = function _countBits(w6) {
          return 32 - Math.clz32(w6);
        };
      } else {
        BN4.prototype._countBits = function _countBits(w6) {
          var t2 = w6;
          var r2 = 0;
          if (t2 >= 4096) {
            r2 += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r2 += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r2 += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r2 += 2;
            t2 >>>= 2;
          }
          return r2 + t2;
        };
      }
      BN4.prototype._zeroBits = function _zeroBits(w6) {
        if (w6 === 0)
          return 26;
        var t2 = w6;
        var r2 = 0;
        if ((t2 & 8191) === 0) {
          r2 += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r2 += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r2 += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r2 += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN4.prototype.bitLength = function bitLength() {
        var w6 = this.words[this.length - 1];
        var hi = this._countBits(w6);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w6 = new Array(num.bitLength());
        for (var bit = 0; bit < w6.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w6[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w6;
      }
      BN4.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var b4 = this._zeroBits(this.words[i3]);
          r2 += b4;
          if (b4 !== 26)
            break;
        }
        return r2;
      };
      BN4.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN4.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN4.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN4.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN4.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN4.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN4.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i3 = 0; i3 < num.length; i3++) {
          this.words[i3] = this.words[i3] | num.words[i3];
        }
        return this.strip();
      };
      BN4.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN4.prototype.or = function or3(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN4.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN4.prototype.iuand = function iuand(num) {
        var b4;
        if (this.length > num.length) {
          b4 = num;
        } else {
          b4 = this;
        }
        for (var i3 = 0; i3 < b4.length; i3++) {
          this.words[i3] = this.words[i3] & num.words[i3];
        }
        this.length = b4.length;
        return this.strip();
      };
      BN4.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN4.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN4.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN4.prototype.iuxor = function iuxor(num) {
        var a2;
        var b4;
        if (this.length > num.length) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        for (var i3 = 0; i3 < b4.length; i3++) {
          this.words[i3] = a2.words[i3] ^ b4.words[i3];
        }
        if (this !== a2) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN4.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN4.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN4.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN4.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i3 = 0; i3 < bytesNeeded; i3++) {
          this.words[i3] = ~this.words[i3] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i3] = ~this.words[i3] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN4.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN4.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN4.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a2, b4;
        if (this.length > num.length) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b4.length; i3++) {
          r2 = (a2.words[i3] | 0) + (b4.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i3 < a2.length; i3++) {
          r2 = (a2.words[i3] | 0) + carry;
          this.words[i3] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        return this;
      };
      BN4.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN4.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b4;
        if (cmp > 0) {
          a2 = this;
          b4 = num;
        } else {
          a2 = num;
          b4 = this;
        }
        var carry = 0;
        for (var i3 = 0; i3 < b4.length; i3++) {
          r2 = (a2.words[i3] | 0) - (b4.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        for (; carry !== 0 && i3 < a2.length; i3++) {
          r2 = (a2.words[i3] | 0) + carry;
          carry = r2 >> 26;
          this.words[i3] = r2 & 67108863;
        }
        if (carry === 0 && i3 < a2.length && a2 !== this) {
          for (; i3 < a2.length; i3++) {
            this.words[i3] = a2.words[i3];
          }
        }
        this.length = Math.max(this.length, i3);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN4.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b4 = num.words[0] | 0;
        var r2 = a2 * b4;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k4 = 1; k4 < len; k4++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j5 = Math.max(0, k4 - self2.length + 1); j5 <= maxJ; j5++) {
            var i3 = k4 - j5 | 0;
            a2 = self2.words[i3] | 0;
            b4 = num.words[j5] | 0;
            r2 = a2 * b4 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k4] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k4] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b4 = num.words;
        var o2 = out.words;
        var c3 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b4[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b4[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b4[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b4[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b4[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b5 = b4[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b4[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b4[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b4[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b4[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w52 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
        w52 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c3 + lo | 0) + ((mid & 8191) << 13) | 0;
        c3 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o2[0] = w0;
        o2[1] = w1;
        o2[2] = w22;
        o2[3] = w32;
        o2[4] = w42;
        o2[5] = w52;
        o2[6] = w6;
        o2[7] = w7;
        o2[8] = w8;
        o2[9] = w9;
        o2[10] = w10;
        o2[11] = w11;
        o2[12] = w12;
        o2[13] = w13;
        o2[14] = w14;
        o2[15] = w15;
        o2[16] = w16;
        o2[17] = w17;
        o2[18] = w18;
        if (c3 !== 0) {
          o2[19] = c3;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k4 = 0; k4 < out.length - 1; k4++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k4, num.length - 1);
          for (var j5 = Math.max(0, k4 - self2.length + 1); j5 <= maxJ; j5++) {
            var i3 = k4 - j5;
            var a2 = self2.words[i3] | 0;
            var b4 = num.words[j5] | 0;
            var r2 = a2 * b4;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k4] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k4] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN4.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x6, y4) {
        this.x = x6;
        this.y = y4;
      }
      FFTM.prototype.makeRBT = function makeRBT(N6) {
        var t2 = new Array(N6);
        var l2 = BN4.prototype._countBits(N6) - 1;
        for (var i3 = 0; i3 < N6; i3++) {
          t2[i3] = this.revBin(i3, l2, N6);
        }
        return t2;
      };
      FFTM.prototype.revBin = function revBin(x6, l2, N6) {
        if (x6 === 0 || x6 === N6 - 1)
          return x6;
        var rb = 0;
        for (var i3 = 0; i3 < l2; i3++) {
          rb |= (x6 & 1) << l2 - i3 - 1;
          x6 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N6) {
        for (var i3 = 0; i3 < N6; i3++) {
          rtws[i3] = rws[rbt[i3]];
          itws[i3] = iws[rbt[i3]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N6, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N6);
        for (var s = 1; s < N6; s <<= 1) {
          var l2 = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p6 = 0; p6 < N6; p6 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j5 = 0; j5 < s; j5++) {
              var re4 = rtws[p6 + j5];
              var ie4 = itws[p6 + j5];
              var ro = rtws[p6 + j5 + s];
              var io = itws[p6 + j5 + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j5] = re4 + ro;
              itws[p6 + j5] = ie4 + io;
              rtws[p6 + j5 + s] = re4 - ro;
              itws[p6 + j5 + s] = ie4 - io;
              if (j5 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m4) {
        var N6 = Math.max(m4, n2) | 1;
        var odd = N6 & 1;
        var i3 = 0;
        for (N6 = N6 / 2 | 0; N6; N6 = N6 >>> 1) {
          i3++;
        }
        return 1 << i3 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N6) {
        if (N6 <= 1)
          return;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var t2 = rws[i3];
          rws[i3] = rws[N6 - i3 - 1];
          rws[N6 - i3 - 1] = t2;
          t2 = iws[i3];
          iws[i3] = -iws[N6 - i3 - 1];
          iws[N6 - i3 - 1] = -t2;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < N6 / 2; i3++) {
          var w6 = Math.round(ws2[2 * i3 + 1] / N6) * 8192 + Math.round(ws2[2 * i3] / N6) + carry;
          ws2[i3] = w6 & 67108863;
          if (w6 < 67108864) {
            carry = 0;
          } else {
            carry = w6 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N6) {
        var carry = 0;
        for (var i3 = 0; i3 < len; i3++) {
          carry = carry + (ws2[i3] | 0);
          rws[2 * i3] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i3 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i3 = 2 * len; i3 < N6; ++i3) {
          rws[i3] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N6) {
        var ph = new Array(N6);
        for (var i3 = 0; i3 < N6; i3++) {
          ph[i3] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x6, y4, out) {
        var N6 = 2 * this.guessLen13b(x6.length, y4.length);
        var rbt = this.makeRBT(N6);
        var _6 = this.stub(N6);
        var rws = new Array(N6);
        var rwst = new Array(N6);
        var iwst = new Array(N6);
        var nrws = new Array(N6);
        var nrwst = new Array(N6);
        var niwst = new Array(N6);
        var rmws = out.words;
        rmws.length = N6;
        this.convert13b(x6.words, x6.length, rws, N6);
        this.convert13b(y4.words, y4.length, nrws, N6);
        this.transform(rws, _6, rwst, iwst, N6, rbt);
        this.transform(nrws, _6, nrwst, niwst, N6, rbt);
        for (var i3 = 0; i3 < N6; i3++) {
          var rx = rwst[i3] * nrwst[i3] - iwst[i3] * niwst[i3];
          iwst[i3] = rwst[i3] * niwst[i3] + iwst[i3] * nrwst[i3];
          rwst[i3] = rx;
        }
        this.conjugate(rwst, iwst, N6);
        this.transform(rwst, iwst, rmws, _6, N6, rbt);
        this.conjugate(rmws, _6, N6);
        this.normalize13b(rmws, N6);
        out.negative = x6.negative ^ y4.negative;
        out.length = x6.length + y4.length;
        return out.strip();
      };
      BN4.prototype.mul = function mul(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN4.prototype.mulf = function mulf(num) {
        var out = new BN4(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN4.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN4.prototype.imuln = function imuln(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i3 = 0; i3 < this.length; i3++) {
          var w6 = (this.words[i3] | 0) * num;
          var lo = (w6 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w6 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i3] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN4.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN4.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN4.prototype.pow = function pow(num) {
        var w6 = toBitArray(num);
        if (w6.length === 0)
          return new BN4(1);
        var res = this;
        for (var i3 = 0; i3 < w6.length; i3++, res = res.sqr()) {
          if (w6[i3] !== 0)
            break;
        }
        if (++i3 < w6.length) {
          for (var q4 = res.sqr(); i3 < w6.length; i3++, q4 = q4.sqr()) {
            if (w6[i3] === 0)
              continue;
            res = res.mul(q4);
          }
        }
        return res;
      };
      BN4.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i3;
        if (r2 !== 0) {
          var carry = 0;
          for (i3 = 0; i3 < this.length; i3++) {
            var newCarry = this.words[i3] & carryMask;
            var c3 = (this.words[i3] | 0) - newCarry << r2;
            this.words[i3] = c3 | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i3] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i3 = this.length - 1; i3 >= 0; i3--) {
            this.words[i3 + s] = this.words[i3];
          }
          for (i3 = 0; i3 < s; i3++) {
            this.words[i3] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN4.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN4.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h5;
        if (hint) {
          h5 = (hint - hint % 26) / 26;
        } else {
          h5 = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h5 -= s;
        h5 = Math.max(0, h5);
        if (maskedWords) {
          for (var i3 = 0; i3 < s; i3++) {
            maskedWords.words[i3] = this.words[i3];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i3 = 0; i3 < this.length; i3++) {
            this.words[i3] = this.words[i3 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i3 = this.length - 1; i3 >= 0 && (carry !== 0 || i3 >= h5); i3--) {
          var word = this.words[i3] | 0;
          this.words[i3] = carry << 26 - r2 | word >>> r2;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN4.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN4.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN4.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN4.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN4.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN4.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s)
          return false;
        var w6 = this.words[s];
        return !!(w6 & q4);
      };
      BN4.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN4.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN4.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN4.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i3 = 0; i3 < this.length && this.words[i3] >= 67108864; i3++) {
          this.words[i3] -= 67108864;
          if (i3 === this.length - 1) {
            this.words[i3 + 1] = 1;
          } else {
            this.words[i3 + 1]++;
          }
        }
        this.length = Math.max(this.length, i3 + 1);
        return this;
      };
      BN4.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i3 = 0; i3 < this.length && this.words[i3] < 0; i3++) {
            this.words[i3] += 67108864;
            this.words[i3 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN4.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN4.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN4.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN4.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN4.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
        var len = num.length + shift2;
        var i3;
        this._expand(len);
        var w6;
        var carry = 0;
        for (i3 = 0; i3 < num.length; i3++) {
          w6 = (this.words[i3 + shift2] | 0) + carry;
          var right2 = (num.words[i3] | 0) * mul;
          w6 -= right2 & 67108863;
          carry = (w6 >> 26) - (right2 / 67108864 | 0);
          this.words[i3 + shift2] = w6 & 67108863;
        }
        for (; i3 < this.length - shift2; i3++) {
          w6 = (this.words[i3 + shift2] | 0) + carry;
          carry = w6 >> 26;
          this.words[i3 + shift2] = w6 & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert3(carry === -1);
        carry = 0;
        for (i3 = 0; i3 < this.length; i3++) {
          w6 = -(this.words[i3] | 0) + carry;
          carry = w6 >> 26;
          this.words[i3] = w6 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN4.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift2 = this.length - num.length;
        var a2 = this.clone();
        var b4 = num;
        var bhi = b4.words[b4.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift2 = 26 - bhiBits;
        if (shift2 !== 0) {
          b4 = b4.ushln(shift2);
          a2.iushln(shift2);
          bhi = b4.words[b4.length - 1] | 0;
        }
        var m4 = a2.length - b4.length;
        var q4;
        if (mode !== "mod") {
          q4 = new BN4(null);
          q4.length = m4 + 1;
          q4.words = new Array(q4.length);
          for (var i3 = 0; i3 < q4.length; i3++) {
            q4.words[i3] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b4, 1, m4);
        if (diff.negative === 0) {
          a2 = diff;
          if (q4) {
            q4.words[m4] = 1;
          }
        }
        for (var j5 = m4 - 1; j5 >= 0; j5--) {
          var qj = (a2.words[b4.length + j5] | 0) * 67108864 + (a2.words[b4.length + j5 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b4, qj, j5);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b4, 1, j5);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q4) {
            q4.words[j5] = qj;
          }
        }
        if (q4) {
          q4.strip();
        }
        a2.strip();
        if (mode !== "div" && shift2 !== 0) {
          a2.iushrn(shift2);
        }
        return {
          div: q4 || null,
          mod: a2
        };
      };
      BN4.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN4(0),
            mod: new BN4(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN4(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN4(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN4(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN4.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN4.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN4.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN4.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN4.prototype.modn = function modn(num) {
        assert3(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          acc = (p6 * acc + (this.words[i3] | 0)) % num;
        }
        return acc;
      };
      BN4.prototype.idivn = function idivn(num) {
        assert3(num <= 67108863);
        var carry = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var w6 = (this.words[i3] | 0) + carry * 67108864;
          this.words[i3] = w6 / num | 0;
          carry = w6 % num;
        }
        return this.strip();
      };
      BN4.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN4.prototype.egcd = function egcd(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var x6 = this;
        var y4 = p6.clone();
        if (x6.negative !== 0) {
          x6 = x6.umod(p6);
        } else {
          x6 = x6.clone();
        }
        var A2 = new BN4(1);
        var B4 = new BN4(0);
        var C4 = new BN4(0);
        var D4 = new BN4(1);
        var g5 = 0;
        while (x6.isEven() && y4.isEven()) {
          x6.iushrn(1);
          y4.iushrn(1);
          ++g5;
        }
        var yp = y4.clone();
        var xp = x6.clone();
        while (!x6.isZero()) {
          for (var i3 = 0, im = 1; (x6.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            x6.iushrn(i3);
            while (i3-- > 0) {
              if (A2.isOdd() || B4.isOdd()) {
                A2.iadd(yp);
                B4.isub(xp);
              }
              A2.iushrn(1);
              B4.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (y4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            y4.iushrn(j5);
            while (j5-- > 0) {
              if (C4.isOdd() || D4.isOdd()) {
                C4.iadd(yp);
                D4.isub(xp);
              }
              C4.iushrn(1);
              D4.iushrn(1);
            }
          }
          if (x6.cmp(y4) >= 0) {
            x6.isub(y4);
            A2.isub(C4);
            B4.isub(D4);
          } else {
            y4.isub(x6);
            C4.isub(A2);
            D4.isub(B4);
          }
        }
        return {
          a: C4,
          b: D4,
          gcd: y4.iushln(g5)
        };
      };
      BN4.prototype._invmp = function _invmp(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var a2 = this;
        var b4 = p6.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p6);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN4(1);
        var x22 = new BN4(0);
        var delta = b4.clone();
        while (a2.cmpn(1) > 0 && b4.cmpn(1) > 0) {
          for (var i3 = 0, im = 1; (a2.words[0] & im) === 0 && i3 < 26; ++i3, im <<= 1)
            ;
          if (i3 > 0) {
            a2.iushrn(i3);
            while (i3-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j5 = 0, jm = 1; (b4.words[0] & jm) === 0 && j5 < 26; ++j5, jm <<= 1)
            ;
          if (j5 > 0) {
            b4.iushrn(j5);
            while (j5-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a2.cmp(b4) >= 0) {
            a2.isub(b4);
            x1.isub(x22);
          } else {
            b4.isub(a2);
            x22.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN4.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a2 = this.clone();
        var b4 = num.clone();
        a2.negative = 0;
        b4.negative = 0;
        for (var shift2 = 0; a2.isEven() && b4.isEven(); shift2++) {
          a2.iushrn(1);
          b4.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b4.isEven()) {
            b4.iushrn(1);
          }
          var r2 = a2.cmp(b4);
          if (r2 < 0) {
            var t2 = a2;
            a2 = b4;
            b4 = t2;
          } else if (r2 === 0 || b4.cmpn(1) === 0) {
            break;
          }
          a2.isub(b4);
        } while (true);
        return b4.iushln(shift2);
      };
      BN4.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN4.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN4.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN4.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN4.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q4 = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q4;
          return this;
        }
        var carry = q4;
        for (var i3 = s; carry !== 0 && i3 < this.length; i3++) {
          var w6 = this.words[i3] | 0;
          w6 += carry;
          carry = w6 >>> 26;
          w6 &= 67108863;
          this.words[i3] = w6;
        }
        if (carry !== 0) {
          this.words[i3] = carry;
          this.length++;
        }
        return this;
      };
      BN4.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN4.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w6 = this.words[0] | 0;
          res = w6 === num ? 0 : w6 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN4.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i3 = this.length - 1; i3 >= 0; i3--) {
          var a2 = this.words[i3] | 0;
          var b4 = num.words[i3] | 0;
          if (a2 === b4)
            continue;
          if (a2 < b4) {
            res = -1;
          } else if (a2 > b4) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN4.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN4.prototype.gt = function gt5(num) {
        return this.cmp(num) === 1;
      };
      BN4.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN4.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN4.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN4.prototype.lt = function lt6(num) {
        return this.cmp(num) === -1;
      };
      BN4.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN4.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN4.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN4.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN4.red = function red(num) {
        return new Red(num);
      };
      BN4.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN4.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN4.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN4.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN4.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN4.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN4.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN4.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN4.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN4.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN4.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN4.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN4.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN4.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN4.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN4.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN4.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p6) {
        this.name = name;
        this.p = new BN4(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN4(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN4(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          r2.strip();
        }
        return r2;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i3 = 0; i3 < outLen; i3++) {
          output.words[i3] = input.words[i3];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i3 = 10; i3 < input.length; i3++) {
          var next2 = input.words[i3] | 0;
          input.words[i3 - 10] = (next2 & mask) << 4 | prev >>> 22;
          prev = next2;
        }
        prev >>>= 22;
        input.words[i3 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var w6 = num.words[i3] | 0;
          lo += w6 * 977;
          num.words[i3] = lo & 67108863;
          lo = w6 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i3 = 0; i3 < num.length; i3++) {
          var hi = (num.words[i3] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i3] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN4._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m4) {
        if (typeof m4 === "string") {
          var prime = BN4._prime(m4);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m4.gtn(1), "modulus must be greater than 1");
          this.m = m4;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert3(a2.negative === 0, "red works only with positives");
        assert3(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b4) {
        assert3((a2.negative | b4.negative) === 0, "red works only with positives");
        assert3(
          a2.red && a2.red === b4.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime)
          return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.add(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.iadd(b4);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.sub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b4) {
        this._verify2(a2, b4);
        var res = a2.isub(b4);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b4) {
        this._verify2(a2, b4);
        return this.imod(a2.imul(b4));
      };
      Red.prototype.mul = function mul(a2, b4) {
        this._verify2(a2, b4);
        return this.imod(a2.mul(b4));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero())
          return a2.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN4(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q4 = this.m.subn(1);
        var s = 0;
        while (!q4.isZero() && q4.andln(1) === 0) {
          s++;
          q4.iushrn(1);
        }
        assert3(!q4.isZero());
        var one3 = new BN4(1).toRed(this);
        var nOne = one3.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z3 = this.m.bitLength();
        z3 = new BN4(2 * z3 * z3).toRed(this);
        while (this.pow(z3, lpow).cmp(nOne) !== 0) {
          z3.redIAdd(nOne);
        }
        var c3 = this.pow(z3, q4);
        var r2 = this.pow(a2, q4.addn(1).iushrn(1));
        var t2 = this.pow(a2, q4);
        var m4 = s;
        while (t2.cmp(one3) !== 0) {
          var tmp = t2;
          for (var i3 = 0; tmp.cmp(one3) !== 0; i3++) {
            tmp = tmp.redSqr();
          }
          assert3(i3 < m4);
          var b4 = this.pow(c3, new BN4(1).iushln(m4 - i3 - 1));
          r2 = r2.redMul(b4);
          c3 = b4.redSqr();
          t2 = t2.redMul(c3);
          m4 = i3;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero())
          return new BN4(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN4(1).toRed(this);
        wnd[1] = a2;
        for (var i3 = 2; i3 < wnd.length; i3++) {
          wnd[i3] = this.mul(wnd[i3 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start2 = num.bitLength() % 26;
        if (start2 === 0) {
          start2 = 26;
        }
        for (i3 = num.length - 1; i3 >= 0; i3--) {
          var word = num.words[i3];
          for (var j5 = start2 - 1; j5 >= 0; j5--) {
            var bit = word >> j5 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i3 !== 0 || j5 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start2 = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN4.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m4) {
        Red.call(this, m4);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN4(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a2, b4) {
        if (a2.isZero() || b4.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t2 = a2.imul(b4);
        var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t2.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b4) {
        if (a2.isZero() || b4.isZero())
          return new BN4(0)._forceRed(this);
        var t2 = a2.mul(b4);
        var c3 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u3 = t2.isub(c3).iushrn(this.shift);
        var res = u3;
        if (u3.cmp(this.m) >= 0) {
          res = u3.isub(this.m);
        } else if (u3.cmpn(0) < 0) {
          res = u3.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@walletconnect/iso-crypto/node_modules/query-string/index.js
var require_query_string3 = __commonJS({
  "node_modules/@walletconnect/iso-crypto/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray3 = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray3 ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b4) => Number(a2) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse10(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse10;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys5 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys5.sort(options.sort);
      }
      return keys5.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x6) => x6.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash3] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse10(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode2(hash3, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash3 = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash3}`;
    };
  }
});

// node_modules/@walletconnect/core/node_modules/query-string/index.js
var require_query_string4 = __commonJS({
  "node_modules/@walletconnect/core/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), ":list="].join("")];
            }
            return [...result, [encode2(key, options), ":list=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode2(key, options), keyValueSep, encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray3 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray3 && decode2(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode2(value, options) : value;
            const newValue = isArray3 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray3 = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray3) {
              accumulator[key] = value ? decode2(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b4) => Number(a2) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse10(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse10;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys5 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys5.sort(options.sort);
      }
      return keys5.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode2(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x6) => x6.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash3] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse10(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode2(hash3, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash3 = `#${options[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash3}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/auth-client/node_modules/query-string/index.js
var require_query_string5 = __commonJS({
  "node_modules/@walletconnect/auth-client/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), ":list="].join("")];
            }
            return [...result, [encode2(key, options), ":list=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode2(key, options), keyValueSep, encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray3 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray3 && decode2(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode2(value, options) : value;
            const newValue = isArray3 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray3 = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray3) {
              accumulator[key] = value ? decode2(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b4) => Number(a2) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse10(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse10;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys5 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys5.sort(options.sort);
      }
      return keys5.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode2(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x6) => x6.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash3] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse10(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode2(hash3, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash3 = `#${options[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash3}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/unfetch/dist/unfetch.module.js
var unfetch_module_exports = {};
__export(unfetch_module_exports, {
  default: () => unfetch_module_default
});
function unfetch_module_default(e2, n2) {
  return n2 = n2 || {}, new Promise(function(t2, r2) {
    var s = new XMLHttpRequest(), o2 = [], u3 = [], i3 = {}, a2 = function() {
      return { ok: 2 == (s.status / 100 | 0), statusText: s.statusText, status: s.status, url: s.responseURL, text: function() {
        return Promise.resolve(s.responseText);
      }, json: function() {
        return Promise.resolve(s.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s.response]));
      }, clone: a2, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u3;
      }, get: function(e3) {
        return i3[e3.toLowerCase()];
      }, has: function(e3) {
        return e3.toLowerCase() in i3;
      } } };
    };
    for (var l2 in s.open(n2.method || "get", e2, true), s.onload = function() {
      s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e3, n3, t3) {
        o2.push(n3 = n3.toLowerCase()), u3.push([n3, t3]), i3[n3] = i3[n3] ? i3[n3] + "," + t3 : t3;
      }), t2(a2());
    }, s.onerror = r2, s.withCredentials = "include" == n2.credentials, n2.headers)
      s.setRequestHeader(l2, n2.headers[l2]);
    s.send(n2.body || null);
  });
}
var init_unfetch_module = __esm({
  "node_modules/unfetch/dist/unfetch.module.js"() {
  }
});

// node_modules/isomorphic-unfetch/browser.js
var require_browser4 = __commonJS({
  "node_modules/isomorphic-unfetch/browser.js"(exports, module) {
    module.exports = self.fetch || (self.fetch = (init_unfetch_module(), __toCommonJS(unfetch_module_exports)).default || (init_unfetch_module(), __toCommonJS(unfetch_module_exports)));
  }
});

// node_modules/@walletconnect/web3wallet/node_modules/query-string/index.js
var require_query_string6 = __commonJS({
  "node_modules/@walletconnect/web3wallet/node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index2 = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index2, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index2, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), ":list="].join("")];
            }
            return [...result, [encode2(key, options), ":list=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode2(key, options), keyValueSep, encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray3 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray3 && decode2(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode2(value, options) : value;
            const newValue = isArray3 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray3 = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray3) {
              accumulator[key] = value ? decode2(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b4) => Number(a2) - Number(b4)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse10(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k4 of Object.keys(value)) {
            value[k4] = parseValue(value[k4], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse10;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys5 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys5.sort(options.sort);
      }
      return keys5.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode2(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x6) => x6.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash3] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse10(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode2(hash3, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash3 = `#${options[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash3}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty4 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject2(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i3 = 0; i3 < 10; i3++) {
          test2["_" + String.fromCharCode(i3)] = i3;
        }
        var order22 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order22.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject2(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty4.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i3 = 0; i3 < symbols.length; i3++) {
            if (propIsEnumerable.call(from, symbols[i3])) {
              to[symbols[i3]] = from[symbols[i3]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has3 = require_has();
      printWarning = function(text4) {
        var message = "Warning: " + text4;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x6) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has3;
    function checkPropTypes(typeSpecs, values4, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has3(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values4, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign3 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has3 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text4) {
        var message = "Warning: " + text4;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x6) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is5(x6, y4) {
        if (x6 === y4) {
          return x6 !== 0 || 1 / x6 === 1 / y4;
        } else {
          return x6 !== x6 && y4 !== y4;
        }
      }
      function PropTypeError(message, data2) {
        this.message = message;
        this.data = data2 && typeof data2 === "object" ? data2 : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate2) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate2(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate2(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate2(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i3 = 0; i3 < propValue.length; i3++) {
            var error = typeChecker(propValue, i3, componentName, location, propFullName + "[" + i3 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeChecker() {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeTypeChecker() {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate2(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i3 = 0; i3 < expectedValues.length; i3++) {
            if (is5(propValue, expectedValues[i3])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer2(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate2(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has3(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
          var checker = arrayOfTypeCheckers[i3];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i3 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate2(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
            var checker2 = arrayOfTypeCheckers[i4];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has3(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createNodeChecker() {
        function validate2(props, propName, componentName, location, propFullName) {
          if (!isNode2(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate2(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign3({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has3(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol2(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol2(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a2, b4) {
      if (a2 === b4)
        return true;
      if (a2 && b4 && typeof a2 == "object" && typeof b4 == "object") {
        if (a2.constructor !== b4.constructor)
          return false;
        var length, i3, keys5;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b4.length)
            return false;
          for (i3 = length; i3-- !== 0; )
            if (!equal(a2[i3], b4[i3]))
              return false;
          return true;
        }
        var it5;
        if (hasMap && a2 instanceof Map && b4 instanceof Map) {
          if (a2.size !== b4.size)
            return false;
          it5 = a2.entries();
          while (!(i3 = it5.next()).done)
            if (!b4.has(i3.value[0]))
              return false;
          it5 = a2.entries();
          while (!(i3 = it5.next()).done)
            if (!equal(i3.value[1], b4.get(i3.value[0])))
              return false;
          return true;
        }
        if (hasSet && a2 instanceof Set && b4 instanceof Set) {
          if (a2.size !== b4.size)
            return false;
          it5 = a2.entries();
          while (!(i3 = it5.next()).done)
            if (!b4.has(i3.value[0]))
              return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b4)) {
          length = a2.length;
          if (length != b4.length)
            return false;
          for (i3 = length; i3-- !== 0; )
            if (a2[i3] !== b4[i3])
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b4.source && a2.flags === b4.flags;
        if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b4.valueOf === "function")
          return a2.valueOf() === b4.valueOf();
        if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b4.toString === "function")
          return a2.toString() === b4.toString();
        keys5 = Object.keys(a2);
        length = keys5.length;
        if (length !== Object.keys(b4).length)
          return false;
        for (i3 = length; i3-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b4, keys5[i3]))
            return false;
        if (hasElementType && a2 instanceof Element)
          return false;
        for (i3 = length; i3-- !== 0; ) {
          if ((keys5[i3] === "_owner" || keys5[i3] === "__v" || keys5[i3] === "__o") && a2.$$typeof) {
            continue;
          }
          if (!equal(a2[keys5[i3]], b4[keys5[i3]]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b4 !== b4;
    }
    module.exports = function isEqual3(a2, b4) {
      try {
        return equal(a2, b4);
      } catch (error) {
        if ((error.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error;
      }
    };
  }
});

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports, module) {
    "use strict";
    var __DEV__ = true;
    var warning3 = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format2, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format2.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x6) {
        }
      };
      warning3 = function(condition, format2, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format2 === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format2].concat(args));
        }
      };
    }
    var printWarning;
    module.exports = warning3;
  }
});

// node_modules/@daohaus/moloch-v3-fields/index.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react3 = __toESM(require_react());
var import_keychain_utils = __toESM(require_src2());
var import_moloch_v3_data = __toESM(require_src4());
var import_utils12 = __toESM(require_src3());
init_esm2();

// node_modules/react-icons/bi/index.esm.js
var import_lib = __toESM(require_cjs());
function BiPencil(props) {
  return (0, import_lib.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M4 21a1 1 0 0 0 .24 0l4-1a1 1 0 0 0 .47-.26L21 7.41a2 2 0 0 0 0-2.82L19.42 3a2 2 0 0 0-2.83 0L4.3 15.29a1.06 1.06 0 0 0-.27.47l-1 4A1 1 0 0 0 3.76 21 1 1 0 0 0 4 21zM18 4.41 19.59 6 18 7.59 16.42 6zM5.91 16.51 15 7.41 16.59 9l-9.1 9.1-2.11.52z" } }] })(props);
}
function BiSearch(props) {
  return (0, import_lib.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z" } }] })(props);
}

// node_modules/react-icons/md/index.esm.js
var import_lib2 = __toESM(require_cjs());
function MdPreview(props) {
  return (0, import_lib2.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M19 3H5a2 2 0 00-2 2v14a2 2 0 002 2h14c1.1 0 2-.9 2-2V5a2 2 0 00-2-2zm0 16H5V7h14v12zm-5.5-6c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5.67-1.5 1.5-1.5 1.5.67 1.5 1.5zM12 9c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4zm0 6.5a2.5 2.5 0 010-5 2.5 2.5 0 010 5z" } }] })(props);
}
function MdFullscreenExit(props) {
  return (0, import_lib2.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" } }] })(props);
}
function MdFullscreen(props) {
  return (0, import_lib2.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" } }] })(props);
}
function MdOutlineGavel(props) {
  return (0, import_lib2.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M1 21h12v2H1v-2zM5.24 8.07l2.83-2.83 14.14 14.14-2.83 2.83L5.24 8.07zM12.32 1l5.66 5.66-2.83 2.83-5.66-5.66L12.32 1zM3.83 9.48l5.66 5.66-2.83 2.83L1 12.31l2.83-2.83z" } }] })(props);
}

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(this, "name", "Assertion");
    __publicField(this, "code", "ERR_ASSERTION");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value, message) {
  assert(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function unreachable(message) {
  assert(false, false, true, "ok", "Unreachable", message);
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/comma-separated-tokens/index.js
function stringify(values4, options) {
  const settings = options || {};
  const input = values4[values4.length - 1] === "" ? [...values4, ""] : values4;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}

// node_modules/hast-util-whitespace/lib/index.js
var re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re, "") === "";
}

// node_modules/property-information/lib/util/schema.js
var Schema = class {
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;

// node_modules/property-information/lib/util/merge.js
function merge(definitions, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions.length) {
    Object.assign(property, definitions[index2].property);
    Object.assign(normal, definitions[index2].normal);
  }
  return new Schema(property, normal, space2);
}

// node_modules/property-information/lib/normalize.js
function normalize(value) {
  return value.toLowerCase();
}

// node_modules/property-information/lib/util/info.js
var Info = class {
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
};
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = Object.keys(types_exports);
var DefinedInfo = class extends Info {
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check2 = checks[index2];
        mark(this, checks[index2], (mask & types_exports[check2]) === types_exports[check2]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values4, key, value) {
  if (value) {
    values4[key] = value;
  }
}

// node_modules/property-information/lib/util/create.js
var own = {}.hasOwnProperty;
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize(prop)] = prop;
      normal[normalize(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition2.space);
}

// node_modules/property-information/lib/xlink.js
var xlink = create({
  space: "xlink",
  transform(_6, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});

// node_modules/property-information/lib/xml.js
var xml = create({
  space: "xml",
  transform(_6, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}

// node_modules/property-information/lib/xmlns.js
var xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});

// node_modules/property-information/lib/aria.js
var aria = create({
  transform(_6, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});

// node_modules/property-information/lib/html.js
var html = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    align: null,
    aLink: null,
    archive: spaceSeparated,
    axis: null,
    background: null,
    bgColor: null,
    border: number,
    borderColor: null,
    bottomMargin: number,
    cellPadding: null,
    cellSpacing: null,
    char: null,
    charOff: null,
    classId: null,
    clear: null,
    code: null,
    codeBase: null,
    codeType: null,
    color: null,
    compact: boolean,
    declare: boolean,
    event: null,
    face: null,
    frame: null,
    frameBorder: null,
    hSpace: number,
    leftMargin: number,
    link: null,
    longDesc: null,
    lowSrc: null,
    marginHeight: number,
    marginWidth: number,
    noResize: boolean,
    noHref: boolean,
    noShade: boolean,
    noWrap: boolean,
    object: null,
    profile: null,
    prompt: null,
    rev: null,
    rightMargin: number,
    rules: null,
    scheme: null,
    scrolling: booleanish,
    standby: null,
    summary: null,
    text: null,
    topMargin: number,
    valueType: null,
    version: null,
    vAlign: null,
    vLink: null,
    vSpace: number,
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});

// node_modules/property-information/lib/svg.js
var svg = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    keySplines: null,
    keyTimes: null,
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});

// node_modules/property-information/lib/find.js
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/lib/hast-to-react.js
var hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};

// node_modules/property-information/index.js
var html2 = merge([xml, xlink, xmlns, aria, html], "html");
var svg2 = merge([xml, xlink, xmlns, aria, svg], "svg");

// node_modules/space-separated-tokens/index.js
function stringify2(values4) {
  return values4.join(" ").trim();
}

// node_modules/style-to-object/index.mjs
var import_index = __toESM(require_style_to_object(), 1);
var style_to_object_default = import_index.default;

// node_modules/unist-util-position/lib/index.js
var pointEnd = point("end");
var pointStart = point("start");
function point(type) {
  return point4;
  function point4(node2) {
    const point5 = node2 && node2.position && node2.position[type] || {};
    if (typeof point5.line === "number" && point5.line > 0 && typeof point5.column === "number" && point5.column > 0) {
      return {
        line: point5.line,
        column: point5.column,
        offset: typeof point5.offset === "number" && point5.offset > -1 ? point5.offset : void 0
      };
    }
  }
}
function position(node2) {
  const start2 = pointStart(node2);
  const end2 = pointEnd(node2);
  if (start2 && end2) {
    return { start: start2, end: end2 };
  }
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position2(value.position);
  }
  if ("start" in value || "end" in value) {
    return position2(value);
  }
  if ("line" in value || "column" in value) {
    return point2(value);
  }
  return "";
}
function point2(point4) {
  return index(point4 && point4.line) + ":" + index(point4 && point4.column);
}
function position2(pos) {
  return point2(pos && pos.start) + "-" + point2(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start2 = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start2 ? start2.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start2 ? start2.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/hast-util-to-jsx-runtime/lib/index.js
var own2 = {}.hasOwnProperty;
var emptyMap = /* @__PURE__ */ new Map();
var cap2 = /[A-Z]/g;
var dashSomething = /-([a-z])/g;
var tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
var tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0) {
    throw new TypeError("Expected `Fragment` in options");
  }
  const filePath = options.filePath || void 0;
  let create4;
  if (options.development) {
    if (typeof options.jsxDEV !== "function") {
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    }
    create4 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx !== "function") {
      throw new TypeError("Expected `jsx` in production options");
    }
    if (typeof options.jsxs !== "function") {
      throw new TypeError("Expected `jsxs` in production options");
    }
    create4 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create4,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || false,
    passKeys: options.passKeys !== false,
    passNode: options.passNode || false,
    schema: options.space === "svg" ? svg2 : html2,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== false
  };
  const result = one(state, tree, void 0);
  if (result && typeof result !== "string") {
    return result;
  }
  return state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one(state, node2, key) {
  if (node2.type === "element" || node2.type === "root") {
    const parentSchema = state.schema;
    let schema = parentSchema;
    if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
      schema = svg2;
      state.schema = schema;
    }
    state.ancestors.push(node2);
    let children = createChildren(state, node2);
    const props = createProperties(state, state.ancestors);
    let type = state.Fragment;
    state.ancestors.pop();
    if (node2.type === "element") {
      if (children && tableElements.has(node2.tagName)) {
        children = children.filter(function(child) {
          return typeof child === "string" ? !whitespace(child) : true;
        });
      }
      if (own2.call(state.components, node2.tagName)) {
        const key2 = node2.tagName;
        type = state.components[key2];
        if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
          props.node = node2;
        }
      } else {
        type = node2.tagName;
      }
    }
    if (children.length > 0) {
      const value = children.length > 1 ? children : children[0];
      if (value) {
        props.children = value;
      }
    }
    state.schema = parentSchema;
    return state.create(node2, type, props, key);
  }
  if (node2.type === "text") {
    return node2.value;
  }
}
function productionCreate(_6, jsx3, jsxs3) {
  return create4;
  function create4(_7, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const fn3 = isStaticChildren ? jsxs3 : jsx3;
    return key ? fn3(type, props, key) : fn3(type, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create4;
  function create4(node2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const point4 = pointStart(node2);
    return jsxDEV(
      type,
      props,
      key,
      isStaticChildren,
      {
        columnNumber: point4 ? point4.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point4 ? point4.line : void 0
      },
      void 0
    );
  }
}
function createChildren(state, node2) {
  const children = [];
  let index2 = -1;
  const countsByTagName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    let key;
    if (state.passKeys && child.type === "element") {
      const count = countsByTagName.get(child.tagName) || 0;
      key = child.tagName + "-" + count;
      countsByTagName.set(child.tagName, count + 1);
    }
    const result = one(state, child, key);
    if (result !== void 0)
      children.push(result);
  }
  return children;
}
function createProperties(state, ancestors) {
  const node2 = ancestors[ancestors.length - 1];
  const props = {};
  let prop;
  if ("properties" in node2 && node2.properties) {
    let alignValue;
    for (prop in node2.properties) {
      if (prop !== "children" && own2.call(node2.properties, prop)) {
        const result = createProperty(
          state,
          ancestors,
          prop,
          node2.properties[prop]
        );
        if (result) {
          const [key, value] = result;
          if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
            alignValue = value;
          } else {
            props[key] = value;
          }
        }
      }
    }
    if (alignValue) {
      const style = props.style || (props.style = {});
      style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
    }
  }
  return props;
}
function createProperty(state, ancestors, prop, value) {
  const info = find(state.schema, prop);
  if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify(value) : stringify2(value);
  }
  if (info.property === "style") {
    let styleObject = typeof value === "object" ? value : parseStyle(state, ancestors, String(value));
    if (state.stylePropertyNameCase === "css") {
      styleObject = transformStylesToCssCasing(styleObject);
    }
    return ["style", styleObject];
  }
  return [
    state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
    value
  ];
}
function parseStyle(state, ancestors, value) {
  const result = {};
  try {
    style_to_object_default(value, replacer2);
  } catch (error) {
    if (!state.ignoreInvalidStyle) {
      const cause = error;
      const message = new VFileMessage("Cannot parse `style` attribute", {
        ancestors,
        cause,
        source: "hast-util-to-jsx-runtime",
        ruleId: "style"
      });
      message.file = state.filePath || void 0;
      message.url = "https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute";
      throw message;
    }
  }
  return result;
  function replacer2(name, value2) {
    let key = name;
    if (key.slice(0, 2) !== "--") {
      if (key.slice(0, 4) === "-ms-")
        key = "ms-" + key.slice(4);
      key = key.replace(dashSomething, toCamel);
    }
    result[key] = value2;
  }
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from;
  for (from in domCasing) {
    if (own2.call(domCasing, from)) {
      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
    }
  }
  return cssCasing;
}
function transformStyleToCssCasing(from) {
  let to = from.replace(cap2, toDash);
  if (to.slice(0, 3) === "ms-")
    to = "-" + to;
  return to;
}
function toCamel(_6, $1) {
  return $1.toUpperCase();
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}

// node_modules/html-url-attributes/lib/index.js
var urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};

// node_modules/micromark-util-symbol/lib/codes.js
var codes = {
  carriageReturn: -5,
  lineFeed: -4,
  carriageReturnLineFeed: -3,
  horizontalTab: -2,
  virtualSpace: -1,
  eof: null,
  nul: 0,
  soh: 1,
  stx: 2,
  etx: 3,
  eot: 4,
  enq: 5,
  ack: 6,
  bel: 7,
  bs: 8,
  ht: 9,
  lf: 10,
  vt: 11,
  ff: 12,
  cr: 13,
  so: 14,
  si: 15,
  dle: 16,
  dc1: 17,
  dc2: 18,
  dc3: 19,
  dc4: 20,
  nak: 21,
  syn: 22,
  etb: 23,
  can: 24,
  em: 25,
  sub: 26,
  esc: 27,
  fs: 28,
  gs: 29,
  rs: 30,
  us: 31,
  space: 32,
  exclamationMark: 33,
  quotationMark: 34,
  numberSign: 35,
  dollarSign: 36,
  percentSign: 37,
  ampersand: 38,
  apostrophe: 39,
  leftParenthesis: 40,
  rightParenthesis: 41,
  asterisk: 42,
  plusSign: 43,
  comma: 44,
  dash: 45,
  dot: 46,
  slash: 47,
  digit0: 48,
  digit1: 49,
  digit2: 50,
  digit3: 51,
  digit4: 52,
  digit5: 53,
  digit6: 54,
  digit7: 55,
  digit8: 56,
  digit9: 57,
  colon: 58,
  semicolon: 59,
  lessThan: 60,
  equalsTo: 61,
  greaterThan: 62,
  questionMark: 63,
  atSign: 64,
  uppercaseA: 65,
  uppercaseB: 66,
  uppercaseC: 67,
  uppercaseD: 68,
  uppercaseE: 69,
  uppercaseF: 70,
  uppercaseG: 71,
  uppercaseH: 72,
  uppercaseI: 73,
  uppercaseJ: 74,
  uppercaseK: 75,
  uppercaseL: 76,
  uppercaseM: 77,
  uppercaseN: 78,
  uppercaseO: 79,
  uppercaseP: 80,
  uppercaseQ: 81,
  uppercaseR: 82,
  uppercaseS: 83,
  uppercaseT: 84,
  uppercaseU: 85,
  uppercaseV: 86,
  uppercaseW: 87,
  uppercaseX: 88,
  uppercaseY: 89,
  uppercaseZ: 90,
  leftSquareBracket: 91,
  backslash: 92,
  rightSquareBracket: 93,
  caret: 94,
  underscore: 95,
  graveAccent: 96,
  lowercaseA: 97,
  lowercaseB: 98,
  lowercaseC: 99,
  lowercaseD: 100,
  lowercaseE: 101,
  lowercaseF: 102,
  lowercaseG: 103,
  lowercaseH: 104,
  lowercaseI: 105,
  lowercaseJ: 106,
  lowercaseK: 107,
  lowercaseL: 108,
  lowercaseM: 109,
  lowercaseN: 110,
  lowercaseO: 111,
  lowercaseP: 112,
  lowercaseQ: 113,
  lowercaseR: 114,
  lowercaseS: 115,
  lowercaseT: 116,
  lowercaseU: 117,
  lowercaseV: 118,
  lowercaseW: 119,
  lowercaseX: 120,
  lowercaseY: 121,
  lowercaseZ: 122,
  leftCurlyBrace: 123,
  verticalBar: 124,
  rightCurlyBrace: 125,
  tilde: 126,
  del: 127,
  byteOrderMarker: 65279,
  replacementCharacter: 65533
};

// node_modules/micromark-util-symbol/lib/constants.js
var constants = {
  attentionSideBefore: 1,
  attentionSideAfter: 2,
  atxHeadingOpeningFenceSizeMax: 6,
  autolinkDomainSizeMax: 63,
  autolinkSchemeSizeMax: 32,
  cdataOpeningString: "CDATA[",
  characterGroupWhitespace: 1,
  characterGroupPunctuation: 2,
  characterReferenceDecimalSizeMax: 7,
  characterReferenceHexadecimalSizeMax: 6,
  characterReferenceNamedSizeMax: 31,
  codeFencedSequenceSizeMin: 3,
  contentTypeDocument: "document",
  contentTypeFlow: "flow",
  contentTypeContent: "content",
  contentTypeString: "string",
  contentTypeText: "text",
  hardBreakPrefixSizeMin: 2,
  htmlRaw: 1,
  htmlComment: 2,
  htmlInstruction: 3,
  htmlDeclaration: 4,
  htmlCdata: 5,
  htmlBasic: 6,
  htmlComplete: 7,
  htmlRawSizeMax: 8,
  linkResourceDestinationBalanceMax: 32,
  linkReferenceSizeMax: 999,
  listItemValueSizeMax: 10,
  numericBaseDecimal: 10,
  numericBaseHexadecimal: 16,
  tabSize: 4,
  thematicBreakMarkerCountMin: 3,
  v8MaxSafeChunkSize: 1e4
};

// node_modules/micromark-util-symbol/lib/types.js
var types = {
  data: "data",
  whitespace: "whitespace",
  lineEnding: "lineEnding",
  lineEndingBlank: "lineEndingBlank",
  linePrefix: "linePrefix",
  lineSuffix: "lineSuffix",
  atxHeading: "atxHeading",
  atxHeadingSequence: "atxHeadingSequence",
  atxHeadingText: "atxHeadingText",
  autolink: "autolink",
  autolinkEmail: "autolinkEmail",
  autolinkMarker: "autolinkMarker",
  autolinkProtocol: "autolinkProtocol",
  characterEscape: "characterEscape",
  characterEscapeValue: "characterEscapeValue",
  characterReference: "characterReference",
  characterReferenceMarker: "characterReferenceMarker",
  characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
  characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
  characterReferenceValue: "characterReferenceValue",
  codeFenced: "codeFenced",
  codeFencedFence: "codeFencedFence",
  codeFencedFenceSequence: "codeFencedFenceSequence",
  codeFencedFenceInfo: "codeFencedFenceInfo",
  codeFencedFenceMeta: "codeFencedFenceMeta",
  codeFlowValue: "codeFlowValue",
  codeIndented: "codeIndented",
  codeText: "codeText",
  codeTextData: "codeTextData",
  codeTextPadding: "codeTextPadding",
  codeTextSequence: "codeTextSequence",
  content: "content",
  definition: "definition",
  definitionDestination: "definitionDestination",
  definitionDestinationLiteral: "definitionDestinationLiteral",
  definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
  definitionDestinationRaw: "definitionDestinationRaw",
  definitionDestinationString: "definitionDestinationString",
  definitionLabel: "definitionLabel",
  definitionLabelMarker: "definitionLabelMarker",
  definitionLabelString: "definitionLabelString",
  definitionMarker: "definitionMarker",
  definitionTitle: "definitionTitle",
  definitionTitleMarker: "definitionTitleMarker",
  definitionTitleString: "definitionTitleString",
  emphasis: "emphasis",
  emphasisSequence: "emphasisSequence",
  emphasisText: "emphasisText",
  escapeMarker: "escapeMarker",
  hardBreakEscape: "hardBreakEscape",
  hardBreakTrailing: "hardBreakTrailing",
  htmlFlow: "htmlFlow",
  htmlFlowData: "htmlFlowData",
  htmlText: "htmlText",
  htmlTextData: "htmlTextData",
  image: "image",
  label: "label",
  labelText: "labelText",
  labelLink: "labelLink",
  labelImage: "labelImage",
  labelMarker: "labelMarker",
  labelImageMarker: "labelImageMarker",
  labelEnd: "labelEnd",
  link: "link",
  paragraph: "paragraph",
  reference: "reference",
  referenceMarker: "referenceMarker",
  referenceString: "referenceString",
  resource: "resource",
  resourceDestination: "resourceDestination",
  resourceDestinationLiteral: "resourceDestinationLiteral",
  resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
  resourceDestinationRaw: "resourceDestinationRaw",
  resourceDestinationString: "resourceDestinationString",
  resourceMarker: "resourceMarker",
  resourceTitle: "resourceTitle",
  resourceTitleMarker: "resourceTitleMarker",
  resourceTitleString: "resourceTitleString",
  setextHeading: "setextHeading",
  setextHeadingText: "setextHeadingText",
  setextHeadingLine: "setextHeadingLine",
  setextHeadingLineSequence: "setextHeadingLineSequence",
  strong: "strong",
  strongSequence: "strongSequence",
  strongText: "strongText",
  thematicBreak: "thematicBreak",
  thematicBreakSequence: "thematicBreakSequence",
  blockQuote: "blockQuote",
  blockQuotePrefix: "blockQuotePrefix",
  blockQuoteMarker: "blockQuoteMarker",
  blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
  listOrdered: "listOrdered",
  listUnordered: "listUnordered",
  listItemIndent: "listItemIndent",
  listItemMarker: "listItemMarker",
  listItemPrefix: "listItemPrefix",
  listItemPrefixWhitespace: "listItemPrefixWhitespace",
  listItemValue: "listItemValue",
  chunkDocument: "chunkDocument",
  chunkContent: "chunkContent",
  chunkFlow: "chunkFlow",
  chunkText: "chunkText",
  chunkString: "chunkString"
};

// node_modules/micromark-util-symbol/lib/values.js
var values = {
  ht: "	",
  lf: "\n",
  cr: "\r",
  space: " ",
  exclamationMark: "!",
  quotationMark: '"',
  numberSign: "#",
  dollarSign: "$",
  percentSign: "%",
  ampersand: "&",
  apostrophe: "'",
  leftParenthesis: "(",
  rightParenthesis: ")",
  asterisk: "*",
  plusSign: "+",
  comma: ",",
  dash: "-",
  dot: ".",
  slash: "/",
  digit0: "0",
  digit1: "1",
  digit2: "2",
  digit3: "3",
  digit4: "4",
  digit5: "5",
  digit6: "6",
  digit7: "7",
  digit8: "8",
  digit9: "9",
  colon: ":",
  semicolon: ";",
  lessThan: "<",
  equalsTo: "=",
  greaterThan: ">",
  questionMark: "?",
  atSign: "@",
  uppercaseA: "A",
  uppercaseB: "B",
  uppercaseC: "C",
  uppercaseD: "D",
  uppercaseE: "E",
  uppercaseF: "F",
  uppercaseG: "G",
  uppercaseH: "H",
  uppercaseI: "I",
  uppercaseJ: "J",
  uppercaseK: "K",
  uppercaseL: "L",
  uppercaseM: "M",
  uppercaseN: "N",
  uppercaseO: "O",
  uppercaseP: "P",
  uppercaseQ: "Q",
  uppercaseR: "R",
  uppercaseS: "S",
  uppercaseT: "T",
  uppercaseU: "U",
  uppercaseV: "V",
  uppercaseW: "W",
  uppercaseX: "X",
  uppercaseY: "Y",
  uppercaseZ: "Z",
  leftSquareBracket: "[",
  backslash: "\\",
  rightSquareBracket: "]",
  caret: "^",
  underscore: "_",
  graveAccent: "`",
  lowercaseA: "a",
  lowercaseB: "b",
  lowercaseC: "c",
  lowercaseD: "d",
  lowercaseE: "e",
  lowercaseF: "f",
  lowercaseG: "g",
  lowercaseH: "h",
  lowercaseI: "i",
  lowercaseJ: "j",
  lowercaseK: "k",
  lowercaseL: "l",
  lowercaseM: "m",
  lowercaseN: "n",
  lowercaseO: "o",
  lowercaseP: "p",
  lowercaseQ: "q",
  lowercaseR: "r",
  lowercaseS: "s",
  lowercaseT: "t",
  lowercaseU: "u",
  lowercaseV: "v",
  lowercaseW: "w",
  lowercaseX: "x",
  lowercaseY: "y",
  lowercaseZ: "z",
  leftCurlyBrace: "{",
  verticalBar: "|",
  rightCurlyBrace: "}",
  tilde: "~",
  replacementCharacter: "\uFFFD"
};

// node_modules/micromark-util-character/dev/index.js
var unicodePunctuationInternal = regexCheck(/\p{P}/u);
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return code2 !== null && (code2 < codes.space || code2 === codes.del);
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < codes.nul || code2 === codes.space);
}
function markdownSpace(code2) {
  return code2 === codes.horizontalTab || code2 === codes.virtualSpace || code2 === codes.space;
}
function unicodePunctuation(code2) {
  return asciiPunctuation(code2) || unicodePunctuationInternal(code2);
}
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check2;
  function check2(code2) {
    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/micromark-util-encode/index.js
var characterReferences = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
function encode(value) {
  return value.replace(/["&<>]/g, replace2);
  function replace2(value2) {
    return "&" + characterReferences[value2] + ";";
  }
}

// node_modules/micromark-util-sanitize-uri/dev/index.js
function sanitizeUri(url, protocol) {
  const value = encode(normalizeUri(url || ""));
  if (!protocol) {
    return value;
  }
  const colon = value.indexOf(":");
  const questionMark = value.indexOf("?");
  const numberSign = value.indexOf("#");
  const slash = value.indexOf("/");
  if (colon < 0 || slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || protocol.test(value.slice(0, colon))) {
    return value;
  }
  return "";
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start2 = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace2 = "";
    if (code2 === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace2 = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next2 = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
        replace2 = String.fromCharCode(code2, next2);
        skip = 1;
      } else {
        replace2 = values.replacementCharacter;
      }
    } else {
      replace2 = String.fromCharCode(code2);
    }
    if (replace2) {
      result.push(value.slice(start2, index2), encodeURIComponent(replace2));
      start2 = index2 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start2);
}

// node_modules/react-markdown/lib/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString2(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one2(value, includeImageAlt, includeHtml);
}
function one2(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values4, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values4.length) {
    result[index2] = one2(values4[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// node_modules/micromark-util-chunked/dev/index.js
function splice(list3, start2, remove, items) {
  const end2 = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end2 ? 0 : end2 + start2;
  } else {
    start2 = start2 > end2 ? end2 : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list3.splice(...parameters);
  } else {
    if (remove)
      list3.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start2, 0);
      list3.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start2 += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left2 = maybe || (all2[hook] = {});
    const right2 = extension2[hook];
    let code2;
    if (right2) {
      for (code2 in right2) {
        if (!hasOwnProperty.call(left2, code2))
          left2[code2] = [];
        const value = right2[code2];
        constructs(
          left2[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list3) {
  let index2 = -1;
  const before = [];
  while (++index2 < list3.length) {
    ;
    (list3[index2].add === "after" ? existing : before).push(list3[index2]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  if (code2 < codes.ht || code2 === codes.vt || code2 > codes.cr && code2 < codes.space || code2 > codes.tilde && code2 < 160 || code2 > 55295 && code2 < 57344 || code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || code2 > 1114111) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code2);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty2 = {}.hasOwnProperty;

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max4) {
  const limit = max4 ? max4 - 1 : Number.POSITIVE_INFINITY;
  let size2 = 0;
  return start2;
  function start2(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok3(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size2++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok3(code2);
  }
}

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data2(code2);
  }
  function data2(code2) {
    if (code2 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code2);
    return data2;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point4 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point4);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start2(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow)
      closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === codes.eof) {
      if (childFlow)
        closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      contentType: constants.contentTypeFlow,
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (eof)
      stream.push(null);
    token.previous = childToken;
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (childFlow.events[index2][1].start.offset < lineStartOffset && (!childFlow.events[index2][1].end || childFlow.events[index2][1].end.offset > lineStartOffset)) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point4;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point4 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point4, "could not find previous flow chunk");
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point4);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size2) {
    let index2 = stack.length;
    while (index2-- > size2) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size2;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code2) {
  if (code2 === codes.eof || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code2)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset2;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start2 = Object.assign({}, events[open][1].end);
          const end2 = Object.assign({}, events[index2][1].start);
          movePoint(start2, -use);
          movePoint(end2, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: start2,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: Object.assign({}, events[index2][1].start),
            end: end2
          };
          text4 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset2 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset2 = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset2 - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start2;
  function start2(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code2);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok3(code2);
  }
}
function movePoint(point4, offset2) {
  point4.column += offset2;
  point4.offset += offset2;
  point4._bufferIndex += offset2;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size2 = 0;
  return start2;
  function start2(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code2);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) {
      size2 = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === codes.colon) {
      effects.consume(code2);
      size2 = 0;
      return urlInside;
    }
    if ((code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) && size2++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size2 = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code2);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.lessThan || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === codes.atSign) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === codes.dot) {
      effects.consume(code2);
      size2 = 0;
      return emailAtSignOrDot;
    }
    if (code2 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code2);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === codes.dash || asciiAlphanumeric(code2)) && size2++ < constants.autolinkDomainSizeMax) {
      const next2 = code2 === codes.dash ? emailValue : emailLabel;
      effects.consume(code2);
      return next2;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { tokenize: tokenizeBlankLine, partial: true };
function tokenizeBlankLine(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, types.linePrefix)(code2) : after(code2);
  }
  function after(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code2);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code2);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok3, nok)(code2);
  }
}
function exit(effects) {
  effects.exit(types.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code2);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code2);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size2 = 0;
  let max4;
  let test2;
  return start2;
  function start2(code2) {
    ok(code2 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code2);
    effects.exit(types.characterReferenceMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max4 = constants.characterReferenceNamedSizeMax;
    test2 = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === codes.uppercaseX || code2 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max4 = constants.characterReferenceHexadecimalSizeMax;
      test2 = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max4 = constants.characterReferenceDecimalSizeMax;
    test2 = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === codes.semicolon && size2) {
      const token = effects.exit(types.characterReferenceValue);
      if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code2);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test2(code2) && size2++ < max4) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { tokenize: tokenizeCloseStart, partial: true };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    ok(
      code2 === codes.graveAccent || code2 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code2);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, types.whitespace)(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info(code2);
  }
  function info(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit(types.codeFenced);
    return ok3(code2);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size2 = 0;
    return startBefore;
    function startBefore(code2) {
      ok(markdownLineEnding(code2), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code2);
      effects2.exit(types.lineEnding);
      return start3;
    }
    function start3(code2) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code2) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size2++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size2 >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === codes.eof || markdownLineEnding(code2)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { tokenize: tokenizeFurtherStart, partial: true };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    ok(markdownSpace(code2));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.eof) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter(types.codeFlowValue);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit(types.codeIndented);
    return ok3(code2);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== types.lineEnding) {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === types.lineEnding) {
      events[enter][1].type = types.codeTextData;
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size2;
  let token;
  return start2;
  function start2(code2) {
    ok(code2 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between(code2);
  }
  function between(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.space) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size2 = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return between;
    }
    effects.enter(types.codeTextData);
    return data2(code2);
  }
  function data2(code2) {
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.graveAccent || markdownLineEnding(code2)) {
      effects.exit(types.codeTextData);
      return between(code2);
    }
    effects.consume(code2);
    return data2;
  }
  function sequenceClose(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      size2++;
      return sequenceClose;
    }
    if (size2 === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code2);
    }
    token.type = types.codeTextData;
    return data2(code2);
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === types.chunkFlow && events[index2 - 1][1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    ok(
      !previous2 || current.previous === previous2,
      "expected previous to match"
    );
    ok(!previous2 || previous2.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      ok(current, "expected a current token");
      start2 = index2 + 1;
      breaks.push(start2);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start3 = startPositions.pop();
    ok(start3 !== void 0, "expected a start position when splicing");
    jumps.unshift([start3, start3 + slice.length - 1]);
    splice(events, start3, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { tokenize: tokenizeContent, resolve: resolveContent };
var continuationConstruct = { tokenize: tokenizeContinuation, partial: true };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous2 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === codes.eof) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code2);
  }
  function contentContinue(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.consume(code2);
    effects.exit(types.chunkContent);
    ok(previous2, "expected previous token");
    previous2.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code2);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max4) {
  const limit = max4 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code2) {
    if (code2 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.rightParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === codes.eof || code2 === codes.lessThan || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === codes.lessThan || code2 === codes.greaterThan || code2 === codes.backslash) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === codes.eof || code2 === codes.rightParenthesis || markdownLineEndingOrSpace(code2))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code2);
    }
    if (balance < limit && code2 === codes.leftParenthesis) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === codes.rightParenthesis) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.leftParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === codes.leftParenthesis || code2 === codes.rightParenthesis || code2 === codes.backslash) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size2 = 0;
  let seen;
  return start2;
  function start2(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size2 > constants.linkReferenceSizeMax || code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket && !seen || code2 === codes.caret && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket || markdownLineEnding(code2) || size2++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen)
      seen = !markdownSpace(code2);
    return code2 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === codes.leftSquareBracket || code2 === codes.backslash || code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      size2++;
      return labelInside;
    }
    return labelInside(code2);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start2;
  function start2(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === codes.leftParenthesis ? codes.rightParenthesis : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? escape : inside;
  }
  function escape(code2) {
    if (code2 === marker || code2 === codes.backslash) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      seen = true;
      return start2;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start2,
        seen ? types.linePrefix : types.lineSuffix
      )(code2);
    }
    return ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { tokenize: tokenizeTitleBefore, partial: true };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start2;
  function start2(code2) {
    effects.enter(types.definition);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code2);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, types.whitespace)(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size2 = 0;
  return start2;
  function start2(code2) {
    effects.enter(types.atxHeading);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.numberSign && size2++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === codes.eof || markdownLineEndingOrSpace(code2)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.atxHeading);
      return ok3(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, types.whitespace)(code2);
    }
    effects.enter(types.atxHeadingText);
    return data2(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === codes.numberSign) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code2);
  }
  function data2(code2) {
    if (code2 === codes.eof || code2 === codes.numberSign || markdownLineEndingOrSpace(code2)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code2);
    }
    effects.consume(code2);
    return data2;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = { tokenize: tokenizeBlankLineBefore, partial: true };
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === types.linePrefix) {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start2;
  function start2(code2) {
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      marker = constants.htmlCdata;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === codes.eof || code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === codes.slash;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code2) : continuation(code2);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.slash || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    ok(markdownLineEnding(code2));
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === codes.greaterThan) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer.length < constants.htmlRawSizeMax) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit(types.htmlFlow);
    return ok3(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types.lineEnding);
      effects.consume(code2);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start2;
  function start2(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === codes.greaterThan ? end2(code2) : code2 === codes.dash ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value = constants.cdataOpeningString;
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === codes.greaterThan) {
      return end2(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === codes.eof || code2 === codes.greaterThan) {
      return end2(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === codes.greaterThan ? end2(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end2(code2);
  }
  function tagOpen(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return end2;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end2(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end2(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code2), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code2) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter(types.htmlTextData);
    return returnState(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      events.splice(index2 + 1, token.type === types.labelImage ? 4 : 2);
      token.type = types.data;
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset2 = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open = index2;
        if (token.type !== types.labelLink) {
          offset2 = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close = index2;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types.labelLink ? types.link : types.image,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: types.label,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text4 = {
    type: types.labelText,
    start: Object.assign({}, events[open + offset2 + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset2 + 3));
  media = push(media, [["enter", text4, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset2 + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text4, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === types.labelImage || self2.events[index2][1].type === types.labelLink) && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start2;
  function start2(code2) {
    ok(code2 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code2);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code2) {
    if (code2 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok3(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code2) {
    ok(code2 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code2);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === codes.rightParenthesis) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code2);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code2);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code2);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    ok(code2 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code2);
    effects.exit(types.labelImageMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code2);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code2);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start2;
  function start2(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size2 = 0;
  let marker;
  return start2;
  function start2(code2) {
    effects.enter(types.thematicBreak);
    return before(code2);
  }
  function before(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.dash || code2 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code2);
    }
    if (size2 >= constants.thematicBreakMarkerCountMin && (code2 === codes.eof || markdownLineEnding(code2))) {
      effects.exit(types.thematicBreak);
      return ok3(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size2++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code2) ? factorySpace(effects, atBreak, types.whitespace)(code2) : atBreak(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = { tokenize: tokenizeIndent, partial: true };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size2 = 0;
  return start2;
  function start2(code2) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code2 === codes.asterisk || code2 === codes.plusSign || code2 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code2 === codes.asterisk || code2 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code2) && ++size2 < constants.listItemValueSizeMax) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === codes.rightParenthesis || code2 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    ok(self2.containerState, "expected state");
    ok(code2 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code2);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code2);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code2);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code2) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok3(code2) : nok(code2);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === types.content) {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === types.paragraph) {
        text4 = index2;
      }
    } else {
      if (events[index2][1].type === types.content) {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === types.definition) {
        definition2 = index2;
      }
    }
  }
  ok(text4 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  const heading2 = {
    type: types.setextHeading,
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = types.setextHeadingText;
  if (definition2) {
    events.splice(text4, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    ok(
      code2 === codes.dash || code2 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index2--) {
      if (self2.events[index2][1].type !== types.lineEnding && self2.events[index2][1].type !== types.linePrefix && self2.events[index2][1].type !== types.content) {
        paragraph2 = self2.events[index2][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter(types.setextHeadingLine);
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code2) ? factorySpace(effects, after, types.lineSuffix)(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code2);
    }
    return nok(code2);
  }
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    blankLine,
    atBlankEnding,
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code2);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code2);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === codes.eof) {
        effects.consume(code2);
        return;
      }
      effects.enter(types.data);
      effects.consume(code2);
      return data2;
    }
    function data2(code2) {
      if (atBreak(code2)) {
        effects.exit(types.data);
        return text4(code2);
      }
      effects.consume(code2);
      return data2;
    }
    function atBreak(code2) {
      if (code2 === codes.eof) {
        return true;
      }
      const list3 = constructs2[code2];
      let index2 = -1;
      if (list3) {
        ok(Array.isArray(list3), "expected `disable.null` to be populated");
        while (++index2 < list3.length) {
          const item = list3[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === types.data) {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== types.data) {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data2 = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data2);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size2 = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size2++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size2++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index2++;
          break;
        }
      }
      if (size2) {
        const token = {
          type: eventIndex === events.length || tabs || size2 < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            line: data2.end.line,
            column: data2.end.column - size2,
            offset: data2.end.offset - size2,
            _index: data2.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data2.end)
        };
        data2.end = Object.assign({}, token.start);
        if (data2.start.offset === data2.end.offset) {
          Object.assign(data2, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser2(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from) {
  let point4 = Object.assign(
    from ? Object.assign({}, from) : { line: 1, column: 1, offset: 0 },
    { _index: 0, _bufferIndex: -1 }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    previous: codes.eof,
    code: codes.eof,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write: write2
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write2(slice) {
    chunks = push(chunks, slice);
    main2();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset: offset2, _index, _bufferIndex } = point4;
    return { line, column, offset: offset2, _index, _bufferIndex };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point4);
  }
  function main2() {
    let chunkIndex;
    while (point4._index < chunks.length) {
      const chunk = chunks[point4._index];
      if (typeof chunk === "string") {
        chunkIndex = point4._index;
        if (point4._bufferIndex < 0) {
          point4._bufferIndex = 0;
        }
        while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point4._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code2, state && state.name);
    expectedCode = code2;
    ok(typeof state === "function", "expected state");
    state = state(code2);
  }
  function consume(code2) {
    ok(code2 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code2);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code2 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code2)) {
      point4.line++;
      point4.column = 1;
      point4.offset += code2 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point4);
    } else if (code2 !== codes.virtualSpace) {
      point4.column++;
      point4.offset++;
    }
    if (point4._bufferIndex < 0) {
      point4._index++;
    } else {
      point4._bufferIndex++;
      if (point4._bufferIndex === chunks[point4._index].length) {
        point4._bufferIndex = -1;
        point4._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct2, info) {
    addResult(construct2, info.from);
  }
  function onsuccessfulcheck(_6, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start2;
        function start2(code2) {
          const def = code2 !== null && map[code2];
          const all2 = code2 !== null && map.null;
          const list3 = [
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list3)(code2);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct2) {
        return start2;
        function start2(code2) {
          info = store();
          currentConstruct = construct2;
          if (!construct2.partial) {
            context.currentConstruct = construct2;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct2.name && context.parser.constructs.disable.null.includes(construct2.name)) {
            return nok(code2);
          }
          return construct2.tokenize.call(
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code2);
        }
      }
      function ok3(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct2, from2) {
    if (construct2.resolveAll && !resolveAllConstructs.includes(construct2)) {
      resolveAllConstructs.push(construct2);
    }
    if (construct2.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct2.resolve(context.events.slice(from2), context)
      );
    }
    if (construct2.resolveTo) {
      context.events = construct2.resolveTo(context.events, context);
    }
    ok(
      construct2.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { restore, from: startEventsIndex };
    function restore() {
      point4 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point4);
    }
  }
  function accountForPotentialSkip() {
    if (point4.line in columnStart && point4.column < 2) {
      point4.column = columnStart[point4.line];
      point4.offset += columnStart[point4.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab)
            continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [codes.asterisk]: list,
  [codes.plusSign]: list,
  [codes.dash]: list,
  [codes.digit0]: list,
  [codes.digit1]: list,
  [codes.digit2]: list,
  [codes.digit3]: list,
  [codes.digit4]: list,
  [codes.digit5]: list,
  [codes.digit6]: list,
  [codes.digit7]: list,
  [codes.digit8]: list,
  [codes.digit9]: list,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text2 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/parse.js
function parse2(options) {
  const settings = options || {};
  const constructs2 = combineExtensions([constructs_exports, ...settings.extensions || []]);
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create4(content),
    document: create4(document2),
    flow: create4(flow),
    string: create4(string),
    text: create4(text)
  };
  return parser;
  function create4(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end2) {
    const chunks = [];
    let match2;
    let next2;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start2) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match2 = search.exec(value);
      endPosition = match2 && match2.index !== void 0 ? match2.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match2) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code2 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next2 = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next2)
              chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end2) {
      if (atCarriageReturn)
        chunks.push(codes.carriageReturn);
      if (buffer)
        chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $22) {
  if ($1) {
    return $1;
  }
  const head = $22.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $22.charCodeAt(1);
    const hex2 = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $22.slice(hex2 ? 2 : 1),
      hex2 ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($22) || $0;
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own3 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse2(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html5, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html5, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data2 = {};
  return compile2;
  function compile2(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      data: data2
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === types.listOrdered || events[index2][1].type === types.listUnordered) {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own3.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            { sliceSerialize: events[index2][2].sliceSerialize },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point3(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point3(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length) {
    let index2 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length;
  }
  function opener(create4, and) {
    return open;
    function open(token) {
      enter.call(this, create4(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point3(token.start),
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): it\u2019s not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point3(token.end);
  }
  function resume() {
    return toString2(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data3;
  }
  function onexitcodefencedfencemeta() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data3;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside)
      return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data3.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data3;
  }
  function onexitdefinitiondestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data3;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = {
        start: point3(token.start),
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point3(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point3(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data3;
  }
  function onexithtmltext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data3;
  }
  function onexitcodetext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data3;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data3;
  }
  function onexitresourcetitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data3;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data3 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data3,
        type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data3);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
    tail.position.end = point3(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return {
      type: "heading",
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html5() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list3(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text4() {
    return { type: "text", value: "" };
  }
  function thematicBreak3() {
    return { type: "thematicBreak" };
  }
}
function point3(d4) {
  return { line: d4.line, column: d4.column, offset: d4.offset };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own3.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right2 = extension2[key];
          if (right2) {
            combined[key].push(...right2);
          }
          break;
        }
        case "transforms": {
          const right2 = extension2[key];
          if (right2) {
            combined[key].push(...right2);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right2 = extension2[key];
          if (right2) {
            Object.assign(combined[key], right2);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left2, right2) {
  if (left2) {
    throw new Error(
      "Cannot close `" + left2.type + "` (" + stringifyPosition({ start: left2.start, end: left2.end }) + "): a different token (`" + right2.type + "`, " + stringifyPosition({ start: right2.start, end: right2.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right2.type + "`, " + stringifyPosition({ start: right2.start, end: right2.end }) + ") is still open"
    );
  }
}

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
"";
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/break.js
"";
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}

// node_modules/mdast-util-to-hast/lib/handlers/code.js
"";
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  if (node2.lang) {
    properties.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
"";
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
"";
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id2 = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id2.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id2);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id2);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id2);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id2, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
"";
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/html.js
"";
function html3(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}

// node_modules/mdast-util-to-hast/lib/revert.js
"";
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const def = state.definitionById.get(id2);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
"";
function inlineCode(state, node2) {
  const text4 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text4);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text4]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const def = state.definitionById.get(id2);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
"";
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}

// node_modules/mdast-util-to-hast/lib/handlers/list.js
"";
function list2(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
"";
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/root.js
"";
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
"";
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start2 = pointStart(node2.children[1]);
    const end2 = pointEnd(node2.children[node2.children.length - 1]);
    if (start2 && end2)
      body.position = { start: start2, end: end2 };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
"";
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
"";
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/trim-lines/index.js
var tab = 9;
var space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match2 = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match2) {
    lines.push(
      trimLine(source.slice(last, match2.index), last > 0, true),
      match2[0]
    );
    last = match2.index + match2[0].length;
    match2 = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start2, end2) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start2) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end2) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text3(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
"";
function thematicBreak2(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html: html3,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list: list2,
  paragraph,
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text: text3,
  thematicBreak: thematicBreak2,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}

// node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// node_modules/@ungap/structured-clone/esm/deserialize.js
var env = typeof self === "object" ? self : globalThis;
var deserializer = ($4, _6) => {
  const as3 = (out, index2) => {
    $4.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($4.has(index2))
      return $4.get(index2);
    const [type, value] = _6[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as3(value, index2);
      case ARRAY: {
        const arr = as3([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as3({}, index2);
        for (const [key, index3] of value)
          object[unpair(key)] = unpair(index3);
        return object;
      }
      case DATE:
        return as3(new Date(value), index2);
      case REGEXP: {
        const { source, flags } = value;
        return as3(new RegExp(source, flags), index2);
      }
      case MAP: {
        const map = as3(/* @__PURE__ */ new Map(), index2);
        for (const [key, index3] of value)
          map.set(unpair(key), unpair(index3));
        return map;
      }
      case SET: {
        const set4 = as3(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set4.add(unpair(index3));
        return set4;
      }
      case ERROR: {
        const { name, message } = value;
        return as3(new env[name](message), index2);
      }
      case BIGINT:
        return as3(BigInt(value), index2);
      case "BigInt":
        return as3(Object(BigInt(value)), index2);
    }
    return as3(new env[type](value), index2);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString: toString3 } = {};
var { keys } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString3.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json2, $4, _6) => {
  const as3 = (out, value) => {
    const index2 = _6.push(out) - 1;
    $4.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($4.has(value))
      return $4.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as3([VOID], value);
        }
        return as3([TYPE, entry], value);
      }
      case ARRAY: {
        if (type)
          return as3([type, [...value]], value);
        const arr = [];
        const index2 = as3([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as3([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as3([type, value.valueOf()], value);
          }
        }
        if (json2 && "toJSON" in value)
          return pair(value.toJSON());
        const entries2 = [];
        const index2 = as3([TYPE, entries2], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries2.push([pair(key), pair(value[key])]);
        }
        return index2;
      }
      case DATE:
        return as3([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as3([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries2 = [];
        const index2 = as3([TYPE, entries2], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries2.push([pair(key), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries2 = [];
        const index2 = as3([TYPE, entries2], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries2.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as3([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize = (value, { json: json2, lossy } = {}) => {
  const _6 = [];
  return serializer(!(json2 || lossy), !!json2, /* @__PURE__ */ new Map(), _6)(value), _6;
};

// node_modules/@ungap/structured-clone/esm/index.js
var esm_default2 = typeof structuredClone === "function" ? (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any) : (any, options) => deserialize(serialize(any, options));

// node_modules/mdast-util-to-hast/lib/footer.js
function defaultFootnoteBackContent(_6, rereferenceIndex) {
  const result = [{ type: "text", value: "\u21A9" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const def = state.footnoteById.get(state.footnoteOrder[referenceIndex]);
    if (!def) {
      continue;
    }
    const content3 = state.all(def);
    const id2 = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id2);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(def, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...esm_default2(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/unist-util-is/lib/index.js
var convert = function(test2) {
  if (test2 === null || test2 === void 0) {
    return ok2;
  }
  if (typeof test2 === "function") {
    return castFactory(test2);
  }
  if (typeof test2 === "object") {
    return Array.isArray(test2) ? anyFactory(test2) : propsFactory(test2);
  }
  if (typeof test2 === "string") {
    return typeFactory(test2);
  }
  throw new Error("Expected function, string, or object as test");
};
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function propsFactory(check2) {
  const checkAsRecord = check2;
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = node2;
    let key;
    for (key in check2) {
      if (nodeAsRecord[key] !== checkAsRecord[key])
        return false;
    }
    return true;
  }
}
function typeFactory(check2) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check2;
  }
}
function castFactory(testFunction) {
  return check2;
  function check2(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d4) {
  return d4;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test2, visitor, reverse) {
  let check2;
  if (typeof test2 === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test2;
  } else {
    check2 = test2;
  }
  const is5 = convert(check2);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = node2 && typeof node2 === "object" ? node2 : {};
    if (typeof value.type === "string") {
      const name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty2;
      let subresult;
      let offset2;
      let grandparents;
      if (!test2 || is5(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = node2;
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset2 = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset2 > -1 && offset2 < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset2];
            subresult = factory(child, offset2, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty2 : [value];
}

// node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test2;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test2 = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test2 = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test2, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}

// node_modules/mdast-util-to-hast/lib/state.js
var own4 = {}.hasOwnProperty;
var emptyOptions2 = {};
function createState(tree, options) {
  const settings = options || emptyOptions2;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers2 = { ...handlers, ...settings.handlers };
  const state = {
    all: all2,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers2,
    one: one3,
    options: settings,
    patch,
    wrap
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map = node2.type === "definition" ? definitionById : footnoteById;
      const id2 = String(node2.identifier).toUpperCase();
      if (!map.has(id2)) {
        map.set(id2, node2);
      }
    }
  });
  return state;
  function one3(node2, parent) {
    const type = node2.type;
    const handle = state.handlers[type];
    if (own4.call(state.handlers, type) && handle) {
      return handle(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = esm_default2(shallow);
        result.children = state.all(node2);
        return result;
      }
      return esm_default2(node2);
    }
    const unknown = state.options.unknownHandler || defaultUnknownHandler;
    return unknown(state, node2, parent);
  }
  function all2(parent) {
    const values4 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head = result.children[0];
              if (head && head.type === "text") {
                head.value = trimMarkdownSpaceStart(head.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values4.push(...result);
          } else {
            values4.push(result);
          }
        }
      }
    }
    return values4;
  }
}
function patch(from, to) {
  if (from.position)
    to.position = position(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, esm_default2(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data2 = node2.data || {};
  const result = "value" in node2 && !(own4.call(data2, "hProperties") || own4.call(data2, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2)
      result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code2 = value.charCodeAt(index2);
  while (code2 === 9 || code2 === 32) {
    index2++;
    code2 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    ok("children" in result);
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}

// node_modules/remark-rehype/lib/index.js
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = toHast(tree, options);
      await destination.run(hastTree, file);
    };
  }
  return function(tree) {
    return toHast(tree, options || destination);
  };
}

// node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// node_modules/trough/index.js
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values4) {
    let middlewareIndex = -1;
    const callback = values4.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next2(null, ...values4);
    function next2(error, ...output) {
      const fn3 = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values4.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values4[index2];
        }
      }
      values4 = output;
      if (fn3) {
        wrap2(fn3, next2)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap2(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = error;
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result instanceof Promise) {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// node_modules/vfile/lib/minpath.browser.js
var path = { basename, dirname, extname, join, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start2 = 0;
  let end2 = -1;
  let index2 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index2--) {
      if (path2.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start2 = index2 + 1;
          break;
        }
      } else if (end2 < 0) {
        seenNonSlash = true;
        end2 = index2 + 1;
      }
    }
    return end2 < 0 ? "" : path2.slice(start2, end2);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path2.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start2 = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path2.codePointAt(index2) === ext.codePointAt(extIndex--)) {
          if (extIndex < 0) {
            end2 = index2;
          }
        } else {
          extIndex = -1;
          end2 = firstNonSlashEnd;
        }
      }
    }
  }
  if (start2 === end2) {
    end2 = firstNonSlashEnd;
  } else if (end2 < 0) {
    end2 = path2.length;
  }
  return path2.slice(start2, end2);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end2 = -1;
  let index2 = path2.length;
  let unmatchedSlash;
  while (--index2) {
    if (path2.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end2 = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end2 < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end2 === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end2);
}
function extname(path2) {
  assertPath(path2);
  let index2 = path2.length;
  let end2 = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path2.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end2 < 0) {
      unmatchedSlash = true;
      end2 = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end2 < 0 || preDotState === 0 || preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end2);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize2(joined);
}
function normalize2(path2) {
  assertPath(path2);
  const absolute = path2.codePointAt(0) === 47;
  let value = normalizeString(path2, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path2.length) {
    if (index2 < path2.length) {
      code2 = path2.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index2);
        } else {
          result = path2.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// node_modules/vfile/lib/minproc.browser.js
var proc = { cwd };
function cwd() {
  return "/";
}

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && fileUrlOrPath.auth === void 0
  );
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path2.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = [
  "history",
  "path",
  "basename",
  "stem",
  "extname",
  "dirname"
];
var VFile = class {
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = proc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  get path() {
    return this.history[this.history.length - 1];
  }
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
};
function assertPart(part, name) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error("`" + name + "` cannot be empty");
  }
}
function assertPath2(path2, name) {
  if (!path2) {
    throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/unified/lib/callable-instance.js
var CallableInstance = function(property) {
  const self2 = this;
  const constr = self2.constructor;
  const proto = constr.prototype;
  const func = proto[property];
  const apply2 = function() {
    return func.apply(apply2, arguments);
  };
  Object.setPrototypeOf(apply2, proto);
  const names = Object.getOwnPropertyNames(func);
  for (const p6 of names) {
    const descriptor = Object.getOwnPropertyDescriptor(func, p6);
    if (descriptor)
      Object.defineProperty(apply2, p6, descriptor);
  }
  return apply2;
};

// node_modules/unified/lib/index.js
var own5 = {}.hasOwnProperty;
var Processor = class extends CallableInstance {
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  copy() {
    const destination = new Processor();
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own5.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = this;
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = self2.parse(realFile);
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = tree;
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(error, file2);
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      ok(
        typeof file !== "function",
        "`file` can\u2019t be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = outputTree || tree;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = value2;
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `parser`");
  }
}
function assertCompiler(name, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name + "` without `compiler`");
  }
}
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/react-markdown/lib/index.js
var own6 = {}.hasOwnProperty;
var changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var emptyPlugins = [];
var emptyRemarkRehypeOptions = { allowDangerousHtml: true };
var safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
var deprecations = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Markdown(options) {
  const allowedElements = options.allowedElements;
  const allowElement = options.allowElement;
  const children = options.children || "";
  const className = options.className;
  const components = options.components;
  const disallowedElements = options.disallowedElements;
  const rehypePlugins = options.rehypePlugins || emptyPlugins;
  const remarkPlugins = options.remarkPlugins || emptyPlugins;
  const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
  const skipHtml = options.skipHtml;
  const unwrapDisallowed = options.unwrapDisallowed;
  const urlTransform = options.urlTransform || defaultUrlTransform;
  const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
  const file = new VFile();
  if (typeof children === "string") {
    file.value = children;
  } else {
    unreachable(
      "Unexpected value `" + children + "` for `children` prop, expected `string`"
    );
  }
  if (allowedElements && disallowedElements) {
    unreachable(
      "Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other"
    );
  }
  for (const deprecation of deprecations) {
    if (Object.hasOwn(options, deprecation.from)) {
      unreachable(
        "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
      );
    }
  }
  const mdastTree = processor.parse(file);
  let hastTree = processor.runSync(mdastTree, file);
  if (className) {
    hastTree = {
      type: "element",
      tagName: "div",
      properties: { className },
      children: hastTree.type === "root" ? hastTree.children : [hastTree]
    };
  }
  visit(hastTree, transform);
  return toJsxRuntime(hastTree, {
    Fragment: import_jsx_runtime.Fragment,
    components,
    ignoreInvalidStyle: true,
    jsx: import_jsx_runtime.jsx,
    jsxs: import_jsx_runtime.jsxs,
    passKeys: true,
    passNode: true
  });
  function transform(node2, index2, parent) {
    if (node2.type === "raw" && parent && typeof index2 === "number") {
      if (skipHtml) {
        parent.children.splice(index2, 1);
      } else {
        parent.children[index2] = { type: "text", value: node2.value };
      }
      return index2;
    }
    if (node2.type === "element") {
      let key;
      for (key in urlAttributes) {
        if (own6.call(urlAttributes, key) && own6.call(node2.properties, key)) {
          const value = node2.properties[key];
          const test2 = urlAttributes[key];
          if (test2 === null || test2.includes(node2.tagName)) {
            node2.properties[key] = urlTransform(String(value || ""), key, node2);
          }
        }
      }
    }
    if (node2.type === "element") {
      let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
      if (!remove && allowElement && typeof index2 === "number") {
        remove = !allowElement(node2, index2, parent);
      }
      if (remove && parent && typeof index2 === "number") {
        if (unwrapDisallowed && node2.children) {
          parent.children.splice(index2, 1, ...node2.children);
        } else {
          parent.children.splice(index2, 1);
        }
        return index2;
      }
    }
  }
}
function defaultUrlTransform(value) {
  return sanitizeUri(value, safeProtocol);
}

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid2) {
  return typeof uuid2 === "string" && regex_default.test(uuid2);
}
var validate_default = validate;

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/parse.js
function parse3(uuid2) {
  if (!validate_default(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse3;

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i3 = 0; i3 < str.length; ++i3) {
    bytes.push(str.charCodeAt(i3));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset2) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (let i3 = 0; i3 < 16; ++i3) {
        buf[offset2 + i3] = bytes[i3];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i3 = 0; i3 < msg.length; ++i3) {
      bytes[i3] = msg.charCodeAt(i3);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i3 = 0; i3 < length32; i3 += 8) {
    const x6 = input[i3 >> 5] >>> i3 % 32 & 255;
    const hex2 = parseInt(hexTab.charAt(x6 >>> 4 & 15) + hexTab.charAt(x6 & 15), 16);
    output.push(hex2);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x6, len) {
  x6[len >> 5] |= 128 << len % 32;
  x6[getOutputLength(len) - 1] = len;
  let a2 = 1732584193;
  let b4 = -271733879;
  let c3 = -1732584194;
  let d4 = 271733878;
  for (let i3 = 0; i3 < x6.length; i3 += 16) {
    const olda = a2;
    const oldb = b4;
    const oldc = c3;
    const oldd = d4;
    a2 = md5ff(a2, b4, c3, d4, x6[i3], 7, -680876936);
    d4 = md5ff(d4, a2, b4, c3, x6[i3 + 1], 12, -389564586);
    c3 = md5ff(c3, d4, a2, b4, x6[i3 + 2], 17, 606105819);
    b4 = md5ff(b4, c3, d4, a2, x6[i3 + 3], 22, -1044525330);
    a2 = md5ff(a2, b4, c3, d4, x6[i3 + 4], 7, -176418897);
    d4 = md5ff(d4, a2, b4, c3, x6[i3 + 5], 12, 1200080426);
    c3 = md5ff(c3, d4, a2, b4, x6[i3 + 6], 17, -1473231341);
    b4 = md5ff(b4, c3, d4, a2, x6[i3 + 7], 22, -45705983);
    a2 = md5ff(a2, b4, c3, d4, x6[i3 + 8], 7, 1770035416);
    d4 = md5ff(d4, a2, b4, c3, x6[i3 + 9], 12, -1958414417);
    c3 = md5ff(c3, d4, a2, b4, x6[i3 + 10], 17, -42063);
    b4 = md5ff(b4, c3, d4, a2, x6[i3 + 11], 22, -1990404162);
    a2 = md5ff(a2, b4, c3, d4, x6[i3 + 12], 7, 1804603682);
    d4 = md5ff(d4, a2, b4, c3, x6[i3 + 13], 12, -40341101);
    c3 = md5ff(c3, d4, a2, b4, x6[i3 + 14], 17, -1502002290);
    b4 = md5ff(b4, c3, d4, a2, x6[i3 + 15], 22, 1236535329);
    a2 = md5gg(a2, b4, c3, d4, x6[i3 + 1], 5, -165796510);
    d4 = md5gg(d4, a2, b4, c3, x6[i3 + 6], 9, -1069501632);
    c3 = md5gg(c3, d4, a2, b4, x6[i3 + 11], 14, 643717713);
    b4 = md5gg(b4, c3, d4, a2, x6[i3], 20, -373897302);
    a2 = md5gg(a2, b4, c3, d4, x6[i3 + 5], 5, -701558691);
    d4 = md5gg(d4, a2, b4, c3, x6[i3 + 10], 9, 38016083);
    c3 = md5gg(c3, d4, a2, b4, x6[i3 + 15], 14, -660478335);
    b4 = md5gg(b4, c3, d4, a2, x6[i3 + 4], 20, -405537848);
    a2 = md5gg(a2, b4, c3, d4, x6[i3 + 9], 5, 568446438);
    d4 = md5gg(d4, a2, b4, c3, x6[i3 + 14], 9, -1019803690);
    c3 = md5gg(c3, d4, a2, b4, x6[i3 + 3], 14, -187363961);
    b4 = md5gg(b4, c3, d4, a2, x6[i3 + 8], 20, 1163531501);
    a2 = md5gg(a2, b4, c3, d4, x6[i3 + 13], 5, -1444681467);
    d4 = md5gg(d4, a2, b4, c3, x6[i3 + 2], 9, -51403784);
    c3 = md5gg(c3, d4, a2, b4, x6[i3 + 7], 14, 1735328473);
    b4 = md5gg(b4, c3, d4, a2, x6[i3 + 12], 20, -1926607734);
    a2 = md5hh(a2, b4, c3, d4, x6[i3 + 5], 4, -378558);
    d4 = md5hh(d4, a2, b4, c3, x6[i3 + 8], 11, -2022574463);
    c3 = md5hh(c3, d4, a2, b4, x6[i3 + 11], 16, 1839030562);
    b4 = md5hh(b4, c3, d4, a2, x6[i3 + 14], 23, -35309556);
    a2 = md5hh(a2, b4, c3, d4, x6[i3 + 1], 4, -1530992060);
    d4 = md5hh(d4, a2, b4, c3, x6[i3 + 4], 11, 1272893353);
    c3 = md5hh(c3, d4, a2, b4, x6[i3 + 7], 16, -155497632);
    b4 = md5hh(b4, c3, d4, a2, x6[i3 + 10], 23, -1094730640);
    a2 = md5hh(a2, b4, c3, d4, x6[i3 + 13], 4, 681279174);
    d4 = md5hh(d4, a2, b4, c3, x6[i3], 11, -358537222);
    c3 = md5hh(c3, d4, a2, b4, x6[i3 + 3], 16, -722521979);
    b4 = md5hh(b4, c3, d4, a2, x6[i3 + 6], 23, 76029189);
    a2 = md5hh(a2, b4, c3, d4, x6[i3 + 9], 4, -640364487);
    d4 = md5hh(d4, a2, b4, c3, x6[i3 + 12], 11, -421815835);
    c3 = md5hh(c3, d4, a2, b4, x6[i3 + 15], 16, 530742520);
    b4 = md5hh(b4, c3, d4, a2, x6[i3 + 2], 23, -995338651);
    a2 = md5ii(a2, b4, c3, d4, x6[i3], 6, -198630844);
    d4 = md5ii(d4, a2, b4, c3, x6[i3 + 7], 10, 1126891415);
    c3 = md5ii(c3, d4, a2, b4, x6[i3 + 14], 15, -1416354905);
    b4 = md5ii(b4, c3, d4, a2, x6[i3 + 5], 21, -57434055);
    a2 = md5ii(a2, b4, c3, d4, x6[i3 + 12], 6, 1700485571);
    d4 = md5ii(d4, a2, b4, c3, x6[i3 + 3], 10, -1894986606);
    c3 = md5ii(c3, d4, a2, b4, x6[i3 + 10], 15, -1051523);
    b4 = md5ii(b4, c3, d4, a2, x6[i3 + 1], 21, -2054922799);
    a2 = md5ii(a2, b4, c3, d4, x6[i3 + 8], 6, 1873313359);
    d4 = md5ii(d4, a2, b4, c3, x6[i3 + 15], 10, -30611744);
    c3 = md5ii(c3, d4, a2, b4, x6[i3 + 6], 15, -1560198380);
    b4 = md5ii(b4, c3, d4, a2, x6[i3 + 13], 21, 1309151649);
    a2 = md5ii(a2, b4, c3, d4, x6[i3 + 4], 6, -145523070);
    d4 = md5ii(d4, a2, b4, c3, x6[i3 + 11], 10, -1120210379);
    c3 = md5ii(c3, d4, a2, b4, x6[i3 + 2], 15, 718787259);
    b4 = md5ii(b4, c3, d4, a2, x6[i3 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b4 = safeAdd(b4, oldb);
    c3 = safeAdd(c3, oldc);
    d4 = safeAdd(d4, oldd);
  }
  return [a2, b4, c3, d4];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i3 = 0; i3 < length8; i3 += 8) {
    output[i3 >> 5] |= (input[i3 / 8] & 255) << i3 % 32;
  }
  return output;
}
function safeAdd(x6, y4) {
  const lsw = (x6 & 65535) + (y4 & 65535);
  const msw = (x6 >> 16) + (y4 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q4, a2, b4, x6, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q4), safeAdd(x6, t2)), s), b4);
}
function md5ff(a2, b4, c3, d4, x6, s, t2) {
  return md5cmn(b4 & c3 | ~b4 & d4, a2, b4, x6, s, t2);
}
function md5gg(a2, b4, c3, d4, x6, s, t2) {
  return md5cmn(b4 & d4 | c3 & ~d4, a2, b4, x6, s, t2);
}
function md5hh(a2, b4, c3, d4, x6, s, t2) {
  return md5cmn(b4 ^ c3 ^ d4, a2, b4, x6, s, t2);
}
function md5ii(a2, b4, c3, d4, x6, s, t2) {
  return md5cmn(c3 ^ (b4 | ~d4), a2, b4, x6, s, t2);
}
var md5_default = md5;

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i3 = 0; i3 < 16; ++i3) {
      buf[offset2 + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x6, y4, z3) {
  switch (s) {
    case 0:
      return x6 & y4 ^ ~x6 & z3;
    case 1:
      return x6 ^ y4 ^ z3;
    case 2:
      return x6 & y4 ^ x6 & z3 ^ y4 & z3;
    case 3:
      return x6 ^ y4 ^ z3;
  }
}
function ROTL(x6, n2) {
  return x6 << n2 | x6 >>> 32 - n2;
}
function sha1(bytes) {
  const K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H7 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i3 = 0; i3 < msg.length; ++i3) {
      bytes.push(msg.charCodeAt(i3));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l2 = bytes.length / 4 + 2;
  const N6 = Math.ceil(l2 / 16);
  const M5 = new Array(N6);
  for (let i3 = 0; i3 < N6; ++i3) {
    const arr = new Uint32Array(16);
    for (let j5 = 0; j5 < 16; ++j5) {
      arr[j5] = bytes[i3 * 64 + j5 * 4] << 24 | bytes[i3 * 64 + j5 * 4 + 1] << 16 | bytes[i3 * 64 + j5 * 4 + 2] << 8 | bytes[i3 * 64 + j5 * 4 + 3];
    }
    M5[i3] = arr;
  }
  M5[N6 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M5[N6 - 1][14] = Math.floor(M5[N6 - 1][14]);
  M5[N6 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i3 = 0; i3 < N6; ++i3) {
    const W7 = new Uint32Array(80);
    for (let t2 = 0; t2 < 16; ++t2) {
      W7[t2] = M5[i3][t2];
    }
    for (let t2 = 16; t2 < 80; ++t2) {
      W7[t2] = ROTL(W7[t2 - 3] ^ W7[t2 - 8] ^ W7[t2 - 14] ^ W7[t2 - 16], 1);
    }
    let a2 = H7[0];
    let b4 = H7[1];
    let c3 = H7[2];
    let d4 = H7[3];
    let e2 = H7[4];
    for (let t2 = 0; t2 < 80; ++t2) {
      const s = Math.floor(t2 / 20);
      const T3 = ROTL(a2, 5) + f(s, b4, c3, d4) + e2 + K3[s] + W7[t2] >>> 0;
      e2 = d4;
      d4 = c3;
      c3 = ROTL(b4, 30) >>> 0;
      b4 = a2;
      a2 = T3;
    }
    H7[0] = H7[0] + a2 >>> 0;
    H7[1] = H7[1] + b4 >>> 0;
    H7[2] = H7[2] + c3 >>> 0;
    H7[3] = H7[3] + d4 >>> 0;
    H7[4] = H7[4] + e2 >>> 0;
  }
  return [H7[0] >> 24 & 255, H7[0] >> 16 & 255, H7[0] >> 8 & 255, H7[0] & 255, H7[1] >> 24 & 255, H7[1] >> 16 & 255, H7[1] >> 8 & 255, H7[1] & 255, H7[2] >> 24 & 255, H7[2] >> 16 & 255, H7[2] >> 8 & 255, H7[2] & 255, H7[3] >> 24 & 255, H7[3] >> 16 & 255, H7[3] >> 8 & 255, H7[3] & 255, H7[4] >> 24 & 255, H7[4] >> 16 & 255, H7[4] >> 8 & 255, H7[4] & 255];
}
var sha1_default = sha1;

// node_modules/@daohaus/moloch-v3-fields/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@daohaus/moloch-v3-fields/node_modules/react-router-dom/dist/index.js
var React2 = __toESM(require_react());

// node_modules/@remix-run/router/dist/router.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var Action;
(function(Action3) {
  Action3["Pop"] = "POP";
  Action3["Push"] = "PUSH";
  Action3["Replace"] = "REPLACE";
})(Action || (Action = {}));
function createPath(_ref) {
  let {
    pathname = "/",
    search: search2 = "",
    hash: hash3 = ""
  } = _ref;
  if (search2 && search2 !== "?")
    pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
  if (hash3 && hash3 !== "#")
    pathname += hash3.charAt(0) === "#" ? hash3 : "#" + hash3;
  return pathname;
}
function parsePath(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path2.substr(hashIndex);
      path2 = path2.substr(0, hashIndex);
    }
    let searchIndex = path2.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path2.substr(searchIndex);
      path2 = path2.substr(0, searchIndex);
    }
    if (path2) {
      parsedPath.pathname = path2;
    }
  }
  return parsedPath;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path2, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_6, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path2.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end2 ? "\\/*$" : "(?:(?=[@.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename2) {
  if (basename2 === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename2.toLowerCase())) {
    return null;
  }
  let startIndex = basename2.endsWith("/") ? basename2.length - 1 : basename2.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search: search2 = "",
    hash: hash3 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search2),
    hash: normalizeHash(hash3)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to = typeof toArg === "string" ? parsePath(toArg) : _extends({}, toArg);
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path2 = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path2.pathname += "/";
  }
  return path2;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
var normalizeHash = (hash3) => !hash3 || hash3 === "#" ? "" : hash3.startsWith("#") ? hash3 : "#" + hash3;

// node_modules/@daohaus/moloch-v3-fields/node_modules/react-router/dist/index.js
var React = __toESM(require_react());
function isPolyfill(x6, y4) {
  return x6 === y4 && (x6 !== 0 || 1 / x6 === 1 / y4) || x6 !== x6 && y4 !== y4;
}
var is2 = typeof Object.is === "function" ? Object.is : isPolyfill;
var {
  useState: useState2,
  useEffect: useEffect2,
  useLayoutEffect: useLayoutEffect2,
  useDebugValue
} = React;
var didWarnOld18Alpha = false;
var didWarnUncachedGetSnapshot = false;
function useSyncExternalStore$2(subscribe, getSnapshot, getServerSnapshot) {
  if (true) {
    if (!didWarnOld18Alpha) {
      if ("startTransition" in React) {
        didWarnOld18Alpha = true;
        console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
      }
    }
  }
  const value = getSnapshot();
  if (true) {
    if (!didWarnUncachedGetSnapshot) {
      const cachedValue = getSnapshot();
      if (!is2(value, cachedValue)) {
        console.error("The result of getSnapshot should be cached to avoid an infinite loop");
        didWarnUncachedGetSnapshot = true;
      }
    }
  }
  const [{
    inst
  }, forceUpdate] = useState2({
    inst: {
      value,
      getSnapshot
    }
  });
  useLayoutEffect2(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe, value, getSnapshot]);
  useEffect2(() => {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe(handleStoreChange);
  }, [subscribe]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is2(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isServerEnvironment = !canUseDOM;
var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
var useSyncExternalStore = "useSyncExternalStore" in React ? ((module) => module.useSyncExternalStore)(React) : shim;
var DataStaticRouterContext = React.createContext(null);
if (true) {
  DataStaticRouterContext.displayName = "DataStaticRouterContext";
}
var DataRouterContext = React.createContext(null);
if (true) {
  DataRouterContext.displayName = "DataRouter";
}
var DataRouterStateContext = React.createContext(null);
if (true) {
  DataRouterStateContext.displayName = "DataRouterState";
}
var AwaitContext = React.createContext(null);
if (true) {
  AwaitContext.displayName = "Await";
}
var NavigationContext = React.createContext(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = React.createContext(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = React.createContext({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
var RouteErrorContext = React.createContext(null);
if (true) {
  RouteErrorContext.displayName = "RouteError";
}
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? true ? invariant(
    false,
    "useHref() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    basename: basename2,
    navigator: navigator2
  } = React.useContext(NavigationContext);
  let {
    hash: hash3,
    pathname,
    search: search2
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename2 !== "/") {
    joinedPathname = pathname === "/" ? basename2 : joinPaths([basename2, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search: search2,
    hash: hash3
  });
}
function useInRouterContext() {
  return React.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(
    false,
    "useLocation() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  return React.useContext(LocationContext).location;
}
function useMatch(pattern) {
  !useInRouterContext() ? true ? invariant(
    false,
    "useMatch() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    pathname
  } = useLocation();
  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || !match2.route.index && match2.pathnameBase !== matches[index2 - 1].pathnameBase);
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant(
    false,
    "useNavigate() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    basename: basename2,
    navigator: navigator2
  } = React.useContext(NavigationContext);
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = React.useRef(false);
  React.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = React.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (basename2 !== "/") {
      path2.pathname = path2.pathname === "/" ? basename2 : joinPaths([basename2, path2.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
  }, [basename2, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = React.createContext(null);
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseLoaderData"] = "useLoaderData";
  DataRouterHook2["UseActionData"] = "useActionData";
  DataRouterHook2["UseRouteError"] = "useRouteError";
  DataRouterHook2["UseNavigation"] = "useNavigation";
  DataRouterHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterHook2["UseMatches"] = "useMatches";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = {}));
function useDataRouterState(hookName) {
  let state = React.useContext(DataRouterStateContext);
  !state ? true ? invariant(false, hookName + " must be used within a DataRouterStateContext") : invariant(false) : void 0;
  return state;
}
function useNavigation() {
  let state = useDataRouterState(DataRouterHook.UseNavigation);
  return state.navigation;
}
function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterHook.UseMatches);
  return React.useMemo(() => matches.map((match2) => {
    let {
      pathname,
      params
    } = match2;
    return {
      id: match2.route.id,
      pathname,
      params,
      data: loaderData[match2.route.id],
      handle: match2.route.handle
    };
  }), [matches, loaderData]);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename2 = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React.useMemo(() => ({
    basename: basename2,
    navigator: navigator2,
    static: staticProp
  }), [basename2, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search: search2 = "",
    hash: hash3 = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = React.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename2);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search: search2,
      hash: hash3,
      state,
      key
    };
  }, [basename2, pathname, search2, hash3, state, key]);
  true ? warning(location != null, '<Router basename="' + basename2 + '"> is not able to match the URL ' + ('"' + pathname + search2 + hash3 + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location == null) {
    return null;
  }
  return React.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, React.createElement(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
var neverSettledPromise = new Promise(() => {
});

// node_modules/@daohaus/moloch-v3-fields/node_modules/react-router-dom/dist/index.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event);
}
function getFormSubmissionInfo(target, defaultAction, options) {
  let method;
  let action;
  let encType;
  let formData;
  if (isFormElement(target)) {
    let submissionTrigger = options.submissionTrigger;
    method = options.method || target.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("enctype") || defaultEncType;
    formData = new FormData(target);
    if (submissionTrigger && submissionTrigger.name) {
      formData.append(submissionTrigger.name, submissionTrigger.value);
    }
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    }
    method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
    formData = new FormData(form);
    if (target.name) {
      formData.append(target.name, target.value);
    }
  } else if (isHtmlElement(target)) {
    throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
  } else {
    method = options.method || defaultMethod;
    action = options.action || defaultAction;
    encType = options.encType || defaultEncType;
    if (target instanceof FormData) {
      formData = target;
    } else {
      formData = new FormData();
      if (target instanceof URLSearchParams) {
        for (let [name, value] of target) {
          formData.append(name, value);
        }
      } else if (target != null) {
        for (let name of Object.keys(target)) {
          formData.append(name, target[name]);
        }
      }
    }
  }
  let {
    protocol,
    host
  } = window.location;
  let url = new URL(action, protocol + "//" + host);
  return {
    url,
    method,
    encType,
    formData
  };
}
var _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
var _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative"];
function HistoryRouter(_ref3) {
  let {
    basename: basename2,
    children,
    history
  } = _ref3;
  const [state, setState] = React2.useState({
    action: history.action,
    location: history.location
  });
  React2.useLayoutEffect(() => history.listen(setState), [history]);
  return React2.createElement(Router, {
    basename: basename2,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
var Link = React2.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return React2.createElement("a", _extends2({}, rest, {
    href,
    onClick: reloadDocument ? onClick : handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = React2.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end: end2 = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let path2 = useResolvedPath(to);
  let match2 = useMatch({
    path: path2.pathname,
    end: end2,
    caseSensitive
  });
  let routerState = React2.useContext(DataRouterStateContext);
  let nextLocation = routerState == null ? void 0 : routerState.navigation.location;
  let nextPath = useResolvedPath(nextLocation || "");
  let nextMatch = React2.useMemo(() => nextLocation ? matchPath({
    path: path2.pathname,
    end: end2,
    caseSensitive
  }, nextPath.pathname) : null, [nextLocation, path2.pathname, caseSensitive, end2, nextPath.pathname]);
  let isPending = nextMatch != null;
  let isActive = match2 != null;
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return React2.createElement(Link, _extends2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
var Form = React2.forwardRef((props, ref) => {
  return React2.createElement(FormImpl, _extends2({}, props, {
    ref
  }));
});
if (true) {
  Form.displayName = "Form";
}
var FormImpl = React2.forwardRef((_ref6, forwardedRef) => {
  let {
    reloadDocument,
    replace: replace2,
    method = defaultMethod,
    action,
    onSubmit,
    fetcherKey,
    routeId,
    relative
  } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3);
  let submit = useSubmitImpl(fetcherKey, routeId);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, {
    relative
  });
  let submitHandler = (event) => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented)
      return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    submit(submitter || event.currentTarget, {
      method,
      replace: replace2,
      relative
    });
  };
  return React2.createElement("form", _extends2({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
if (true) {
  Form.displayName = "Form";
}
function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (true) {
  ScrollRestoration.displayName = "ScrollRestoration";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path2 = useResolvedPath(to, {
    relative
  });
  return React2.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path2, replaceProp, state, target, to, preventScrollReset, relative]);
}
function useSubmitImpl(fetcherKey, routeId) {
  let dataRouterContext = React2.useContext(DataRouterContext);
  !dataRouterContext ? true ? invariant(false, "useSubmitImpl must be used within a Data Router") : invariant(false) : void 0;
  let {
    router
  } = dataRouterContext;
  let defaultAction = useFormAction();
  return React2.useCallback(function(target, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    }
    let {
      method,
      encType,
      formData,
      url
    } = getFormSubmissionInfo(target, defaultAction, options);
    let href = url.pathname + url.search;
    let opts = {
      replace: options.replace,
      formData,
      formMethod: method,
      formEncType: encType
    };
    if (fetcherKey) {
      !(routeId != null) ? true ? invariant(false, "No routeId available for useFetcher()") : invariant(false) : void 0;
      router.fetch(fetcherKey, routeId, href, opts);
    } else {
      router.navigate(href, opts);
    }
  }, [defaultAction, router, fetcherKey, routeId]);
}
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let routeContext = React2.useContext(RouteContext);
  !routeContext ? true ? invariant(false, "useFormAction must be used inside a RouteContext") : invariant(false) : void 0;
  let [match2] = routeContext.matches.slice(-1);
  let resolvedAction = action != null ? action : ".";
  let path2 = useResolvedPath(resolvedAction, {
    relative
  });
  let location = useLocation();
  if (action == null) {
    path2.search = location.search;
    path2.hash = location.hash;
    if (match2.route.index) {
      let params = new URLSearchParams(path2.search);
      params.delete("index");
      path2.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match2.route.index) {
    path2.search = path2.search ? path2.search.replace(/^\?/, "?index&") : "?index";
  }
  return createPath(path2);
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3;
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  let dataRouterContext = React2.useContext(DataRouterContext);
  !dataRouterContext ? true ? invariant(false, "useScrollRestoration must be used within a DataRouterContext") : invariant(false) : void 0;
  let {
    router
  } = dataRouterContext;
  let state = React2.useContext(DataRouterStateContext);
  !(router != null && state != null) ? true ? invariant(false, "useScrollRestoration must be used within a DataRouterStateContext") : invariant(false) : void 0;
  let {
    restoreScrollPosition,
    preventScrollReset
  } = state;
  React2.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  useBeforeUnload(React2.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches]));
  React2.useLayoutEffect(() => {
    try {
      let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
      if (sessionPositions) {
        savedScrollPositions = JSON.parse(sessionPositions);
      }
    } catch (e2) {
    }
  }, [storageKey]);
  React2.useLayoutEffect(() => {
    let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
    return () => disableScrollRestoration && disableScrollRestoration();
  }, [router, getKey]);
  React2.useLayoutEffect(() => {
    if (restoreScrollPosition === false) {
      return;
    }
    if (typeof restoreScrollPosition === "number") {
      window.scrollTo(0, restoreScrollPosition);
      return;
    }
    if (location.hash) {
      let el = document.getElementById(location.hash.slice(1));
      if (el) {
        el.scrollIntoView();
        return;
      }
    }
    if (preventScrollReset === true) {
      return;
    }
    window.scrollTo(0, 0);
  }, [location, restoreScrollPosition, preventScrollReset]);
}
function useBeforeUnload(callback) {
  React2.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}

// node_modules/react-icons/ri/index.esm.js
var import_lib20 = __toESM(require_cjs());
function RiArrowDropDownFill(props) {
  return (0, import_lib20.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 14L8 10H16L12 14Z" } }] })(props);
}
function RiCalendar2Fill(props) {
  return (0, import_lib20.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M17 3H21C21.5523 3 22 3.44772 22 4V20C22 20.5523 21.5523 21 21 21H3C2.44772 21 2 20.5523 2 20V4C2 3.44772 2.44772 3 3 3H7V1H9V3H15V1H17V3ZM4 9V19H20V9H4ZM6 11H8V13H6V11ZM11 11H13V13H11V11ZM16 11H18V13H16V11Z" } }] })(props);
}
function RiAddCircleLine(props) {
  return (0, import_lib20.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M11 11V7H13V11H17V13H13V17H11V13H7V11H11ZM12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20Z" } }] })(props);
}
function RiErrorWarningLine(props) {
  return (0, import_lib20.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" } }] })(props);
}

// node_modules/@daohaus/moloch-v3-fields/index.js
init_tx_builder();
init_esm();
var import_abis = __toESM(require_src());

// node_modules/react-icons/fa/index.esm.js
var import_lib21 = __toESM(require_cjs());
function FaQrcode(props) {
  return (0, import_lib21.GenIcon)({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M0 224h192V32H0v192zM64 96h64v64H64V96zm192-64v192h192V32H256zm128 128h-64V96h64v64zM0 480h192V288H0v192zm64-128h64v64H64v-64zm352-64h32v128h-96v-32h-32v96h-64V288h96v32h64v-32zm0 160h32v32h-32v-32zm-64 0h32v32h-32v-32z" } }] })(props);
}

// node_modules/@daohaus/moloch-v3-fields/index.js
var import_utils13 = __toESM(require_utils());

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
var windowMetadata = __toESM(require_cjs9());
var windowGetters = __toESM(require_cjs10());

// node_modules/@walletconnect/browser-utils/node_modules/detect-browser/es/index.js
var __spreadArrays = function() {
  for (var s = 0, i3 = 0, il = arguments.length; i3 < il; i3++)
    s += arguments[i3].length;
  for (var r2 = Array(s), k4 = 0, i3 = 0; i3 < il; i3++)
    for (var a2 = arguments[i3], j5 = 0, jl = a2.length; j5 < jl; j5++, k4++)
      r2[k4] = a2[j5];
  return r2;
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version2, os3) {
    this.name = name;
    this.version = version2;
    this.os = os3;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version2) {
    this.version = version2;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version2, os3, bot) {
    this.name = name;
    this.version = version2;
    this.os = os3;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FBAV\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect2(userAgent2) {
  if (!!userAgent2) {
    return parseUserAgent(userAgent2);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os3 = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os3, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os3);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os3 = _a[0], regex = _a[1];
    var match2 = regex.exec(ua);
    if (match2) {
      return os3;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent2) {
  return detect2(userAgent2);
}
function detectOS2() {
  const env4 = detectEnv();
  return env4 && env4.os ? env4.os : void 0;
}
function isAndroid() {
  const os3 = detectOS2();
  return os3 ? os3.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os3 = detectOS2();
  return os3 ? os3.toLowerCase().includes("ios") || os3.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os3 = detectOS2();
  return os3 ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env4 = detectEnv();
  const result = env4 && env4.name ? env4.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
var getNavigator2 = windowGetters.getNavigator;
var getLocation2 = windowGetters.getLocation;
var getLocalStorage2 = windowGetters.getLocalStorage;
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}

// node_modules/@walletconnect/browser-utils/node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse2(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify2(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse3 = safeJsonParse2;
var safeJsonStringify3 = safeJsonStringify2;

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key, data2) {
  const raw = safeJsonStringify3(data2);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data2 = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key);
  }
  data2 = raw ? safeJsonParse3(raw) : raw;
  return data2;
}
function removeLocal(key) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key);
  }
}

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
var mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/constants.js
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/encoding.js
var import_bn = __toESM(require_bn());

// node_modules/@walletconnect/encoding/dist/esm/index.js
var import_is_typedarray = __toESM(require_is_typedarray());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var ENC_HEX = "hex";
var ENC_UTF8 = "utf8";
var STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex2 = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex2) : hex2;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex2) {
  return Buffer.from(removeHexPrefix(hex2), ENC_HEX);
}
function hexToArray(hex2) {
  return bufferToArray(hexToBuffer(hex2));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function removeHexPrefix(hex2) {
  return hex2.replace(/^0x/, "");
}
function addHexPrefix(hex2) {
  return hex2.startsWith("0x") ? hex2 : `0x${hex2}`;
}
function sanitizeHex(hex2) {
  hex2 = removeHexPrefix(hex2);
  hex2 = sanitizeBytes(hex2, 2);
  if (hex2) {
    hex2 = addHexPrefix(hex2);
  }
  return hex2;
}
function removeHexLeadingZeros(hex2) {
  const prefixed = hex2.startsWith("0x");
  hex2 = removeHexPrefix(hex2);
  hex2 = hex2.startsWith(STRING_ZERO) ? hex2.substring(1) : hex2;
  return prefixed ? addHexPrefix(hex2) : hex2;
}
function padString(str, length, left2, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad = padding.repeat(diff);
    result = left2 ? pad + str : str + pad;
  }
  return result;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/encoding.js
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex2) {
  return hexToArray(hex2).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex2 = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex2 : addHexPrefix(hex2);
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/ethereum.js
var import_js_sha3 = __toESM(require_sha3());

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex2) {
  return sanitizeHex(hex2);
}
function removeHexLeadingZeros2(hex2) {
  return removeHexLeadingZeros(addHexPrefix(hex2));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a2, b4) => {
    for (b4 = a2 = ""; a2++ < 36; b4 += a2 * 51 & 52 ? (a2 ^ 15 ? 8 ^ Math.random() * (a2 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b4;
  })();
  return result;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/validators.js
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash3 = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i3 = 0; i3 < address.length; i3++) {
    if (parseInt(hash3[i3], 16) > 7) {
      checksum += address[i3].toUpperCase();
    } else {
      checksum += address[i3];
    }
  }
  return addHexPrefix(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/payload.js
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code2 = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code2 = -32700;
        break;
      case "Invalid request":
        code2 = -32600;
        break;
      case "Method not found":
        code2 = -32601;
        break;
      case "Invalid params":
        code2 = -32602;
        break;
      case "Internal error":
        code2 = -32603;
        break;
      default:
        code2 = -32e3;
        break;
    }
  }
  const result = {
    code: code2,
    message
  };
  if (error.data) {
    result.data = error.data;
  }
  return result;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/url.js
var queryStringUtils = __toESM(require_query_string());
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path2 = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path3) {
    const separator = "@";
    const values4 = path3.split(separator);
    const requiredParams2 = {
      handshakeTopic: values4[0],
      version: parseInt(values4[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path2);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/encoding.js
var import_bn2 = __toESM(require_bn2());

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/ethereum.js
var import_js_sha32 = __toESM(require_sha3());

// node_modules/@walletconnect/socket-transport/node_modules/@walletconnect/utils/dist/esm/url.js
var queryStringUtils2 = __toESM(require_query_string2());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString2(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString2(queryString) {
  return queryStringUtils2.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils2.stringify(queryParams);
}

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS = typeof globalThis.WebSocket !== "undefined" ? globalThis.WebSocket : require_browser3();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e2) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e2));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue = this._queue;
    queue.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version2) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version: version2,
    env: "browser",
    host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version: version2,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default3 = SocketTransport;

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/errors.js
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/events.js
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x6) => x6.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default = EventManager;

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/storage.js
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json2 = getLocal(this.storageId);
    if (json2 && isWalletConnectSession(json2)) {
      session = json2;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/url.js
var domain = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/client/node_modules/@walletconnect/core/dist/esm/index.js
var Connector = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default3({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key = convertHexToArrayBuffer(value);
    this._key = key;
  }
  get key() {
    if (this._key) {
      const key = convertArrayBufferToHex(this._key, true);
      return key;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId2() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id2, callback) {
    this.on(`response:${id2}`, callback);
  }
  _subscribeToSessionResponse(id2, errorMsg) {
    this._subscribeToResponse(id2, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id2) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id2, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(payload.error);
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version2 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version2}?bridge=${bridge}&key=${key}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key = result.key;
      return { handshakeTopic, bridge, key };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data2) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.encrypt(data2, key);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.decrypt(payload, key);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json2 = await response.json();
        if (!json2.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default4 = Connector;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert2,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
var env2 = __toESM(require_cjs7());
function randomBytes(length) {
  const browserCrypto = env2.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
var env3 = __toESM(require_cjs7());

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0 = 0;
var LENGTH_1 = 1;
var LENGTH_16 = 16;
var LENGTH_32 = 32;
var LENGTH_64 = 64;
var LENGTH_128 = 128;
var LENGTH_256 = 256;
var LENGTH_512 = 512;
var LENGTH_1024 = 1024;

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH = LENGTH_256;
var HMAC_LENGTH = LENGTH_256;
var AES_BROWSER_ALGO = "AES-CBC";
var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
var HMAC_BROWSER = "HMAC";
var SHA256_BROWSER_ALGO = "SHA-256";
var SHA512_BROWSER_ALGO = "SHA-512";
var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
var SHA256_NODE_ALGO = "sha256";
var SHA512_NODE_ALGO = "sha512";
var RIPEMD160_NODE_ALGO = "ripemd160";
var PREFIX_LENGTH = LENGTH_1;
var KEY_LENGTH = LENGTH_32;
var IV_LENGTH = LENGTH_16;
var MAC_LENGTH = LENGTH_32;

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC = "hex";
var UTF8_ENC = "utf8";

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC = "Bad MAC";

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP = "encrypt";
var DECRYPT_OP = "decrypt";
var SIGN_OP = "sign";
var VERIFY_OP = "verify";

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
  return env3.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key, data2) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data2);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data2) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data2);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data2) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data2);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key, data2) {
  const subtle = env3.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data2);
  return new Uint8Array(signature);
}
async function browserSha256(data2) {
  const subtle = env3.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data2);
  return new Uint8Array(result);
}
async function browserSha512(data2) {
  const subtle = env3.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data2);
  return new Uint8Array(result);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key, data2) {
  return browserAesEncrypt(iv, key, data2);
}
function aesCbcDecrypt(iv, key, data2) {
  return browserAesDecrypt(iv, key, data2);
}

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert2,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports = {};
__reExport(env_exports, __toESM(require_cjs7()));

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
__reExport(helpers_exports, env_exports);

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING = [
  [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
  [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
  [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
  [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
  [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
  [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
  [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
  [9, 9, 9, 9, 9, 9, 9, 9, 9],
  [8, 8, 8, 8, 8, 8, 8, 8],
  [7, 7, 7, 7, 7, 7, 7],
  [6, 6, 6, 6, 6, 6],
  [5, 5, 5, 5, 5],
  [4, 4, 4, 4],
  [3, 3, 3],
  [2, 2],
  [1]
];
var pkcs7 = {
  pad(plaintext) {
    const padding = PADDING[plaintext.byteLength % 16 || 0];
    const result = new Uint8Array(plaintext.byteLength + padding.length);
    result.set(plaintext);
    result.set(padding, plaintext.byteLength);
    return result;
  },
  unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
};

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i3 = 0; i3 < arr1.length; i3++) {
    res |= arr1[i3] ^ arr2[i3];
  }
  return res === 0;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key, msg) {
  const result = await browserHmacSha512Sign(key, msg);
  return result;
}
async function hmacSha512Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha256(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha512(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd160(msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
__reExport(browser_exports, helpers_exports);

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/encoding.js
var import_bn3 = __toESM(require_bn3());
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/ethereum.js
var import_js_sha33 = __toESM(require_sha3());

// node_modules/@walletconnect/iso-crypto/node_modules/@walletconnect/utils/dist/esm/url.js
var queryStringUtils3 = __toESM(require_query_string3());

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data2, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data2);
  const content3 = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content3);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data2;
  try {
    data2 = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data2;
}

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default4 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports4,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default5 = WalletConnect;

// node_modules/@walletconnect/core/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_keyvaluestorage = __toESM(require_browser());
var import_heartbeat = __toESM(require_cjs5());
var import_logger = __toESM(require_cjs6());

// node_modules/@walletconnect/core/node_modules/@walletconnect/types/dist/index.es.js
init_esm3();
var import_events3 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s) {
    super(), this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var h = class extends IEvents {
  constructor(s, t2) {
    super(), this.core = s, this.logger = t2, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s, t2) {
    this.logger = s, this.core = t2;
  }
};
var u = class extends IEvents {
  constructor(s, t2) {
    super(), this.relayer = s, this.logger = t2;
  }
};
var g = class extends IEvents {
  constructor(s) {
    super();
  }
};
var p = class {
  constructor(s, t2, o2, w6) {
    this.core = s, this.logger = t2, this.name = o2;
  }
};
var d = class extends IEvents {
  constructor(s, t2) {
    super(), this.relayer = s, this.logger = t2;
  }
};
var E = class extends IEvents {
  constructor(s, t2) {
    super(), this.core = s, this.logger = t2;
  }
};
var y = class {
  constructor(s, t2) {
    this.projectId = s, this.logger = t2;
  }
};

// node_modules/@walletconnect/core/node_modules/@walletconnect/utils/dist/index.es.js
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var fe = __toESM(require_x25519());
var import_time = __toESM(require_cjs2());
var import_window_getters = __toESM(require_cjs3());
var import_window_metadata = __toESM(require_cjs4());
var k = __toESM(require_query_string4());
var J = "base10";
var p2 = "base16";
var L = "base64pad";
var x = "utf8";
var Q = 0;
var _ = 1;
var $n = 0;
var Ie = 1;
var Z = 12;
var X = 32;
function jn() {
  const e2 = fe.generateKeyPair();
  return { privateKey: toString(e2.secretKey, p2), publicKey: toString(e2.publicKey, p2) };
}
function Dn() {
  const e2 = (0, import_random.randomBytes)(X);
  return toString(e2, p2);
}
function kn(e2, n2) {
  const t2 = fe.sharedKey(fromString(e2, p2), fromString(n2, p2)), r2 = new import_hkdf.HKDF(import_sha256.SHA256, t2).expand(X);
  return toString(r2, p2);
}
function Vn(e2) {
  const n2 = (0, import_sha256.hash)(fromString(e2, p2));
  return toString(n2, p2);
}
function Mn(e2) {
  const n2 = (0, import_sha256.hash)(fromString(e2, x));
  return toString(n2, p2);
}
function Pe(e2) {
  return fromString(`${e2}`, J);
}
function $(e2) {
  return Number(toString(e2, J));
}
function Kn(e2) {
  const n2 = Pe(typeof e2.type < "u" ? e2.type : Q);
  if ($(n2) === _ && typeof e2.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t2 = typeof e2.senderPublicKey < "u" ? fromString(e2.senderPublicKey, p2) : void 0, r2 = typeof e2.iv < "u" ? fromString(e2.iv, p2) : (0, import_random.randomBytes)(Z), o2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p2)).seal(r2, fromString(e2.message, x));
  return Te({ type: n2, sealed: o2, iv: r2, senderPublicKey: t2 });
}
function Ln(e2) {
  const n2 = new import_chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p2)), { sealed: t2, iv: r2 } = ee(e2.encoded), o2 = n2.open(r2, t2);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, x);
}
function Te(e2) {
  if ($(e2.type) === _) {
    if (typeof e2.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e2.type, e2.senderPublicKey, e2.iv, e2.sealed]), L);
  }
  return toString(concat([e2.type, e2.iv, e2.sealed]), L);
}
function ee(e2) {
  const n2 = fromString(e2, L), t2 = n2.slice($n, Ie), r2 = Ie;
  if ($(t2) === _) {
    const l2 = r2 + X, d4 = l2 + Z, c3 = n2.slice(r2, l2), u3 = n2.slice(l2, d4), a2 = n2.slice(d4);
    return { type: t2, sealed: a2, iv: u3, senderPublicKey: c3 };
  }
  const o2 = r2 + Z, s = n2.slice(r2, o2), i3 = n2.slice(o2);
  return { type: t2, sealed: i3, iv: s };
}
function xn(e2, n2) {
  const t2 = ee(e2);
  return Re({ type: $(t2.type), senderPublicKey: typeof t2.senderPublicKey < "u" ? toString(t2.senderPublicKey, p2) : void 0, receiverPublicKey: n2?.receiverPublicKey });
}
function Re(e2) {
  const n2 = e2?.type || Q;
  if (n2 === _) {
    if (typeof e2?.senderPublicKey > "u")
      throw new Error("missing sender public key");
    if (typeof e2?.receiverPublicKey > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e2?.senderPublicKey, receiverPublicKey: e2?.receiverPublicKey };
}
function Fn(e2) {
  return e2.type === _ && typeof e2.senderPublicKey == "string" && typeof e2.receiverPublicKey == "string";
}
var Hn = Object.defineProperty;
var Ae = Object.getOwnPropertySymbols;
var qn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var Ue = (e2, n2, t2) => n2 in e2 ? Hn(e2, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n2] = t2;
var _e = (e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    qn.call(n2, t2) && Ue(e2, t2, n2[t2]);
  if (Ae)
    for (var t2 of Ae(n2))
      Bn.call(n2, t2) && Ue(e2, t2, n2[t2]);
  return e2;
};
var Ce = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var je = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function H() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce;
}
function q() {
  return !te() && !!(0, import_window_getters.getNavigator)();
}
function R() {
  return H() ? m.reactNative : te() ? m.node : q() ? m.browser : m.unknown;
}
function De(e2, n2) {
  let t2 = k.parse(e2);
  return t2 = _e(_e({}, t2), n2), e2 = k.stringify(t2), e2;
}
function ke() {
  if (R() === m.reactNative && typeof globalThis < "u" && typeof (globalThis == null ? void 0 : globalThis.Platform) < "u") {
    const { OS: t2, Version: r2 } = globalThis.Platform;
    return [t2, r2].join("-");
  }
  const e2 = detect();
  if (e2 === null)
    return "unknown";
  const n2 = e2.os ? e2.os.replace(" ", "").toLowerCase() : "unknown";
  return e2.type === "browser" ? [n2, e2.name, e2.version].join("-") : [n2, e2.version].join("-");
}
function Ve() {
  var e2;
  const n2 = R();
  return n2 === m.browser ? [n2, ((e2 = (0, import_window_getters.getLocation)()) == null ? void 0 : e2.host) || "unknown"].join(":") : n2;
}
function Me(e2, n2, t2) {
  const r2 = ke(), o2 = Ve();
  return [[e2, n2].join("-"), [je, t2].join("-"), r2, o2].join("/");
}
function Jn({ protocol: e2, version: n2, relayUrl: t2, sdkVersion: r2, auth: o2, projectId: s, useOnCloseEvent: i3 }) {
  const l2 = t2.split("?"), d4 = Me(e2, n2, r2), c3 = { auth: o2, ua: d4, projectId: s, useOnCloseEvent: i3 || void 0 }, u3 = De(l2[1] || "", c3);
  return l2[0] + "?" + u3;
}
function et(e2) {
  return Object.fromEntries(e2.entries());
}
function nt(e2) {
  return new Map(Object.entries(e2));
}
function st2(e2 = import_time.FIVE_MINUTES, n2) {
  const t2 = (0, import_time.toMiliseconds)(e2 || import_time.FIVE_MINUTES);
  let r2, o2, s;
  return { resolve: (i3) => {
    s && r2 && (clearTimeout(s), r2(i3));
  }, reject: (i3) => {
    s && o2 && (clearTimeout(s), o2(i3));
  }, done: () => new Promise((i3, l2) => {
    s = setTimeout(() => {
      l2(new Error(n2));
    }, t2), r2 = i3, o2 = l2;
  }) };
}
function it(e2, n2, t2) {
  return new Promise(async (r2, o2) => {
    const s = setTimeout(() => o2(new Error(t2)), n2);
    try {
      const i3 = await e2;
      r2(i3);
    } catch (i3) {
      o2(i3);
    }
    clearTimeout(s);
  });
}
function re2(e2, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e2}:`))
    return n2;
  if (e2.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e2.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e2}`);
}
function ct(e2) {
  return re2("topic", e2);
}
function at2(e2) {
  return re2("id", e2);
}
function ut(e2) {
  const [n2, t2] = e2.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n2 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t2}`);
  return r2;
}
function lt(e2, n2) {
  return (0, import_time.fromMiliseconds)((n2 || Date.now()) + (0, import_time.toMiliseconds)(e2));
}
function dt(e2) {
  return Date.now() >= (0, import_time.toMiliseconds)(e2);
}
function ft(e2, n2) {
  return `${e2}${n2 ? `:${n2}` : ""}`;
}
var Fe = "irn";
function mt(e2) {
  return e2?.relay || { protocol: Fe };
}
function yt(e2) {
  const n2 = RELAY_JSONRPC[e2];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e2}`);
  return n2;
}
var ht = Object.defineProperty;
var He = Object.getOwnPropertySymbols;
var vt = Object.prototype.hasOwnProperty;
var gt = Object.prototype.propertyIsEnumerable;
var qe = (e2, n2, t2) => n2 in e2 ? ht(e2, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n2] = t2;
var Et = (e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    vt.call(n2, t2) && qe(e2, t2, n2[t2]);
  if (He)
    for (var t2 of He(n2))
      gt.call(n2, t2) && qe(e2, t2, n2[t2]);
  return e2;
};
function Be(e2, n2 = "-") {
  const t2 = {}, r2 = "relay" + n2;
  return Object.keys(e2).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s = o2.replace(r2, ""), i3 = e2[o2];
      t2[s] = i3;
    }
  }), t2;
}
function bt(e2) {
  const n2 = e2.indexOf(":"), t2 = e2.indexOf("?") !== -1 ? e2.indexOf("?") : void 0, r2 = e2.substring(0, n2), o2 = e2.substring(n2 + 1, t2).split("@"), s = typeof t2 < "u" ? e2.substring(t2) : "", i3 = k.parse(s);
  return { protocol: r2, topic: Ge(o2[0]), version: parseInt(o2[1], 10), symKey: i3.symKey, relay: Be(i3) };
}
function Ge(e2) {
  return e2.startsWith("//") ? e2.substring(2) : e2;
}
function We(e2, n2 = "-") {
  const t2 = "relay", r2 = {};
  return Object.keys(e2).forEach((o2) => {
    const s = t2 + n2 + o2;
    e2[o2] && (r2[s] = e2[o2]);
  }), r2;
}
function Nt(e2) {
  return `${e2.protocol}:${e2.topic}@${e2.version}?` + k.stringify(Et({ symKey: e2.symKey }, We(e2.relay)));
}
var _t = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Ct = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e2, n2) {
  const { message: t2, code: r2 } = Ct[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function U(e2, n2) {
  const { message: t2, code: r2 } = _t[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function j(e2, n2) {
  return Array.isArray(e2) ? typeof n2 < "u" && e2.length ? e2.every(n2) : true : false;
}
function w(e2) {
  return typeof e2 > "u";
}
function h2(e2, n2) {
  return n2 && w(e2) ? true : typeof e2 == "string" && !!e2.trim().length;
}
function jt(e2) {
  if (h2(e2, false))
    try {
      return typeof new URL(e2) < "u";
    } catch {
      return false;
    }
  return false;
}
function Dt(e2) {
  var n2;
  return (n2 = e2?.proposer) == null ? void 0 : n2.publicKey;
}
function kt(e2) {
  return e2?.topic;
}
function xt(e2) {
  return typeof e2 < "u" && typeof e2 !== null;
}
function Zt() {
  const e2 = R();
  return new Promise((n2) => {
    switch (e2) {
      case m.browser:
        n2(dn());
        break;
      case m.reactNative:
        n2(fn());
        break;
      case m.node:
        n2(pn());
        break;
      default:
        n2(true);
    }
  });
}
function dn() {
  return q() && navigator?.onLine;
}
async function fn() {
  if (H() && typeof globalThis < "u" && globalThis != null && globalThis.NetInfo) {
    const e2 = await (globalThis == null ? void 0 : globalThis.NetInfo.fetch());
    return e2?.isConnected;
  }
  return true;
}
function pn() {
  return true;
}
function Xt(e2) {
  switch (R()) {
    case m.browser:
      mn(e2);
      break;
    case m.reactNative:
      yn(e2);
      break;
    case m.node:
      break;
  }
}
function mn(e2) {
  q() && (window.addEventListener("online", () => e2(true)), window.addEventListener("offline", () => e2(false)));
}
function yn(e2) {
  H() && typeof globalThis < "u" && globalThis != null && globalThis.NetInfo && globalThis?.NetInfo.addEventListener((n2) => e2(n2?.isConnected));
}

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs2());
var import_lodash = __toESM(require_lodash());
function ki(r2, e2) {
  if (r2.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t2 = new Uint8Array(256), i3 = 0; i3 < t2.length; i3++)
    t2[i3] = 255;
  for (var s = 0; s < r2.length; s++) {
    var n2 = r2.charAt(s), a2 = n2.charCodeAt(0);
    if (t2[a2] !== 255)
      throw new TypeError(n2 + " is ambiguous");
    t2[a2] = s;
  }
  var o2 = r2.length, h5 = r2.charAt(0), l2 = Math.log(o2) / Math.log(256), d4 = Math.log(256) / Math.log(o2);
  function p6(c3) {
    if (c3 instanceof Uint8Array || (ArrayBuffer.isView(c3) ? c3 = new Uint8Array(c3.buffer, c3.byteOffset, c3.byteLength) : Array.isArray(c3) && (c3 = Uint8Array.from(c3))), !(c3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c3.length === 0)
      return "";
    for (var b4 = 0, z3 = 0, v = 0, _6 = c3.length; v !== _6 && c3[v] === 0; )
      v++, b4++;
    for (var T3 = (_6 - v) * d4 + 1 >>> 0, m4 = new Uint8Array(T3); v !== _6; ) {
      for (var S4 = c3[v], A2 = 0, I2 = T3 - 1; (S4 !== 0 || A2 < z3) && I2 !== -1; I2--, A2++)
        S4 += 256 * m4[I2] >>> 0, m4[I2] = S4 % o2 >>> 0, S4 = S4 / o2 >>> 0;
      if (S4 !== 0)
        throw new Error("Non-zero carry");
      z3 = A2, v++;
    }
    for (var O5 = T3 - z3; O5 !== T3 && m4[O5] === 0; )
      O5++;
    for (var V2 = h5.repeat(b4); O5 < T3; ++O5)
      V2 += r2.charAt(m4[O5]);
    return V2;
  }
  function y4(c3) {
    if (typeof c3 != "string")
      throw new TypeError("Expected String");
    if (c3.length === 0)
      return new Uint8Array();
    var b4 = 0;
    if (c3[b4] !== " ") {
      for (var z3 = 0, v = 0; c3[b4] === h5; )
        z3++, b4++;
      for (var _6 = (c3.length - b4) * l2 + 1 >>> 0, T3 = new Uint8Array(_6); c3[b4]; ) {
        var m4 = t2[c3.charCodeAt(b4)];
        if (m4 === 255)
          return;
        for (var S4 = 0, A2 = _6 - 1; (m4 !== 0 || S4 < v) && A2 !== -1; A2--, S4++)
          m4 += o2 * T3[A2] >>> 0, T3[A2] = m4 % 256 >>> 0, m4 = m4 / 256 >>> 0;
        if (m4 !== 0)
          throw new Error("Non-zero carry");
        v = S4, b4++;
      }
      if (c3[b4] !== " ") {
        for (var I2 = _6 - v; I2 !== _6 && T3[I2] === 0; )
          I2++;
        for (var O5 = new Uint8Array(z3 + (_6 - I2)), V2 = z3; I2 !== _6; )
          O5[V2++] = T3[I2++];
        return O5;
      }
    }
  }
  function $4(c3) {
    var b4 = y4(c3);
    if (b4)
      return b4;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: p6, decodeUnsafe: y4, decode: $4 };
}
var Ki = ki;
var Bi = Ki;
var Ae2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array")
    return r2;
  if (r2 instanceof ArrayBuffer)
    return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2))
    return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Vi = (r2) => new TextEncoder().encode(r2);
var qi = (r2) => new TextDecoder().decode(r2);
var ji = class {
  constructor(e2, t2, i3) {
    this.name = e2, this.prefix = t2, this.baseEncode = i3;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Yi = class {
  constructor(e2, t2, i3) {
    if (this.name = e2, this.prefix = t2, t2.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t2.codePointAt(0), this.baseDecode = i3;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return ze(this, e2);
  }
};
var Gi = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return ze(this, e2);
  }
  decode(e2) {
    const t2 = e2[0], i3 = this.decoders[t2];
    if (i3)
      return i3.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ze = (r2, e2) => new Gi({ ...r2.decoders || { [r2.prefix]: r2 }, ...e2.decoders || { [e2.prefix]: e2 } });
var Hi = class {
  constructor(e2, t2, i3, s) {
    this.name = e2, this.prefix = t2, this.baseEncode = i3, this.baseDecode = s, this.encoder = new ji(e2, t2, i3), this.decoder = new Yi(e2, t2, s);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var J2 = ({ name: r2, prefix: e2, encode: t2, decode: i3 }) => new Hi(r2, e2, t2, i3);
var K = ({ prefix: r2, name: e2, alphabet: t2 }) => {
  const { encode: i3, decode: s } = Bi(t2, e2);
  return J2({ prefix: r2, name: e2, encode: i3, decode: (n2) => Ae2(s(n2)) });
};
var Ji = (r2, e2, t2, i3) => {
  const s = {};
  for (let d4 = 0; d4 < e2.length; ++d4)
    s[e2[d4]] = d4;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; )
    --n2;
  const a2 = new Uint8Array(n2 * t2 / 8 | 0);
  let o2 = 0, h5 = 0, l2 = 0;
  for (let d4 = 0; d4 < n2; ++d4) {
    const p6 = s[r2[d4]];
    if (p6 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    h5 = h5 << t2 | p6, o2 += t2, o2 >= 8 && (o2 -= 8, a2[l2++] = 255 & h5 >> o2);
  }
  if (o2 >= t2 || 255 & h5 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return a2;
};
var Wi = (r2, e2, t2) => {
  const i3 = e2[e2.length - 1] === "=", s = (1 << t2) - 1;
  let n2 = "", a2 = 0, o2 = 0;
  for (let h5 = 0; h5 < r2.length; ++h5)
    for (o2 = o2 << 8 | r2[h5], a2 += 8; a2 > t2; )
      a2 -= t2, n2 += e2[s & o2 >> a2];
  if (a2 && (n2 += e2[s & o2 << t2 - a2]), i3)
    for (; n2.length * t2 & 7; )
      n2 += "=";
  return n2;
};
var g2 = ({ name: r2, prefix: e2, bitsPerChar: t2, alphabet: i3 }) => J2({ prefix: e2, name: r2, encode(s) {
  return Wi(s, i3, t2);
}, decode(s) {
  return Ji(s, i3, t2, r2);
} });
var Xi = J2({ prefix: "\0", name: "identity", encode: (r2) => qi(r2), decode: (r2) => Vi(r2) });
var Qi = Object.freeze({ __proto__: null, identity: Xi });
var Zi = g2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var es = Object.freeze({ __proto__: null, base2: Zi });
var ts = g2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var is3 = Object.freeze({ __proto__: null, base8: ts });
var ss = K({ prefix: "9", name: "base10", alphabet: "0123456789" });
var rs = Object.freeze({ __proto__: null, base10: ss });
var ns = g2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var as = g2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var os = Object.freeze({ __proto__: null, base16: ns, base16upper: as });
var hs = g2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var cs = g2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var us = g2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var ls = g2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var ds = g2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var gs = g2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var ps = g2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Ds = g2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var ys = g2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var bs = Object.freeze({ __proto__: null, base32: hs, base32upper: cs, base32pad: us, base32padupper: ls, base32hex: ds, base32hexupper: gs, base32hexpad: ps, base32hexpadupper: Ds, base32z: ys });
var ms = K({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var fs = K({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Es = Object.freeze({ __proto__: null, base36: ms, base36upper: fs });
var ws = K({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var vs = K({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Is = Object.freeze({ __proto__: null, base58btc: ws, base58flickr: vs });
var Cs = g2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Rs = g2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var _s = g2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Ts = g2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ss = Object.freeze({ __proto__: null, base64: Cs, base64pad: Rs, base64url: _s, base64urlpad: Ts });
var Ne = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Ps = Ne.reduce((r2, e2, t2) => (r2[t2] = e2, r2), []);
var Os = Ne.reduce((r2, e2, t2) => (r2[e2.codePointAt(0)] = t2, r2), []);
function xs(r2) {
  return r2.reduce((e2, t2) => (e2 += Ps[t2], e2), "");
}
function As(r2) {
  const e2 = [];
  for (const t2 of r2) {
    const i3 = Os[t2.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${t2}`);
    e2.push(i3);
  }
  return new Uint8Array(e2);
}
var zs = J2({ prefix: "\u{1F680}", name: "base256emoji", encode: xs, decode: As });
var Ns = Object.freeze({ __proto__: null, base256emoji: zs });
var Ls = Ue2;
var Le = 128;
var Us = 127;
var Fs = ~Us;
var $s = Math.pow(2, 31);
function Ue2(r2, e2, t2) {
  e2 = e2 || [], t2 = t2 || 0;
  for (var i3 = t2; r2 >= $s; )
    e2[t2++] = r2 & 255 | Le, r2 /= 128;
  for (; r2 & Fs; )
    e2[t2++] = r2 & 255 | Le, r2 >>>= 7;
  return e2[t2] = r2 | 0, Ue2.bytes = t2 - i3 + 1, e2;
}
var Ms = ae;
var ks = 128;
var Fe2 = 127;
function ae(r2, i3) {
  var t2 = 0, i3 = i3 || 0, s = 0, n2 = i3, a2, o2 = r2.length;
  do {
    if (n2 >= o2)
      throw ae.bytes = 0, new RangeError("Could not decode varint");
    a2 = r2[n2++], t2 += s < 28 ? (a2 & Fe2) << s : (a2 & Fe2) * Math.pow(2, s), s += 7;
  } while (a2 >= ks);
  return ae.bytes = n2 - i3, t2;
}
var Ks = Math.pow(2, 7);
var Bs = Math.pow(2, 14);
var Vs = Math.pow(2, 21);
var qs = Math.pow(2, 28);
var js = Math.pow(2, 35);
var Ys = Math.pow(2, 42);
var Gs = Math.pow(2, 49);
var Hs = Math.pow(2, 56);
var Js = Math.pow(2, 63);
var Ws = function(r2) {
  return r2 < Ks ? 1 : r2 < Bs ? 2 : r2 < Vs ? 3 : r2 < qs ? 4 : r2 < js ? 5 : r2 < Ys ? 6 : r2 < Gs ? 7 : r2 < Hs ? 8 : r2 < Js ? 9 : 10;
};
var Xs = { encode: Ls, decode: Ms, encodingLength: Ws };
var $e = Xs;
var Me2 = (r2, e2, t2 = 0) => ($e.encode(r2, e2, t2), e2);
var ke2 = (r2) => $e.encodingLength(r2);
var oe = (r2, e2) => {
  const t2 = e2.byteLength, i3 = ke2(r2), s = i3 + ke2(t2), n2 = new Uint8Array(s + t2);
  return Me2(r2, n2, 0), Me2(t2, n2, i3), n2.set(e2, s), new Qs(r2, t2, e2, n2);
};
var Qs = class {
  constructor(e2, t2, i3, s) {
    this.code = e2, this.size = t2, this.digest = i3, this.bytes = s;
  }
};
var Ke = ({ name: r2, code: e2, encode: t2 }) => new Zs(r2, e2, t2);
var Zs = class {
  constructor(e2, t2, i3) {
    this.name = e2, this.code = t2, this.encode = i3;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t2 = this.encode(e2);
      return t2 instanceof Uint8Array ? oe(this.code, t2) : t2.then((i3) => oe(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Be2 = (r2) => async (e2) => new Uint8Array(await crypto.subtle.digest(r2, e2));
var er = Ke({ name: "sha2-256", code: 18, encode: Be2("SHA-256") });
var tr = Ke({ name: "sha2-512", code: 19, encode: Be2("SHA-512") });
var ir = Object.freeze({ __proto__: null, sha256: er, sha512: tr });
var Ve2 = 0;
var sr = "identity";
var qe2 = Ae2;
var rr = (r2) => oe(Ve2, qe2(r2));
var nr = { code: Ve2, name: sr, encode: qe2, digest: rr };
var ar = Object.freeze({ __proto__: null, identity: nr });
new TextEncoder(), new TextDecoder();
var je2 = { ...Qi, ...es, ...is3, ...rs, ...os, ...bs, ...Es, ...Is, ...Ss, ...Ns };
({ ...ir, ...ar });
function Ye(r2) {
  return globalThis.Buffer != null ? new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength) : r2;
}
function or(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ye(globalThis.Buffer.allocUnsafe(r2)) : new Uint8Array(r2);
}
function Ge2(r2, e2, t2, i3) {
  return { name: r2, prefix: e2, encoder: { name: r2, prefix: e2, encode: t2 }, decoder: { decode: i3 } };
}
var He2 = Ge2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var he2 = Ge2("ascii", "a", (r2) => {
  let e2 = "a";
  for (let t2 = 0; t2 < r2.length; t2++)
    e2 += String.fromCharCode(r2[t2]);
  return e2;
}, (r2) => {
  r2 = r2.substring(1);
  const e2 = or(r2.length);
  for (let t2 = 0; t2 < r2.length; t2++)
    e2[t2] = r2.charCodeAt(t2);
  return e2;
});
var hr = { utf8: He2, "utf-8": He2, hex: je2.base16, latin1: he2, ascii: he2, binary: he2, ...je2 };
function cr(r2, e2 = "utf8") {
  const t2 = hr[e2];
  if (!t2)
    throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ye(globalThis.Buffer.from(r2, "utf-8")) : t2.decoder.decode(`${t2.prefix}${r2}`);
}
var ce = "wc";
var Je2 = 2;
var W2 = "core";
var x2 = `${ce}@2:${W2}:`;
var We2 = { name: W2, logger: "error" };
var Xe = { database: ":memory:" };
var Qe = "crypto";
var ue2 = "client_ed25519_seed";
var Ze = import_time2.ONE_DAY;
var et2 = "keychain";
var tt = "0.3";
var it2 = "messages";
var st3 = "0.3";
var rt = import_time2.SIX_HOURS;
var nt2 = "publisher";
var at3 = "irn";
var ot = "error";
var le2 = "wss://relay.walletconnect.com";
var de2 = "wss://relay.walletconnect.org";
var ht2 = "relayer";
var D = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ct2 = "_subscription";
var P = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ut2 = import_time2.ONE_SECOND;
var lt2 = "2.10.0";
var dt2 = 1e4;
var gt2 = "0.3";
var pt = "WALLETCONNECT_CLIENT_ID";
var C = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Dt2 = "subscription";
var yt2 = "0.3";
var bt2 = import_time2.FIVE_SECONDS * 1e3;
var mt2 = "pairing";
var ft2 = "0.3";
var F = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var R2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Et2 = "history";
var wt = "0.3";
var vt2 = "expirer";
var w2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var It = "0.3";
var X2 = "verify-api";
var Q2 = "https://verify.walletconnect.com";
var ge = "https://verify.walletconnect.org";
var Ct2 = class {
  constructor(e2, t2) {
    this.core = e2, this.logger = t2, this.keychain = /* @__PURE__ */ new Map(), this.name = et2, this.version = tt, this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }, this.has = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.set = async (i3, s) => {
      this.isInitialized(), this.keychain.set(i3, s), await this.persist();
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.keychain.get(i3);
      if (typeof s > "u") {
        const { message: n2 } = N("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n2);
      }
      return s;
    }, this.del = async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }, this.core = e2, this.logger = (0, import_logger.generateChildLogger)(t2, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, et(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? nt(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Rt = class {
  constructor(e2, t2, i3) {
    this.core = e2, this.logger = t2, this.name = Qe, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), n2 = generateKeyPair(s);
      return encodeIss(n2.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = jn();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), a2 = generateKeyPair(n2), o2 = Dn(), h5 = Ze;
      return await signJWT(o2, s, h5, a2);
    }, this.generateSharedKey = (s, n2, a2) => {
      this.isInitialized();
      const o2 = this.getPrivateKey(s), h5 = kn(o2, n2);
      return this.setSymKey(h5, a2);
    }, this.setSymKey = async (s, n2) => {
      this.isInitialized();
      const a2 = n2 || Vn(s);
      return await this.keychain.set(a2, s), a2;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, n2, a2) => {
      this.isInitialized();
      const o2 = Re(a2), h5 = safeJsonStringify(n2);
      if (Fn(o2)) {
        const y4 = o2.senderPublicKey, $4 = o2.receiverPublicKey;
        s = await this.generateSharedKey(y4, $4);
      }
      const l2 = this.getSymKey(s), { type: d4, senderPublicKey: p6 } = o2;
      return Kn({ type: d4, symKey: l2, message: h5, senderPublicKey: p6 });
    }, this.decode = async (s, n2, a2) => {
      this.isInitialized();
      const o2 = xn(n2, a2);
      if (Fn(o2)) {
        const h5 = o2.receiverPublicKey, l2 = o2.senderPublicKey;
        s = await this.generateSharedKey(h5, l2);
      }
      try {
        const h5 = this.getSymKey(s), l2 = Ln({ symKey: h5, encoded: n2 });
        return safeJsonParse(l2);
      } catch (h5) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h5);
      }
    }, this.getPayloadType = (s) => {
      const n2 = ee(s);
      return $(n2.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const n2 = ee(s);
      return n2.senderPublicKey ? toString(n2.senderPublicKey, p2) : void 0;
    }, this.core = e2, this.logger = (0, import_logger.generateChildLogger)(t2, this.name), this.keychain = i3 || new Ct2(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e2, t2) {
    return await this.keychain.set(e2, t2), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(ue2);
    } catch {
      e2 = Dn(), await this.keychain.set(ue2, e2);
    }
    return cr(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var _t2 = class extends a {
  constructor(e2, t2) {
    super(e2, t2), this.logger = e2, this.core = t2, this.messages = /* @__PURE__ */ new Map(), this.name = it2, this.version = st3, this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i3, s) => {
      this.isInitialized();
      const n2 = Mn(s);
      let a2 = this.messages.get(i3);
      return typeof a2 > "u" && (a2 = {}), typeof a2[n2] < "u" || (a2[n2] = s, this.messages.set(i3, a2), await this.persist()), n2;
    }, this.get = (i3) => {
      this.isInitialized();
      let s = this.messages.get(i3);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i3, s) => {
      this.isInitialized();
      const n2 = this.get(i3), a2 = Mn(s);
      return typeof n2[a2] < "u";
    }, this.del = async (i3) => {
      this.isInitialized(), this.messages.delete(i3), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e2, this.name), this.core = t2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, et(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? nt(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var pr = class extends u {
  constructor(e2, t2) {
    super(e2, t2), this.relayer = e2, this.logger = t2, this.events = new import_events4.EventEmitter(), this.name = nt2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i3, s, n2) => {
      var a2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n2 } });
      try {
        const o2 = n2?.ttl || rt, h5 = mt(n2), l2 = n2?.prompt || false, d4 = n2?.tag || 0, p6 = n2?.id || getBigIntRpcId().toString(), y4 = { topic: i3, message: s, opts: { ttl: o2, relay: h5, prompt: l2, tag: d4, id: p6 } }, $4 = setTimeout(() => this.queue.set(p6, y4), this.publishTimeout);
        try {
          await await it(this.rpcPublish(i3, s, o2, h5, l2, d4, p6), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p6), this.relayer.events.emit(D.publish, y4);
        } catch (c3) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (a2 = n2?.internal) != null && a2.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p6), c3;
          return;
        } finally {
          clearTimeout($4);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s, opts: n2 } });
      } catch (o2) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o2), o2;
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.relayer = e2, this.logger = (0, import_logger.generateChildLogger)(t2, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e2, t2, i3, s, n2, a2, o2) {
    var h5, l2, d4, p6;
    const y4 = { method: yt(s.protocol).publish, params: { topic: e2, message: t2, ttl: i3, prompt: n2, tag: a2 }, id: o2 };
    return w((h5 = y4.params) == null ? void 0 : h5.prompt) && ((l2 = y4.params) == null || delete l2.prompt), w((d4 = y4.params) == null ? void 0 : d4.tag) && ((p6 = y4.params) == null || delete p6.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y4 }), this.relayer.request(y4);
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2) => {
      const { topic: t2, message: i3, opts: s } = e2;
      await this.publish(t2, i3, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
};
var Dr = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e2, t2) => {
      const i3 = this.get(e2);
      this.exists(e2, t2) || this.map.set(e2, [...i3, t2]);
    }, this.get = (e2) => this.map.get(e2) || [], this.exists = (e2, t2) => this.get(e2).includes(t2), this.delete = (e2, t2) => {
      if (typeof t2 > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2))
        return;
      const i3 = this.get(e2);
      if (!this.exists(e2, t2))
        return;
      const s = i3.filter((n2) => n2 !== t2);
      if (!s.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var yr = Object.defineProperty;
var br = Object.defineProperties;
var mr = Object.getOwnPropertyDescriptors;
var Tt = Object.getOwnPropertySymbols;
var fr = Object.prototype.hasOwnProperty;
var Er = Object.prototype.propertyIsEnumerable;
var St = (r2, e2, t2) => e2 in r2 ? yr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2;
var B = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    fr.call(e2, t2) && St(r2, t2, e2[t2]);
  if (Tt)
    for (var t2 of Tt(e2))
      Er.call(e2, t2) && St(r2, t2, e2[t2]);
  return r2;
};
var pe = (r2, e2) => br(r2, mr(e2));
var Pt = class extends d {
  constructor(e2, t2) {
    super(e2, t2), this.relayer = e2, this.logger = t2, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Dr(), this.events = new import_events4.EventEmitter(), this.name = Dt2, this.version = yt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = x2, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } });
      try {
        const n2 = mt(s), a2 = { topic: i3, relay: n2 };
        this.pending.set(i3, a2);
        const o2 = await this.rpcSubscribe(i3, n2);
        return this.onSubscribe(o2, a2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s } }), o2;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }, this.unsubscribe = async (i3, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof s?.id < "u" ? await this.unsubscribeById(i3, s.id, s) : await this.unsubscribeByTopic(i3, s);
    }, this.isSubscribed = async (i3) => this.topics.includes(i3) ? true : await new Promise((s, n2) => {
      const a2 = new import_time2.Watch();
      a2.start(this.pendingSubscriptionWatchLabel);
      const o2 = setInterval(() => {
        !this.pending.has(i3) && this.topics.includes(i3) && (clearInterval(o2), a2.stop(this.pendingSubscriptionWatchLabel), s(true)), a2.elapsed(this.pendingSubscriptionWatchLabel) >= bt2 && (clearInterval(o2), a2.stop(this.pendingSubscriptionWatchLabel), n2(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e2, this.logger = (0, import_logger.generateChildLogger)(t2, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e2, t2) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e2).topic === t2;
    } catch {
    }
    return i3;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t2) {
    const i3 = this.topicMap.get(e2);
    await Promise.all(i3.map(async (s) => await this.unsubscribeById(e2, s, t2)));
  }
  async unsubscribeById(e2, t2, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t2, opts: i3 } });
    try {
      const s = mt(i3);
      await this.rpcUnsubscribe(e2, t2, s);
      const n2 = U("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t2, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t2, opts: i3 } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e2, t2) {
    const i3 = { method: yt(t2.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await it(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D.connection_stalled);
    }
    return Mn(e2 + this.clientId);
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length)
      return;
    const t2 = e2[0].relay, i3 = { method: yt(t2.protocol).batchSubscribe, params: { topics: e2.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      return await await it(this.relayer.request(i3), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D.connection_stalled);
    }
  }
  rpcUnsubscribe(e2, t2, i3) {
    const s = { method: yt(i3.protocol).unsubscribe, params: { topic: e2, id: t2 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e2, t2) {
    this.setSubscription(e2, pe(B({}, t2), { id: e2 })), this.pending.delete(t2.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t2) => {
      this.setSubscription(t2.id, B({}, t2)), this.pending.delete(t2.topic);
    });
  }
  async onUnsubscribe(e2, t2, i3) {
    this.events.removeAllListeners(t2), this.hasSubscription(t2, e2) && this.deleteSubscription(t2, i3), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t2) {
    this.subscriptions.has(e2) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t2 }), this.addSubscription(e2, t2));
  }
  addSubscription(e2, t2) {
    this.subscriptions.set(e2, B({}, t2)), this.topicMap.set(t2.topic, e2), this.events.emit(C.created, t2);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t2 = this.subscriptions.get(e2);
    if (!t2) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i3);
    }
    return t2;
  }
  deleteSubscription(e2, t2) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t2 });
    const i3 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(i3.topic, e2), this.events.emit(C.deleted, pe(B({}, i3), { reason: t2 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(C.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t2 = 0; t2 < e2; t2++) {
        const i3 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i3);
      }
    }
    this.events.emit(C.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.subscriptions.size) {
        const { message: t2 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    if (!e2.length)
      return;
    const t2 = await this.rpcBatchSubscribe(e2);
    j(t2) && this.onBatchSubscribe(t2.map((i3, s) => pe(B({}, e2[s]), { id: i3 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e2 = [];
    this.pending.forEach((t2) => {
      e2.push(t2);
    }), await this.batchSubscribe(e2);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(C.created, async (e2) => {
      const t2 = C.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), await this.persist();
    }), this.events.on(C.deleted, async (e2) => {
      const t2 = C.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e2) => {
      const t2 = setInterval(() => {
        this.restartInProgress || (clearInterval(t2), e2());
      }, this.pollingInterval);
    });
  }
};
var wr = Object.defineProperty;
var Ot = Object.getOwnPropertySymbols;
var vr = Object.prototype.hasOwnProperty;
var Ir = Object.prototype.propertyIsEnumerable;
var xt2 = (r2, e2, t2) => e2 in r2 ? wr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2;
var Cr = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    vr.call(e2, t2) && xt2(r2, t2, e2[t2]);
  if (Ot)
    for (var t2 of Ot(e2))
      Ir.call(e2, t2) && xt2(r2, t2, e2[t2]);
  return r2;
};
var At = class extends g {
  constructor(e2) {
    super(e2), this.protocol = "wc", this.version = 2, this.events = new import_events4.EventEmitter(), this.name = ht2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t2) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t2);
      } catch (i3) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i3), i3;
      }
    }, this.onPayloadHandler = (t2) => {
      this.onProviderPayload(t2);
    }, this.onConnectHandler = () => {
      this.events.emit(D.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t2) => {
      this.logger.error(t2), this.events.emit(D.error, t2);
    }, this.registerProviderListeners = () => {
      this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);
    }, this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? (0, import_logger.generateChildLogger)(e2.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e2.logger || ot })), this.messages = new _t2(this.logger, e2.core), this.subscriber = new Pt(this, this.logger), this.publisher = new pr(this, this.logger), this.relayUrl = e2?.relayUrl || le2, this.projectId = e2.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${de2}...`), await this.restartTransport(de2);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, dt2);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e2, t2, i3) {
    this.isInitialized(), await this.publisher.publish(e2, t2, i3), await this.recordMessageEvent({ topic: e2, message: t2, publishedAt: Date.now() });
  }
  async subscribe(e2, t2) {
    var i3;
    this.isInitialized();
    let s = ((i3 = this.subscriber.topicMap.get(e2)) == null ? void 0 : i3[0]) || "";
    return s || (await Promise.all([new Promise((n2) => {
      this.subscriber.once(C.created, (a2) => {
        a2.topic === e2 && n2();
      });
    }), new Promise(async (n2) => {
      s = await this.subscriber.subscribe(e2, t2), n2();
    })]), s);
  }
  async unsubscribe(e2, t2) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t2);
  }
  on(e2, t2) {
    this.events.on(e2, t2);
  }
  once(e2, t2) {
    this.events.once(e2, t2);
  }
  off(e2, t2) {
    this.events.off(e2, t2);
  }
  removeListener(e2, t2) {
    this.events.removeListener(e2, t2);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await it(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e2) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t2) => {
          if (!this.initialized)
            return t2();
          this.subscriber.once(C.resubscribed, () => {
            t2();
          });
        }), new Promise(async (t2, i3) => {
          try {
            await it(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s) {
            i3(s);
            return;
          }
          t2();
        })]);
      } catch (t2) {
        this.logger.error(t2);
        const i3 = t2;
        if (!this.isConnectionStalled(i3.message))
          throw t2;
        this.provider.events.emit(P.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e2) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e2 || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e2) {
    return this.staleConnectionErrors.some((t2) => e2.includes(t2));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default(Jn({ sdkVersion: lt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2) {
    const { topic: t2, message: i3 } = e2;
    await this.messages.set(t2, i3);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t2, message: i3 } = e2;
    if (!i3 || i3.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isSubscribed(t2))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t2}`), true;
    const s = this.messages.has(t2, i3);
    return s && this.logger.debug(`Ignoring duplicate message: ${i3}`), s;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(ct2))
        return;
      const t2 = e2.params, { topic: i3, message: s, publishedAt: n2 } = t2.data, a2 = { topic: i3, message: s, publishedAt: n2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Cr({ type: "event", event: t2.id }, a2)), this.events.emit(t2.id, a2), await this.acknowledgePayload(e2), await this.onMessageEvent(a2);
    } else
      isJsonRpcResponse(e2) && this.events.emit(D.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (this.events.emit(D.message, e2), await this.recordMessageEvent(e2));
  }
  async acknowledgePayload(e2) {
    const t2 = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t2);
  }
  unregisterProviderListeners() {
    this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D.connection_stalled, () => {
      this.restartTransport().catch((t2) => this.logger.error(t2));
    });
    let e2 = await Zt();
    Xt(async (t2) => {
      this.initialized && e2 !== t2 && (e2 = t2, t2 ? await this.restartTransport().catch((i3) => this.logger.error(i3)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i3) => this.logger.error(i3))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e2) => this.logger.error(e2));
    }, (0, import_time2.toMiliseconds)(ut2)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e2) => {
          const t2 = setInterval(() => {
            this.connected && (clearInterval(t2), e2());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var Rr = Object.defineProperty;
var zt = Object.getOwnPropertySymbols;
var _r = Object.prototype.hasOwnProperty;
var Tr = Object.prototype.propertyIsEnumerable;
var Nt2 = (r2, e2, t2) => e2 in r2 ? Rr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2;
var Lt = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    _r.call(e2, t2) && Nt2(r2, t2, e2[t2]);
  if (zt)
    for (var t2 of zt(e2))
      Tr.call(e2, t2) && Nt2(r2, t2, e2[t2]);
  return r2;
};
var Ut = class extends p {
  constructor(e2, t2, i3, s = x2, n2 = void 0) {
    super(e2, t2, i3, s), this.core = e2, this.logger = t2, this.name = i3, this.map = /* @__PURE__ */ new Map(), this.version = gt2, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a2) => {
        this.getKey && a2 !== null && !w(a2) ? this.map.set(this.getKey(a2), a2) : Dt(a2) ? this.map.set(a2.id, a2) : kt(a2) && this.map.set(a2.topic, a2);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a2, o2) => {
      this.isInitialized(), this.map.has(a2) ? await this.update(a2, o2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a2, value: o2 }), this.map.set(a2, o2), await this.persist());
    }, this.get = (a2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a2 }), this.getData(a2)), this.getAll = (a2) => (this.isInitialized(), a2 ? this.values.filter((o2) => Object.keys(a2).every((h5) => (0, import_lodash.default)(o2[h5], a2[h5]))) : this.values), this.update = async (a2, o2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a2, update: o2 });
      const h5 = Lt(Lt({}, this.getData(a2)), o2);
      this.map.set(a2, h5), await this.persist();
    }, this.delete = async (a2, o2) => {
      this.isInitialized(), this.map.has(a2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a2, reason: o2 }), this.map.delete(a2), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t2, this.name), this.storagePrefix = s, this.getKey = n2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t2 = this.map.get(e2);
    if (!t2) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t2;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.map.size) {
        const { message: t2 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Ft = class {
  constructor(e2, t2) {
    this.core = e2, this.logger = t2, this.name = mt2, this.version = ft2, this.events = new import_events4.default(), this.initialized = false, this.storagePrefix = x2, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }, this.create = async () => {
      this.isInitialized();
      const i3 = Dn(), s = await this.core.crypto.setSymKey(i3), n2 = lt(import_time2.FIVE_MINUTES), a2 = { protocol: at3 }, o2 = { topic: s, expiry: n2, relay: a2, active: false }, h5 = Nt({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i3, relay: a2 });
      return await this.pairings.set(s, o2), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n2), { topic: s, uri: h5 };
    }, this.pair = async (i3) => {
      this.isInitialized(), this.isValidPair(i3);
      const { topic: s, symKey: n2, relay: a2 } = bt(i3.uri);
      if (this.pairings.keys.includes(s))
        throw new Error(`Pairing already exists: ${s}`);
      if (this.core.crypto.hasKeys(s))
        throw new Error(`Keychain already exists: ${s}`);
      const o2 = lt(import_time2.FIVE_MINUTES), h5 = { topic: s, relay: a2, expiry: o2, active: false };
      return await this.pairings.set(s, h5), await this.core.crypto.setSymKey(n2, s), await this.core.relayer.subscribe(s, { relay: a2 }), this.core.expirer.set(s, o2), i3.activatePairing && await this.activate({ topic: s }), h5;
    }, this.activate = async ({ topic: i3 }) => {
      this.isInitialized();
      const s = lt(import_time2.THIRTY_DAYS);
      await this.pairings.update(i3, { active: true, expiry: s }), this.core.expirer.set(i3, s);
    }, this.ping = async (i3) => {
      this.isInitialized(), await this.isValidPing(i3);
      const { topic: s } = i3;
      if (this.pairings.keys.includes(s)) {
        const n2 = await this.sendRequest(s, "wc_pairingPing", {}), { done: a2, resolve: o2, reject: h5 } = st2();
        this.events.once(ft("pairing_ping", n2), ({ error: l2 }) => {
          l2 ? h5(l2) : o2();
        }), await a2();
      }
    }, this.updateExpiry = async ({ topic: i3, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s });
    }, this.updateMetadata = async ({ topic: i3, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s } = i3;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i3, s, n2) => {
      const a2 = formatJsonRpcRequest(s, n2), o2 = await this.core.crypto.encode(i3, a2), h5 = F[s].req;
      return this.core.history.set(i3, a2), this.core.relayer.publish(i3, o2, h5), a2.id;
    }, this.sendResult = async (i3, s, n2) => {
      const a2 = formatJsonRpcResult(i3, n2), o2 = await this.core.crypto.encode(s, a2), h5 = await this.core.history.get(s, i3), l2 = F[h5.request.method].res;
      await this.core.relayer.publish(s, o2, l2), await this.core.history.resolve(a2);
    }, this.sendError = async (i3, s, n2) => {
      const a2 = formatJsonRpcError(i3, n2), o2 = await this.core.crypto.encode(s, a2), h5 = await this.core.history.get(s, i3), l2 = F[h5.request.method] ? F[h5.request.method].res : F.unregistered_method.res;
      await this.core.relayer.publish(s, o2, l2), await this.core.history.resolve(a2);
    }, this.deletePairing = async (i3, s) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s ? Promise.resolve() : this.core.expirer.del(i3)]);
    }, this.cleanup = async () => {
      const i3 = this.pairings.getAll().filter((s) => dt(s.expiry));
      await Promise.all(i3.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i3) => {
      const { topic: s, payload: n2 } = i3;
      switch (n2.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, n2);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, n2);
        default:
          return this.onUnknownRpcMethodRequest(s, n2);
      }
    }, this.onRelayEventResponse = async (i3) => {
      const { topic: s, payload: n2 } = i3, a2 = (await this.core.history.get(s, n2.id)).request.method;
      switch (a2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, n2);
        default:
          return this.onUnknownRpcMethodResponse(a2);
      }
    }, this.onPairingPingRequest = async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n2, i3, true), this.events.emit("pairing_ping", { id: n2, topic: i3 });
      } catch (a2) {
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      }
    }, this.onPairingPingResponse = (i3, s) => {
      const { id: n2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft("pairing_ping", n2), {}) : isJsonRpcError(s) && this.events.emit(ft("pairing_ping", n2), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i3, s) => {
      const { id: n2 } = s;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit("pairing_delete", { id: n2, topic: i3 });
      } catch (a2) {
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      }
    }, this.onUnknownRpcMethodRequest = async (i3, s) => {
      const { id: n2, method: a2 } = s;
      try {
        if (this.registeredMethods.includes(a2))
          return;
        const o2 = U("WC_METHOD_UNSUPPORTED", a2);
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      } catch (o2) {
        await this.sendError(n2, i3, o2), this.logger.error(o2);
      }
    }, this.onUnknownRpcMethodResponse = (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i3));
    }, this.isValidPair = (i3) => {
      if (!xt(i3)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw new Error(s);
      }
      if (!jt(i3.uri)) {
        const { message: s } = N("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i3) => {
      if (!xt(i3)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i3) => {
      if (!xt(i3)) {
        const { message: n2 } = N("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s } = i3;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i3) => {
      if (!h2(i3, false)) {
        const { message: s } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s);
      }
      if (dt(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s } = N("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s);
      }
    }, this.core = e2, this.logger = (0, import_logger.generateChildLogger)(t2, this.name), this.pairings = new Ut(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D.message, async (e2) => {
      const { topic: t2, message: i3 } = e2;
      if (!this.pairings.keys.includes(t2) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3)))
        return;
      const s = await this.core.crypto.decode(t2, i3);
      try {
        isJsonRpcRequest(s) ? (this.core.history.set(t2, s), this.onRelayEventRequest({ topic: t2, payload: s })) : isJsonRpcResponse(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: t2, payload: s }), this.core.history.delete(t2, s.id));
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(w2.expired, async (e2) => {
      const { topic: t2 } = ut(e2.target);
      t2 && this.pairings.keys.includes(t2) && (await this.deletePairing(t2, true), this.events.emit("pairing_expire", { topic: t2 }));
    });
  }
};
var $t = class extends h {
  constructor(e2, t2) {
    super(e2, t2), this.core = e2, this.logger = t2, this.records = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = Et2, this.version = wt, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i3, s, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s, chainId: n2 }), this.records.has(s.id))
        return;
      const a2 = { id: s.id, topic: i3, request: { method: s.method, params: s.params || null }, chainId: n2, expiry: lt(import_time2.THIRTY_DAYS) };
      this.records.set(a2.id, a2), this.events.emit(R2.created, a2);
    }, this.resolve = async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id))
        return;
      const s = await this.getRecord(i3.id);
      typeof s.response > "u" && (s.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s.id, s), this.events.emit(R2.updated, s));
    }, this.get = async (i3, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s }), await this.getRecord(s)), this.delete = (i3, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((n2) => {
        if (n2.topic === i3) {
          if (typeof s < "u" && n2.id !== s)
            return;
          this.records.delete(n2.id), this.events.emit(R2.deleted, n2);
        }
      });
    }, this.exists = async (i3, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i3 : false), this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t2, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t2) => {
      if (typeof t2.response < "u")
        return;
      const i3 = { topic: t2.topic, request: formatJsonRpcRequest(t2.request.method, t2.request.params, t2.id), chainId: t2.chainId };
      return e2.push(i3);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t2 = this.records.get(e2);
    if (!t2) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(i3);
    }
    return t2;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R2.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.records.size) {
        const { message: t2 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(R2.created, (e2) => {
      const t2 = R2.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e2 }), this.persist();
    }), this.events.on(R2.updated, (e2) => {
      const t2 = R2.updated;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e2 }), this.persist();
    }), this.events.on(R2.deleted, (e2) => {
      const t2 = R2.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, record: e2 }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e2) => {
        (0, import_time2.toMiliseconds)(e2.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e2.id}`), this.delete(e2.topic, e2.id));
      });
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Mt = class extends E {
  constructor(e2, t2) {
    super(e2, t2), this.core = e2, this.logger = t2, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events4.EventEmitter(), this.name = vt2, this.version = It, this.cached = [], this.initialized = false, this.storagePrefix = x2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i3) => {
      try {
        const s = this.formatTarget(i3);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }, this.set = (i3, s) => {
      this.isInitialized();
      const n2 = this.formatTarget(i3), a2 = { target: n2, expiry: s };
      this.expirations.set(n2, a2), this.checkExpiry(n2, a2), this.events.emit(w2.created, { target: n2, expiration: a2 });
    }, this.get = (i3) => {
      this.isInitialized();
      const s = this.formatTarget(i3);
      return this.getExpiration(s);
    }, this.del = (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s = this.formatTarget(i3), n2 = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(w2.deleted, { target: s, expiration: n2 });
      }
    }, this.on = (i3, s) => {
      this.events.on(i3, s);
    }, this.once = (i3, s) => {
      this.events.once(i3, s);
    }, this.off = (i3, s) => {
      this.events.off(i3, s);
    }, this.removeListener = (i3, s) => {
      this.events.removeListener(i3, s);
    }, this.logger = (0, import_logger.generateChildLogger)(t2, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string")
      return ct(e2);
    if (typeof e2 == "number")
      return at2(e2);
    const { message: t2 } = N("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t2);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(w2.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length)
        return;
      if (this.expirations.size) {
        const { message: t2 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t2), new Error(t2);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t2 = this.expirations.get(e2);
    if (!t2) {
      const { message: i3 } = N("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t2;
  }
  checkExpiry(e2, t2) {
    const { expiry: i3 } = t2;
    (0, import_time2.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e2, t2);
  }
  expire(e2, t2) {
    this.expirations.delete(e2), this.events.emit(w2.expired, { target: e2, expiration: t2 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t2) => this.checkExpiry(t2, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(w2.created, (e2) => {
      const t2 = w2.created;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), this.persist();
    }), this.events.on(w2.expired, (e2) => {
      const t2 = w2.expired;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), this.persist();
    }), this.events.on(w2.deleted, (e2) => {
      const t2 = w2.deleted;
      this.logger.info(`Emitting ${t2}`), this.logger.debug({ type: "event", event: t2, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var kt2 = class extends y {
  constructor(e2, t2) {
    super(e2, t2), this.projectId = e2, this.logger = t2, this.name = X2, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i3) => {
      if (this.verifyDisabled || H() || !q())
        return;
      const s = i3?.verifyUrl || Q2;
      this.verifyUrl !== s && this.removeIframe(), this.verifyUrl = s;
      try {
        await this.createIframe();
      } catch (n2) {
        this.logger.warn(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.warn(n2);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = ge;
        try {
          await this.createIframe();
        } catch (n2) {
          this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(n2), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i3) => {
      this.initialized ? this.sendPost(i3.attestationId) : (this.addToQueue(i3.attestationId), await this.init());
    }, this.resolve = async (i3) => {
      if (this.isDevEnv)
        return "";
      const s = i3?.verifyUrl || Q2;
      let n2 = "";
      try {
        n2 = await this.fetchAttestation(i3.attestationId, s);
      } catch (a2) {
        this.logger.warn(`failed to resolve attestation: ${i3.attestationId} from url: ${s}`), this.logger.warn(a2), n2 = await this.fetchAttestation(i3.attestationId, ge);
      }
      return n2;
    }, this.fetchAttestation = async (i3, s) => {
      var n2;
      this.logger.info(`resolving attestation: ${i3} from url: ${s}`);
      const a2 = this.startAbortTimer(import_time2.ONE_SECOND * 2), o2 = await fetch(`${s}/attestation/${i3}`, { signal: this.abortController.signal });
      return clearTimeout(a2), o2.status === 200 ? (n2 = await o2.json()) == null ? void 0 : n2.origin : "";
    }, this.addToQueue = (i3) => {
      this.queue.push(i3);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i3) => this.sendPost(i3)), this.queue = []);
    }, this.sendPost = (i3) => {
      var s;
      try {
        if (!this.iframe)
          return;
        (s = this.iframe.contentWindow) == null || s.postMessage(i3, "*"), this.logger.info(`postMessage sent: ${i3} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i3;
      const s = (n2) => {
        n2.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s), i3());
      };
      await Promise.race([new Promise((n2) => {
        if (document.getElementById(X2))
          return n2();
        window.addEventListener("message", s);
        const a2 = document.createElement("iframe");
        a2.id = X2, a2.src = `${this.verifyUrl}/${this.projectId}`, a2.style.display = "none", document.body.append(a2), this.iframe = a2, i3 = n2;
      }), new Promise((n2, a2) => setTimeout(() => {
        window.removeEventListener("message", s), a2("verify iframe load timeout");
      }, (0, import_time2.toMiliseconds)(import_time2.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.logger = (0, import_logger.generateChildLogger)(t2, this.name), this.verifyUrl = Q2, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e2));
  }
};
var Sr = Object.defineProperty;
var Kt = Object.getOwnPropertySymbols;
var Pr = Object.prototype.hasOwnProperty;
var Or = Object.prototype.propertyIsEnumerable;
var Bt = (r2, e2, t2) => e2 in r2 ? Sr(r2, e2, { enumerable: true, configurable: true, writable: true, value: t2 }) : r2[e2] = t2;
var Vt = (r2, e2) => {
  for (var t2 in e2 || (e2 = {}))
    Pr.call(e2, t2) && Bt(r2, t2, e2[t2]);
  if (Kt)
    for (var t2 of Kt(e2))
      Or.call(e2, t2) && Bt(r2, t2, e2[t2]);
  return r2;
};
var Z2 = class extends n {
  constructor(e2) {
    super(e2), this.protocol = ce, this.version = Je2, this.name = W2, this.events = new import_events4.EventEmitter(), this.initialized = false, this.on = (i3, s) => this.events.on(i3, s), this.once = (i3, s) => this.events.once(i3, s), this.off = (i3, s) => this.events.off(i3, s), this.removeListener = (i3, s) => this.events.removeListener(i3, s), this.projectId = e2?.projectId, this.relayUrl = e2?.relayUrl || le2;
    const t2 = typeof e2?.logger < "u" && typeof e2?.logger != "string" ? e2.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e2?.logger || We2.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t2, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new Rt(this, this.logger, e2?.keychain), this.history = new $t(this, this.logger), this.expirer = new Mt(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new import_keyvaluestorage.default(Vt(Vt({}, Xe), e2?.storageOptions)), this.relayer = new At({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Ft(this, this.logger), this.verify = new kt2(this.projectId || "", this.logger);
  }
  static async init(e2) {
    const t2 = new Z2(e2);
    await t2.initialize();
    const i3 = await t2.crypto.getClientId();
    return await t2.storage.setItem(pt, i3), t2;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
};
var xr = Z2;

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_logger2 = __toESM(require_cjs6());
var import_events5 = __toESM(require_events());

// node_modules/@walletconnect/auth-client/node_modules/@walletconnect/utils/dist/index.es.js
var import_chacha20poly13052 = __toESM(require_chacha20poly1305());
var import_hkdf2 = __toESM(require_hkdf());
var import_random2 = __toESM(require_random());
var import_sha2562 = __toESM(require_sha256());
var fe2 = __toESM(require_x25519());
var import_time3 = __toESM(require_cjs2());
var import_window_getters2 = __toESM(require_cjs3());
var import_window_metadata2 = __toESM(require_cjs4());
var k2 = __toESM(require_query_string5());
var p3 = "base16";
var _2 = 1;
function Vn2(e2) {
  const n2 = (0, import_sha2562.hash)(fromString(e2, p3));
  return toString(n2, p3);
}
var Ct3 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N3(e2, n2) {
  const { message: t2, code: r2 } = Ct3[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function w3(e2) {
  return typeof e2 > "u";
}
function h3(e2, n2) {
  return n2 && w3(e2) ? true : typeof e2 == "string" && !!e2.trim().length;
}
function G(e2, n2) {
  return n2 && w3(e2) ? true : typeof e2 == "number" && !isNaN(e2);
}
function jt3(e2) {
  if (h3(e2, false))
    try {
      return typeof new URL(e2) < "u";
    } catch {
      return false;
    }
  return false;
}
function Qt(e2, n2) {
  return G(e2, false) && e2 <= n2.max && e2 >= n2.min;
}

// node_modules/@walletconnect/auth-client/dist/index.es.js
var import_time4 = __toESM(require_cjs2());
init_lib9();
init_lib12();
var import_isomorphic_unfetch = __toESM(require_browser4());
var import_random3 = __toESM(require_random());
var import_sha2563 = __toESM(require_sha256());
var J3 = class {
  constructor(t2) {
    this.client = t2;
  }
};
var X3 = class {
  constructor(t2) {
    this.opts = t2;
  }
};
var G2 = "https://rpc.walletconnect.com/v1";
var R3 = { wc_authRequest: { req: { ttl: import_time4.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 3001 } } };
var U3 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var B2 = "wc";
var H3 = 1;
var Y = "auth";
var N4 = "authClient";
var F2 = `${B2}@${1}:${Y}:`;
var x3 = `${F2}:PUB_KEY`;
function P2(r2) {
  return r2?.split(":");
}
function He3(r2) {
  const t2 = r2 && P2(r2);
  if (t2)
    return t2[3];
}
function Ye2(r2) {
  const t2 = r2 && P2(r2);
  if (t2)
    return t2[2] + ":" + t2[3];
}
function Q3(r2) {
  const t2 = r2 && P2(r2);
  if (t2)
    return t2.pop();
}
async function Qe2(r2, t2, e2, i3, n2) {
  switch (e2.t) {
    case "eip191":
      return Ze2(r2, t2, e2.s);
    case "eip1271":
      return await We3(r2, t2, e2.s, i3, n2);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e2.t}`);
  }
}
function Ze2(r2, t2, e2) {
  return recoverAddress(hashMessage(t2), e2).toLowerCase() === r2.toLowerCase();
}
async function We3(r2, t2, e2, i3, n2) {
  try {
    const s = "0x1626ba7e", u3 = "0000000000000000000000000000000000000000000000000000000000000040", o2 = "0000000000000000000000000000000000000000000000000000000000000041", a2 = e2.substring(2), h5 = hashMessage(t2).substring(2), D4 = s + h5 + u3 + o2 + a2, p6 = await (0, import_isomorphic_unfetch.default)(`${G2}/?chainId=${i3}&projectId=${n2}`, { method: "POST", body: JSON.stringify({ id: et3(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r2, data: D4 }, "latest"] }) }), { result: g5 } = await p6.json();
    return g5 ? g5.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function et3() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Z3(r2) {
  return r2.getAll().filter((t2) => "requester" in t2);
}
function W4(r2, t2) {
  return Z3(r2).find((e2) => e2.id === t2);
}
function tt2(r2) {
  const t2 = jt3(r2.aud), e2 = new RegExp(`${r2.domain}`).test(r2.aud), i3 = !!r2.nonce, n2 = r2.type ? r2.type === "eip4361" : true, s = r2.expiry;
  if (s && !Qt(s, U3)) {
    const { message: u3 } = N3("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U3.min} and ${U3.max}`);
    throw new Error(u3);
  }
  return !!(t2 && e2 && i3 && n2);
}
function rt2(r2, t2) {
  return !!W4(t2, r2.id);
}
function it3(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r2) : new Uint8Array(r2);
}
function nt3(r2, t2) {
  if (r2.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e2 = new Uint8Array(256), i3 = 0; i3 < e2.length; i3++)
    e2[i3] = 255;
  for (var n2 = 0; n2 < r2.length; n2++) {
    var s = r2.charAt(n2), u3 = s.charCodeAt(0);
    if (e2[u3] !== 255)
      throw new TypeError(s + " is ambiguous");
    e2[u3] = n2;
  }
  var o2 = r2.length, a2 = r2.charAt(0), h5 = Math.log(o2) / Math.log(256), D4 = Math.log(256) / Math.log(o2);
  function p6(c3) {
    if (c3 instanceof Uint8Array || (ArrayBuffer.isView(c3) ? c3 = new Uint8Array(c3.buffer, c3.byteOffset, c3.byteLength) : Array.isArray(c3) && (c3 = Uint8Array.from(c3))), !(c3 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c3.length === 0)
      return "";
    for (var f4 = 0, _6 = 0, b4 = 0, w6 = c3.length; b4 !== w6 && c3[b4] === 0; )
      b4++, f4++;
    for (var C4 = (w6 - b4) * D4 + 1 >>> 0, E5 = new Uint8Array(C4); b4 !== w6; ) {
      for (var m4 = c3[b4], A2 = 0, y4 = C4 - 1; (m4 !== 0 || A2 < _6) && y4 !== -1; y4--, A2++)
        m4 += 256 * E5[y4] >>> 0, E5[y4] = m4 % o2 >>> 0, m4 = m4 / o2 >>> 0;
      if (m4 !== 0)
        throw new Error("Non-zero carry");
      _6 = A2, b4++;
    }
    for (var v = C4 - _6; v !== C4 && E5[v] === 0; )
      v++;
    for (var I2 = a2.repeat(f4); v < C4; ++v)
      I2 += r2.charAt(E5[v]);
    return I2;
  }
  function g5(c3) {
    if (typeof c3 != "string")
      throw new TypeError("Expected String");
    if (c3.length === 0)
      return new Uint8Array();
    var f4 = 0;
    if (c3[f4] !== " ") {
      for (var _6 = 0, b4 = 0; c3[f4] === a2; )
        _6++, f4++;
      for (var w6 = (c3.length - f4) * h5 + 1 >>> 0, C4 = new Uint8Array(w6); c3[f4]; ) {
        var E5 = e2[c3.charCodeAt(f4)];
        if (E5 === 255)
          return;
        for (var m4 = 0, A2 = w6 - 1; (E5 !== 0 || m4 < b4) && A2 !== -1; A2--, m4++)
          E5 += o2 * C4[A2] >>> 0, C4[A2] = E5 % 256 >>> 0, E5 = E5 / 256 >>> 0;
        if (E5 !== 0)
          throw new Error("Non-zero carry");
        b4 = m4, f4++;
      }
      if (c3[f4] !== " ") {
        for (var y4 = w6 - b4; y4 !== w6 && C4[y4] === 0; )
          y4++;
        for (var v = new Uint8Array(_6 + (w6 - y4)), I2 = _6; y4 !== w6; )
          v[I2++] = C4[y4++];
        return v;
      }
    }
  }
  function l2(c3) {
    var f4 = g5(c3);
    if (f4)
      return f4;
    throw new Error(`Non-${t2} character`);
  }
  return { encode: p6, decodeUnsafe: g5, decode: l2 };
}
var st4 = nt3;
var ut3 = st4;
var ee2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array")
    return r2;
  if (r2 instanceof ArrayBuffer)
    return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2))
    return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ot2 = (r2) => new TextEncoder().encode(r2);
var at4 = (r2) => new TextDecoder().decode(r2);
var Dt3 = class {
  constructor(t2, e2, i3) {
    this.name = t2, this.prefix = e2, this.baseEncode = i3;
  }
  encode(t2) {
    if (t2 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ct3 = class {
  constructor(t2, e2, i3) {
    if (this.name = t2, this.prefix = e2, e2.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e2.codePointAt(0), this.baseDecode = i3;
  }
  decode(t2) {
    if (typeof t2 == "string") {
      if (t2.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t2.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t2) {
    return te2(this, t2);
  }
};
var ht3 = class {
  constructor(t2) {
    this.decoders = t2;
  }
  or(t2) {
    return te2(this, t2);
  }
  decode(t2) {
    const e2 = t2[0], i3 = this.decoders[e2];
    if (i3)
      return i3.decode(t2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var te2 = (r2, t2) => new ht3({ ...r2.decoders || { [r2.prefix]: r2 }, ...t2.decoders || { [t2.prefix]: t2 } });
var lt3 = class {
  constructor(t2, e2, i3, n2) {
    this.name = t2, this.prefix = e2, this.baseEncode = i3, this.baseDecode = n2, this.encoder = new Dt3(t2, e2, i3), this.decoder = new ct3(t2, e2, n2);
  }
  encode(t2) {
    return this.encoder.encode(t2);
  }
  decode(t2) {
    return this.decoder.decode(t2);
  }
};
var S = ({ name: r2, prefix: t2, encode: e2, decode: i3 }) => new lt3(r2, t2, e2, i3);
var T = ({ prefix: r2, name: t2, alphabet: e2 }) => {
  const { encode: i3, decode: n2 } = ut3(e2, t2);
  return S({ prefix: r2, name: t2, encode: i3, decode: (s) => ee2(n2(s)) });
};
var dt3 = (r2, t2, e2, i3) => {
  const n2 = {};
  for (let D4 = 0; D4 < t2.length; ++D4)
    n2[t2[D4]] = D4;
  let s = r2.length;
  for (; r2[s - 1] === "="; )
    --s;
  const u3 = new Uint8Array(s * e2 / 8 | 0);
  let o2 = 0, a2 = 0, h5 = 0;
  for (let D4 = 0; D4 < s; ++D4) {
    const p6 = n2[r2[D4]];
    if (p6 === void 0)
      throw new SyntaxError(`Non-${i3} character`);
    a2 = a2 << e2 | p6, o2 += e2, o2 >= 8 && (o2 -= 8, u3[h5++] = 255 & a2 >> o2);
  }
  if (o2 >= e2 || 255 & a2 << 8 - o2)
    throw new SyntaxError("Unexpected end of data");
  return u3;
};
var pt2 = (r2, t2, e2) => {
  const i3 = t2[t2.length - 1] === "=", n2 = (1 << e2) - 1;
  let s = "", u3 = 0, o2 = 0;
  for (let a2 = 0; a2 < r2.length; ++a2)
    for (o2 = o2 << 8 | r2[a2], u3 += 8; u3 > e2; )
      u3 -= e2, s += t2[n2 & o2 >> u3];
  if (u3 && (s += t2[n2 & o2 << e2 - u3]), i3)
    for (; s.length * e2 & 7; )
      s += "=";
  return s;
};
var d2 = ({ name: r2, prefix: t2, bitsPerChar: e2, alphabet: i3 }) => S({ prefix: t2, name: r2, encode(n2) {
  return pt2(n2, i3, e2);
}, decode(n2) {
  return dt3(n2, i3, e2, r2);
} });
var ft3 = S({ prefix: "\0", name: "identity", encode: (r2) => at4(r2), decode: (r2) => ot2(r2) });
var gt3 = Object.freeze({ __proto__: null, identity: ft3 });
var Et3 = d2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var bt3 = Object.freeze({ __proto__: null, base2: Et3 });
var yt3 = d2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var wt2 = Object.freeze({ __proto__: null, base8: yt3 });
var Ct4 = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var mt3 = Object.freeze({ __proto__: null, base10: Ct4 });
var vt3 = d2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var At2 = d2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var _t3 = Object.freeze({ __proto__: null, base16: vt3, base16upper: At2 });
var xt3 = d2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Rt2 = d2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Ft2 = d2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Tt2 = d2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var It2 = d2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Ut2 = d2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var St2 = d2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Ot2 = d2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var qt2 = d2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var $t2 = Object.freeze({ __proto__: null, base32: xt3, base32upper: Rt2, base32pad: Ft2, base32padupper: Tt2, base32hex: It2, base32hexupper: Ut2, base32hexpad: St2, base32hexpadupper: Ot2, base32z: qt2 });
var Bt2 = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Nt3 = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Pt2 = Object.freeze({ __proto__: null, base36: Bt2, base36upper: Nt3 });
var zt2 = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Mt2 = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var jt4 = Object.freeze({ __proto__: null, base58btc: zt2, base58flickr: Mt2 });
var Lt2 = d2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Kt2 = d2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Vt2 = d2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var kt3 = d2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Jt = Object.freeze({ __proto__: null, base64: Lt2, base64pad: Kt2, base64url: Vt2, base64urlpad: kt3 });
var re3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Xt2 = re3.reduce((r2, t2, e2) => (r2[e2] = t2, r2), []);
var Gt = re3.reduce((r2, t2, e2) => (r2[t2.codePointAt(0)] = e2, r2), []);
function Ht(r2) {
  return r2.reduce((t2, e2) => (t2 += Xt2[e2], t2), "");
}
function Yt2(r2) {
  const t2 = [];
  for (const e2 of r2) {
    const i3 = Gt[e2.codePointAt(0)];
    if (i3 === void 0)
      throw new Error(`Non-base256emoji character: ${e2}`);
    t2.push(i3);
  }
  return new Uint8Array(t2);
}
var Qt2 = S({ prefix: "\u{1F680}", name: "base256emoji", encode: Ht, decode: Yt2 });
var Zt2 = Object.freeze({ __proto__: null, base256emoji: Qt2 });
var Wt = ne;
var ie = 128;
var er2 = 127;
var tr2 = ~er2;
var rr2 = Math.pow(2, 31);
function ne(r2, t2, e2) {
  t2 = t2 || [], e2 = e2 || 0;
  for (var i3 = e2; r2 >= rr2; )
    t2[e2++] = r2 & 255 | ie, r2 /= 128;
  for (; r2 & tr2; )
    t2[e2++] = r2 & 255 | ie, r2 >>>= 7;
  return t2[e2] = r2 | 0, ne.bytes = e2 - i3 + 1, t2;
}
var ir2 = z;
var nr2 = 128;
var se = 127;
function z(r2, i3) {
  var e2 = 0, i3 = i3 || 0, n2 = 0, s = i3, u3, o2 = r2.length;
  do {
    if (s >= o2)
      throw z.bytes = 0, new RangeError("Could not decode varint");
    u3 = r2[s++], e2 += n2 < 28 ? (u3 & se) << n2 : (u3 & se) * Math.pow(2, n2), n2 += 7;
  } while (u3 >= nr2);
  return z.bytes = s - i3, e2;
}
var sr2 = Math.pow(2, 7);
var ur = Math.pow(2, 14);
var or2 = Math.pow(2, 21);
var ar2 = Math.pow(2, 28);
var Dr2 = Math.pow(2, 35);
var cr2 = Math.pow(2, 42);
var hr2 = Math.pow(2, 49);
var lr = Math.pow(2, 56);
var dr = Math.pow(2, 63);
var pr2 = function(r2) {
  return r2 < sr2 ? 1 : r2 < ur ? 2 : r2 < or2 ? 3 : r2 < ar2 ? 4 : r2 < Dr2 ? 5 : r2 < cr2 ? 6 : r2 < hr2 ? 7 : r2 < lr ? 8 : r2 < dr ? 9 : 10;
};
var fr2 = { encode: Wt, decode: ir2, encodingLength: pr2 };
var ue4 = fr2;
var oe2 = (r2, t2, e2 = 0) => (ue4.encode(r2, t2, e2), t2);
var ae2 = (r2) => ue4.encodingLength(r2);
var M = (r2, t2) => {
  const e2 = t2.byteLength, i3 = ae2(r2), n2 = i3 + ae2(e2), s = new Uint8Array(n2 + e2);
  return oe2(r2, s, 0), oe2(e2, s, i3), s.set(t2, n2), new gr(r2, e2, t2, s);
};
var gr = class {
  constructor(t2, e2, i3, n2) {
    this.code = t2, this.size = e2, this.digest = i3, this.bytes = n2;
  }
};
var De3 = ({ name: r2, code: t2, encode: e2 }) => new Er2(r2, t2, e2);
var Er2 = class {
  constructor(t2, e2, i3) {
    this.name = t2, this.code = e2, this.encode = i3;
  }
  digest(t2) {
    if (t2 instanceof Uint8Array) {
      const e2 = this.encode(t2);
      return e2 instanceof Uint8Array ? M(this.code, e2) : e2.then((i3) => M(this.code, i3));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var ce2 = (r2) => async (t2) => new Uint8Array(await crypto.subtle.digest(r2, t2));
var br2 = De3({ name: "sha2-256", code: 18, encode: ce2("SHA-256") });
var yr2 = De3({ name: "sha2-512", code: 19, encode: ce2("SHA-512") });
var wr2 = Object.freeze({ __proto__: null, sha256: br2, sha512: yr2 });
var he4 = 0;
var Cr2 = "identity";
var le4 = ee2;
var mr2 = (r2) => M(he4, le4(r2));
var vr2 = { code: he4, name: Cr2, encode: le4, digest: mr2 };
var Ar = Object.freeze({ __proto__: null, identity: vr2 });
new TextEncoder(), new TextDecoder();
var de4 = { ...gt3, ...bt3, ...wt2, ...mt3, ..._t3, ...$t2, ...Pt2, ...jt4, ...Jt, ...Zt2 };
({ ...wr2, ...Ar });
function pe2(r2, t2, e2, i3) {
  return { name: r2, prefix: t2, encoder: { name: r2, prefix: t2, encode: e2 }, decoder: { decode: i3 } };
}
var fe3 = pe2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var j2 = pe2("ascii", "a", (r2) => {
  let t2 = "a";
  for (let e2 = 0; e2 < r2.length; e2++)
    t2 += String.fromCharCode(r2[e2]);
  return t2;
}, (r2) => {
  r2 = r2.substring(1);
  const t2 = it3(r2.length);
  for (let e2 = 0; e2 < r2.length; e2++)
    t2[e2] = r2.charCodeAt(e2);
  return t2;
});
var ge2 = { utf8: fe3, "utf-8": fe3, hex: de4.base16, latin1: j2, ascii: j2, binary: j2, ...de4 };
function _r2(r2, t2 = "utf8") {
  const e2 = ge2[t2];
  if (!e2)
    throw new Error(`Unsupported encoding "${t2}"`);
  return (t2 === "utf8" || t2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r2, "utf8") : e2.decoder.decode(`${e2.prefix}${r2}`);
}
function xr2(r2, t2 = "utf8") {
  const e2 = ge2[t2];
  if (!e2)
    throw new Error(`Unsupported encoding "${t2}"`);
  return (t2 === "utf8" || t2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r2.buffer, r2.byteOffset, r2.byteLength).toString("utf8") : e2.encoder.encode(r2).substring(1);
}
var Ee = "base16";
var be = "utf8";
function ye4(r2) {
  const t2 = (0, import_sha2563.hash)(_r2(r2, be));
  return xr2(t2, Ee);
}
var Ir2 = Object.defineProperty;
var Ur = Object.defineProperties;
var Sr2 = Object.getOwnPropertyDescriptors;
var we = Object.getOwnPropertySymbols;
var Or2 = Object.prototype.hasOwnProperty;
var qr = Object.prototype.propertyIsEnumerable;
var Ce3 = (r2, t2, e2) => t2 in r2 ? Ir2(r2, t2, { enumerable: true, configurable: true, writable: true, value: e2 }) : r2[t2] = e2;
var L3 = (r2, t2) => {
  for (var e2 in t2 || (t2 = {}))
    Or2.call(t2, e2) && Ce3(r2, e2, t2[e2]);
  if (we)
    for (var e2 of we(t2))
      qr.call(t2, e2) && Ce3(r2, e2, t2[e2]);
  return r2;
};
var $r = (r2, t2) => Ur(r2, Sr2(t2));
var Br = class extends J3 {
  constructor(t2) {
    super(t2), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.client.core.pairing.register({ methods: Object.keys(R3) }), this.initialized = true);
    }, this.request = async (e2, i3) => {
      if (this.isInitialized(), !tt2(e2))
        throw new Error("Invalid request");
      if (i3 != null && i3.topic)
        return await this.requestOnKnownPairing(i3.topic, e2);
      const { chainId: n2, statement: s, aud: u3, domain: o2, nonce: a2, type: h5 } = e2, { topic: D4, uri: p6 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: D4, uri: p6 } });
      const g5 = await this.client.core.crypto.generateKeyPair(), l2 = Vn2(g5);
      await this.client.authKeys.set(x3, { responseTopic: l2, publicKey: g5 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: D4 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${D4}`);
      const c3 = await this.sendRequest(D4, "wc_authRequest", { payloadParams: { type: h5 ?? "eip4361", chainId: n2, statement: s, aud: u3, domain: o2, version: "1", nonce: a2, iat: new Date().toISOString() }, requester: { publicKey: g5, metadata: this.client.metadata } }, {}, e2.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${D4}`), { uri: p6, id: c3 };
    }, this.respond = async (e2, i3) => {
      if (this.isInitialized(), !rt2(e2, this.client.requests))
        throw new Error("Invalid response");
      const n2 = W4(this.client.requests, e2.id), s = n2.requester.publicKey, u3 = await this.client.core.crypto.generateKeyPair(), o2 = Vn2(s), a2 = { type: _2, receiverPublicKey: s, senderPublicKey: u3 };
      if ("error" in e2) {
        await this.sendError(n2.id, o2, e2, a2);
        return;
      }
      const h5 = { h: { t: "eip4361" }, p: $r(L3({}, n2.cacaoPayload), { iss: i3 }), s: e2.signature }, D4 = await this.sendResult(n2.id, o2, h5, a2);
      await this.client.requests.update(D4, L3({}, h5));
    }, this.getPendingRequests = () => Z3(this.client.requests), this.formatMessage = (e2, i3) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e2)}`);
      const n2 = `${e2.domain} wants you to sign in with your Ethereum account:`, s = Q3(i3), u3 = e2.statement, o2 = `URI: ${e2.aud}`, a2 = `Version: ${e2.version}`, h5 = `Chain ID: ${He3(i3)}`, D4 = `Nonce: ${e2.nonce}`, p6 = `Issued At: ${e2.iat}`, g5 = e2.resources && e2.resources.length > 0 ? `Resources:
${e2.resources.map((l2) => `- ${l2}`).join(`
`)}` : void 0;
      return [n2, s, "", u3, "", o2, a2, h5, D4, p6, g5].filter((l2) => l2 != null).join(`
`);
    }, this.setExpiry = async (e2, i3) => {
      this.client.core.pairing.pairings.keys.includes(e2) && await this.client.core.pairing.updateExpiry({ topic: e2, expiry: i3 }), this.client.core.expirer.set(e2, i3);
    }, this.sendRequest = async (e2, i3, n2, s, u3) => {
      const o2 = formatJsonRpcRequest(i3, n2), a2 = await this.client.core.crypto.encode(e2, o2, s), h5 = R3[i3].req;
      return u3 && (h5.ttl = u3), this.client.core.history.set(e2, o2), await this.client.core.relayer.publish(e2, a2, h5), o2.id;
    }, this.sendResult = async (e2, i3, n2, s) => {
      const u3 = formatJsonRpcResult(e2, n2), o2 = await this.client.core.crypto.encode(i3, u3, s), a2 = await this.client.core.history.get(i3, e2), h5 = R3[a2.request.method].res;
      return await this.client.core.relayer.publish(i3, o2, h5), await this.client.core.history.resolve(u3), u3.id;
    }, this.sendError = async (e2, i3, n2, s) => {
      const u3 = formatJsonRpcError(e2, n2.error), o2 = await this.client.core.crypto.encode(i3, u3, s), a2 = await this.client.core.history.get(i3, e2), h5 = R3[a2.request.method].res;
      return await this.client.core.relayer.publish(i3, o2, h5), await this.client.core.history.resolve(u3), u3.id;
    }, this.requestOnKnownPairing = async (e2, i3) => {
      const n2 = this.client.core.pairing.pairings.getAll({ active: true }).find((l2) => l2.topic === e2);
      if (!n2)
        throw new Error(`Could not find pairing for provided topic ${e2}`);
      const { publicKey: s } = this.client.authKeys.get(x3), { chainId: u3, statement: o2, aud: a2, domain: h5, nonce: D4, type: p6 } = i3, g5 = await this.sendRequest(n2.topic, "wc_authRequest", { payloadParams: { type: p6 ?? "eip4361", chainId: u3, statement: o2, aud: a2, domain: h5, version: "1", nonce: D4, iat: new Date().toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i3.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n2.topic}`), { id: g5 };
    }, this.onRelayEventRequest = (e2) => {
      const { topic: i3, payload: n2 } = e2, s = n2.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i3, n2);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: i3, payload: n2 } = e2, s = (await this.client.core.history.get(i3, n2.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i3, n2);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e2, i3) => {
      const { requester: n2, payloadParams: { resources: s, statement: u3, aud: o2, domain: a2, version: h5, nonce: D4, iat: p6, chainId: g5 } } = i3.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e2, payload: i3 });
      try {
        const l2 = { aud: o2, domain: a2, version: h5, nonce: D4, iat: p6, statement: u3, resources: s, chainId: g5 };
        await this.client.requests.set(i3.id, { requester: n2, pairingTopic: e2, id: i3.id, cacaoPayload: l2 });
        const c3 = ye4(JSON.stringify(i3)), f4 = await this.getVerifyContext(c3, this.client.metadata);
        this.client.emit("auth_request", { id: i3.id, topic: e2, params: { requester: n2, cacaoPayload: l2 }, verifyContext: f4 });
      } catch (l2) {
        await this.sendError(i3.id, e2, l2), this.client.logger.error(l2);
      }
    }, this.onAuthResponse = async (e2, i3) => {
      const { id: n2 } = i3;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e2, response: i3 }), isJsonRpcResult(i3)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e2);
        await this.client.core.pairing.activate({ topic: s });
        const { s: u3, p: o2 } = i3.result;
        await this.client.requests.set(n2, L3({ id: n2, pairingTopic: s }, i3.result));
        const a2 = this.formatMessage(o2, o2.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a2)), this.client.logger.debug("payload.iss:", o2.iss), this.client.logger.debug("signature:", u3);
        const h5 = Q3(o2.iss), D4 = Ye2(o2.iss);
        if (!h5)
          throw new Error("Could not derive address from `payload.iss`");
        if (!D4)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", h5), await Qe2(h5, a2, u3, D4, this.client.projectId) ? this.client.emit("auth_response", { id: n2, topic: e2, params: i3 }) : this.client.emit("auth_response", { id: n2, topic: e2, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i3) && this.client.emit("auth_response", { id: n2, topic: e2, params: i3 });
    }, this.getVerifyContext = async (e2, i3) => {
      const n2 = { verified: { verifyUrl: i3.verifyUrl || "", validation: "UNKNOWN", origin: i3.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e2, verifyUrl: i3.verifyUrl });
        s && (n2.verified.origin = s, n2.verified.validation = s === i3.url ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n2)}`), n2;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t2 } = N3("NOT_INITIALIZED", this.name);
      throw new Error(t2);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (t2) => {
      const { topic: e2, message: i3 } = t2, { responseTopic: n2, publicKey: s } = this.client.authKeys.keys.includes(x3) ? this.client.authKeys.get(x3) : { responseTopic: void 0, publicKey: void 0 };
      if (n2 && e2 !== n2) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e2);
        return;
      }
      const u3 = await this.client.core.crypto.decode(e2, i3, { receiverPublicKey: s });
      isJsonRpcRequest(u3) ? (this.client.core.history.set(e2, u3), this.onRelayEventRequest({ topic: e2, payload: u3 })) : isJsonRpcResponse(u3) && (await this.client.core.history.resolve(u3), this.onRelayEventResponse({ topic: e2, payload: u3 }));
    });
  }
};
var O = class extends X3 {
  constructor(t2) {
    super(t2), this.protocol = B2, this.version = H3, this.name = N4, this.events = new import_events5.EventEmitter(), this.emit = (i3, n2) => this.events.emit(i3, n2), this.on = (i3, n2) => this.events.on(i3, n2), this.once = (i3, n2) => this.events.once(i3, n2), this.off = (i3, n2) => this.events.off(i3, n2), this.removeListener = (i3, n2) => this.events.removeListener(i3, n2), this.request = async (i3, n2) => {
      try {
        return await this.engine.request(i3, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i3, n2) => {
      try {
        return await this.engine.respond(i3, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatMessage = (i3, n2) => {
      try {
        return this.engine.formatMessage(i3, n2);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e2 = typeof t2.logger < "u" && typeof t2.logger != "string" ? t2.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: t2.logger || "error" }));
    this.name = t2?.name || N4, this.metadata = t2.metadata, this.projectId = t2.projectId, this.core = t2.core || new xr(t2), this.logger = (0, import_logger2.generateChildLogger)(e2, this.name), this.authKeys = new Ut(this.core, this.logger, "authKeys", F2, () => x3), this.pairingTopics = new Ut(this.core, this.logger, "pairingTopics", F2), this.requests = new Ut(this.core, this.logger, "requests", F2), this.engine = new Br(this);
  }
  static async init(t2) {
    const e2 = new O(t2);
    return await e2.initialize(), e2;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t2) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t2.message), t2;
    }
  }
};
var Nr = O;

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger3 = __toESM(require_cjs6());

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/types/dist/index.es.js
init_esm3();
var import_events7 = __toESM(require_events());
var b = class {
  constructor(s) {
    this.opts = s, this.protocol = "wc", this.version = 2;
  }
};
var S2 = class {
  constructor(s) {
    this.client = s;
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/utils/dist/index.es.js
var import_chacha20poly13053 = __toESM(require_chacha20poly1305());
var import_hkdf3 = __toESM(require_hkdf());
var import_random4 = __toESM(require_random());
var import_sha2564 = __toESM(require_sha256());
var fe4 = __toESM(require_x25519());
var import_time5 = __toESM(require_cjs2());
var import_window_getters3 = __toESM(require_cjs3());
var import_window_metadata3 = __toESM(require_cjs4());
var k3 = __toESM(require_query_string6());
function M2(e2, n2) {
  return e2.includes(":") ? [e2] : n2.chains || [];
}
var p4 = "base16";
var x4 = "utf8";
var _3 = 1;
function Mn2(e2) {
  const n2 = (0, import_sha2564.hash)(fromString(e2, x4));
  return toString(n2, p4);
}
var Ce4 = "ReactNative";
var m2 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
function te3() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function H4() {
  return !(0, import_window_getters3.getDocument)() && !!(0, import_window_getters3.getNavigator)() && navigator.product === Ce4;
}
function q3() {
  return !te3() && !!(0, import_window_getters3.getNavigator)();
}
function R4() {
  return H4() ? m2.reactNative : te3() ? m2.node : q3() ? m2.browser : m2.unknown;
}
function zn() {
  return (0, import_window_metadata3.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function O2(e2, n2) {
  return e2.filter((t2) => n2.includes(t2)).length === e2.length;
}
function st5(e2 = import_time5.FIVE_MINUTES, n2) {
  const t2 = (0, import_time5.toMiliseconds)(e2 || import_time5.FIVE_MINUTES);
  let r2, o2, s;
  return { resolve: (i3) => {
    s && r2 && (clearTimeout(s), r2(i3));
  }, reject: (i3) => {
    s && o2 && (clearTimeout(s), o2(i3));
  }, done: () => new Promise((i3, l2) => {
    s = setTimeout(() => {
      l2(new Error(n2));
    }, t2), r2 = i3, o2 = l2;
  }) };
}
function ut4(e2) {
  const [n2, t2] = e2.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n2 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t2}`);
  return r2;
}
function lt4(e2, n2) {
  return (0, import_time5.fromMiliseconds)((n2 || Date.now()) + (0, import_time5.toMiliseconds)(e2));
}
function dt4(e2) {
  return Date.now() >= (0, import_time5.toMiliseconds)(e2);
}
function ft4(e2, n2) {
  return `${e2}${n2 ? `:${n2}` : ""}`;
}
async function pt3({ id: e2, topic: n2, wcDeepLink: t2 }) {
  try {
    if (!t2)
      return;
    const r2 = typeof t2 == "string" ? JSON.parse(t2) : t2;
    let o2 = r2?.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e2}&sessionTopic=${n2}`, i3 = R4();
    i3 === m2.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i3 === m2.reactNative && typeof (globalThis == null ? void 0 : globalThis.Linking) < "u" && await globalThis.Linking.openURL(s);
  } catch (r2) {
    console.error(r2);
  }
}
function A(e2) {
  const n2 = [];
  return e2.forEach((t2) => {
    const [r2, o2] = t2.split(":");
    n2.push(`${r2}:${o2}`);
  }), n2;
}
function Je3(e2) {
  const n2 = [];
  return Object.values(e2).forEach((t2) => {
    n2.push(...A(t2.accounts));
  }), n2;
}
function Qe3(e2, n2) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.methods);
  }), t2;
}
function Ze3(e2, n2) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.events);
  }), t2;
}
function At3(e2, n2) {
  const t2 = cn(e2, n2);
  if (t2)
    throw new Error(t2.message);
  const r2 = {};
  for (const [o2, s] of Object.entries(e2))
    r2[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i3) => `${i3.split(":")[0]}:${i3.split(":")[1]}`) };
  return r2;
}
var _t4 = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Ct5 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N5(e2, n2) {
  const { message: t2, code: r2 } = Ct5[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function U4(e2, n2) {
  const { message: t2, code: r2 } = _t4[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function j3(e2, n2) {
  return Array.isArray(e2) ? typeof n2 < "u" && e2.length ? e2.every(n2) : true : false;
}
function B3(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
function w4(e2) {
  return typeof e2 > "u";
}
function h4(e2, n2) {
  return n2 && w4(e2) ? true : typeof e2 == "string" && !!e2.trim().length;
}
function G3(e2, n2) {
  return n2 && w4(e2) ? true : typeof e2 == "number" && !isNaN(e2);
}
function $t3(e2, n2) {
  const { requiredNamespaces: t2 } = n2, r2 = Object.keys(e2.namespaces), o2 = Object.keys(t2);
  let s = true;
  return O2(o2, r2) ? (r2.forEach((i3) => {
    const { accounts: l2, methods: d4, events: c3 } = e2.namespaces[i3], u3 = A(l2), a2 = t2[i3];
    (!O2(M2(i3, a2), u3) || !O2(a2.methods, d4) || !O2(a2.events, c3)) && (s = false);
  }), s) : false;
}
function D2(e2) {
  return h4(e2, false) && e2.includes(":") ? e2.split(":").length === 2 : false;
}
function en(e2) {
  if (h4(e2, false) && e2.includes(":")) {
    const n2 = e2.split(":");
    if (n2.length === 3) {
      const t2 = n2[0] + ":" + n2[1];
      return !!n2[2] && D2(t2);
    }
  }
  return false;
}
function Vt3(e2, n2) {
  let t2 = null;
  return h4(e2?.publicKey, false) || (t2 = N5("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t2;
}
function ie2(e2) {
  let n2 = true;
  return j3(e2) ? e2.length && (n2 = e2.every((t2) => h4(t2, false))) : n2 = false, n2;
}
function nn(e2, n2, t2) {
  let r2 = null;
  return j3(n2) && n2.length ? n2.forEach((o2) => {
    r2 || D2(o2) || (r2 = U4("UNSUPPORTED_CHAINS", `${t2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : D2(e2) || (r2 = U4("UNSUPPORTED_CHAINS", `${t2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function tn(e2, n2, t2) {
  let r2 = null;
  return Object.entries(e2).forEach(([o2, s]) => {
    if (r2)
      return;
    const i3 = nn(o2, M2(o2, s), `${n2} ${t2}`);
    i3 && (r2 = i3);
  }), r2;
}
function rn(e2, n2) {
  let t2 = null;
  return j3(e2) ? e2.forEach((r2) => {
    t2 || en(r2) || (t2 = U4("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : t2 = U4("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t2;
}
function on(e2, n2) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = rn(r2?.accounts, `${n2} namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function sn(e2, n2) {
  let t2 = null;
  return ie2(e2?.methods) ? ie2(e2?.events) || (t2 = U4("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t2 = U4("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t2;
}
function ce3(e2, n2) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = sn(r2, `${n2}, namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function Mt3(e2, n2, t2) {
  let r2 = null;
  if (e2 && B3(e2)) {
    const o2 = ce3(e2, n2);
    o2 && (r2 = o2);
    const s = tn(e2, n2, t2);
    s && (r2 = s);
  } else
    r2 = N5("MISSING_OR_INVALID", `${n2}, ${t2} should be an object with data`);
  return r2;
}
function cn(e2, n2) {
  let t2 = null;
  if (e2 && B3(e2)) {
    const r2 = ce3(e2, n2);
    r2 && (t2 = r2);
    const o2 = on(e2, n2);
    o2 && (t2 = o2);
  } else
    t2 = N5("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t2;
}
function an(e2) {
  return h4(e2.protocol, true);
}
function Kt3(e2, n2) {
  let t2 = false;
  return n2 && !e2 ? t2 = true : e2 && j3(e2) && e2.length && e2.forEach((r2) => {
    t2 = an(r2);
  }), t2;
}
function Lt3(e2) {
  return typeof e2 == "number";
}
function xt4(e2) {
  return typeof e2 < "u" && typeof e2 !== null;
}
function Ft3(e2) {
  return !(!e2 || typeof e2 != "object" || !e2.code || !G3(e2.code, false) || !e2.message || !h4(e2.message, false));
}
function Ht2(e2) {
  return !(w4(e2) || !h4(e2.method, false));
}
function qt3(e2) {
  return !(w4(e2) || w4(e2.result) && w4(e2.error) || !G3(e2.id, false) || !h4(e2.jsonrpc, false));
}
function Bt3(e2) {
  return !(w4(e2) || !h4(e2.name, false));
}
function Gt2(e2, n2) {
  return !(!D2(n2) || !Je3(e2).includes(n2));
}
function Wt2(e2, n2, t2) {
  return h4(t2, false) ? Qe3(e2, n2).includes(t2) : false;
}
function zt3(e2, n2, t2) {
  return h4(t2, false) ? Ze3(e2, n2).includes(t2) : false;
}
function un(e2, n2, t2) {
  let r2 = null;
  const o2 = Yt3(e2), s = Jt2(n2), i3 = Object.keys(o2), l2 = Object.keys(s), d4 = ln(Object.keys(e2)), c3 = ln(Object.keys(n2)), u3 = d4.filter((a2) => !c3.includes(a2));
  return u3.length && (r2 = N5("NON_CONFORMING_NAMESPACES", `${t2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u3.toString()}
      Received: ${Object.keys(n2).toString()}`)), O2(i3, l2) || (r2 = N5("NON_CONFORMING_NAMESPACES", `${t2} namespaces chains don't satisfy required namespaces.
      Required: ${i3.toString()}
      Approved: ${l2.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r2)
      return;
    const b4 = A(n2[a2].accounts);
    b4.includes(a2) || (r2 = N5("NON_CONFORMING_NAMESPACES", `${t2} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b4.toString()}`));
  }), i3.forEach((a2) => {
    r2 || (O2(o2[a2].methods, s[a2].methods) ? O2(o2[a2].events, s[a2].events) || (r2 = N5("NON_CONFORMING_NAMESPACES", `${t2} namespaces events don't satisfy namespace events for ${a2}`)) : r2 = N5("NON_CONFORMING_NAMESPACES", `${t2} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r2;
}
function Yt3(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t2) => {
    var r2;
    t2.includes(":") ? n2[t2] = e2[t2] : (r2 = e2[t2].chains) == null || r2.forEach((o2) => {
      n2[o2] = { methods: e2[t2].methods, events: e2[t2].events };
    });
  }), n2;
}
function ln(e2) {
  return [...new Set(e2.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function Jt2(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t2) => {
    if (t2.includes(":"))
      n2[t2] = e2[t2];
    else {
      const r2 = A(e2[t2].accounts);
      r2?.forEach((o2) => {
        n2[o2] = { accounts: e2[t2].accounts.filter((s) => s.includes(`${o2}:`)), methods: e2[t2].methods, events: e2[t2].events };
      });
    }
  }), n2;
}
function Qt3(e2, n2) {
  return G3(e2, false) && e2 <= n2.max && e2 >= n2.min;
}
var ae3 = {};
var er3 = class {
  static get(n2) {
    return ae3[n2];
  }
  static set(n2, t2) {
    ae3[n2] = t2;
  }
  static delete(n2) {
    delete ae3[n2];
  }
};

// node_modules/@walletconnect/web3wallet/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time6 = __toESM(require_cjs2());
var J4 = "wc";
var X4 = 2;
var F3 = "client";
var G4 = `${J4}@${X4}:${F3}:`;
var M3 = { name: F3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var H6 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ne2 = "proposal";
var oe3 = "Proposal expired";
var ae4 = "session";
var C2 = import_time6.SEVEN_DAYS;
var ce4 = "engine";
var V = { wc_sessionPropose: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time6.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time6.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time6.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time6.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var U5 = { min: import_time6.FIVE_MINUTES, max: import_time6.SEVEN_DAYS };
var E3 = { idle: "IDLE", active: "ACTIVE" };
var le6 = "request";
var pe3 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var rs2 = Object.defineProperty;
var ns2 = Object.defineProperties;
var os2 = Object.getOwnPropertyDescriptors;
var he6 = Object.getOwnPropertySymbols;
var as2 = Object.prototype.hasOwnProperty;
var cs2 = Object.prototype.propertyIsEnumerable;
var de6 = (m4, r2, e2) => r2 in m4 ? rs2(m4, r2, { enumerable: true, configurable: true, writable: true, value: e2 }) : m4[r2] = e2;
var g3 = (m4, r2) => {
  for (var e2 in r2 || (r2 = {}))
    as2.call(r2, e2) && de6(m4, e2, r2[e2]);
  if (he6)
    for (var e2 of he6(r2))
      cs2.call(r2, e2) && de6(m4, e2, r2[e2]);
  return m4;
};
var b2 = (m4, r2) => ns2(m4, os2(r2));
var ls2 = class extends S2 {
  constructor(r2) {
    super(r2), this.name = ce4, this.events = new import_events8.default(), this.initialized = false, this.ignoredPayloadTypes = [_3], this.requestQueue = { state: E3.idle, queue: [] }, this.sessionRequestQueue = { state: E3.idle, queue: [] }, this.requestQueueDelay = import_time6.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(V) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e2) => {
      await this.isInitialized();
      const s = b2(g3({}, e2), { requiredNamespaces: e2.requiredNamespaces || {}, optionalNamespaces: e2.optionalNamespaces || {} });
      await this.isValidConnect(s);
      const { pairingTopic: t2, requiredNamespaces: i3, optionalNamespaces: n2, sessionProperties: o2, relays: a2 } = s;
      let l2 = t2, p6, d4 = false;
      if (l2 && (d4 = this.client.core.pairing.pairings.get(l2).active), !l2 || !d4) {
        const { topic: v, uri: S4 } = await this.client.core.pairing.create();
        l2 = v, p6 = S4;
      }
      const h5 = await this.client.core.crypto.generateKeyPair(), I2 = g3({ requiredNamespaces: i3, optionalNamespaces: n2, relays: a2 ?? [{ protocol: at3 }], proposer: { publicKey: h5, metadata: this.client.metadata } }, o2 && { sessionProperties: o2 }), { reject: w6, resolve: T3, done: K3 } = st5(import_time6.FIVE_MINUTES, oe3);
      if (this.events.once(ft4("session_connect"), async ({ error: v, session: S4 }) => {
        if (v)
          w6(v);
        else if (S4) {
          S4.self.publicKey = h5;
          const W7 = b2(g3({}, S4), { requiredNamespaces: S4.requiredNamespaces, optionalNamespaces: S4.optionalNamespaces });
          await this.client.session.set(S4.topic, W7), await this.setExpiry(S4.topic, S4.expiry), l2 && await this.client.core.pairing.updateMetadata({ topic: l2, metadata: S4.peer.metadata }), T3(W7);
        }
      }), !l2) {
        const { message: v } = N5("NO_MATCHING_KEY", `connect() pairing topic: ${l2}`);
        throw new Error(v);
      }
      const L5 = await this.sendRequest({ topic: l2, method: "wc_sessionPropose", params: I2 }), ue7 = lt4(import_time6.FIVE_MINUTES);
      return await this.setProposal(L5, g3({ id: L5, expiry: ue7 }, I2)), { uri: p6, approval: K3 };
    }, this.pair = async (e2) => (await this.isInitialized(), await this.client.core.pairing.pair(e2)), this.approve = async (e2) => {
      await this.isInitialized(), await this.isValidApprove(e2);
      const { id: s, relayProtocol: t2, namespaces: i3, sessionProperties: n2 } = e2, o2 = this.client.proposal.get(s);
      let { pairingTopic: a2, proposer: l2, requiredNamespaces: p6, optionalNamespaces: d4 } = o2;
      a2 = a2 || "", B3(p6) || (p6 = At3(i3, "approve()"));
      const h5 = await this.client.core.crypto.generateKeyPair(), I2 = l2.publicKey, w6 = await this.client.core.crypto.generateSharedKey(h5, I2);
      a2 && s && (await this.client.core.pairing.updateMetadata({ topic: a2, metadata: l2.metadata }), await this.sendResult({ id: s, topic: a2, result: { relay: { protocol: t2 ?? "irn" }, responderPublicKey: h5 } }), await this.client.proposal.delete(s, U4("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a2 }));
      const T3 = g3({ relay: { protocol: t2 ?? "irn" }, namespaces: i3, requiredNamespaces: p6, optionalNamespaces: d4, pairingTopic: a2, controller: { publicKey: h5, metadata: this.client.metadata }, expiry: lt4(C2) }, n2 && { sessionProperties: n2 });
      await this.client.core.relayer.subscribe(w6), await this.sendRequest({ topic: w6, method: "wc_sessionSettle", params: T3, throwOnFailedPublish: true });
      const K3 = b2(g3({}, T3), { topic: w6, pairingTopic: a2, acknowledged: false, self: T3.controller, peer: { publicKey: l2.publicKey, metadata: l2.metadata }, controller: h5 });
      return await this.client.session.set(w6, K3), await this.setExpiry(w6, lt4(C2)), { topic: w6, acknowledged: () => new Promise((L5) => setTimeout(() => L5(this.client.session.get(w6)), 500)) };
    }, this.reject = async (e2) => {
      await this.isInitialized(), await this.isValidReject(e2);
      const { id: s, reason: t2 } = e2, { pairingTopic: i3 } = this.client.proposal.get(s);
      i3 && (await this.sendError(s, i3, t2), await this.client.proposal.delete(s, U4("USER_DISCONNECTED")));
    }, this.update = async (e2) => {
      await this.isInitialized(), await this.isValidUpdate(e2);
      const { topic: s, namespaces: t2 } = e2, i3 = await this.sendRequest({ topic: s, method: "wc_sessionUpdate", params: { namespaces: t2 } }), { done: n2, resolve: o2, reject: a2 } = st5();
      return this.events.once(ft4("session_update", i3), ({ error: l2 }) => {
        l2 ? a2(l2) : o2();
      }), await this.client.session.update(s, { namespaces: t2 }), { acknowledged: n2 };
    }, this.extend = async (e2) => {
      await this.isInitialized(), await this.isValidExtend(e2);
      const { topic: s } = e2, t2 = await this.sendRequest({ topic: s, method: "wc_sessionExtend", params: {} }), { done: i3, resolve: n2, reject: o2 } = st5();
      return this.events.once(ft4("session_extend", t2), ({ error: a2 }) => {
        a2 ? o2(a2) : n2();
      }), await this.setExpiry(s, lt4(C2)), { acknowledged: i3 };
    }, this.request = async (e2) => {
      await this.isInitialized(), await this.isValidRequest(e2);
      const { chainId: s, request: t2, topic: i3, expiry: n2 } = e2, o2 = payloadId(), { done: a2, resolve: l2, reject: p6 } = st5(n2);
      return this.events.once(ft4("session_request", o2), ({ error: d4, result: h5 }) => {
        d4 ? p6(d4) : l2(h5);
      }), await Promise.all([new Promise(async (d4) => {
        await this.sendRequest({ clientRpcId: o2, topic: i3, method: "wc_sessionRequest", params: { request: t2, chainId: s }, expiry: n2, throwOnFailedPublish: true }).catch((h5) => p6(h5)), this.client.events.emit("session_request_sent", { topic: i3, request: t2, chainId: s, id: o2 }), d4();
      }), new Promise(async (d4) => {
        const h5 = await this.client.core.storage.getItem(H6);
        pt3({ id: o2, topic: i3, wcDeepLink: h5 }), d4();
      }), a2()]).then((d4) => d4[2]);
    }, this.respond = async (e2) => {
      await this.isInitialized(), await this.isValidRespond(e2);
      const { topic: s, response: t2 } = e2, { id: i3 } = t2;
      isJsonRpcResult(t2) ? await this.sendResult({ id: i3, topic: s, result: t2.result, throwOnFailedPublish: true }) : isJsonRpcError(t2) && await this.sendError(i3, s, t2.error), this.cleanupAfterResponse(e2);
    }, this.ping = async (e2) => {
      await this.isInitialized(), await this.isValidPing(e2);
      const { topic: s } = e2;
      if (this.client.session.keys.includes(s)) {
        const t2 = await this.sendRequest({ topic: s, method: "wc_sessionPing", params: {} }), { done: i3, resolve: n2, reject: o2 } = st5();
        this.events.once(ft4("session_ping", t2), ({ error: a2 }) => {
          a2 ? o2(a2) : n2();
        }), await i3();
      } else
        this.client.core.pairing.pairings.keys.includes(s) && await this.client.core.pairing.ping({ topic: s });
    }, this.emit = async (e2) => {
      await this.isInitialized(), await this.isValidEmit(e2);
      const { topic: s, event: t2, chainId: i3 } = e2;
      await this.sendRequest({ topic: s, method: "wc_sessionEvent", params: { event: t2, chainId: i3 } });
    }, this.disconnect = async (e2) => {
      await this.isInitialized(), await this.isValidDisconnect(e2);
      const { topic: s } = e2;
      this.client.session.keys.includes(s) ? (await this.sendRequest({ topic: s, method: "wc_sessionDelete", params: U4("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({ topic: s });
    }, this.find = (e2) => (this.isInitialized(), this.client.session.getAll().filter((s) => $t3(s, e2))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e2) => {
      if (e2.pairingTopic)
        try {
          const s = this.client.core.pairing.pairings.get(e2.pairingTopic), t2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
            var n2, o2;
            return ((n2 = i3.peerMetadata) == null ? void 0 : n2.url) && ((o2 = i3.peerMetadata) == null ? void 0 : o2.url) === e2.peer.metadata.url && i3.topic && i3.topic !== s.topic;
          });
          if (t2.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t2.length} duplicate pairing(s)`), await Promise.all(t2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s) {
          this.client.logger.error(s);
        }
    }, this.deleteSession = async (e2, s) => {
      const { self: t2 } = this.client.session.get(e2);
      await this.client.core.relayer.unsubscribe(e2), this.client.session.delete(e2, U4("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t2.publicKey) && await this.client.core.crypto.deleteKeyPair(t2.publicKey), this.client.core.crypto.keychain.has(e2) && await this.client.core.crypto.deleteSymKey(e2), s || this.client.core.expirer.del(e2), this.client.core.storage.removeItem(H6).catch((i3) => this.client.logger.warn(i3));
    }, this.deleteProposal = async (e2, s) => {
      await Promise.all([this.client.proposal.delete(e2, U4("USER_DISCONNECTED")), s ? Promise.resolve() : this.client.core.expirer.del(e2)]);
    }, this.deletePendingSessionRequest = async (e2, s, t2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e2, s), t2 ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e2), t2 && (this.sessionRequestQueue.state = E3.idle);
    }, this.setExpiry = async (e2, s) => {
      this.client.session.keys.includes(e2) && await this.client.session.update(e2, { expiry: s }), this.client.core.expirer.set(e2, s);
    }, this.setProposal = async (e2, s) => {
      await this.client.proposal.set(e2, s), this.client.core.expirer.set(e2, s.expiry);
    }, this.setPendingSessionRequest = async (e2) => {
      const s = V.wc_sessionRequest.req.ttl, { id: t2, topic: i3, params: n2 } = e2;
      await this.client.pendingRequest.set(t2, { id: t2, topic: i3, params: n2 }), s && this.client.core.expirer.set(t2, lt4(s));
    }, this.sendRequest = async (e2) => {
      const { topic: s, method: t2, params: i3, expiry: n2, relayRpcId: o2, clientRpcId: a2, throwOnFailedPublish: l2 } = e2, p6 = formatJsonRpcRequest(t2, i3, a2);
      if (q3() && pe3.includes(t2)) {
        const I2 = Mn2(JSON.stringify(p6));
        this.client.core.verify.register({ attestationId: I2 });
      }
      const d4 = await this.client.core.crypto.encode(s, p6), h5 = V[t2].req;
      return n2 && (h5.ttl = n2), o2 && (h5.id = o2), this.client.core.history.set(s, p6), l2 ? (h5.internal = b2(g3({}, h5.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, d4, h5)) : this.client.core.relayer.publish(s, d4, h5).catch((I2) => this.client.logger.error(I2)), p6.id;
    }, this.sendResult = async (e2) => {
      const { id: s, topic: t2, result: i3, throwOnFailedPublish: n2 } = e2, o2 = formatJsonRpcResult(s, i3), a2 = await this.client.core.crypto.encode(t2, o2), l2 = await this.client.core.history.get(t2, s), p6 = V[l2.request.method].res;
      n2 ? (p6.internal = b2(g3({}, p6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t2, a2, p6)) : this.client.core.relayer.publish(t2, a2, p6).catch((d4) => this.client.logger.error(d4)), await this.client.core.history.resolve(o2);
    }, this.sendError = async (e2, s, t2) => {
      const i3 = formatJsonRpcError(e2, t2), n2 = await this.client.core.crypto.encode(s, i3), o2 = await this.client.core.history.get(s, e2), a2 = V[o2.request.method].res;
      this.client.core.relayer.publish(s, n2, a2), await this.client.core.history.resolve(i3);
    }, this.cleanup = async () => {
      const e2 = [], s = [];
      this.client.session.getAll().forEach((t2) => {
        dt4(t2.expiry) && e2.push(t2.topic);
      }), this.client.proposal.getAll().forEach((t2) => {
        dt4(t2.expiry) && s.push(t2.id);
      }), await Promise.all([...e2.map((t2) => this.deleteSession(t2)), ...s.map((t2) => this.deleteProposal(t2))]);
    }, this.onRelayEventRequest = async (e2) => {
      this.requestQueue.queue.push(e2), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === E3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = E3.active;
        const e2 = this.requestQueue.queue.shift();
        if (e2)
          try {
            this.processRequest(e2), await new Promise((s) => setTimeout(s, 300));
          } catch (s) {
            this.client.logger.warn(s);
          }
      }
      this.requestQueue.state = E3.idle;
    }, this.processRequest = (e2) => {
      const { topic: s, payload: t2 } = e2, i3 = t2.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s, t2);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s, t2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s, t2);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s, t2);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s, t2);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s, t2);
        case "wc_sessionRequest":
          return this.onSessionRequest(s, t2);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s, t2);
        default:
          return this.client.logger.info(`Unsupported request method ${i3}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: s, payload: t2 } = e2, i3 = (await this.client.core.history.get(s, t2.id)).request.method;
      switch (i3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s, t2);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s, t2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s, t2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s, t2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s, t2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s, t2);
        default:
          return this.client.logger.info(`Unsupported response method ${i3}`);
      }
    }, this.onRelayEventUnknownPayload = (e2) => {
      const { topic: s } = e2, { message: t2 } = N5("MISSING_OR_INVALID", `Decoded payload on topic ${s} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t2);
    }, this.onSessionProposeRequest = async (e2, s) => {
      const { params: t2, id: i3 } = s;
      try {
        this.isValidConnect(g3({}, s.params));
        const n2 = lt4(import_time6.FIVE_MINUTES), o2 = g3({ id: i3, pairingTopic: e2, expiry: n2 }, t2);
        await this.setProposal(i3, o2);
        const a2 = Mn2(JSON.stringify(s)), l2 = await this.getVerifyContext(a2, o2.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i3, params: o2, verifyContext: l2 });
      } catch (n2) {
        await this.sendError(i3, e2, n2), this.client.logger.error(n2);
      }
    }, this.onSessionProposeResponse = async (e2, s) => {
      const { id: t2 } = s;
      if (isJsonRpcResult(s)) {
        const { result: i3 } = s;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i3 });
        const n2 = this.client.proposal.get(t2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n2 });
        const o2 = n2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o2 });
        const a2 = i3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a2 });
        const l2 = await this.client.core.crypto.generateSharedKey(o2, a2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: l2 });
        const p6 = await this.client.core.relayer.subscribe(l2);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p6 }), await this.client.core.pairing.activate({ topic: e2 });
      } else
        isJsonRpcError(s) && (await this.client.proposal.delete(t2, U4("USER_DISCONNECTED")), this.events.emit(ft4("session_connect"), { error: s.error }));
    }, this.onSessionSettleRequest = async (e2, s) => {
      const { id: t2, params: i3 } = s;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: n2, controller: o2, expiry: a2, namespaces: l2, requiredNamespaces: p6, optionalNamespaces: d4, sessionProperties: h5, pairingTopic: I2 } = s.params, w6 = g3({ topic: e2, relay: n2, expiry: a2, namespaces: l2, acknowledged: true, pairingTopic: I2, requiredNamespaces: p6, optionalNamespaces: d4, controller: o2.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, h5 && { sessionProperties: h5 });
        await this.sendResult({ id: s.id, topic: e2, result: true }), this.events.emit(ft4("session_connect"), { session: w6 }), this.cleanupDuplicatePairings(w6);
      } catch (n2) {
        await this.sendError(t2, e2, n2), this.client.logger.error(n2);
      }
    }, this.onSessionSettleResponse = async (e2, s) => {
      const { id: t2 } = s;
      isJsonRpcResult(s) ? (await this.client.session.update(e2, { acknowledged: true }), this.events.emit(ft4("session_approve", t2), {})) : isJsonRpcError(s) && (await this.client.session.delete(e2, U4("USER_DISCONNECTED")), this.events.emit(ft4("session_approve", t2), { error: s.error }));
    }, this.onSessionUpdateRequest = async (e2, s) => {
      const { params: t2, id: i3 } = s;
      try {
        const n2 = `${e2}_session_update`, o2 = er3.get(n2);
        if (o2 && this.isRequestOutOfSync(o2, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`);
          return;
        }
        this.isValidUpdate(g3({ topic: e2 }, t2)), await this.client.session.update(e2, { namespaces: t2.namespaces }), await this.sendResult({ id: i3, topic: e2, result: true }), this.client.events.emit("session_update", { id: i3, topic: e2, params: t2 }), er3.set(n2, i3);
      } catch (n2) {
        await this.sendError(i3, e2, n2), this.client.logger.error(n2);
      }
    }, this.isRequestOutOfSync = (e2, s) => parseInt(s.toString().slice(0, -3)) <= parseInt(e2.toString().slice(0, -3)), this.onSessionUpdateResponse = (e2, s) => {
      const { id: t2 } = s;
      isJsonRpcResult(s) ? this.events.emit(ft4("session_update", t2), {}) : isJsonRpcError(s) && this.events.emit(ft4("session_update", t2), { error: s.error });
    }, this.onSessionExtendRequest = async (e2, s) => {
      const { id: t2 } = s;
      try {
        this.isValidExtend({ topic: e2 }), await this.setExpiry(e2, lt4(C2)), await this.sendResult({ id: t2, topic: e2, result: true }), this.client.events.emit("session_extend", { id: t2, topic: e2 });
      } catch (i3) {
        await this.sendError(t2, e2, i3), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e2, s) => {
      const { id: t2 } = s;
      isJsonRpcResult(s) ? this.events.emit(ft4("session_extend", t2), {}) : isJsonRpcError(s) && this.events.emit(ft4("session_extend", t2), { error: s.error });
    }, this.onSessionPingRequest = async (e2, s) => {
      const { id: t2 } = s;
      try {
        this.isValidPing({ topic: e2 }), await this.sendResult({ id: t2, topic: e2, result: true }), this.client.events.emit("session_ping", { id: t2, topic: e2 });
      } catch (i3) {
        await this.sendError(t2, e2, i3), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e2, s) => {
      const { id: t2 } = s;
      setTimeout(() => {
        isJsonRpcResult(s) ? this.events.emit(ft4("session_ping", t2), {}) : isJsonRpcError(s) && this.events.emit(ft4("session_ping", t2), { error: s.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e2, s) => {
      const { id: t2 } = s;
      try {
        this.isValidDisconnect({ topic: e2, reason: s.params }), await Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(D.publish, async () => {
            i3(await this.deleteSession(e2));
          });
        }), this.sendResult({ id: t2, topic: e2, result: true })]), this.client.events.emit("session_delete", { id: t2, topic: e2 });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e2, s) => {
      const { id: t2, params: i3 } = s;
      try {
        this.isValidRequest(g3({ topic: e2 }, i3)), await this.setPendingSessionRequest({ id: t2, topic: e2, params: i3 }), this.addSessionRequestToSessionRequestQueue({ id: t2, topic: e2, params: i3 }), await this.processSessionRequestQueue();
      } catch (n2) {
        await this.sendError(t2, e2, n2), this.client.logger.error(n2);
      }
    }, this.onSessionRequestResponse = (e2, s) => {
      const { id: t2 } = s;
      isJsonRpcResult(s) ? this.events.emit(ft4("session_request", t2), { result: s.result }) : isJsonRpcError(s) && this.events.emit(ft4("session_request", t2), { error: s.error });
    }, this.onSessionEventRequest = async (e2, s) => {
      const { id: t2, params: i3 } = s;
      try {
        const n2 = `${e2}_session_event_${i3.event.name}`, o2 = er3.get(n2);
        if (o2 && this.isRequestOutOfSync(o2, t2)) {
          this.client.logger.info(`Discarding out of sync request - ${t2}`);
          return;
        }
        this.isValidEmit(g3({ topic: e2 }, i3)), this.client.events.emit("session_event", { id: t2, topic: e2, params: i3 }), er3.set(n2, t2);
      } catch (n2) {
        await this.sendError(t2, e2, n2), this.client.logger.error(n2);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e2) => {
      this.sessionRequestQueue.queue.push(e2);
    }, this.cleanupAfterResponse = (e2) => {
      this.deletePendingSessionRequest(e2.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = E3.idle, this.processSessionRequestQueue();
      }, (0, import_time6.toMiliseconds)(this.requestQueueDelay));
    }, this.processSessionRequestQueue = async () => {
      if (this.sessionRequestQueue.state === E3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e2 = this.sessionRequestQueue.queue[0];
      if (!e2) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        const { id: s, topic: t2, params: i3 } = e2, n2 = Mn2(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i3, s))), o2 = this.client.session.get(t2), a2 = await this.getVerifyContext(n2, o2.peer.metadata);
        this.sessionRequestQueue.state = E3.active, this.client.events.emit("session_request", { id: s, topic: t2, params: i3, verifyContext: a2 });
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.isValidConnect = async (e2) => {
      if (!xt4(e2)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e2)}`);
        throw new Error(a2);
      }
      const { pairingTopic: s, requiredNamespaces: t2, optionalNamespaces: i3, sessionProperties: n2, relays: o2 } = e2;
      if (w4(s) || await this.isValidPairingTopic(s), !Kt3(o2, true)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `connect() relays: ${o2}`);
        throw new Error(a2);
      }
      !w4(t2) && B3(t2) !== 0 && this.validateNamespaces(t2, "requiredNamespaces"), !w4(i3) && B3(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), w4(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.validateNamespaces = (e2, s) => {
      const t2 = Mt3(e2, "connect()", s);
      if (t2)
        throw new Error(t2.message);
    }, this.isValidApprove = async (e2) => {
      if (!xt4(e2))
        throw new Error(N5("MISSING_OR_INVALID", `approve() params: ${e2}`).message);
      const { id: s, namespaces: t2, relayProtocol: i3, sessionProperties: n2 } = e2;
      await this.isValidProposalId(s);
      const o2 = this.client.proposal.get(s), a2 = cn(t2, "approve()");
      if (a2)
        throw new Error(a2.message);
      const l2 = un(o2.requiredNamespaces, t2, "approve()");
      if (l2)
        throw new Error(l2.message);
      if (!h4(i3, true)) {
        const { message: p6 } = N5("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(p6);
      }
      w4(n2) || this.validateSessionProps(n2, "sessionProperties");
    }, this.isValidReject = async (e2) => {
      if (!xt4(e2)) {
        const { message: i3 } = N5("MISSING_OR_INVALID", `reject() params: ${e2}`);
        throw new Error(i3);
      }
      const { id: s, reason: t2 } = e2;
      if (await this.isValidProposalId(s), !Ft3(t2)) {
        const { message: i3 } = N5("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t2)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e2) => {
      if (!xt4(e2)) {
        const { message: l2 } = N5("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e2}`);
        throw new Error(l2);
      }
      const { relay: s, controller: t2, namespaces: i3, expiry: n2 } = e2;
      if (!an(s)) {
        const { message: l2 } = N5("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l2);
      }
      const o2 = Vt3(t2, "onSessionSettleRequest()");
      if (o2)
        throw new Error(o2.message);
      const a2 = cn(i3, "onSessionSettleRequest()");
      if (a2)
        throw new Error(a2.message);
      if (dt4(n2)) {
        const { message: l2 } = N5("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l2);
      }
    }, this.isValidUpdate = async (e2) => {
      if (!xt4(e2)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `update() params: ${e2}`);
        throw new Error(a2);
      }
      const { topic: s, namespaces: t2 } = e2;
      await this.isValidSessionTopic(s);
      const i3 = this.client.session.get(s), n2 = cn(t2, "update()");
      if (n2)
        throw new Error(n2.message);
      const o2 = un(i3.requiredNamespaces, t2, "update()");
      if (o2)
        throw new Error(o2.message);
    }, this.isValidExtend = async (e2) => {
      if (!xt4(e2)) {
        const { message: t2 } = N5("MISSING_OR_INVALID", `extend() params: ${e2}`);
        throw new Error(t2);
      }
      const { topic: s } = e2;
      await this.isValidSessionTopic(s);
    }, this.isValidRequest = async (e2) => {
      if (!xt4(e2)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `request() params: ${e2}`);
        throw new Error(a2);
      }
      const { topic: s, request: t2, chainId: i3, expiry: n2 } = e2;
      await this.isValidSessionTopic(s);
      const { namespaces: o2 } = this.client.session.get(s);
      if (!Gt2(o2, i3)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!Ht2(t2)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `request() ${JSON.stringify(t2)}`);
        throw new Error(a2);
      }
      if (!Wt2(o2, i3, t2.method)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `request() method: ${t2.method}`);
        throw new Error(a2);
      }
      if (n2 && !Qt3(n2, U5)) {
        const { message: a2 } = N5("MISSING_OR_INVALID", `request() expiry: ${n2}. Expiry must be a number (in seconds) between ${U5.min} and ${U5.max}`);
        throw new Error(a2);
      }
    }, this.isValidRespond = async (e2) => {
      if (!xt4(e2)) {
        const { message: i3 } = N5("MISSING_OR_INVALID", `respond() params: ${e2}`);
        throw new Error(i3);
      }
      const { topic: s, response: t2 } = e2;
      if (await this.isValidSessionTopic(s), !qt3(t2)) {
        const { message: i3 } = N5("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t2)}`);
        throw new Error(i3);
      }
    }, this.isValidPing = async (e2) => {
      if (!xt4(e2)) {
        const { message: t2 } = N5("MISSING_OR_INVALID", `ping() params: ${e2}`);
        throw new Error(t2);
      }
      const { topic: s } = e2;
      await this.isValidSessionOrPairingTopic(s);
    }, this.isValidEmit = async (e2) => {
      if (!xt4(e2)) {
        const { message: o2 } = N5("MISSING_OR_INVALID", `emit() params: ${e2}`);
        throw new Error(o2);
      }
      const { topic: s, event: t2, chainId: i3 } = e2;
      await this.isValidSessionTopic(s);
      const { namespaces: n2 } = this.client.session.get(s);
      if (!Gt2(n2, i3)) {
        const { message: o2 } = N5("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o2);
      }
      if (!Bt3(t2)) {
        const { message: o2 } = N5("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t2)}`);
        throw new Error(o2);
      }
      if (!zt3(n2, i3, t2.name)) {
        const { message: o2 } = N5("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t2)}`);
        throw new Error(o2);
      }
    }, this.isValidDisconnect = async (e2) => {
      if (!xt4(e2)) {
        const { message: t2 } = N5("MISSING_OR_INVALID", `disconnect() params: ${e2}`);
        throw new Error(t2);
      }
      const { topic: s } = e2;
      await this.isValidSessionOrPairingTopic(s);
    }, this.getVerifyContext = async (e2, s) => {
      const t2 = { verified: { verifyUrl: s.verifyUrl || Q2, validation: "UNKNOWN", origin: s.url || "" } };
      try {
        const i3 = await this.client.core.verify.resolve({ attestationId: e2, verifyUrl: s.verifyUrl });
        i3 && (t2.verified.origin = i3, t2.verified.validation = i3 === new URL(s.url).origin ? "VALID" : "INVALID");
      } catch (i3) {
        this.client.logger.error(i3);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t2)}`), t2;
    }, this.validateSessionProps = (e2, s) => {
      Object.values(e2).forEach((t2) => {
        if (!h4(t2, false)) {
          const { message: i3 } = N5("MISSING_OR_INVALID", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t2)}`);
          throw new Error(i3);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r2 } = N5("NOT_INITIALIZED", this.name);
      throw new Error(r2);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D.message, async (r2) => {
      const { topic: e2, message: s } = r2;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s)))
        return;
      const t2 = await this.client.core.crypto.decode(e2, s);
      try {
        isJsonRpcRequest(t2) ? (this.client.core.history.set(e2, t2), this.onRelayEventRequest({ topic: e2, payload: t2 })) : isJsonRpcResponse(t2) ? (await this.client.core.history.resolve(t2), await this.onRelayEventResponse({ topic: e2, payload: t2 }), this.client.core.history.delete(e2, t2.id)) : this.onRelayEventUnknownPayload({ topic: e2, payload: t2 });
      } catch (i3) {
        this.client.logger.error(i3);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(w2.expired, async (r2) => {
      const { topic: e2, id: s } = ut4(r2.target);
      if (s && this.client.pendingRequest.keys.includes(s))
        return await this.deletePendingSessionRequest(s, N5("EXPIRED"), true);
      e2 ? this.client.session.keys.includes(e2) && (await this.deleteSession(e2, true), this.client.events.emit("session_expire", { topic: e2 })) : s && (await this.deleteProposal(s, true), this.client.events.emit("proposal_expire", { id: s }));
    });
  }
  isValidPairingTopic(r2) {
    if (!h4(r2, false)) {
      const { message: e2 } = N5("MISSING_OR_INVALID", `pairing topic should be a string: ${r2}`);
      throw new Error(e2);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r2)) {
      const { message: e2 } = N5("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r2}`);
      throw new Error(e2);
    }
    if (dt4(this.client.core.pairing.pairings.get(r2).expiry)) {
      const { message: e2 } = N5("EXPIRED", `pairing topic: ${r2}`);
      throw new Error(e2);
    }
  }
  async isValidSessionTopic(r2) {
    if (!h4(r2, false)) {
      const { message: e2 } = N5("MISSING_OR_INVALID", `session topic should be a string: ${r2}`);
      throw new Error(e2);
    }
    if (!this.client.session.keys.includes(r2)) {
      const { message: e2 } = N5("NO_MATCHING_KEY", `session topic doesn't exist: ${r2}`);
      throw new Error(e2);
    }
    if (dt4(this.client.session.get(r2).expiry)) {
      await this.deleteSession(r2);
      const { message: e2 } = N5("EXPIRED", `session topic: ${r2}`);
      throw new Error(e2);
    }
  }
  async isValidSessionOrPairingTopic(r2) {
    if (this.client.session.keys.includes(r2))
      await this.isValidSessionTopic(r2);
    else if (this.client.core.pairing.pairings.keys.includes(r2))
      this.isValidPairingTopic(r2);
    else if (h4(r2, false)) {
      const { message: e2 } = N5("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r2}`);
      throw new Error(e2);
    } else {
      const { message: e2 } = N5("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r2}`);
      throw new Error(e2);
    }
  }
  async isValidProposalId(r2) {
    if (!Lt3(r2)) {
      const { message: e2 } = N5("MISSING_OR_INVALID", `proposal id should be a number: ${r2}`);
      throw new Error(e2);
    }
    if (!this.client.proposal.keys.includes(r2)) {
      const { message: e2 } = N5("NO_MATCHING_KEY", `proposal id doesn't exist: ${r2}`);
      throw new Error(e2);
    }
    if (dt4(this.client.proposal.get(r2).expiry)) {
      await this.deleteProposal(r2);
      const { message: e2 } = N5("EXPIRED", `proposal id: ${r2}`);
      throw new Error(e2);
    }
  }
};
var ps2 = class extends Ut {
  constructor(r2, e2) {
    super(r2, e2, ne2, G4), this.core = r2, this.logger = e2;
  }
};
var hs2 = class extends Ut {
  constructor(r2, e2) {
    super(r2, e2, ae4, G4), this.core = r2, this.logger = e2;
  }
};
var ds2 = class extends Ut {
  constructor(r2, e2) {
    super(r2, e2, le6, G4, (s) => s.id), this.core = r2, this.logger = e2;
  }
};
var Q4 = class extends b {
  constructor(r2) {
    super(r2), this.protocol = J4, this.version = X4, this.name = M3.name, this.events = new import_events8.EventEmitter(), this.on = (s, t2) => this.events.on(s, t2), this.once = (s, t2) => this.events.once(s, t2), this.off = (s, t2) => this.events.off(s, t2), this.removeListener = (s, t2) => this.events.removeListener(s, t2), this.removeAllListeners = (s) => this.events.removeAllListeners(s), this.connect = async (s) => {
      try {
        return await this.engine.connect(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.pair = async (s) => {
      try {
        return await this.engine.pair(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.approve = async (s) => {
      try {
        return await this.engine.approve(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.reject = async (s) => {
      try {
        return await this.engine.reject(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.update = async (s) => {
      try {
        return await this.engine.update(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.extend = async (s) => {
      try {
        return await this.engine.extend(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.request = async (s) => {
      try {
        return await this.engine.request(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.respond = async (s) => {
      try {
        return await this.engine.respond(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.ping = async (s) => {
      try {
        return await this.engine.ping(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.emit = async (s) => {
      try {
        return await this.engine.emit(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.disconnect = async (s) => {
      try {
        return await this.engine.disconnect(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.find = (s) => {
      try {
        return this.engine.find(s);
      } catch (t2) {
        throw this.logger.error(t2.message), t2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.name = r2?.name || M3.name, this.metadata = r2?.metadata || zn();
    const e2 = typeof r2?.logger < "u" && typeof r2?.logger != "string" ? r2.logger : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: r2?.logger || M3.logger }));
    this.core = r2?.core || new xr(r2), this.logger = (0, import_logger3.generateChildLogger)(e2, this.name), this.session = new hs2(this.core, this.logger), this.proposal = new ps2(this.core, this.logger), this.pendingRequest = new ds2(this.core, this.logger), this.engine = new ls2(this);
  }
  static async init(r2) {
    const e2 = new Q4(r2);
    return await e2.initialize(), e2;
  }
  get context() {
    return (0, import_logger3.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r2.message), r2;
    }
  }
};
var us2 = Q4;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var u2 = typeof Reflect == "object" ? Reflect : null;
var m3 = u2 && typeof u2.apply == "function" ? u2.apply : function(t2, e2, n2) {
  return Function.prototype.apply.call(t2, e2, n2);
};
var f3;
u2 && typeof u2.ownKeys == "function" ? f3 = u2.ownKeys : Object.getOwnPropertySymbols ? f3 = function(t2) {
  return Object.getOwnPropertyNames(t2).concat(Object.getOwnPropertySymbols(t2));
} : f3 = function(t2) {
  return Object.getOwnPropertyNames(t2);
};
function T2(s) {
  console && console.warn && console.warn(s);
}
var y3 = Number.isNaN || function(t2) {
  return t2 !== t2;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = M4, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var w5 = 10;
function g4(s) {
  if (typeof s != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return w5;
}, set: function(s) {
  if (typeof s != "number" || s < 0 || y3(s))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
  w5 = s;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(t2) {
  if (typeof t2 != "number" || t2 < 0 || y3(t2))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t2 + ".");
  return this._maxListeners = t2, this;
};
function L4(s) {
  return s._maxListeners === void 0 ? o.defaultMaxListeners : s._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return L4(this);
}, o.prototype.emit = function(t2) {
  for (var e2 = [], n2 = 1; n2 < arguments.length; n2++)
    e2.push(arguments[n2]);
  var i3 = t2 === "error", a2 = this._events;
  if (a2 !== void 0)
    i3 = i3 && a2.error === void 0;
  else if (!i3)
    return false;
  if (i3) {
    var r2;
    if (e2.length > 0 && (r2 = e2[0]), r2 instanceof Error)
      throw r2;
    var h5 = new Error("Unhandled error." + (r2 ? " (" + r2.message + ")" : ""));
    throw h5.context = r2, h5;
  }
  var c3 = a2[t2];
  if (c3 === void 0)
    return false;
  if (typeof c3 == "function")
    m3(c3, this, e2);
  else
    for (var v = c3.length, A2 = b3(c3, v), n2 = 0; n2 < v; ++n2)
      m3(A2[n2], this, e2);
  return true;
};
function _4(s, t2, e2, n2) {
  var i3, a2, r2;
  if (g4(e2), a2 = s._events, a2 === void 0 ? (a2 = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (a2.newListener !== void 0 && (s.emit("newListener", t2, e2.listener ? e2.listener : e2), a2 = s._events), r2 = a2[t2]), r2 === void 0)
    r2 = a2[t2] = e2, ++s._eventsCount;
  else if (typeof r2 == "function" ? r2 = a2[t2] = n2 ? [e2, r2] : [r2, e2] : n2 ? r2.unshift(e2) : r2.push(e2), i3 = L4(s), i3 > 0 && r2.length > i3 && !r2.warned) {
    r2.warned = true;
    var h5 = new Error("Possible EventEmitter memory leak detected. " + r2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    h5.name = "MaxListenersExceededWarning", h5.emitter = s, h5.type = t2, h5.count = r2.length, T2(h5);
  }
  return s;
}
o.prototype.addListener = function(t2, e2) {
  return _4(this, t2, e2, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t2, e2) {
  return _4(this, t2, e2, true);
};
function j4() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function S3(s, t2, e2) {
  var n2 = { fired: false, wrapFn: void 0, target: s, type: t2, listener: e2 }, i3 = j4.bind(n2);
  return i3.listener = e2, n2.wrapFn = i3, i3;
}
o.prototype.once = function(t2, e2) {
  return g4(e2), this.on(t2, S3(this, t2, e2)), this;
}, o.prototype.prependOnceListener = function(t2, e2) {
  return g4(e2), this.prependListener(t2, S3(this, t2, e2)), this;
}, o.prototype.removeListener = function(t2, e2) {
  var n2, i3, a2, r2, h5;
  if (g4(e2), i3 = this._events, i3 === void 0)
    return this;
  if (n2 = i3[t2], n2 === void 0)
    return this;
  if (n2 === e2 || n2.listener === e2)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i3[t2], i3.removeListener && this.emit("removeListener", t2, n2.listener || e2));
  else if (typeof n2 != "function") {
    for (a2 = -1, r2 = n2.length - 1; r2 >= 0; r2--)
      if (n2[r2] === e2 || n2[r2].listener === e2) {
        h5 = n2[r2].listener, a2 = r2;
        break;
      }
    if (a2 < 0)
      return this;
    a2 === 0 ? n2.shift() : I(n2, a2), n2.length === 1 && (i3[t2] = n2[0]), i3.removeListener !== void 0 && this.emit("removeListener", t2, h5 || e2);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t2) {
  var e2, n2, i3;
  if (n2 = this._events, n2 === void 0)
    return this;
  if (n2.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n2[t2] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[t2]), this;
  if (arguments.length === 0) {
    var a2 = Object.keys(n2), r2;
    for (i3 = 0; i3 < a2.length; ++i3)
      r2 = a2[i3], r2 !== "removeListener" && this.removeAllListeners(r2);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e2 = n2[t2], typeof e2 == "function")
    this.removeListener(t2, e2);
  else if (e2 !== void 0)
    for (i3 = e2.length - 1; i3 >= 0; i3--)
      this.removeListener(t2, e2[i3]);
  return this;
};
function C3(s, t2, e2) {
  var n2 = s._events;
  if (n2 === void 0)
    return [];
  var i3 = n2[t2];
  return i3 === void 0 ? [] : typeof i3 == "function" ? e2 ? [i3.listener || i3] : [i3] : e2 ? W6(i3) : b3(i3, i3.length);
}
o.prototype.listeners = function(t2) {
  return C3(this, t2, true);
}, o.prototype.rawListeners = function(t2) {
  return C3(this, t2, false);
}, o.listenerCount = function(s, t2) {
  return typeof s.listenerCount == "function" ? s.listenerCount(t2) : E4.call(s, t2);
}, o.prototype.listenerCount = E4;
function E4(s) {
  var t2 = this._events;
  if (t2 !== void 0) {
    var e2 = t2[s];
    if (typeof e2 == "function")
      return 1;
    if (e2 !== void 0)
      return e2.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f3(this._events) : [];
};
function b3(s, t2) {
  for (var e2 = new Array(t2), n2 = 0; n2 < t2; ++n2)
    e2[n2] = s[n2];
  return e2;
}
function I(s, t2) {
  for (; t2 + 1 < s.length; t2++)
    s[t2] = s[t2 + 1];
  s.pop();
}
function W6(s) {
  for (var t2 = new Array(s.length), e2 = 0; e2 < t2.length; ++e2)
    t2[e2] = s[e2].listener || s[e2];
  return t2;
}
function M4(s, t2) {
  return new Promise(function(e2, n2) {
    function i3(r2) {
      s.removeListener(t2, a2), n2(r2);
    }
    function a2() {
      typeof s.removeListener == "function" && s.removeListener("error", i3), e2([].slice.call(arguments));
    }
    R5(s, t2, a2, { once: true }), t2 !== "error" && z2(s, i3, { once: true });
  });
}
function z2(s, t2, e2) {
  typeof s.on == "function" && R5(s, "error", t2, e2);
}
function R5(s, t2, e2, n2) {
  if (typeof s.on == "function")
    n2.once ? s.once(t2, e2) : s.on(t2, e2);
  else if (typeof s.addEventListener == "function")
    s.addEventListener(t2, function i3(a2) {
      n2.once && s.removeEventListener(t2, i3), e2(a2);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
}
var O4 = "wc";
var d3 = "Web3Wallet";
var K2 = `${O4}@2:${d3}:`;
var X5 = class extends l.exports {
  constructor() {
    super();
  }
};
var x5 = class {
  constructor(t2) {
    this.opts = t2;
  }
};
var P3 = class {
  constructor(t2) {
    this.client = t2;
  }
};
var D3 = class extends P3 {
  constructor(t2) {
    super(t2), this.init = async () => {
      this.signClient = await us2.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await Nr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e2) => {
      await this.client.core.pairing.pair(e2);
    }, this.approveSession = async (e2) => {
      const { topic: n2, acknowledged: i3 } = await this.signClient.approve({ id: e2.id, namespaces: e2.namespaces });
      return await i3(), this.signClient.session.get(n2);
    }, this.rejectSession = async (e2) => await this.signClient.reject(e2), this.updateSession = async (e2) => await (await this.signClient.update(e2)).acknowledged(), this.extendSession = async (e2) => await (await this.signClient.extend(e2)).acknowledged(), this.respondSessionRequest = async (e2) => await this.signClient.respond(e2), this.disconnectSession = async (e2) => await this.signClient.disconnect(e2), this.emitSessionEvent = async (e2) => await this.signClient.emit(e2), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e2, n2) => (e2[n2.topic] = n2, e2), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e2, n2) => await this.authClient.respond(e2, n2), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e2) => "requester" in e2), this.formatMessage = (e2, n2) => this.authClient.formatMessage(e2, n2), this.onSessionRequest = (e2) => {
      this.client.events.emit("session_request", e2);
    }, this.onSessionProposal = (e2) => {
      this.client.events.emit("session_proposal", e2);
    }, this.onSessionDelete = (e2) => {
      this.client.events.emit("session_delete", e2);
    }, this.onAuthRequest = (e2) => {
      this.client.events.emit("auth_request", e2);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest);
    }, this.signClient = {}, this.authClient = {};
  }
};
var p5 = class extends x5 {
  constructor(t2) {
    super(t2), this.events = new l.exports(), this.on = (e2, n2) => this.events.on(e2, n2), this.once = (e2, n2) => this.events.once(e2, n2), this.off = (e2, n2) => this.events.off(e2, n2), this.removeListener = (e2, n2) => this.events.removeListener(e2, n2), this.pair = async (e2) => {
      try {
        return await this.engine.pair(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.approveSession = async (e2) => {
      try {
        return await this.engine.approveSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.rejectSession = async (e2) => {
      try {
        return await this.engine.rejectSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.updateSession = async (e2) => {
      try {
        return await this.engine.updateSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.extendSession = async (e2) => {
      try {
        return await this.engine.extendSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.respondSessionRequest = async (e2) => {
      try {
        return await this.engine.respondSessionRequest(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.disconnectSession = async (e2) => {
      try {
        return await this.engine.disconnectSession(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.emitSessionEvent = async (e2) => {
      try {
        return await this.engine.emitSessionEvent(e2);
      } catch (n2) {
        throw this.logger.error(n2.message), n2;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.respondAuthRequest = async (e2, n2) => {
      try {
        return await this.engine.respondAuthRequest(e2, n2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (e2) {
        throw this.logger.error(e2.message), e2;
      }
    }, this.formatMessage = (e2, n2) => {
      try {
        return this.engine.formatMessage(e2, n2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.metadata = t2.metadata, this.name = t2.name || d3, this.core = t2.core, this.logger = this.core.logger, this.engine = new D3(this);
  }
  static async init(t2) {
    const e2 = new p5(t2);
    return await e2.initialize(), e2;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (t2) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(t2.message), t2;
    }
  }
};
var G5 = p5;

// node_modules/react-datepicker/dist/es/index.js
var import_react2 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_classnames = __toESM(require_classnames());
init_isDate();
init_isValid();
init_format();
init_addMinutes();
init_addHours();
init_addDays();
init_addWeeks();
init_addMonths();
init_addQuarters();
init_addYears();
init_subDays();
init_subWeeks();
init_subMonths();
init_subQuarters();
init_subYears();
init_getSeconds();
init_getMinutes();
init_getHours();
init_getDay();
init_getDate();
init_getISOWeek();
init_getMonth();
init_getQuarter();
init_getYear();
init_getTime();
init_setSeconds();
init_setMinutes();
init_setHours();
init_setMonth();
init_setQuarter();
init_setYear();
init_min();
init_max();
init_differenceInCalendarDays();
init_differenceInCalendarMonths();
init_differenceInCalendarYears();
init_startOfDay();
init_startOfWeek();
init_startOfMonth();
init_startOfQuarter();
init_startOfYear();
init_endOfDay();
init_endOfWeek();
init_endOfMonth();
init_endOfYear();
init_isEqual();
init_isSameDay();
init_isSameMonth();
init_isSameYear();
init_isSameQuarter();
init_isAfter();
init_isBefore();
init_isWithinInterval();
init_toDate();
init_parse();
init_parseISO();

// node_modules/react-onclickoutside/dist/react-onclickoutside.es.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p6) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p7) {
    o3.__proto__ = p7;
    return o3;
  };
  return _setPrototypeOf(o2, p6);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }
  return current.classList.contains(ignoreClass);
}
function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  while (current.parentNode || current.host) {
    if (current.parentNode && isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }
    current = current.parentNode || current.host;
  }
  return current;
}
function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}
var testPassiveEventSupport = function testPassiveEventSupport2() {
  if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
    return;
  }
  var passive2 = false;
  var options = Object.defineProperty({}, "passive", {
    get: function get3() {
      passive2 = true;
    }
  });
  var noop2 = function noop3() {
  };
  window.addEventListener("testPassiveEventSupport", noop2, options);
  window.removeEventListener("testPassiveEventSupport", noop2, options);
  return passive2;
};
function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }
  return function() {
    return ++seed;
  };
}
var uid = autoInc();
var passiveEventSupport;
var handlersMap = {};
var enabledInstances = {};
var touchEvents = ["touchstart", "touchmove"];
var IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = {};
  var isTouchEvent = touchEvents.indexOf(eventName) !== -1;
  if (isTouchEvent && passiveEventSupport) {
    handlerOptions.passive = !instance.props.preventDefault;
  }
  return handlerOptions;
}
function onClickOutsideHOC(WrappedComponent, config) {
  var _class, _temp;
  var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
  return _temp = _class = function(_Component) {
    _inheritsLoose(onClickOutside, _Component);
    function onClickOutside(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.__outsideClickHandler = function(event) {
        if (typeof _this.__clickOutsideHandlerProp === "function") {
          _this.__clickOutsideHandlerProp(event);
          return;
        }
        var instance = _this.getInstance();
        if (typeof instance.props.handleClickOutside === "function") {
          instance.props.handleClickOutside(event);
          return;
        }
        if (typeof instance.handleClickOutside === "function") {
          instance.handleClickOutside(event);
          return;
        }
        throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
      };
      _this.__getComponentNode = function() {
        var instance = _this.getInstance();
        if (config && typeof config.setClickOutsideRef === "function") {
          return config.setClickOutsideRef()(instance);
        }
        if (typeof instance.setClickOutsideRef === "function") {
          return instance.setClickOutsideRef();
        }
        return (0, import_react_dom.findDOMNode)(instance);
      };
      _this.enableOnClickOutside = function() {
        if (typeof document === "undefined" || enabledInstances[_this._uid]) {
          return;
        }
        if (typeof passiveEventSupport === "undefined") {
          passiveEventSupport = testPassiveEventSupport();
        }
        enabledInstances[_this._uid] = true;
        var events = _this.props.eventTypes;
        if (!events.forEach) {
          events = [events];
        }
        handlersMap[_this._uid] = function(event) {
          if (_this.componentNode === null)
            return;
          if (_this.props.preventDefault) {
            event.preventDefault();
          }
          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }
          if (_this.props.excludeScrollbar && clickedScrollbar(event))
            return;
          var current = event.composed && event.composedPath && event.composedPath().shift() || event.target;
          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }
          _this.__outsideClickHandler(event);
        };
        events.forEach(function(eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized(_this), eventName));
        });
      };
      _this.disableOnClickOutside = function() {
        delete enabledInstances[_this._uid];
        var fn3 = handlersMap[_this._uid];
        if (fn3 && typeof document !== "undefined") {
          var events = _this.props.eventTypes;
          if (!events.forEach) {
            events = [events];
          }
          events.forEach(function(eventName) {
            return document.removeEventListener(eventName, fn3, getEventHandlerOptions(_assertThisInitialized(_this), eventName));
          });
          delete handlersMap[_this._uid];
        }
      };
      _this.getRef = function(ref) {
        return _this.instanceRef = ref;
      };
      _this._uid = uid();
      return _this;
    }
    var _proto = onClickOutside.prototype;
    _proto.getInstance = function getInstance() {
      if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
        return this;
      }
      var ref = this.instanceRef;
      return ref.getInstance ? ref.getInstance() : ref;
    };
    _proto.componentDidMount = function componentDidMount() {
      if (typeof document === "undefined" || !document.createElement) {
        return;
      }
      var instance = this.getInstance();
      if (config && typeof config.handleClickOutside === "function") {
        this.__clickOutsideHandlerProp = config.handleClickOutside(instance);
        if (typeof this.__clickOutsideHandlerProp !== "function") {
          throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
        }
      }
      this.componentNode = this.__getComponentNode();
      if (this.props.disableOnClickOutside)
        return;
      this.enableOnClickOutside();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = this.__getComponentNode();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    _proto.render = function render() {
      var _this$props = this.props;
      _this$props.excludeScrollbar;
      var props = _objectWithoutPropertiesLoose2(_this$props, ["excludeScrollbar"]);
      if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }
      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return (0, import_react.createElement)(WrappedComponent, props);
    };
    return onClickOutside;
  }(import_react.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
    eventTypes: ["mousedown", "touchstart"],
    excludeScrollbar: config && config.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function() {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}
var react_onclickoutside_es_default = onClickOutsideHOC;

// node_modules/react-datepicker/dist/es/index.js
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/react-popper/lib/esm/Popper.js
var React6 = __toESM(require_react());

// node_modules/react-popper/lib/esm/Manager.js
var React3 = __toESM(require_react());
var ManagerReferenceNodeContext = React3.createContext();
var ManagerReferenceNodeSetterContext = React3.createContext();
function Manager(_ref) {
  var children = _ref.children;
  var _React$useState = React3.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = React3.useRef(false);
  React3.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = React3.useCallback(function(node2) {
    if (!hasUnmounted.current) {
      setReferenceNode(node2);
    }
  }, []);
  return React3.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, React3.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}

// node_modules/react-popper/lib/esm/utils.js
var React4 = __toESM(require_react());
var unwrapArray = function unwrapArray2(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
var safeInvoke = function safeInvoke2(fn3) {
  if (typeof fn3 === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return fn3.apply(void 0, args);
  }
};
var setRef = function setRef2(ref, node2) {
  if (typeof ref === "function") {
    return safeInvoke(ref, node2);
  } else if (ref != null) {
    ref.current = node2;
  }
};
var fromEntries = function fromEntries2(entries2) {
  return entries2.reduce(function(acc, _ref) {
    var key = _ref[0], value = _ref[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React4.useLayoutEffect : React4.useEffect;

// node_modules/react-popper/lib/esm/usePopper.js
var React5 = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument = node2.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node2;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max2 = Math.max;
var min2 = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x6 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y4 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y4,
    right: x6 + width,
    bottom: y4 + height,
    left: x6,
    x: x6,
    y: y4
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min4, value, max4) {
  return max2(min4, min2(value, max4));
}
function withinMaxClamp(min4, value, max4) {
  var v = within(min4, value, max4);
  return v > max4 ? max4 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys5) {
  return keys5.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min4 = paddingObject[minProp];
  var max4 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min4, center, max4);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x6 = _ref.x, y4 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x6 * dpr) / dpr || 0,
    y: round(y4 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position3 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x6 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y4 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x6,
    y: y4
  }) : {
    x: x6,
    y: y4
  };
  x6 = _ref3.x;
  y4 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position3 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y4 -= offsetY - popperRect.height;
      y4 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x6 -= offsetX - popperRect.width;
      x6 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position3
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x6,
    y: y4
  }, getWindow(popper2)) : {
    x: x6,
    y: y4
  };
  x6 = _ref4.x;
  y4 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x6 + "px, " + y4 + "px)" : "translate3d(" + x6 + "px, " + y4 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y4 + "px" : "", _Object$assign2[sideX] = hasX ? x6 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html5 = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html5.clientWidth;
  var height = html5.clientHeight;
  var x6 = 0;
  var y4 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x6 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x6 + getWindowScrollBarX(element2),
    y: y4
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html5 = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max2(html5.scrollWidth, html5.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max2(html5.scrollHeight, html5.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x6 = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y4 = -winScroll.scrollTop;
  if (getComputedStyle(body || html5).direction === "rtl") {
    x6 += max2(html5.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x6,
    y: y4
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list3) {
  var _element$ownerDocumen;
  if (list3 === void 0) {
    list3 = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list3.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b4) {
    return overflows[a2] - overflows[b4];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i3 = 0; i3 < placements2.length; i3++) {
    var placement = placements2[i3];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks2 = [];
    if (checkMainAxis) {
      checks2.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks2.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks2.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks2);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks3 = checksMap.get(placement2);
        if (checks3) {
          return checks3.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state.placement], x6 = _data$state$placement.x, y4 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x6;
    state.modifiersData.popperOffsets.y += y4;
  }
  state.modifiersData[name] = data2;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min4 = offset2 + overflow[mainSide];
    var max4 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min2(min4, tetherMin) : min4, offset2, tether ? max2(max4, tetherMax) : max4);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data2;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order2(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort3(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort3(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort3(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order2(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper4(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m4) {
          return m4.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper = popperGenerator();

// node_modules/@popperjs/core/lib/popper-lite.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
var createPopper2 = popperGenerator({
  defaultModifiers
});

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper3 = popperGenerator({
  defaultModifiers: defaultModifiers2
});

// node_modules/react-popper/lib/esm/usePopper.js
var import_react_fast_compare = __toESM(require_react_fast_compare());
var EMPTY_MODIFIERS = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = React5.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS
  };
  var _React$useState = React5.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = React5.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn3(_ref) {
        var state2 = _ref.state;
        var elements = Object.keys(state2.elements);
        ReactDOM.flushSync(function() {
          setState({
            styles: fromEntries(elements.map(function(element2) {
              return [element2, state2.styles[element2] || {}];
            })),
            attributes: fromEntries(elements.map(function(element2) {
              return [element2, state2.attributes[element2]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = React5.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = React5.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper4 = options.createPopper || createPopper3;
    var popperInstance = createPopper4(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};

// node_modules/react-popper/lib/esm/Popper.js
var NOOP = function NOOP2() {
  return void 0;
};
var NOOP_PROMISE = function NOOP_PROMISE2() {
  return Promise.resolve(null);
};
var EMPTY_MODIFIERS2 = [];
function Popper(_ref) {
  var _ref$placement = _ref.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref.modifiers, modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS2 : _ref$modifiers, referenceElement = _ref.referenceElement, onFirstUpdate = _ref.onFirstUpdate, innerRef = _ref.innerRef, children = _ref.children;
  var referenceNode = React6.useContext(ManagerReferenceNodeContext);
  var _React$useState = React6.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = React6.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  React6.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = React6.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options), state = _usePopper.state, styles = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update;
  var childrenProps = React6.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}

// node_modules/react-popper/lib/esm/Reference.js
var React7 = __toESM(require_react());
var import_warning = __toESM(require_warning());
function Reference(_ref) {
  var children = _ref.children, innerRef = _ref.innerRef;
  var setReferenceNode = React7.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = React7.useCallback(function(node2) {
    setRef(innerRef, node2);
    safeInvoke(setReferenceNode, node2);
  }, [innerRef, setReferenceNode]);
  React7.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []);
  React7.useEffect(function() {
    (0, import_warning.default)(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}

// node_modules/react-datepicker/dist/es/index.js
init_set();
function le7(e2, t2) {
  var r2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), r2.push.apply(r2, n2);
  }
  return r2;
}
function de7(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? le7(Object(r2), true).forEach(function(t3) {
      ye6(e2, t3, r2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(r2)) : le7(Object(r2)).forEach(function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(r2, t3));
    });
  }
  return e2;
}
function ue6(e2) {
  return ue6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  }, ue6(e2);
}
function he7(e2, t2) {
  if (!(e2 instanceof t2))
    throw new TypeError("Cannot call a class as a function");
}
function me4(e2, t2) {
  for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e2, _e4(n2.key), n2);
  }
}
function fe5(e2, t2, r2) {
  return t2 && me4(e2.prototype, t2), r2 && me4(e2, r2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function ye6(e2, t2, r2) {
  return (t2 = _e4(t2)) in e2 ? Object.defineProperty(e2, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e2[t2] = r2, e2;
}
function ve() {
  return ve = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, ve.apply(this, arguments);
}
function De4(e2, t2) {
  if ("function" != typeof t2 && null !== t2)
    throw new TypeError("Super expression must either be null or a function");
  e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t2 && we2(e2, t2);
}
function ge3(e2) {
  return ge3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e3) {
    return e3.__proto__ || Object.getPrototypeOf(e3);
  }, ge3(e2);
}
function we2(e2, t2) {
  return we2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
    return e3.__proto__ = t3, e3;
  }, we2(e2, t2);
}
function ke4(e2) {
  if (void 0 === e2)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function be2(e2) {
  var t2 = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }();
  return function() {
    var r2, n2 = ge3(e2);
    if (t2) {
      var o2 = ge3(this).constructor;
      r2 = Reflect.construct(n2, arguments, o2);
    } else
      r2 = n2.apply(this, arguments);
    return function(e3, t3) {
      if (t3 && ("object" == typeof t3 || "function" == typeof t3))
        return t3;
      if (void 0 !== t3)
        throw new TypeError("Derived constructors may only return object or undefined");
      return ke4(e3);
    }(this, r2);
  };
}
function Se2(e2) {
  return function(e3) {
    if (Array.isArray(e3))
      return Ce5(e3);
  }(e2) || function(e3) {
    if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
      return Array.from(e3);
  }(e2) || function(e3, t2) {
    if (!e3)
      return;
    if ("string" == typeof e3)
      return Ce5(e3, t2);
    var r2 = Object.prototype.toString.call(e3).slice(8, -1);
    "Object" === r2 && e3.constructor && (r2 = e3.constructor.name);
    if ("Map" === r2 || "Set" === r2)
      return Array.from(e3);
    if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
      return Ce5(e3, t2);
  }(e2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function Ce5(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
    n2[r2] = e2[r2];
  return n2;
}
function _e4(e2) {
  var t2 = function(e3, t3) {
    if ("object" != typeof e3 || null === e3)
      return e3;
    var r2 = e3[Symbol.toPrimitive];
    if (void 0 !== r2) {
      var n2 = r2.call(e3, t3 || "default");
      if ("object" != typeof n2)
        return n2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t3 ? String : Number)(e3);
  }(e2, "string");
  return "symbol" == typeof t2 ? t2 : String(t2);
}
var Me4 = function(e2, t2) {
  switch (e2) {
    case "P":
      return t2.date({ width: "short" });
    case "PP":
      return t2.date({ width: "medium" });
    case "PPP":
      return t2.date({ width: "long" });
    default:
      return t2.date({ width: "full" });
  }
};
var Ee3 = function(e2, t2) {
  switch (e2) {
    case "p":
      return t2.time({ width: "short" });
    case "pp":
      return t2.time({ width: "medium" });
    case "ppp":
      return t2.time({ width: "long" });
    default:
      return t2.time({ width: "full" });
  }
};
var Pe2 = { p: Ee3, P: function(e2, t2) {
  var r2, n2 = e2.match(/(P+)(p+)?/) || [], o2 = n2[1], a2 = n2[2];
  if (!a2)
    return Me4(e2, t2);
  switch (o2) {
    case "P":
      r2 = t2.dateTime({ width: "short" });
      break;
    case "PP":
      r2 = t2.dateTime({ width: "medium" });
      break;
    case "PPP":
      r2 = t2.dateTime({ width: "long" });
      break;
    default:
      r2 = t2.dateTime({ width: "full" });
  }
  return r2.replace("{{date}}", Me4(o2, t2)).replace("{{time}}", Ee3(a2, t2));
} };
var Ne2 = 12;
var xe2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
function Ye4(e2) {
  var t2 = e2 ? "string" == typeof e2 || e2 instanceof String ? parseISO(e2) : toDate(e2) : new Date();
  return Te2(t2) ? t2 : null;
}
function Te2(e2, t2) {
  return t2 = t2 || new Date("1/1/1000"), isValid(e2) && !isBefore(e2, t2);
}
function Ie4(e2, t2, r2) {
  if ("en" === r2)
    return format(e2, t2, { awareOfUnicodeTokens: true });
  var n2 = Ge3(r2);
  return r2 && !n2 && console.warn('A locale object was not found for the provided string ["'.concat(r2, '"].')), !n2 && $e2() && Ge3($e2()) && (n2 = Ge3($e2())), format(e2, t2, { locale: n2 || null, awareOfUnicodeTokens: true });
}
function Oe(e2, t2) {
  var r2 = t2.dateFormat, n2 = t2.locale;
  return e2 && Ie4(e2, Array.isArray(r2) ? r2[0] : r2, n2) || "";
}
function Re5(e2, t2) {
  var r2 = t2.hour, n2 = void 0 === r2 ? 0 : r2, o2 = t2.minute, a2 = void 0 === o2 ? 0 : o2, s = t2.second;
  return setHours(setMinutes(setSeconds(e2, void 0 === s ? 0 : s), a2), n2);
}
function Le3(e2, t2, r2) {
  var n2 = Ge3(t2 || $e2());
  return startOfWeek(e2, { locale: n2, weekStartsOn: r2 });
}
function Fe4(e2) {
  return startOfMonth(e2);
}
function Ae4(e2) {
  return startOfYear(e2);
}
function Be3(e2) {
  return startOfQuarter(e2);
}
function Ke3() {
  return startOfDay(Ye4());
}
function Qe4(e2, t2) {
  return e2 && t2 ? isSameYear(e2, t2) : !e2 && !t2;
}
function He4(e2, t2) {
  return e2 && t2 ? isSameMonth(e2, t2) : !e2 && !t2;
}
function je4(e2, t2) {
  return e2 && t2 ? isSameQuarter(e2, t2) : !e2 && !t2;
}
function We4(e2, t2) {
  return e2 && t2 ? isSameDay(e2, t2) : !e2 && !t2;
}
function Ve4(e2, t2) {
  return e2 && t2 ? isEqual(e2, t2) : !e2 && !t2;
}
function qe3(e2, t2, r2) {
  var n2, o2 = startOfDay(t2), a2 = endOfDay(r2);
  try {
    n2 = isWithinInterval(e2, { start: o2, end: a2 });
  } catch (e3) {
    n2 = false;
  }
  return n2;
}
function $e2() {
  return ("undefined" != typeof window ? window : globalThis).__localeId__;
}
function Ge3(e2) {
  if ("string" == typeof e2) {
    var t2 = "undefined" != typeof window ? window : globalThis;
    return t2.__localeData__ ? t2.__localeData__[e2] : null;
  }
  return e2;
}
function Je4(e2, t2) {
  return Ie4(setMonth(Ye4(), e2), "LLLL", t2);
}
function Xe2(e2, t2) {
  return Ie4(setMonth(Ye4(), e2), "LLL", t2);
}
function Ze4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = t2.excludeDates, a2 = t2.excludeDateIntervals, s = t2.includeDates, i3 = t2.includeDateIntervals, p6 = t2.filterDate;
  return it4(e2, { minDate: r2, maxDate: n2 }) || o2 && o2.some(function(t3) {
    return We4(e2, t3);
  }) || a2 && a2.some(function(t3) {
    var r3 = t3.start, n3 = t3.end;
    return isWithinInterval(e2, { start: r3, end: n3 });
  }) || s && !s.some(function(t3) {
    return We4(e2, t3);
  }) || i3 && !i3.some(function(t3) {
    var r3 = t3.start, n3 = t3.end;
    return isWithinInterval(e2, { start: r3, end: n3 });
  }) || p6 && !p6(Ye4(e2)) || false;
}
function et4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.excludeDates, n2 = t2.excludeDateIntervals;
  return n2 && n2.length > 0 ? n2.some(function(t3) {
    var r3 = t3.start, n3 = t3.end;
    return isWithinInterval(e2, { start: r3, end: n3 });
  }) : r2 && r2.some(function(t3) {
    return We4(e2, t3);
  }) || false;
}
function tt3(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = t2.excludeDates, a2 = t2.includeDates, s = t2.filterDate;
  return it4(e2, { minDate: startOfMonth(r2), maxDate: endOfMonth(n2) }) || o2 && o2.some(function(t3) {
    return He4(e2, t3);
  }) || a2 && !a2.some(function(t3) {
    return He4(e2, t3);
  }) || s && !s(Ye4(e2)) || false;
}
function rt3(e2, t2, r2, n2) {
  var o2 = getYear(e2), a2 = getMonth(e2), s = getYear(t2), i3 = getMonth(t2), p6 = getYear(n2);
  return o2 === s && o2 === p6 ? a2 <= r2 && r2 <= i3 : o2 < s ? p6 === o2 && a2 <= r2 || p6 === s && i3 >= r2 || p6 < s && p6 > o2 : void 0;
}
function nt4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = t2.excludeDates, a2 = t2.includeDates, s = t2.filterDate;
  return it4(e2, { minDate: r2, maxDate: n2 }) || o2 && o2.some(function(t3) {
    return je4(e2, t3);
  }) || a2 && !a2.some(function(t3) {
    return je4(e2, t3);
  }) || s && !s(Ye4(e2)) || false;
}
function ot3(e2, t2, r2) {
  if (!isValid(t2) || !isValid(r2))
    return false;
  var n2 = getYear(t2), a2 = getYear(r2);
  return n2 <= e2 && a2 >= e2;
}
function at5(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate, o2 = t2.excludeDates, a2 = t2.includeDates, s = t2.filterDate, i3 = new Date(e2, 0, 1);
  return it4(i3, { minDate: startOfYear(r2), maxDate: endOfYear(n2) }) || o2 && o2.some(function(e3) {
    return Qe4(i3, e3);
  }) || a2 && !a2.some(function(e3) {
    return Qe4(i3, e3);
  }) || s && !s(Ye4(i3)) || false;
}
function st6(e2, t2, r2, n2) {
  var o2 = getYear(e2), a2 = getQuarter(e2), s = getYear(t2), i3 = getQuarter(t2), p6 = getYear(n2);
  return o2 === s && o2 === p6 ? a2 <= r2 && r2 <= i3 : o2 < s ? p6 === o2 && a2 <= r2 || p6 === s && i3 >= r2 || p6 < s && p6 > o2 : void 0;
}
function it4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.maxDate;
  return r2 && differenceInCalendarDays(e2, r2) < 0 || n2 && differenceInCalendarDays(e2, n2) > 0;
}
function pt4(e2, t2) {
  return t2.some(function(t3) {
    return getHours(t3) === getHours(e2) && getMinutes(t3) === getMinutes(e2);
  });
}
function ct4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.excludeTimes, n2 = t2.includeTimes, o2 = t2.filterTime;
  return r2 && pt4(e2, r2) || n2 && !pt4(e2, n2) || o2 && !o2(e2) || false;
}
function lt5(e2, t2) {
  var r2 = t2.minTime, n2 = t2.maxTime;
  if (!r2 || !n2)
    throw new Error("Both minTime and maxTime props required");
  var o2, a2 = Ye4(), s = setHours(setMinutes(a2, getMinutes(e2)), getHours(e2)), i3 = setHours(setMinutes(a2, getMinutes(r2)), getHours(r2)), p6 = setHours(setMinutes(a2, getMinutes(n2)), getHours(n2));
  try {
    o2 = !isWithinInterval(s, { start: i3, end: p6 });
  } catch (e3) {
    o2 = false;
  }
  return o2;
}
function dt5(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.includeDates, o2 = subMonths(e2, 1);
  return r2 && differenceInCalendarMonths(r2, o2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarMonths(e3, o2) > 0;
  }) || false;
}
function ut5(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.maxDate, n2 = t2.includeDates, o2 = addMonths(e2, 1);
  return r2 && differenceInCalendarMonths(o2, r2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarMonths(o2, e3) > 0;
  }) || false;
}
function ht4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.minDate, n2 = t2.includeDates, o2 = subYears(e2, 1);
  return r2 && differenceInCalendarYears(r2, o2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarYears(e3, o2) > 0;
  }) || false;
}
function mt4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.maxDate, n2 = t2.includeDates, o2 = addYears(e2, 1);
  return r2 && differenceInCalendarYears(o2, r2) > 0 || n2 && n2.every(function(e3) {
    return differenceInCalendarYears(o2, e3) > 0;
  }) || false;
}
function ft5(e2) {
  var t2 = e2.minDate, r2 = e2.includeDates;
  if (r2 && t2) {
    var n2 = r2.filter(function(e3) {
      return differenceInCalendarDays(e3, t2) >= 0;
    });
    return min(n2);
  }
  return r2 ? min(r2) : t2;
}
function yt4(e2) {
  var t2 = e2.maxDate, r2 = e2.includeDates;
  if (r2 && t2) {
    var n2 = r2.filter(function(e3) {
      return differenceInCalendarDays(e3, t2) <= 0;
    });
    return max(n2);
  }
  return r2 ? max(r2) : t2;
}
function vt4() {
  for (var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--highlighted", r2 = /* @__PURE__ */ new Map(), o2 = 0, a2 = e2.length; o2 < a2; o2++) {
    var s = e2[o2];
    if (isDate(s)) {
      var i3 = Ie4(s, "MM.dd.yyyy"), p6 = r2.get(i3) || [];
      p6.includes(t2) || (p6.push(t2), r2.set(i3, p6));
    } else if ("object" === ue6(s)) {
      var c3 = Object.keys(s), l2 = c3[0], d4 = s[c3[0]];
      if ("string" == typeof l2 && d4.constructor === Array)
        for (var u3 = 0, h5 = d4.length; u3 < h5; u3++) {
          var m4 = Ie4(d4[u3], "MM.dd.yyyy"), f4 = r2.get(m4) || [];
          f4.includes(l2) || (f4.push(l2), r2.set(m4, f4));
        }
    }
  }
  return r2;
}
function Dt4() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--holidays", r2 = /* @__PURE__ */ new Map();
  return e2.forEach(function(e3) {
    var o2 = e3.date, a2 = e3.holidayName;
    if (isDate(o2)) {
      var s = Ie4(o2, "MM.dd.yyyy"), i3 = r2.get(s) || {};
      if (!("className" in i3) || i3.className !== t2 || (p6 = i3.holidayNames, c3 = [a2], p6.length !== c3.length || !p6.every(function(e4, t3) {
        return e4 === c3[t3];
      }))) {
        var p6, c3;
        i3.className = t2;
        var l2 = i3.holidayNames;
        i3.holidayNames = l2 ? [].concat(Se2(l2), [a2]) : [a2], r2.set(s, i3);
      }
    }
  }), r2;
}
function gt4(e2, t2, r2, n2, o2) {
  for (var a2 = o2.length, p6 = [], c3 = 0; c3 < a2; c3++) {
    var l2 = addMinutes(addHours(e2, getHours(o2[c3])), getMinutes(o2[c3])), d4 = addMinutes(e2, (r2 + 1) * n2);
    isAfter(l2, t2) && isBefore(l2, d4) && p6.push(o2[c3]);
  }
  return p6;
}
function wt3(e2) {
  return e2 < 10 ? "0".concat(e2) : "".concat(e2);
}
function kt4(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ne2, r2 = Math.ceil(getYear(e2) / t2) * t2;
  return { startPeriod: r2 - (t2 - 1), endPeriod: r2 };
}
function bt4(e2) {
  var t2 = e2.getSeconds(), r2 = e2.getMilliseconds();
  return toDate(e2.getTime() - 1e3 * t2 - r2);
}
function St3(e2, t2, r2, n2) {
  for (var o2 = [], a2 = 0; a2 < 2 * t2 + 1; a2++) {
    var s = e2 + t2 - a2, i3 = true;
    r2 && (i3 = getYear(r2) <= s), n2 && i3 && (i3 = getYear(n2) >= s), i3 && o2.push(s);
  }
  return o2;
}
var Ct6 = react_onclickoutside_es_default(function(n2) {
  De4(a2, import_react2.default.Component);
  var o2 = be2(a2);
  function a2(r2) {
    var n3;
    he7(this, a2), ye6(ke4(n3 = o2.call(this, r2)), "renderOptions", function() {
      var t2 = n3.props.year, r3 = n3.state.yearsList.map(function(r4) {
        return import_react2.default.createElement("div", { className: t2 === r4 ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option", key: r4, onClick: n3.onChange.bind(ke4(n3), r4), "aria-selected": t2 === r4 ? "true" : void 0 }, t2 === r4 ? import_react2.default.createElement("span", { className: "react-datepicker__year-option--selected" }, "\u2713") : "", r4);
      }), o3 = n3.props.minDate ? getYear(n3.props.minDate) : null, a3 = n3.props.maxDate ? getYear(n3.props.maxDate) : null;
      return a3 && n3.state.yearsList.find(function(e2) {
        return e2 === a3;
      }) || r3.unshift(import_react2.default.createElement("div", { className: "react-datepicker__year-option", key: "upcoming", onClick: n3.incrementYears }, import_react2.default.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" }))), o3 && n3.state.yearsList.find(function(e2) {
        return e2 === o3;
      }) || r3.push(import_react2.default.createElement("div", { className: "react-datepicker__year-option", key: "previous", onClick: n3.decrementYears }, import_react2.default.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" }))), r3;
    }), ye6(ke4(n3), "onChange", function(e2) {
      n3.props.onChange(e2);
    }), ye6(ke4(n3), "handleClickOutside", function() {
      n3.props.onCancel();
    }), ye6(ke4(n3), "shiftYears", function(e2) {
      var t2 = n3.state.yearsList.map(function(t3) {
        return t3 + e2;
      });
      n3.setState({ yearsList: t2 });
    }), ye6(ke4(n3), "incrementYears", function() {
      return n3.shiftYears(1);
    }), ye6(ke4(n3), "decrementYears", function() {
      return n3.shiftYears(-1);
    });
    var s = r2.yearDropdownItemNumber, i3 = r2.scrollableYearDropdown, p6 = s || (i3 ? 10 : 5);
    return n3.state = { yearsList: St3(n3.props.year, p6, n3.props.minDate, n3.props.maxDate) }, n3.dropdownRef = (0, import_react2.createRef)(), n3;
  }
  return fe5(a2, [{ key: "componentDidMount", value: function() {
    var e2 = this.dropdownRef.current;
    if (e2) {
      var t2 = e2.children ? Array.from(e2.children) : null, r2 = t2 ? t2.find(function(e3) {
        return e3.ariaSelected;
      }) : null;
      e2.scrollTop = r2 ? r2.offsetTop + (r2.clientHeight - e2.clientHeight) / 2 : (e2.scrollHeight - e2.clientHeight) / 2;
    }
  } }, { key: "render", value: function() {
    var t2 = (0, import_classnames.default)({ "react-datepicker__year-dropdown": true, "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown });
    return import_react2.default.createElement("div", { className: t2, ref: this.dropdownRef }, this.renderOptions());
  } }]), a2;
}());
var _t5 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2() {
    var t3;
    he7(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s = 0; s < o2; s++)
      a2[s] = arguments[s];
    return ye6(ke4(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { dropdownVisible: false }), ye6(ke4(t3), "renderSelectOptions", function() {
      for (var r3 = t3.props.minDate ? getYear(t3.props.minDate) : 1900, n3 = t3.props.maxDate ? getYear(t3.props.maxDate) : 2100, o3 = [], a3 = r3; a3 <= n3; a3++)
        o3.push(import_react2.default.createElement("option", { key: a3, value: a3 }, a3));
      return o3;
    }), ye6(ke4(t3), "onSelectChange", function(e2) {
      t3.onChange(e2.target.value);
    }), ye6(ke4(t3), "renderSelectMode", function() {
      return import_react2.default.createElement("select", { value: t3.props.year, className: "react-datepicker__year-select", onChange: t3.onSelectChange }, t3.renderSelectOptions());
    }), ye6(ke4(t3), "renderReadView", function(r3) {
      return import_react2.default.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__year-read-view", onClick: function(e2) {
        return t3.toggleDropdown(e2);
      } }, import_react2.default.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }), import_react2.default.createElement("span", { className: "react-datepicker__year-read-view--selected-year" }, t3.props.year));
    }), ye6(ke4(t3), "renderDropdown", function() {
      return import_react2.default.createElement(Ct6, { key: "dropdown", year: t3.props.year, onChange: t3.onChange, onCancel: t3.toggleDropdown, minDate: t3.props.minDate, maxDate: t3.props.maxDate, scrollableYearDropdown: t3.props.scrollableYearDropdown, yearDropdownItemNumber: t3.props.yearDropdownItemNumber });
    }), ye6(ke4(t3), "renderScrollMode", function() {
      var e2 = t3.state.dropdownVisible, r3 = [t3.renderReadView(!e2)];
      return e2 && r3.unshift(t3.renderDropdown()), r3;
    }), ye6(ke4(t3), "onChange", function(e2) {
      t3.toggleDropdown(), e2 !== t3.props.year && t3.props.onChange(e2);
    }), ye6(ke4(t3), "toggleDropdown", function(e2) {
      t3.setState({ dropdownVisible: !t3.state.dropdownVisible }, function() {
        t3.props.adjustDateOnChange && t3.handleYearChange(t3.props.date, e2);
      });
    }), ye6(ke4(t3), "handleYearChange", function(e2, r3) {
      t3.onSelect(e2, r3), t3.setOpen();
    }), ye6(ke4(t3), "onSelect", function(e2, r3) {
      t3.props.onSelect && t3.props.onSelect(e2, r3);
    }), ye6(ke4(t3), "setOpen", function() {
      t3.props.setOpen && t3.props.setOpen(true);
    }), t3;
  }
  return fe5(n2, [{ key: "render", value: function() {
    var t3;
    switch (this.props.dropdownMode) {
      case "scroll":
        t3 = this.renderScrollMode();
        break;
      case "select":
        t3 = this.renderSelectMode();
    }
    return import_react2.default.createElement("div", { className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode) }, t3);
  } }]), n2;
}();
var Mt4 = react_onclickoutside_es_default(function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2() {
    var t3;
    he7(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s = 0; s < o2; s++)
      a2[s] = arguments[s];
    return ye6(ke4(t3 = r2.call.apply(r2, [this].concat(a2))), "isSelectedMonth", function(e2) {
      return t3.props.month === e2;
    }), ye6(ke4(t3), "renderOptions", function() {
      return t3.props.monthNames.map(function(r3, n3) {
        return import_react2.default.createElement("div", { className: t3.isSelectedMonth(n3) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option", key: r3, onClick: t3.onChange.bind(ke4(t3), n3), "aria-selected": t3.isSelectedMonth(n3) ? "true" : void 0 }, t3.isSelectedMonth(n3) ? import_react2.default.createElement("span", { className: "react-datepicker__month-option--selected" }, "\u2713") : "", r3);
      });
    }), ye6(ke4(t3), "onChange", function(e2) {
      return t3.props.onChange(e2);
    }), ye6(ke4(t3), "handleClickOutside", function() {
      return t3.props.onCancel();
    }), t3;
  }
  return fe5(n2, [{ key: "render", value: function() {
    return import_react2.default.createElement("div", { className: "react-datepicker__month-dropdown" }, this.renderOptions());
  } }]), n2;
}());
var Et4 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2() {
    var t3;
    he7(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s = 0; s < o2; s++)
      a2[s] = arguments[s];
    return ye6(ke4(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { dropdownVisible: false }), ye6(ke4(t3), "renderSelectOptions", function(t4) {
      return t4.map(function(t5, r3) {
        return import_react2.default.createElement("option", { key: r3, value: r3 }, t5);
      });
    }), ye6(ke4(t3), "renderSelectMode", function(r3) {
      return import_react2.default.createElement("select", { value: t3.props.month, className: "react-datepicker__month-select", onChange: function(e2) {
        return t3.onChange(e2.target.value);
      } }, t3.renderSelectOptions(r3));
    }), ye6(ke4(t3), "renderReadView", function(r3, n3) {
      return import_react2.default.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-read-view", onClick: t3.toggleDropdown }, import_react2.default.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }), import_react2.default.createElement("span", { className: "react-datepicker__month-read-view--selected-month" }, n3[t3.props.month]));
    }), ye6(ke4(t3), "renderDropdown", function(r3) {
      return import_react2.default.createElement(Mt4, { key: "dropdown", month: t3.props.month, monthNames: r3, onChange: t3.onChange, onCancel: t3.toggleDropdown });
    }), ye6(ke4(t3), "renderScrollMode", function(e2) {
      var r3 = t3.state.dropdownVisible, n3 = [t3.renderReadView(!r3, e2)];
      return r3 && n3.unshift(t3.renderDropdown(e2)), n3;
    }), ye6(ke4(t3), "onChange", function(e2) {
      t3.toggleDropdown(), e2 !== t3.props.month && t3.props.onChange(e2);
    }), ye6(ke4(t3), "toggleDropdown", function() {
      return t3.setState({ dropdownVisible: !t3.state.dropdownVisible });
    }), t3;
  }
  return fe5(n2, [{ key: "render", value: function() {
    var t3, r3 = this, n3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(e2) {
      return Xe2(e2, r3.props.locale);
    } : function(e2) {
      return Je4(e2, r3.props.locale);
    });
    switch (this.props.dropdownMode) {
      case "scroll":
        t3 = this.renderScrollMode(n3);
        break;
      case "select":
        t3 = this.renderSelectMode(n3);
    }
    return import_react2.default.createElement("div", { className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode) }, t3);
  } }]), n2;
}();
function Pt3(e2, t2) {
  for (var r2 = [], n2 = Fe4(e2), o2 = Fe4(t2); !isAfter(n2, o2); )
    r2.push(Ye4(n2)), n2 = addMonths(n2, 1);
  return r2;
}
var Nt4;
var xt5 = react_onclickoutside_es_default(function(t2) {
  De4(o2, import_react2.default.Component);
  var n2 = be2(o2);
  function o2(t3) {
    var r2;
    return he7(this, o2), ye6(ke4(r2 = n2.call(this, t3)), "renderOptions", function() {
      return r2.state.monthYearsList.map(function(t4) {
        var n3 = getTime(t4), o3 = Qe4(r2.props.date, t4) && He4(r2.props.date, t4);
        return import_react2.default.createElement("div", { className: o3 ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option", key: n3, onClick: r2.onChange.bind(ke4(r2), n3), "aria-selected": o3 ? "true" : void 0 }, o3 ? import_react2.default.createElement("span", { className: "react-datepicker__month-year-option--selected" }, "\u2713") : "", Ie4(t4, r2.props.dateFormat, r2.props.locale));
      });
    }), ye6(ke4(r2), "onChange", function(e2) {
      return r2.props.onChange(e2);
    }), ye6(ke4(r2), "handleClickOutside", function() {
      r2.props.onCancel();
    }), r2.state = { monthYearsList: Pt3(r2.props.minDate, r2.props.maxDate) }, r2;
  }
  return fe5(o2, [{ key: "render", value: function() {
    var t3 = (0, import_classnames.default)({ "react-datepicker__month-year-dropdown": true, "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown });
    return import_react2.default.createElement("div", { className: t3 }, this.renderOptions());
  } }]), o2;
}());
var Yt4 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2() {
    var t3;
    he7(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s = 0; s < o2; s++)
      a2[s] = arguments[s];
    return ye6(ke4(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { dropdownVisible: false }), ye6(ke4(t3), "renderSelectOptions", function() {
      for (var r3 = Fe4(t3.props.minDate), n3 = Fe4(t3.props.maxDate), o3 = []; !isAfter(r3, n3); ) {
        var a3 = getTime(r3);
        o3.push(import_react2.default.createElement("option", { key: a3, value: a3 }, Ie4(r3, t3.props.dateFormat, t3.props.locale))), r3 = addMonths(r3, 1);
      }
      return o3;
    }), ye6(ke4(t3), "onSelectChange", function(e2) {
      t3.onChange(e2.target.value);
    }), ye6(ke4(t3), "renderSelectMode", function() {
      return import_react2.default.createElement("select", { value: getTime(Fe4(t3.props.date)), className: "react-datepicker__month-year-select", onChange: t3.onSelectChange }, t3.renderSelectOptions());
    }), ye6(ke4(t3), "renderReadView", function(r3) {
      var n3 = Ie4(t3.props.date, t3.props.dateFormat, t3.props.locale);
      return import_react2.default.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-year-read-view", onClick: function(e2) {
        return t3.toggleDropdown(e2);
      } }, import_react2.default.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }), import_react2.default.createElement("span", { className: "react-datepicker__month-year-read-view--selected-month-year" }, n3));
    }), ye6(ke4(t3), "renderDropdown", function() {
      return import_react2.default.createElement(xt5, { key: "dropdown", date: t3.props.date, dateFormat: t3.props.dateFormat, onChange: t3.onChange, onCancel: t3.toggleDropdown, minDate: t3.props.minDate, maxDate: t3.props.maxDate, scrollableMonthYearDropdown: t3.props.scrollableMonthYearDropdown, locale: t3.props.locale });
    }), ye6(ke4(t3), "renderScrollMode", function() {
      var e2 = t3.state.dropdownVisible, r3 = [t3.renderReadView(!e2)];
      return e2 && r3.unshift(t3.renderDropdown()), r3;
    }), ye6(ke4(t3), "onChange", function(e2) {
      t3.toggleDropdown();
      var r3 = Ye4(parseInt(e2));
      Qe4(t3.props.date, r3) && He4(t3.props.date, r3) || t3.props.onChange(r3);
    }), ye6(ke4(t3), "toggleDropdown", function() {
      return t3.setState({ dropdownVisible: !t3.state.dropdownVisible });
    }), t3;
  }
  return fe5(n2, [{ key: "render", value: function() {
    var t3;
    switch (this.props.dropdownMode) {
      case "scroll":
        t3 = this.renderScrollMode();
        break;
      case "select":
        t3 = this.renderSelectMode();
    }
    return import_react2.default.createElement("div", { className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode) }, t3);
  } }]), n2;
}();
var Tt3 = function(t2) {
  De4(o2, import_react2.default.Component);
  var n2 = be2(o2);
  function o2() {
    var t3;
    he7(this, o2);
    for (var a2 = arguments.length, s = new Array(a2), i3 = 0; i3 < a2; i3++)
      s[i3] = arguments[i3];
    return ye6(ke4(t3 = n2.call.apply(n2, [this].concat(s))), "dayEl", import_react2.default.createRef()), ye6(ke4(t3), "handleClick", function(e2) {
      !t3.isDisabled() && t3.props.onClick && t3.props.onClick(e2);
    }), ye6(ke4(t3), "handleMouseEnter", function(e2) {
      !t3.isDisabled() && t3.props.onMouseEnter && t3.props.onMouseEnter(e2);
    }), ye6(ke4(t3), "handleOnKeyDown", function(e2) {
      " " === e2.key && (e2.preventDefault(), e2.key = "Enter"), t3.props.handleOnKeyDown(e2);
    }), ye6(ke4(t3), "isSameDay", function(e2) {
      return We4(t3.props.day, e2);
    }), ye6(ke4(t3), "isKeyboardSelected", function() {
      return !t3.props.disabledKeyboardNavigation && !t3.isSameDay(t3.props.selected) && t3.isSameDay(t3.props.preSelection);
    }), ye6(ke4(t3), "isDisabled", function() {
      return Ze4(t3.props.day, t3.props);
    }), ye6(ke4(t3), "isExcluded", function() {
      return et4(t3.props.day, t3.props);
    }), ye6(ke4(t3), "getHighLightedClass", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.highlightDates;
      if (!n3)
        return false;
      var o3 = Ie4(r2, "MM.dd.yyyy");
      return n3.get(o3);
    }), ye6(ke4(t3), "getHolidaysClass", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.holidays;
      if (!n3)
        return false;
      var o3 = Ie4(r2, "MM.dd.yyyy");
      return n3.has(o3) ? [n3.get(o3).className] : void 0;
    }), ye6(ke4(t3), "isInRange", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.startDate, o3 = e2.endDate;
      return !(!n3 || !o3) && qe3(r2, n3, o3);
    }), ye6(ke4(t3), "isInSelectingRange", function() {
      var e2, r2 = t3.props, n3 = r2.day, o3 = r2.selectsStart, a3 = r2.selectsEnd, s2 = r2.selectsRange, i4 = r2.selectsDisabledDaysInRange, p6 = r2.startDate, c3 = r2.endDate, l2 = null !== (e2 = t3.props.selectingDate) && void 0 !== e2 ? e2 : t3.props.preSelection;
      return !(!(o3 || a3 || s2) || !l2 || !i4 && t3.isDisabled()) && (o3 && c3 && (isBefore(l2, c3) || Ve4(l2, c3)) ? qe3(n3, l2, c3) : (a3 && p6 && (isAfter(l2, p6) || Ve4(l2, p6)) || !(!s2 || !p6 || c3 || !isAfter(l2, p6) && !Ve4(l2, p6))) && qe3(n3, p6, l2));
    }), ye6(ke4(t3), "isSelectingRangeStart", function() {
      var e2;
      if (!t3.isInSelectingRange())
        return false;
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.selectsStart, s2 = null !== (e2 = t3.props.selectingDate) && void 0 !== e2 ? e2 : t3.props.preSelection;
      return We4(n3, a3 ? s2 : o3);
    }), ye6(ke4(t3), "isSelectingRangeEnd", function() {
      var e2;
      if (!t3.isInSelectingRange())
        return false;
      var r2 = t3.props, n3 = r2.day, o3 = r2.endDate, a3 = r2.selectsEnd, s2 = r2.selectsRange, i4 = null !== (e2 = t3.props.selectingDate) && void 0 !== e2 ? e2 : t3.props.preSelection;
      return We4(n3, a3 || s2 ? i4 : o3);
    }), ye6(ke4(t3), "isRangeStart", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.startDate, o3 = e2.endDate;
      return !(!n3 || !o3) && We4(n3, r2);
    }), ye6(ke4(t3), "isRangeEnd", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.startDate, o3 = e2.endDate;
      return !(!n3 || !o3) && We4(o3, r2);
    }), ye6(ke4(t3), "isWeekend", function() {
      var e2 = getDay(t3.props.day);
      return 0 === e2 || 6 === e2;
    }), ye6(ke4(t3), "isAfterMonth", function() {
      return void 0 !== t3.props.month && (t3.props.month + 1) % 12 === getMonth(t3.props.day);
    }), ye6(ke4(t3), "isBeforeMonth", function() {
      return void 0 !== t3.props.month && (getMonth(t3.props.day) + 1) % 12 === t3.props.month;
    }), ye6(ke4(t3), "isCurrentDay", function() {
      return t3.isSameDay(Ye4());
    }), ye6(ke4(t3), "isSelected", function() {
      return t3.isSameDay(t3.props.selected);
    }), ye6(ke4(t3), "getClassNames", function(e2) {
      var n3, o3 = t3.props.dayClassName ? t3.props.dayClassName(e2) : void 0;
      return (0, import_classnames.default)("react-datepicker__day", o3, "react-datepicker__day--" + Ie4(t3.props.day, "ddd", n3), { "react-datepicker__day--disabled": t3.isDisabled(), "react-datepicker__day--excluded": t3.isExcluded(), "react-datepicker__day--selected": t3.isSelected(), "react-datepicker__day--keyboard-selected": t3.isKeyboardSelected(), "react-datepicker__day--range-start": t3.isRangeStart(), "react-datepicker__day--range-end": t3.isRangeEnd(), "react-datepicker__day--in-range": t3.isInRange(), "react-datepicker__day--in-selecting-range": t3.isInSelectingRange(), "react-datepicker__day--selecting-range-start": t3.isSelectingRangeStart(), "react-datepicker__day--selecting-range-end": t3.isSelectingRangeEnd(), "react-datepicker__day--today": t3.isCurrentDay(), "react-datepicker__day--weekend": t3.isWeekend(), "react-datepicker__day--outside-month": t3.isAfterMonth() || t3.isBeforeMonth() }, t3.getHighLightedClass("react-datepicker__day--highlighted"), t3.getHolidaysClass());
    }), ye6(ke4(t3), "getAriaLabel", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.ariaLabelPrefixWhenEnabled, o3 = void 0 === n3 ? "Choose" : n3, a3 = e2.ariaLabelPrefixWhenDisabled, s2 = void 0 === a3 ? "Not available" : a3, i4 = t3.isDisabled() || t3.isExcluded() ? s2 : o3;
      return "".concat(i4, " ").concat(Ie4(r2, "PPPP", t3.props.locale));
    }), ye6(ke4(t3), "getTitle", function() {
      var e2 = t3.props, r2 = e2.day, n3 = e2.holidays, o3 = void 0 === n3 ? /* @__PURE__ */ new Map() : n3, a3 = Ie4(r2, "MM.dd.yyyy");
      return o3.has(a3) && o3.get(a3).holidayNames.length > 0 ? o3.get(a3).holidayNames.join(", ") : "";
    }), ye6(ke4(t3), "getTabIndex", function(e2, r2) {
      var n3 = e2 || t3.props.selected, o3 = r2 || t3.props.preSelection;
      return t3.isKeyboardSelected() || t3.isSameDay(n3) && We4(o3, n3) ? 0 : -1;
    }), ye6(ke4(t3), "handleFocusDay", function() {
      var e2, r2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n3 = false;
      0 === t3.getTabIndex() && !r2.isInputFocused && t3.isSameDay(t3.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (n3 = true), t3.props.inline && !t3.props.shouldFocusDayInline && (n3 = false), t3.props.containerRef && t3.props.containerRef.current && t3.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (n3 = true), t3.props.monthShowsDuplicateDaysEnd && t3.isAfterMonth() && (n3 = false), t3.props.monthShowsDuplicateDaysStart && t3.isBeforeMonth() && (n3 = false)), n3 && (null === (e2 = t3.dayEl.current) || void 0 === e2 || e2.focus({ preventScroll: true }));
    }), ye6(ke4(t3), "renderDayContents", function() {
      return t3.props.monthShowsDuplicateDaysEnd && t3.isAfterMonth() || t3.props.monthShowsDuplicateDaysStart && t3.isBeforeMonth() ? null : t3.props.renderDayContents ? t3.props.renderDayContents(getDate(t3.props.day), t3.props.day) : getDate(t3.props.day);
    }), ye6(ke4(t3), "render", function() {
      return import_react2.default.createElement("div", { ref: t3.dayEl, className: t3.getClassNames(t3.props.day), onKeyDown: t3.handleOnKeyDown, onClick: t3.handleClick, onMouseEnter: t3.handleMouseEnter, tabIndex: t3.getTabIndex(), "aria-label": t3.getAriaLabel(), role: "option", title: t3.getTitle(), "aria-disabled": t3.isDisabled(), "aria-current": t3.isCurrentDay() ? "date" : void 0, "aria-selected": t3.isSelected() || t3.isInRange() }, t3.renderDayContents(), "" !== t3.getTitle() && import_react2.default.createElement("span", { className: "holiday-overlay" }, t3.getTitle()));
    }), t3;
  }
  return fe5(o2, [{ key: "componentDidMount", value: function() {
    this.handleFocusDay();
  } }, { key: "componentDidUpdate", value: function(e2) {
    this.handleFocusDay(e2);
  } }]), o2;
}();
var It3 = function(t2) {
  De4(o2, import_react2.default.Component);
  var n2 = be2(o2);
  function o2() {
    var e2;
    he7(this, o2);
    for (var t3 = arguments.length, r2 = new Array(t3), a2 = 0; a2 < t3; a2++)
      r2[a2] = arguments[a2];
    return ye6(ke4(e2 = n2.call.apply(n2, [this].concat(r2))), "handleClick", function(t4) {
      e2.props.onClick && e2.props.onClick(t4);
    }), e2;
  }
  return fe5(o2, [{ key: "render", value: function() {
    var t3 = this.props, n3 = t3.weekNumber, o3 = t3.ariaLabelPrefix, a2 = void 0 === o3 ? "week " : o3, s = { "react-datepicker__week-number": true, "react-datepicker__week-number--clickable": !!t3.onClick };
    return import_react2.default.createElement("div", { className: (0, import_classnames.default)(s), "aria-label": "".concat(a2, " ").concat(this.props.weekNumber), onClick: this.handleClick }, n3);
  } }], [{ key: "defaultProps", get: function() {
    return { ariaLabelPrefix: "week " };
  } }]), o2;
}();
var Ot3 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2() {
    var t3;
    he7(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), s = 0; s < o2; s++)
      a2[s] = arguments[s];
    return ye6(ke4(t3 = r2.call.apply(r2, [this].concat(a2))), "handleDayClick", function(e2, r3) {
      t3.props.onDayClick && t3.props.onDayClick(e2, r3);
    }), ye6(ke4(t3), "handleDayMouseEnter", function(e2) {
      t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e2);
    }), ye6(ke4(t3), "handleWeekClick", function(e2, r3, n3) {
      "function" == typeof t3.props.onWeekSelect && t3.props.onWeekSelect(e2, r3, n3), t3.props.shouldCloseOnSelect && t3.props.setOpen(false);
    }), ye6(ke4(t3), "formatWeekNumber", function(e2) {
      return t3.props.formatWeekNumber ? t3.props.formatWeekNumber(e2) : function(e3, t4) {
        var r3 = t4 && Ge3(t4) || $e2() && Ge3($e2());
        return getISOWeek(e3, r3 ? { locale: r3 } : null);
      }(e2);
    }), ye6(ke4(t3), "renderDays", function() {
      var r3 = Le3(t3.props.day, t3.props.locale, t3.props.calendarStartDay), n3 = [], o3 = t3.formatWeekNumber(r3);
      if (t3.props.showWeekNumber) {
        var a3 = t3.props.onWeekSelect ? t3.handleWeekClick.bind(ke4(t3), r3, o3) : void 0;
        n3.push(import_react2.default.createElement(It3, { key: "W", weekNumber: o3, onClick: a3, ariaLabelPrefix: t3.props.ariaLabelPrefix }));
      }
      return n3.concat([0, 1, 2, 3, 4, 5, 6].map(function(n4) {
        var o4 = addDays(r3, n4);
        return import_react2.default.createElement(Tt3, { ariaLabelPrefixWhenEnabled: t3.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: t3.props.disabledDayAriaLabelPrefix, key: o4.valueOf(), day: o4, month: t3.props.month, onClick: t3.handleDayClick.bind(ke4(t3), o4), onMouseEnter: t3.handleDayMouseEnter.bind(ke4(t3), o4), minDate: t3.props.minDate, maxDate: t3.props.maxDate, excludeDates: t3.props.excludeDates, excludeDateIntervals: t3.props.excludeDateIntervals, includeDates: t3.props.includeDates, includeDateIntervals: t3.props.includeDateIntervals, highlightDates: t3.props.highlightDates, holidays: t3.props.holidays, selectingDate: t3.props.selectingDate, filterDate: t3.props.filterDate, preSelection: t3.props.preSelection, selected: t3.props.selected, selectsStart: t3.props.selectsStart, selectsEnd: t3.props.selectsEnd, selectsRange: t3.props.selectsRange, selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange, startDate: t3.props.startDate, endDate: t3.props.endDate, dayClassName: t3.props.dayClassName, renderDayContents: t3.props.renderDayContents, disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation, handleOnKeyDown: t3.props.handleOnKeyDown, isInputFocused: t3.props.isInputFocused, containerRef: t3.props.containerRef, inline: t3.props.inline, shouldFocusDayInline: t3.props.shouldFocusDayInline, monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart, locale: t3.props.locale });
      }));
    }), t3;
  }
  return fe5(n2, [{ key: "render", value: function() {
    return import_react2.default.createElement("div", { className: "react-datepicker__week" }, this.renderDays());
  } }], [{ key: "defaultProps", get: function() {
    return { shouldCloseOnSelect: true };
  } }]), n2;
}();
var Rt3 = "two_columns";
var Lt4 = "three_columns";
var Ft4 = "four_columns";
var At4 = (ye6(Nt4 = {}, Rt3, { grid: [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]], verticalNavigationOffset: 2 }), ye6(Nt4, Lt4, { grid: [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]], verticalNavigationOffset: 3 }), ye6(Nt4, Ft4, { grid: [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]], verticalNavigationOffset: 4 }), Nt4);
function Bt4(e2, t2) {
  return e2 ? Ft4 : t2 ? Rt3 : Lt4;
}
var Kt4 = function(t2) {
  De4(o2, import_react2.default.Component);
  var n2 = be2(o2);
  function o2() {
    var t3;
    he7(this, o2);
    for (var a2 = arguments.length, s = new Array(a2), i3 = 0; i3 < a2; i3++)
      s[i3] = arguments[i3];
    return ye6(ke4(t3 = n2.call.apply(n2, [this].concat(s))), "MONTH_REFS", Se2(Array(12)).map(function() {
      return import_react2.default.createRef();
    })), ye6(ke4(t3), "QUARTER_REFS", Se2(Array(4)).map(function() {
      return import_react2.default.createRef();
    })), ye6(ke4(t3), "isDisabled", function(e2) {
      return Ze4(e2, t3.props);
    }), ye6(ke4(t3), "isExcluded", function(e2) {
      return et4(e2, t3.props);
    }), ye6(ke4(t3), "handleDayClick", function(e2, r2) {
      t3.props.onDayClick && t3.props.onDayClick(e2, r2, t3.props.orderInDisplay);
    }), ye6(ke4(t3), "handleDayMouseEnter", function(e2) {
      t3.props.onDayMouseEnter && t3.props.onDayMouseEnter(e2);
    }), ye6(ke4(t3), "handleMouseLeave", function() {
      t3.props.onMouseLeave && t3.props.onMouseLeave();
    }), ye6(ke4(t3), "isRangeStartMonth", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && He4(setMonth(n3, e2), o3);
    }), ye6(ke4(t3), "isRangeStartQuarter", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && je4(setQuarter(n3, e2), o3);
    }), ye6(ke4(t3), "isRangeEndMonth", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && He4(setMonth(n3, e2), a3);
    }), ye6(ke4(t3), "isRangeEndQuarter", function(e2) {
      var r2 = t3.props, n3 = r2.day, o3 = r2.startDate, a3 = r2.endDate;
      return !(!o3 || !a3) && je4(setQuarter(n3, e2), a3);
    }), ye6(ke4(t3), "isInSelectingRangeMonth", function(e2) {
      var r2, n3 = t3.props, o3 = n3.day, a3 = n3.selectsStart, s2 = n3.selectsEnd, i4 = n3.selectsRange, p6 = n3.startDate, c3 = n3.endDate, l2 = null !== (r2 = t3.props.selectingDate) && void 0 !== r2 ? r2 : t3.props.preSelection;
      return !(!(a3 || s2 || i4) || !l2) && (a3 && c3 ? rt3(l2, c3, e2, o3) : (s2 && p6 || !(!i4 || !p6 || c3)) && rt3(p6, l2, e2, o3));
    }), ye6(ke4(t3), "isSelectingMonthRangeStart", function(e2) {
      var r2;
      if (!t3.isInSelectingRangeMonth(e2))
        return false;
      var n3 = t3.props, o3 = n3.day, a3 = n3.startDate, s2 = n3.selectsStart, i4 = setMonth(o3, e2), p6 = null !== (r2 = t3.props.selectingDate) && void 0 !== r2 ? r2 : t3.props.preSelection;
      return He4(i4, s2 ? p6 : a3);
    }), ye6(ke4(t3), "isSelectingMonthRangeEnd", function(e2) {
      var r2;
      if (!t3.isInSelectingRangeMonth(e2))
        return false;
      var n3 = t3.props, o3 = n3.day, a3 = n3.endDate, s2 = n3.selectsEnd, i4 = n3.selectsRange, p6 = setMonth(o3, e2), c3 = null !== (r2 = t3.props.selectingDate) && void 0 !== r2 ? r2 : t3.props.preSelection;
      return He4(p6, s2 || i4 ? c3 : a3);
    }), ye6(ke4(t3), "isInSelectingRangeQuarter", function(e2) {
      var r2, n3 = t3.props, o3 = n3.day, a3 = n3.selectsStart, s2 = n3.selectsEnd, i4 = n3.selectsRange, p6 = n3.startDate, c3 = n3.endDate, l2 = null !== (r2 = t3.props.selectingDate) && void 0 !== r2 ? r2 : t3.props.preSelection;
      return !(!(a3 || s2 || i4) || !l2) && (a3 && c3 ? st6(l2, c3, e2, o3) : (s2 && p6 || !(!i4 || !p6 || c3)) && st6(p6, l2, e2, o3));
    }), ye6(ke4(t3), "isWeekInMonth", function(e2) {
      var r2 = t3.props.day, n3 = addDays(e2, 6);
      return He4(e2, r2) || He4(n3, r2);
    }), ye6(ke4(t3), "isCurrentMonth", function(e2, t4) {
      return getYear(e2) === getYear(Ye4()) && t4 === getMonth(Ye4());
    }), ye6(ke4(t3), "isCurrentQuarter", function(e2, t4) {
      return getYear(e2) === getYear(Ye4()) && t4 === getQuarter(Ye4());
    }), ye6(ke4(t3), "isSelectedMonth", function(e2, t4, r2) {
      return getMonth(r2) === t4 && getYear(e2) === getYear(r2);
    }), ye6(ke4(t3), "isSelectedQuarter", function(e2, t4, r2) {
      return getQuarter(e2) === t4 && getYear(e2) === getYear(r2);
    }), ye6(ke4(t3), "renderWeeks", function() {
      for (var r2 = [], n3 = t3.props.fixedHeight, o3 = 0, a3 = false, s2 = Le3(Fe4(t3.props.day), t3.props.locale, t3.props.calendarStartDay); r2.push(import_react2.default.createElement(Ot3, { ariaLabelPrefix: t3.props.weekAriaLabelPrefix, chooseDayAriaLabelPrefix: t3.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: t3.props.disabledDayAriaLabelPrefix, key: o3, day: s2, month: getMonth(t3.props.day), onDayClick: t3.handleDayClick, onDayMouseEnter: t3.handleDayMouseEnter, onWeekSelect: t3.props.onWeekSelect, formatWeekNumber: t3.props.formatWeekNumber, locale: t3.props.locale, minDate: t3.props.minDate, maxDate: t3.props.maxDate, excludeDates: t3.props.excludeDates, excludeDateIntervals: t3.props.excludeDateIntervals, includeDates: t3.props.includeDates, includeDateIntervals: t3.props.includeDateIntervals, inline: t3.props.inline, shouldFocusDayInline: t3.props.shouldFocusDayInline, highlightDates: t3.props.highlightDates, holidays: t3.props.holidays, selectingDate: t3.props.selectingDate, filterDate: t3.props.filterDate, preSelection: t3.props.preSelection, selected: t3.props.selected, selectsStart: t3.props.selectsStart, selectsEnd: t3.props.selectsEnd, selectsRange: t3.props.selectsRange, selectsDisabledDaysInRange: t3.props.selectsDisabledDaysInRange, showWeekNumber: t3.props.showWeekNumbers, startDate: t3.props.startDate, endDate: t3.props.endDate, dayClassName: t3.props.dayClassName, setOpen: t3.props.setOpen, shouldCloseOnSelect: t3.props.shouldCloseOnSelect, disabledKeyboardNavigation: t3.props.disabledKeyboardNavigation, renderDayContents: t3.props.renderDayContents, handleOnKeyDown: t3.props.handleOnKeyDown, isInputFocused: t3.props.isInputFocused, containerRef: t3.props.containerRef, calendarStartDay: t3.props.calendarStartDay, monthShowsDuplicateDaysEnd: t3.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t3.props.monthShowsDuplicateDaysStart })), !a3; ) {
        o3++, s2 = addWeeks(s2, 1);
        var i4 = n3 && o3 >= 6, p6 = !n3 && !t3.isWeekInMonth(s2);
        if (i4 || p6) {
          if (!t3.props.peekNextMonth)
            break;
          a3 = true;
        }
      }
      return r2;
    }), ye6(ke4(t3), "onMonthClick", function(e2, r2) {
      t3.handleDayClick(Fe4(setMonth(t3.props.day, r2)), e2);
    }), ye6(ke4(t3), "onMonthMouseEnter", function(e2) {
      t3.handleDayMouseEnter(Fe4(setMonth(t3.props.day, e2)));
    }), ye6(ke4(t3), "handleMonthNavigation", function(e2, r2) {
      t3.isDisabled(r2) || t3.isExcluded(r2) || (t3.props.setPreSelection(r2), t3.MONTH_REFS[e2].current && t3.MONTH_REFS[e2].current.focus());
    }), ye6(ke4(t3), "onMonthKeyDown", function(e2, r2) {
      var n3 = t3.props, o3 = n3.selected, a3 = n3.preSelection, s2 = n3.disabledKeyboardNavigation, i4 = n3.showTwoColumnMonthYearPicker, p6 = n3.showFourColumnMonthYearPicker, c3 = n3.setPreSelection, d4 = e2.key;
      if ("Tab" !== d4 && e2.preventDefault(), !s2) {
        var u3 = Bt4(p6, i4), h5 = At4[u3].verticalNavigationOffset, m4 = At4[u3].grid;
        switch (d4) {
          case "Enter":
            t3.onMonthClick(e2, r2), c3(o3);
            break;
          case "ArrowRight":
            t3.handleMonthNavigation(11 === r2 ? 0 : r2 + 1, addMonths(a3, 1));
            break;
          case "ArrowLeft":
            t3.handleMonthNavigation(0 === r2 ? 11 : r2 - 1, subMonths(a3, 1));
            break;
          case "ArrowUp":
            t3.handleMonthNavigation(m4[0].includes(r2) ? r2 + 12 - h5 : r2 - h5, subMonths(a3, h5));
            break;
          case "ArrowDown":
            t3.handleMonthNavigation(m4[m4.length - 1].includes(r2) ? r2 - 12 + h5 : r2 + h5, addMonths(a3, h5));
        }
      }
    }), ye6(ke4(t3), "onQuarterClick", function(e2, r2) {
      t3.handleDayClick(Be3(setQuarter(t3.props.day, r2)), e2);
    }), ye6(ke4(t3), "onQuarterMouseEnter", function(e2) {
      t3.handleDayMouseEnter(Be3(setQuarter(t3.props.day, e2)));
    }), ye6(ke4(t3), "handleQuarterNavigation", function(e2, r2) {
      t3.isDisabled(r2) || t3.isExcluded(r2) || (t3.props.setPreSelection(r2), t3.QUARTER_REFS[e2 - 1].current && t3.QUARTER_REFS[e2 - 1].current.focus());
    }), ye6(ke4(t3), "onQuarterKeyDown", function(e2, r2) {
      var n3 = e2.key;
      if (!t3.props.disabledKeyboardNavigation)
        switch (n3) {
          case "Enter":
            t3.onQuarterClick(e2, r2), t3.props.setPreSelection(t3.props.selected);
            break;
          case "ArrowRight":
            t3.handleQuarterNavigation(4 === r2 ? 1 : r2 + 1, addQuarters(t3.props.preSelection, 1));
            break;
          case "ArrowLeft":
            t3.handleQuarterNavigation(1 === r2 ? 4 : r2 - 1, subQuarters(t3.props.preSelection, 1));
        }
    }), ye6(ke4(t3), "getMonthClassNames", function(e2) {
      var n3 = t3.props, o3 = n3.day, a3 = n3.startDate, s2 = n3.endDate, i4 = n3.selected, p6 = n3.minDate, c3 = n3.maxDate, l2 = n3.preSelection, d4 = n3.monthClassName, u3 = n3.excludeDates, h5 = n3.includeDates, m4 = d4 ? d4(setMonth(o3, e2)) : void 0, f4 = setMonth(o3, e2);
      return (0, import_classnames.default)("react-datepicker__month-text", "react-datepicker__month-".concat(e2), m4, { "react-datepicker__month-text--disabled": (p6 || c3 || u3 || h5) && tt3(f4, t3.props), "react-datepicker__month-text--selected": t3.isSelectedMonth(o3, e2, i4), "react-datepicker__month-text--keyboard-selected": !t3.props.disabledKeyboardNavigation && getMonth(l2) === e2, "react-datepicker__month-text--in-selecting-range": t3.isInSelectingRangeMonth(e2), "react-datepicker__month-text--in-range": rt3(a3, s2, e2, o3), "react-datepicker__month-text--range-start": t3.isRangeStartMonth(e2), "react-datepicker__month-text--range-end": t3.isRangeEndMonth(e2), "react-datepicker__month-text--selecting-range-start": t3.isSelectingMonthRangeStart(e2), "react-datepicker__month-text--selecting-range-end": t3.isSelectingMonthRangeEnd(e2), "react-datepicker__month-text--today": t3.isCurrentMonth(o3, e2) });
    }), ye6(ke4(t3), "getTabIndex", function(e2) {
      var r2 = getMonth(t3.props.preSelection);
      return t3.props.disabledKeyboardNavigation || e2 !== r2 ? "-1" : "0";
    }), ye6(ke4(t3), "getQuarterTabIndex", function(e2) {
      var r2 = getQuarter(t3.props.preSelection);
      return t3.props.disabledKeyboardNavigation || e2 !== r2 ? "-1" : "0";
    }), ye6(ke4(t3), "getAriaLabel", function(e2) {
      var r2 = t3.props, n3 = r2.chooseDayAriaLabelPrefix, o3 = void 0 === n3 ? "Choose" : n3, a3 = r2.disabledDayAriaLabelPrefix, s2 = void 0 === a3 ? "Not available" : a3, i4 = r2.day, p6 = setMonth(i4, e2), c3 = t3.isDisabled(p6) || t3.isExcluded(p6) ? s2 : o3;
      return "".concat(c3, " ").concat(Ie4(p6, "MMMM yyyy"));
    }), ye6(ke4(t3), "getQuarterClassNames", function(e2) {
      var n3 = t3.props, o3 = n3.day, a3 = n3.startDate, s2 = n3.endDate, i4 = n3.selected, p6 = n3.minDate, c3 = n3.maxDate, l2 = n3.preSelection;
      return (0, import_classnames.default)("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(e2), { "react-datepicker__quarter-text--disabled": (p6 || c3) && nt4(setQuarter(o3, e2), t3.props), "react-datepicker__quarter-text--selected": t3.isSelectedQuarter(o3, e2, i4), "react-datepicker__quarter-text--keyboard-selected": getQuarter(l2) === e2, "react-datepicker__quarter-text--in-selecting-range": t3.isInSelectingRangeQuarter(e2), "react-datepicker__quarter-text--in-range": st6(a3, s2, e2, o3), "react-datepicker__quarter-text--range-start": t3.isRangeStartQuarter(e2), "react-datepicker__quarter-text--range-end": t3.isRangeEndQuarter(e2) });
    }), ye6(ke4(t3), "getMonthContent", function(e2) {
      var r2 = t3.props, n3 = r2.showFullMonthYearPicker, o3 = r2.renderMonthContent, a3 = r2.locale, s2 = Xe2(e2, a3), i4 = Je4(e2, a3);
      return o3 ? o3(e2, s2, i4) : n3 ? i4 : s2;
    }), ye6(ke4(t3), "getQuarterContent", function(e2) {
      var r2 = t3.props, n3 = r2.renderQuarterContent, o3 = function(e3, t4) {
        return Ie4(setQuarter(Ye4(), e3), "QQQ", t4);
      }(e2, r2.locale);
      return n3 ? n3(e2, o3) : o3;
    }), ye6(ke4(t3), "renderMonths", function() {
      var r2 = t3.props, n3 = r2.showTwoColumnMonthYearPicker, o3 = r2.showFourColumnMonthYearPicker, a3 = r2.day, s2 = r2.selected;
      return At4[Bt4(o3, n3)].grid.map(function(r3, n4) {
        return import_react2.default.createElement("div", { className: "react-datepicker__month-wrapper", key: n4 }, r3.map(function(r4, n5) {
          return import_react2.default.createElement("div", { ref: t3.MONTH_REFS[r4], key: n5, onClick: function(e2) {
            t3.onMonthClick(e2, r4);
          }, onKeyDown: function(e2) {
            t3.onMonthKeyDown(e2, r4);
          }, onMouseEnter: function() {
            return t3.onMonthMouseEnter(r4);
          }, tabIndex: t3.getTabIndex(r4), className: t3.getMonthClassNames(r4), role: "option", "aria-label": t3.getAriaLabel(r4), "aria-current": t3.isCurrentMonth(a3, r4) ? "date" : void 0, "aria-selected": t3.isSelectedMonth(a3, r4, s2) }, t3.getMonthContent(r4));
        }));
      });
    }), ye6(ke4(t3), "renderQuarters", function() {
      var r2 = t3.props, n3 = r2.day, o3 = r2.selected;
      return import_react2.default.createElement("div", { className: "react-datepicker__quarter-wrapper" }, [1, 2, 3, 4].map(function(r3, a3) {
        return import_react2.default.createElement("div", { key: a3, ref: t3.QUARTER_REFS[a3], role: "option", onClick: function(e2) {
          t3.onQuarterClick(e2, r3);
        }, onKeyDown: function(e2) {
          t3.onQuarterKeyDown(e2, r3);
        }, onMouseEnter: function() {
          return t3.onQuarterMouseEnter(r3);
        }, className: t3.getQuarterClassNames(r3), "aria-selected": t3.isSelectedQuarter(n3, r3, o3), tabIndex: t3.getQuarterTabIndex(r3), "aria-current": t3.isCurrentQuarter(n3, r3) ? "date" : void 0 }, t3.getQuarterContent(r3));
      }));
    }), ye6(ke4(t3), "getClassNames", function() {
      var e2 = t3.props, n3 = e2.selectingDate, o3 = e2.selectsStart, a3 = e2.selectsEnd, s2 = e2.showMonthYearPicker, i4 = e2.showQuarterYearPicker;
      return (0, import_classnames.default)("react-datepicker__month", { "react-datepicker__month--selecting-range": n3 && (o3 || a3) }, { "react-datepicker__monthPicker": s2 }, { "react-datepicker__quarterPicker": i4 });
    }), t3;
  }
  return fe5(o2, [{ key: "render", value: function() {
    var t3 = this.props, r2 = t3.showMonthYearPicker, n3 = t3.showQuarterYearPicker, o3 = t3.day, a2 = t3.ariaLabelPrefix, s = void 0 === a2 ? "month " : a2;
    return import_react2.default.createElement("div", { className: this.getClassNames(), onMouseLeave: this.handleMouseLeave, "aria-label": "".concat(s, " ").concat(Ie4(o3, "yyyy-MM")), role: "listbox" }, r2 ? this.renderMonths() : n3 ? this.renderQuarters() : this.renderWeeks());
  } }]), o2;
}();
var Qt4 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2() {
    var t3;
    he7(this, n2);
    for (var o2 = arguments.length, a2 = new Array(o2), i3 = 0; i3 < o2; i3++)
      a2[i3] = arguments[i3];
    return ye6(ke4(t3 = r2.call.apply(r2, [this].concat(a2))), "state", { height: null }), ye6(ke4(t3), "scrollToTheSelectedTime", function() {
      requestAnimationFrame(function() {
        t3.list && (t3.list.scrollTop = t3.centerLi && n2.calcCenterPosition(t3.props.monthRef ? t3.props.monthRef.clientHeight - t3.header.clientHeight : t3.list.clientHeight, t3.centerLi));
      });
    }), ye6(ke4(t3), "handleClick", function(e2) {
      (t3.props.minTime || t3.props.maxTime) && lt5(e2, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && ct4(e2, t3.props) || t3.props.onChange(e2);
    }), ye6(ke4(t3), "isSelectedTime", function(e2) {
      return t3.props.selected && (r3 = t3.props.selected, n3 = e2, bt4(r3).getTime() === bt4(n3).getTime());
      var r3, n3;
    }), ye6(ke4(t3), "isDisabledTime", function(e2) {
      return (t3.props.minTime || t3.props.maxTime) && lt5(e2, t3.props) || (t3.props.excludeTimes || t3.props.includeTimes || t3.props.filterTime) && ct4(e2, t3.props);
    }), ye6(ke4(t3), "liClasses", function(e2) {
      var r3 = ["react-datepicker__time-list-item", t3.props.timeClassName ? t3.props.timeClassName(e2) : void 0];
      return t3.isSelectedTime(e2) && r3.push("react-datepicker__time-list-item--selected"), t3.isDisabledTime(e2) && r3.push("react-datepicker__time-list-item--disabled"), t3.props.injectTimes && (60 * getHours(e2) + getMinutes(e2)) % t3.props.intervals != 0 && r3.push("react-datepicker__time-list-item--injected"), r3.join(" ");
    }), ye6(ke4(t3), "handleOnKeyDown", function(e2, r3) {
      " " === e2.key && (e2.preventDefault(), e2.key = "Enter"), "ArrowUp" !== e2.key && "ArrowLeft" !== e2.key || !e2.target.previousSibling || (e2.preventDefault(), e2.target.previousSibling.focus()), "ArrowDown" !== e2.key && "ArrowRight" !== e2.key || !e2.target.nextSibling || (e2.preventDefault(), e2.target.nextSibling.focus()), "Enter" === e2.key && t3.handleClick(r3), t3.props.handleOnKeyDown(e2);
    }), ye6(ke4(t3), "renderTimes", function() {
      for (var r3 = [], n3 = t3.props.format ? t3.props.format : "p", o3 = t3.props.intervals, a3 = t3.props.selected || t3.props.openToDate || Ye4(), i4 = startOfDay(a3), p6 = t3.props.injectTimes && t3.props.injectTimes.sort(function(e2, t4) {
        return e2 - t4;
      }), c3 = 60 * function(e2) {
        var t4 = new Date(e2.getFullYear(), e2.getMonth(), e2.getDate()), r4 = new Date(e2.getFullYear(), e2.getMonth(), e2.getDate(), 24);
        return Math.round((+r4 - +t4) / 36e5);
      }(a3), l2 = c3 / o3, d4 = 0; d4 < l2; d4++) {
        var u3 = addMinutes(i4, d4 * o3);
        if (r3.push(u3), p6) {
          var h5 = gt4(i4, u3, d4, o3, p6);
          r3 = r3.concat(h5);
        }
      }
      var m4 = r3.reduce(function(e2, t4) {
        return t4.getTime() <= a3.getTime() ? t4 : e2;
      }, r3[0]);
      return r3.map(function(r4, o4) {
        return import_react2.default.createElement("li", { key: o4, onClick: t3.handleClick.bind(ke4(t3), r4), className: t3.liClasses(r4), ref: function(e2) {
          r4 === m4 && (t3.centerLi = e2);
        }, onKeyDown: function(e2) {
          t3.handleOnKeyDown(e2, r4);
        }, tabIndex: r4 === m4 ? 0 : -1, role: "option", "aria-selected": t3.isSelectedTime(r4) ? "true" : void 0, "aria-disabled": t3.isDisabledTime(r4) ? "true" : void 0 }, Ie4(r4, n3, t3.props.locale));
      });
    }), t3;
  }
  return fe5(n2, [{ key: "componentDidMount", value: function() {
    this.scrollToTheSelectedTime(), this.props.monthRef && this.header && this.setState({ height: this.props.monthRef.clientHeight - this.header.clientHeight });
  } }, { key: "render", value: function() {
    var t3 = this, r3 = this.state.height;
    return import_react2.default.createElement("div", { className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "") }, import_react2.default.createElement("div", { className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""), ref: function(e2) {
      t3.header = e2;
    } }, import_react2.default.createElement("div", { className: "react-datepicker-time__header" }, this.props.timeCaption)), import_react2.default.createElement("div", { className: "react-datepicker__time" }, import_react2.default.createElement("div", { className: "react-datepicker__time-box" }, import_react2.default.createElement("ul", { className: "react-datepicker__time-list", ref: function(e2) {
      t3.list = e2;
    }, style: r3 ? { height: r3 } : {}, role: "listbox", "aria-label": this.props.timeCaption }, this.renderTimes()))));
  } }], [{ key: "defaultProps", get: function() {
    return { intervals: 30, onTimeChange: function() {
    }, todayButton: null, timeCaption: "Time" };
  } }]), n2;
}();
ye6(Qt4, "calcCenterPosition", function(e2, t2) {
  return t2.offsetTop - (e2 / 2 - t2.clientHeight / 2);
});
var Ht3 = function(t2) {
  De4(o2, import_react2.default.Component);
  var n2 = be2(o2);
  function o2(t3) {
    var a2;
    return he7(this, o2), ye6(ke4(a2 = n2.call(this, t3)), "YEAR_REFS", Se2(Array(a2.props.yearItemNumber)).map(function() {
      return import_react2.default.createRef();
    })), ye6(ke4(a2), "isDisabled", function(e2) {
      return Ze4(e2, a2.props);
    }), ye6(ke4(a2), "isExcluded", function(e2) {
      return et4(e2, a2.props);
    }), ye6(ke4(a2), "selectingDate", function() {
      var e2;
      return null !== (e2 = a2.props.selectingDate) && void 0 !== e2 ? e2 : a2.props.preSelection;
    }), ye6(ke4(a2), "updateFocusOnPaginate", function(e2) {
      var t4 = function() {
        this.YEAR_REFS[e2].current.focus();
      }.bind(ke4(a2));
      window.requestAnimationFrame(t4);
    }), ye6(ke4(a2), "handleYearClick", function(e2, t4) {
      a2.props.onDayClick && a2.props.onDayClick(e2, t4);
    }), ye6(ke4(a2), "handleYearNavigation", function(e2, t4) {
      var r2 = a2.props, n3 = r2.date, o3 = r2.yearItemNumber, s = kt4(n3, o3).startPeriod;
      a2.isDisabled(t4) || a2.isExcluded(t4) || (a2.props.setPreSelection(t4), e2 - s == -1 ? a2.updateFocusOnPaginate(o3 - 1) : e2 - s === o3 ? a2.updateFocusOnPaginate(0) : a2.YEAR_REFS[e2 - s].current.focus());
    }), ye6(ke4(a2), "isSameDay", function(e2, t4) {
      return We4(e2, t4);
    }), ye6(ke4(a2), "isCurrentYear", function(e2) {
      return e2 === getYear(Ye4());
    }), ye6(ke4(a2), "isRangeStart", function(e2) {
      return a2.props.startDate && a2.props.endDate && Qe4(setYear(Ye4(), e2), a2.props.startDate);
    }), ye6(ke4(a2), "isRangeEnd", function(e2) {
      return a2.props.startDate && a2.props.endDate && Qe4(setYear(Ye4(), e2), a2.props.endDate);
    }), ye6(ke4(a2), "isInRange", function(e2) {
      return ot3(e2, a2.props.startDate, a2.props.endDate);
    }), ye6(ke4(a2), "isInSelectingRange", function(e2) {
      var t4 = a2.props, r2 = t4.selectsStart, n3 = t4.selectsEnd, o3 = t4.selectsRange, s = t4.startDate, i3 = t4.endDate;
      return !(!(r2 || n3 || o3) || !a2.selectingDate()) && (r2 && i3 ? ot3(e2, a2.selectingDate(), i3) : (n3 && s || !(!o3 || !s || i3)) && ot3(e2, s, a2.selectingDate()));
    }), ye6(ke4(a2), "isSelectingRangeStart", function(e2) {
      if (!a2.isInSelectingRange(e2))
        return false;
      var t4 = a2.props, r2 = t4.startDate, n3 = t4.selectsStart, o3 = setYear(Ye4(), e2);
      return Qe4(o3, n3 ? a2.selectingDate() : r2);
    }), ye6(ke4(a2), "isSelectingRangeEnd", function(e2) {
      if (!a2.isInSelectingRange(e2))
        return false;
      var t4 = a2.props, r2 = t4.endDate, n3 = t4.selectsEnd, o3 = t4.selectsRange, s = setYear(Ye4(), e2);
      return Qe4(s, n3 || o3 ? a2.selectingDate() : r2);
    }), ye6(ke4(a2), "isKeyboardSelected", function(e2) {
      var t4 = Ae4(setYear(a2.props.date, e2));
      return !a2.props.disabledKeyboardNavigation && !a2.props.inline && !We4(t4, Ae4(a2.props.selected)) && We4(t4, Ae4(a2.props.preSelection));
    }), ye6(ke4(a2), "onYearClick", function(e2, t4) {
      var r2 = a2.props.date;
      a2.handleYearClick(Ae4(setYear(r2, t4)), e2);
    }), ye6(ke4(a2), "onYearKeyDown", function(e2, t4) {
      var r2 = e2.key;
      if (!a2.props.disabledKeyboardNavigation)
        switch (r2) {
          case "Enter":
            a2.onYearClick(e2, t4), a2.props.setPreSelection(a2.props.selected);
            break;
          case "ArrowRight":
            a2.handleYearNavigation(t4 + 1, addYears(a2.props.preSelection, 1));
            break;
          case "ArrowLeft":
            a2.handleYearNavigation(t4 - 1, subYears(a2.props.preSelection, 1));
        }
    }), ye6(ke4(a2), "getYearClassNames", function(e2) {
      var t4 = a2.props, n3 = t4.minDate, o3 = t4.maxDate, s = t4.selected, i3 = t4.excludeDates, p6 = t4.includeDates, c3 = t4.filterDate;
      return (0, import_classnames.default)("react-datepicker__year-text", { "react-datepicker__year-text--selected": e2 === getYear(s), "react-datepicker__year-text--disabled": (n3 || o3 || i3 || p6 || c3) && at5(e2, a2.props), "react-datepicker__year-text--keyboard-selected": a2.isKeyboardSelected(e2), "react-datepicker__year-text--range-start": a2.isRangeStart(e2), "react-datepicker__year-text--range-end": a2.isRangeEnd(e2), "react-datepicker__year-text--in-range": a2.isInRange(e2), "react-datepicker__year-text--in-selecting-range": a2.isInSelectingRange(e2), "react-datepicker__year-text--selecting-range-start": a2.isSelectingRangeStart(e2), "react-datepicker__year-text--selecting-range-end": a2.isSelectingRangeEnd(e2), "react-datepicker__year-text--today": a2.isCurrentYear(e2) });
    }), ye6(ke4(a2), "getYearTabIndex", function(e2) {
      return a2.props.disabledKeyboardNavigation ? "-1" : e2 === getYear(a2.props.preSelection) ? "0" : "-1";
    }), ye6(ke4(a2), "getYearContainerClassNames", function() {
      var e2 = a2.props, t4 = e2.selectingDate, n3 = e2.selectsStart, o3 = e2.selectsEnd, s = e2.selectsRange;
      return (0, import_classnames.default)("react-datepicker__year", { "react-datepicker__year--selecting-range": t4 && (n3 || o3 || s) });
    }), ye6(ke4(a2), "getYearContent", function(e2) {
      return a2.props.renderYearContent ? a2.props.renderYearContent(e2) : e2;
    }), a2;
  }
  return fe5(o2, [{ key: "render", value: function() {
    for (var t3 = this, r2 = [], n3 = this.props, o3 = n3.date, a2 = n3.yearItemNumber, s = n3.onYearMouseEnter, i3 = n3.onYearMouseLeave, p6 = kt4(o3, a2), c3 = p6.startPeriod, l2 = p6.endPeriod, d4 = function(n4) {
      r2.push(import_react2.default.createElement("div", { ref: t3.YEAR_REFS[n4 - c3], onClick: function(e2) {
        t3.onYearClick(e2, n4);
      }, onKeyDown: function(e2) {
        t3.onYearKeyDown(e2, n4);
      }, tabIndex: t3.getYearTabIndex(n4), className: t3.getYearClassNames(n4), onMouseEnter: function(e2) {
        return s(e2, n4);
      }, onMouseLeave: function(e2) {
        return i3(e2, n4);
      }, key: n4, "aria-current": t3.isCurrentYear(n4) ? "date" : void 0 }, t3.getYearContent(n4)));
    }, u3 = c3; u3 <= l2; u3++)
      d4(u3);
    return import_react2.default.createElement("div", { className: this.getYearContainerClassNames() }, import_react2.default.createElement("div", { className: "react-datepicker__year-wrapper", onMouseLeave: this.props.clearSelectingDate }, r2));
  } }]), o2;
}();
var jt5 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2(t3) {
    var o2;
    return he7(this, n2), ye6(ke4(o2 = r2.call(this, t3)), "onTimeChange", function(e2) {
      o2.setState({ time: e2 });
      var t4 = o2.props.date, r3 = t4 instanceof Date && !isNaN(t4) ? t4 : new Date();
      r3.setHours(e2.split(":")[0]), r3.setMinutes(e2.split(":")[1]), o2.props.onChange(r3);
    }), ye6(ke4(o2), "renderTimeInput", function() {
      var t4 = o2.state.time, r3 = o2.props, n3 = r3.date, a2 = r3.timeString, s = r3.customTimeInput;
      return s ? import_react2.default.cloneElement(s, { date: n3, value: t4, onChange: o2.onTimeChange }) : import_react2.default.createElement("input", { type: "time", className: "react-datepicker-time__input", placeholder: "Time", name: "time-input", required: true, value: t4, onChange: function(e2) {
        o2.onTimeChange(e2.target.value || a2);
      } });
    }), o2.state = { time: o2.props.timeString }, o2;
  }
  return fe5(n2, [{ key: "render", value: function() {
    return import_react2.default.createElement("div", { className: "react-datepicker__input-time-container" }, import_react2.default.createElement("div", { className: "react-datepicker-time__caption" }, this.props.timeInputLabel), import_react2.default.createElement("div", { className: "react-datepicker-time__input-container" }, import_react2.default.createElement("div", { className: "react-datepicker-time__input" }, this.renderTimeInput())));
  } }], [{ key: "getDerivedStateFromProps", value: function(e2, t3) {
    return e2.timeString !== t3.time ? { time: e2.timeString } : null;
  } }]), n2;
}();
function Wt3(t2) {
  var r2 = t2.className, n2 = t2.children, o2 = t2.showPopperArrow, a2 = t2.arrowProps, s = void 0 === a2 ? {} : a2;
  return import_react2.default.createElement("div", { className: r2 }, o2 && import_react2.default.createElement("div", ve({ className: "react-datepicker__triangle" }, s)), n2);
}
var Vt4 = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"];
var qt4 = function(t2) {
  De4(o2, import_react2.default.Component);
  var n2 = be2(o2);
  function o2(t3) {
    var a2;
    return he7(this, o2), ye6(ke4(a2 = n2.call(this, t3)), "handleClickOutside", function(e2) {
      a2.props.onClickOutside(e2);
    }), ye6(ke4(a2), "setClickOutsideRef", function() {
      return a2.containerRef.current;
    }), ye6(ke4(a2), "handleDropdownFocus", function(e2) {
      (function() {
        var e3 = ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).className || "").split(/\s+/);
        return Vt4.some(function(t4) {
          return e3.indexOf(t4) >= 0;
        });
      })(e2.target) && a2.props.onDropdownFocus();
    }), ye6(ke4(a2), "getDateInView", function() {
      var e2 = a2.props, t4 = e2.preSelection, r2 = e2.selected, n3 = e2.openToDate, o3 = ft5(a2.props), s = yt4(a2.props), i3 = Ye4(), p6 = n3 || r2 || t4;
      return p6 || (o3 && isBefore(i3, o3) ? o3 : s && isAfter(i3, s) ? s : i3);
    }), ye6(ke4(a2), "increaseMonth", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: addMonths(t4, 1) };
      }, function() {
        return a2.handleMonthChange(a2.state.date);
      });
    }), ye6(ke4(a2), "decreaseMonth", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: subMonths(t4, 1) };
      }, function() {
        return a2.handleMonthChange(a2.state.date);
      });
    }), ye6(ke4(a2), "handleDayClick", function(e2, t4, r2) {
      a2.props.onSelect(e2, t4, r2), a2.props.setPreSelection && a2.props.setPreSelection(e2);
    }), ye6(ke4(a2), "handleDayMouseEnter", function(e2) {
      a2.setState({ selectingDate: e2 }), a2.props.onDayMouseEnter && a2.props.onDayMouseEnter(e2);
    }), ye6(ke4(a2), "handleMonthMouseLeave", function() {
      a2.setState({ selectingDate: null }), a2.props.onMonthMouseLeave && a2.props.onMonthMouseLeave();
    }), ye6(ke4(a2), "handleYearMouseEnter", function(e2, t4) {
      a2.setState({ selectingDate: setYear(Ye4(), t4) }), a2.props.onYearMouseEnter && a2.props.onYearMouseEnter(e2, t4);
    }), ye6(ke4(a2), "handleYearMouseLeave", function(e2, t4) {
      a2.props.onYearMouseLeave && a2.props.onYearMouseLeave(e2, t4);
    }), ye6(ke4(a2), "handleYearChange", function(e2) {
      a2.props.onYearChange && (a2.props.onYearChange(e2), a2.setState({ isRenderAriaLiveMessage: true })), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e2), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e2);
    }), ye6(ke4(a2), "handleMonthChange", function(e2) {
      a2.handleCustomMonthChange(e2), a2.props.adjustDateOnChange && (a2.props.onSelect && a2.props.onSelect(e2), a2.props.setOpen && a2.props.setOpen(true)), a2.props.setPreSelection && a2.props.setPreSelection(e2);
    }), ye6(ke4(a2), "handleCustomMonthChange", function(e2) {
      a2.props.onMonthChange && (a2.props.onMonthChange(e2), a2.setState({ isRenderAriaLiveMessage: true }));
    }), ye6(ke4(a2), "handleMonthYearChange", function(e2) {
      a2.handleYearChange(e2), a2.handleMonthChange(e2);
    }), ye6(ke4(a2), "changeYear", function(e2) {
      a2.setState(function(t4) {
        var r2 = t4.date;
        return { date: setYear(r2, e2) };
      }, function() {
        return a2.handleYearChange(a2.state.date);
      });
    }), ye6(ke4(a2), "changeMonth", function(e2) {
      a2.setState(function(t4) {
        var r2 = t4.date;
        return { date: setMonth(r2, e2) };
      }, function() {
        return a2.handleMonthChange(a2.state.date);
      });
    }), ye6(ke4(a2), "changeMonthYear", function(e2) {
      a2.setState(function(t4) {
        var r2 = t4.date;
        return { date: setYear(setMonth(r2, getMonth(e2)), getYear(e2)) };
      }, function() {
        return a2.handleMonthYearChange(a2.state.date);
      });
    }), ye6(ke4(a2), "header", function() {
      var t4 = Le3(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2.state.date, a2.props.locale, a2.props.calendarStartDay), n3 = [];
      return a2.props.showWeekNumbers && n3.push(import_react2.default.createElement("div", { key: "W", className: "react-datepicker__day-name" }, a2.props.weekLabel || "#")), n3.concat([0, 1, 2, 3, 4, 5, 6].map(function(n4) {
        var o3 = addDays(t4, n4), s = a2.formatWeekday(o3, a2.props.locale), i3 = a2.props.weekDayClassName ? a2.props.weekDayClassName(o3) : void 0;
        return import_react2.default.createElement("div", { key: n4, className: (0, import_classnames.default)("react-datepicker__day-name", i3) }, s);
      }));
    }), ye6(ke4(a2), "formatWeekday", function(e2, t4) {
      return a2.props.formatWeekDay ? function(e3, t5, r2) {
        return t5(Ie4(e3, "EEEE", r2));
      }(e2, a2.props.formatWeekDay, t4) : a2.props.useWeekdaysShort ? function(e3, t5) {
        return Ie4(e3, "EEE", t5);
      }(e2, t4) : function(e3, t5) {
        return Ie4(e3, "EEEEEE", t5);
      }(e2, t4);
    }), ye6(ke4(a2), "decreaseYear", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: subYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1) };
      }, function() {
        return a2.handleYearChange(a2.state.date);
      });
    }), ye6(ke4(a2), "clearSelectingDate", function() {
      a2.setState({ selectingDate: null });
    }), ye6(ke4(a2), "renderPreviousButton", function() {
      if (!a2.props.renderCustomHeader) {
        var t4;
        switch (true) {
          case a2.props.showMonthYearPicker:
            t4 = ht4(a2.state.date, a2.props);
            break;
          case a2.props.showYearPicker:
            t4 = function(e2) {
              var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t5.minDate, n4 = t5.yearItemNumber, o4 = void 0 === n4 ? Ne2 : n4, a3 = kt4(Ae4(subYears(e2, o4)), o4).endPeriod, s2 = r3 && getYear(r3);
              return s2 && s2 > a3 || false;
            }(a2.state.date, a2.props);
            break;
          default:
            t4 = dt5(a2.state.date, a2.props);
        }
        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--previous"], n3 = a2.decreaseMonth;
          (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.decreaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--previous--disabled"), n3 = null);
          var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker, s = a2.props, i3 = s.previousMonthButtonLabel, p6 = s.previousYearButtonLabel, c3 = a2.props, l2 = c3.previousMonthAriaLabel, d4 = void 0 === l2 ? "string" == typeof i3 ? i3 : "Previous Month" : l2, u3 = c3.previousYearAriaLabel, h5 = void 0 === u3 ? "string" == typeof p6 ? p6 : "Previous Year" : u3;
          return import_react2.default.createElement("button", { type: "button", className: r2.join(" "), onClick: n3, onKeyDown: a2.props.handleOnKeyDown, "aria-label": o3 ? h5 : d4 }, import_react2.default.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"].join(" ") }, o3 ? a2.props.previousYearButtonLabel : a2.props.previousMonthButtonLabel));
        }
      }
    }), ye6(ke4(a2), "increaseYear", function() {
      a2.setState(function(e2) {
        var t4 = e2.date;
        return { date: addYears(t4, a2.props.showYearPicker ? a2.props.yearItemNumber : 1) };
      }, function() {
        return a2.handleYearChange(a2.state.date);
      });
    }), ye6(ke4(a2), "renderNextButton", function() {
      if (!a2.props.renderCustomHeader) {
        var t4;
        switch (true) {
          case a2.props.showMonthYearPicker:
            t4 = mt4(a2.state.date, a2.props);
            break;
          case a2.props.showYearPicker:
            t4 = function(e2) {
              var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t5.maxDate, n4 = t5.yearItemNumber, o4 = void 0 === n4 ? Ne2 : n4, a3 = kt4(addYears(e2, o4), o4).startPeriod, s2 = r3 && getYear(r3);
              return s2 && s2 < a3 || false;
            }(a2.state.date, a2.props);
            break;
          default:
            t4 = ut5(a2.state.date, a2.props);
        }
        if ((a2.props.forceShowMonthNavigation || a2.props.showDisabledMonthNavigation || !t4) && !a2.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
          a2.props.showTimeSelect && r2.push("react-datepicker__navigation--next--with-time"), a2.props.todayButton && r2.push("react-datepicker__navigation--next--with-today-button");
          var n3 = a2.increaseMonth;
          (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker) && (n3 = a2.increaseYear), t4 && a2.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--next--disabled"), n3 = null);
          var o3 = a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker, s = a2.props, i3 = s.nextMonthButtonLabel, p6 = s.nextYearButtonLabel, c3 = a2.props, l2 = c3.nextMonthAriaLabel, d4 = void 0 === l2 ? "string" == typeof i3 ? i3 : "Next Month" : l2, h5 = c3.nextYearAriaLabel, m4 = void 0 === h5 ? "string" == typeof p6 ? p6 : "Next Year" : h5;
          return import_react2.default.createElement("button", { type: "button", className: r2.join(" "), onClick: n3, onKeyDown: a2.props.handleOnKeyDown, "aria-label": o3 ? m4 : d4 }, import_react2.default.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"].join(" ") }, o3 ? a2.props.nextYearButtonLabel : a2.props.nextMonthButtonLabel));
        }
      }
    }), ye6(ke4(a2), "renderCurrentMonth", function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a2.state.date, r2 = ["react-datepicker__current-month"];
      return a2.props.showYearDropdown && r2.push("react-datepicker__current-month--hasYearDropdown"), a2.props.showMonthDropdown && r2.push("react-datepicker__current-month--hasMonthDropdown"), a2.props.showMonthYearDropdown && r2.push("react-datepicker__current-month--hasMonthYearDropdown"), import_react2.default.createElement("div", { className: r2.join(" ") }, Ie4(t4, a2.props.dateFormat, a2.props.locale));
    }), ye6(ke4(a2), "renderYearDropdown", function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a2.props.showYearDropdown && !t4)
        return import_react2.default.createElement(_t5, { adjustDateOnChange: a2.props.adjustDateOnChange, date: a2.state.date, onSelect: a2.props.onSelect, setOpen: a2.props.setOpen, dropdownMode: a2.props.dropdownMode, onChange: a2.changeYear, minDate: a2.props.minDate, maxDate: a2.props.maxDate, year: getYear(a2.state.date), scrollableYearDropdown: a2.props.scrollableYearDropdown, yearDropdownItemNumber: a2.props.yearDropdownItemNumber });
    }), ye6(ke4(a2), "renderMonthDropdown", function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a2.props.showMonthDropdown && !t4)
        return import_react2.default.createElement(Et4, { dropdownMode: a2.props.dropdownMode, locale: a2.props.locale, onChange: a2.changeMonth, month: getMonth(a2.state.date), useShortMonthInDropdown: a2.props.useShortMonthInDropdown });
    }), ye6(ke4(a2), "renderMonthYearDropdown", function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a2.props.showMonthYearDropdown && !t4)
        return import_react2.default.createElement(Yt4, { dropdownMode: a2.props.dropdownMode, locale: a2.props.locale, dateFormat: a2.props.dateFormat, onChange: a2.changeMonthYear, minDate: a2.props.minDate, maxDate: a2.props.maxDate, date: a2.state.date, scrollableMonthYearDropdown: a2.props.scrollableMonthYearDropdown });
    }), ye6(ke4(a2), "handleTodayButtonClick", function(e2) {
      a2.props.onSelect(Ke3(), e2), a2.props.setPreSelection && a2.props.setPreSelection(Ke3());
    }), ye6(ke4(a2), "renderTodayButton", function() {
      if (a2.props.todayButton && !a2.props.showTimeSelectOnly)
        return import_react2.default.createElement("div", { className: "react-datepicker__today-button", onClick: function(e2) {
          return a2.handleTodayButtonClick(e2);
        } }, a2.props.todayButton);
    }), ye6(ke4(a2), "renderDefaultHeader", function(t4) {
      var r2 = t4.monthDate, n3 = t4.i;
      return import_react2.default.createElement("div", { className: "react-datepicker__header ".concat(a2.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "") }, a2.renderCurrentMonth(r2), import_react2.default.createElement("div", { className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(a2.props.dropdownMode), onFocus: a2.handleDropdownFocus }, a2.renderMonthDropdown(0 !== n3), a2.renderMonthYearDropdown(0 !== n3), a2.renderYearDropdown(0 !== n3)), import_react2.default.createElement("div", { className: "react-datepicker__day-names" }, a2.header(r2)));
    }), ye6(ke4(a2), "renderCustomHeader", function() {
      var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = t4.monthDate, n3 = t4.i;
      if (a2.props.showTimeSelect && !a2.state.monthContainer || a2.props.showTimeSelectOnly)
        return null;
      var o3 = dt5(a2.state.date, a2.props), s = ut5(a2.state.date, a2.props), i3 = ht4(a2.state.date, a2.props), p6 = mt4(a2.state.date, a2.props), c3 = !a2.props.showMonthYearPicker && !a2.props.showQuarterYearPicker && !a2.props.showYearPicker;
      return import_react2.default.createElement("div", { className: "react-datepicker__header react-datepicker__header--custom", onFocus: a2.props.onDropdownFocus }, a2.props.renderCustomHeader(de7(de7({}, a2.state), {}, { customHeaderCount: n3, monthDate: r2, changeMonth: a2.changeMonth, changeYear: a2.changeYear, decreaseMonth: a2.decreaseMonth, increaseMonth: a2.increaseMonth, decreaseYear: a2.decreaseYear, increaseYear: a2.increaseYear, prevMonthButtonDisabled: o3, nextMonthButtonDisabled: s, prevYearButtonDisabled: i3, nextYearButtonDisabled: p6 })), c3 && import_react2.default.createElement("div", { className: "react-datepicker__day-names" }, a2.header(r2)));
    }), ye6(ke4(a2), "renderYearHeader", function() {
      var t4 = a2.state.date, r2 = a2.props, n3 = r2.showYearPicker, o3 = kt4(t4, r2.yearItemNumber), s = o3.startPeriod, i3 = o3.endPeriod;
      return import_react2.default.createElement("div", { className: "react-datepicker__header react-datepicker-year-header" }, n3 ? "".concat(s, " - ").concat(i3) : getYear(t4));
    }), ye6(ke4(a2), "renderHeader", function(e2) {
      switch (true) {
        case void 0 !== a2.props.renderCustomHeader:
          return a2.renderCustomHeader(e2);
        case (a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker || a2.props.showYearPicker):
          return a2.renderYearHeader(e2);
        default:
          return a2.renderDefaultHeader(e2);
      }
    }), ye6(ke4(a2), "renderMonths", function() {
      var t4;
      if (!a2.props.showTimeSelectOnly && !a2.props.showYearPicker) {
        for (var r2 = [], n3 = a2.props.showPreviousMonths ? a2.props.monthsShown - 1 : 0, o3 = subMonths(a2.state.date, n3), s = null !== (t4 = a2.props.monthSelectedIn) && void 0 !== t4 ? t4 : n3, i3 = 0; i3 < a2.props.monthsShown; ++i3) {
          var p6 = addMonths(o3, i3 - s + n3), c3 = "month-".concat(i3), d4 = i3 < a2.props.monthsShown - 1, u3 = i3 > 0;
          r2.push(import_react2.default.createElement("div", { key: c3, ref: function(e2) {
            a2.monthContainer = e2;
          }, className: "react-datepicker__month-container" }, a2.renderHeader({ monthDate: p6, i: i3 }), import_react2.default.createElement(Kt4, { chooseDayAriaLabelPrefix: a2.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: a2.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: a2.props.weekAriaLabelPrefix, ariaLabelPrefix: a2.props.monthAriaLabelPrefix, onChange: a2.changeMonthYear, day: p6, dayClassName: a2.props.dayClassName, calendarStartDay: a2.props.calendarStartDay, monthClassName: a2.props.monthClassName, onDayClick: a2.handleDayClick, handleOnKeyDown: a2.props.handleOnDayKeyDown, onDayMouseEnter: a2.handleDayMouseEnter, onMouseLeave: a2.handleMonthMouseLeave, onWeekSelect: a2.props.onWeekSelect, orderInDisplay: i3, formatWeekNumber: a2.props.formatWeekNumber, locale: a2.props.locale, minDate: a2.props.minDate, maxDate: a2.props.maxDate, excludeDates: a2.props.excludeDates, excludeDateIntervals: a2.props.excludeDateIntervals, highlightDates: a2.props.highlightDates, holidays: a2.props.holidays, selectingDate: a2.state.selectingDate, includeDates: a2.props.includeDates, includeDateIntervals: a2.props.includeDateIntervals, inline: a2.props.inline, shouldFocusDayInline: a2.props.shouldFocusDayInline, fixedHeight: a2.props.fixedHeight, filterDate: a2.props.filterDate, preSelection: a2.props.preSelection, setPreSelection: a2.props.setPreSelection, selected: a2.props.selected, selectsStart: a2.props.selectsStart, selectsEnd: a2.props.selectsEnd, selectsRange: a2.props.selectsRange, selectsDisabledDaysInRange: a2.props.selectsDisabledDaysInRange, showWeekNumbers: a2.props.showWeekNumbers, startDate: a2.props.startDate, endDate: a2.props.endDate, peekNextMonth: a2.props.peekNextMonth, setOpen: a2.props.setOpen, shouldCloseOnSelect: a2.props.shouldCloseOnSelect, renderDayContents: a2.props.renderDayContents, renderMonthContent: a2.props.renderMonthContent, renderQuarterContent: a2.props.renderQuarterContent, renderYearContent: a2.props.renderYearContent, disabledKeyboardNavigation: a2.props.disabledKeyboardNavigation, showMonthYearPicker: a2.props.showMonthYearPicker, showFullMonthYearPicker: a2.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: a2.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: a2.props.showFourColumnMonthYearPicker, showYearPicker: a2.props.showYearPicker, showQuarterYearPicker: a2.props.showQuarterYearPicker, isInputFocused: a2.props.isInputFocused, containerRef: a2.containerRef, monthShowsDuplicateDaysEnd: d4, monthShowsDuplicateDaysStart: u3 })));
        }
        return r2;
      }
    }), ye6(ke4(a2), "renderYears", function() {
      if (!a2.props.showTimeSelectOnly)
        return a2.props.showYearPicker ? import_react2.default.createElement("div", { className: "react-datepicker__year--container" }, a2.renderHeader(), import_react2.default.createElement(Ht3, ve({ onDayClick: a2.handleDayClick, selectingDate: a2.state.selectingDate, clearSelectingDate: a2.clearSelectingDate, date: a2.state.date }, a2.props, { onYearMouseEnter: a2.handleYearMouseEnter, onYearMouseLeave: a2.handleYearMouseLeave }))) : void 0;
    }), ye6(ke4(a2), "renderTimeSection", function() {
      if (a2.props.showTimeSelect && (a2.state.monthContainer || a2.props.showTimeSelectOnly))
        return import_react2.default.createElement(Qt4, { selected: a2.props.selected, openToDate: a2.props.openToDate, onChange: a2.props.onTimeChange, timeClassName: a2.props.timeClassName, format: a2.props.timeFormat, includeTimes: a2.props.includeTimes, intervals: a2.props.timeIntervals, minTime: a2.props.minTime, maxTime: a2.props.maxTime, excludeTimes: a2.props.excludeTimes, filterTime: a2.props.filterTime, timeCaption: a2.props.timeCaption, todayButton: a2.props.todayButton, showMonthDropdown: a2.props.showMonthDropdown, showMonthYearDropdown: a2.props.showMonthYearDropdown, showYearDropdown: a2.props.showYearDropdown, withPortal: a2.props.withPortal, monthRef: a2.state.monthContainer, injectTimes: a2.props.injectTimes, locale: a2.props.locale, handleOnKeyDown: a2.props.handleOnKeyDown, showTimeSelectOnly: a2.props.showTimeSelectOnly });
    }), ye6(ke4(a2), "renderInputTimeSection", function() {
      var t4 = new Date(a2.props.selected), r2 = Te2(t4) && Boolean(a2.props.selected) ? "".concat(wt3(t4.getHours()), ":").concat(wt3(t4.getMinutes())) : "";
      if (a2.props.showTimeInput)
        return import_react2.default.createElement(jt5, { date: t4, timeString: r2, timeInputLabel: a2.props.timeInputLabel, onChange: a2.props.onTimeChange, customTimeInput: a2.props.customTimeInput });
    }), ye6(ke4(a2), "renderAriaLiveRegion", function() {
      var t4, r2 = kt4(a2.state.date, a2.props.yearItemNumber), n3 = r2.startPeriod, o3 = r2.endPeriod;
      return t4 = a2.props.showYearPicker ? "".concat(n3, " - ").concat(o3) : a2.props.showMonthYearPicker || a2.props.showQuarterYearPicker ? getYear(a2.state.date) : "".concat(Je4(getMonth(a2.state.date), a2.props.locale), " ").concat(getYear(a2.state.date)), import_react2.default.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, a2.state.isRenderAriaLiveMessage && t4);
    }), ye6(ke4(a2), "renderChildren", function() {
      if (a2.props.children)
        return import_react2.default.createElement("div", { className: "react-datepicker__children-container" }, a2.props.children);
    }), a2.containerRef = import_react2.default.createRef(), a2.state = { date: a2.getDateInView(), selectingDate: null, monthContainer: null, isRenderAriaLiveMessage: false }, a2;
  }
  return fe5(o2, [{ key: "componentDidMount", value: function() {
    var e2 = this;
    this.props.showTimeSelect && (this.assignMonthContainer = void e2.setState({ monthContainer: e2.monthContainer }));
  } }, { key: "componentDidUpdate", value: function(e2) {
    var t3 = this;
    if (!this.props.preSelection || We4(this.props.preSelection, e2.preSelection) && this.props.monthSelectedIn === e2.monthSelectedIn)
      this.props.openToDate && !We4(this.props.openToDate, e2.openToDate) && this.setState({ date: this.props.openToDate });
    else {
      var r2 = !He4(this.state.date, this.props.preSelection);
      this.setState({ date: this.props.preSelection }, function() {
        return r2 && t3.handleCustomMonthChange(t3.state.date);
      });
    }
  } }, { key: "render", value: function() {
    var t3 = this.props.container || Wt3;
    return import_react2.default.createElement("div", { ref: this.containerRef }, import_react2.default.createElement(t3, { className: (0, import_classnames.default)("react-datepicker", this.props.className, { "react-datepicker--time-only": this.props.showTimeSelectOnly }), showPopperArrow: this.props.showPopperArrow, arrowProps: this.props.arrowProps }, this.renderAriaLiveRegion(), this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.renderChildren()));
  } }], [{ key: "defaultProps", get: function() {
    return { onDropdownFocus: function() {
    }, monthsShown: 1, forceShowMonthNavigation: false, timeCaption: "Time", previousYearButtonLabel: "Previous Year", nextYearButtonLabel: "Next Year", previousMonthButtonLabel: "Previous Month", nextMonthButtonLabel: "Next Month", customTimeInput: null, yearItemNumber: Ne2 };
  } }]), o2;
}();
var Ut3 = function(t2) {
  var r2 = t2.icon, n2 = t2.className, o2 = void 0 === n2 ? "" : n2, a2 = "react-datepicker__calendar-icon";
  return import_react2.default.isValidElement(r2) ? import_react2.default.cloneElement(r2, { className: "".concat(r2.props.className || "", " ").concat(a2, " ").concat(o2) }) : "string" == typeof r2 ? import_react2.default.createElement("i", { className: "".concat(a2, " ").concat(r2, " ").concat(o2), "aria-hidden": "true" }) : import_react2.default.createElement("svg", { className: "".concat(a2, " ").concat(o2), xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 448 512" }, import_react2.default.createElement("path", { d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z" }));
};
var zt4 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2(e2) {
    var t3;
    return he7(this, n2), (t3 = r2.call(this, e2)).el = document.createElement("div"), t3;
  }
  return fe5(n2, [{ key: "componentDidMount", value: function() {
    this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
  } }, { key: "componentWillUnmount", value: function() {
    this.portalRoot.removeChild(this.el);
  } }, { key: "render", value: function() {
    return import_react_dom2.default.createPortal(this.props.children, this.el);
  } }]), n2;
}();
var $t4 = function(e2) {
  return !e2.disabled && -1 !== e2.tabIndex;
};
var Gt3 = function(t2) {
  De4(n2, import_react2.default.Component);
  var r2 = be2(n2);
  function n2(t3) {
    var o2;
    return he7(this, n2), ye6(ke4(o2 = r2.call(this, t3)), "getTabChildren", function() {
      return Array.prototype.slice.call(o2.tabLoopRef.current.querySelectorAll("[tabindex], a, button, input, select, textarea"), 1, -1).filter($t4);
    }), ye6(ke4(o2), "handleFocusStart", function() {
      var e2 = o2.getTabChildren();
      e2 && e2.length > 1 && e2[e2.length - 1].focus();
    }), ye6(ke4(o2), "handleFocusEnd", function() {
      var e2 = o2.getTabChildren();
      e2 && e2.length > 1 && e2[0].focus();
    }), o2.tabLoopRef = import_react2.default.createRef(), o2;
  }
  return fe5(n2, [{ key: "render", value: function() {
    return this.props.enableTabLoop ? import_react2.default.createElement("div", { className: "react-datepicker__tab-loop", ref: this.tabLoopRef }, import_react2.default.createElement("div", { className: "react-datepicker__tab-loop__start", tabIndex: "0", onFocus: this.handleFocusStart }), this.props.children, import_react2.default.createElement("div", { className: "react-datepicker__tab-loop__end", tabIndex: "0", onFocus: this.handleFocusEnd })) : this.props.children;
  } }], [{ key: "defaultProps", get: function() {
    return { enableTabLoop: true };
  } }]), n2;
}();
var Jt3 = function(t2) {
  De4(o2, import_react2.default.Component);
  var n2 = be2(o2);
  function o2() {
    return he7(this, o2), n2.apply(this, arguments);
  }
  return fe5(o2, [{ key: "render", value: function() {
    var t3, n3 = this.props, o3 = n3.className, a2 = n3.wrapperClassName, s = n3.hidePopper, i3 = n3.popperComponent, p6 = n3.popperModifiers, c3 = n3.popperPlacement, l2 = n3.popperProps, d4 = n3.targetComponent, u3 = n3.enableTabLoop, h5 = n3.popperOnKeyDown, m4 = n3.portalId, f4 = n3.portalHost;
    if (!s) {
      var y4 = (0, import_classnames.default)("react-datepicker-popper", o3);
      t3 = import_react2.default.createElement(Popper, ve({ modifiers: p6, placement: c3 }, l2), function(t4) {
        var r2 = t4.ref, n4 = t4.style, o4 = t4.placement, a3 = t4.arrowProps;
        return import_react2.default.createElement(Gt3, { enableTabLoop: u3 }, import_react2.default.createElement("div", { ref: r2, style: n4, className: y4, "data-placement": o4, onKeyDown: h5 }, import_react2.default.cloneElement(i3, { arrowProps: a3 })));
      });
    }
    this.props.popperContainer && (t3 = import_react2.default.createElement(this.props.popperContainer, {}, t3)), m4 && !s && (t3 = import_react2.default.createElement(zt4, { portalId: m4, portalHost: f4 }, t3));
    var v = (0, import_classnames.default)("react-datepicker-wrapper", a2);
    return import_react2.default.createElement(Manager, { className: "react-datepicker-manager" }, import_react2.default.createElement(Reference, null, function(t4) {
      var r2 = t4.ref;
      return import_react2.default.createElement("div", { ref: r2, className: v }, d4);
    }), t3);
  } }], [{ key: "defaultProps", get: function() {
    return { hidePopper: true, popperModifiers: [], popperProps: {}, popperPlacement: "bottom-start" };
  } }]), o2;
}();
var Xt3 = "react-datepicker-ignore-onclickoutside";
var Zt3 = react_onclickoutside_es_default(qt4);
var er4 = "Date input not valid.";
var tr3 = function(t2) {
  De4(s, import_react2.default.Component);
  var a2 = be2(s);
  function s(t3) {
    var i3;
    return he7(this, s), ye6(ke4(i3 = a2.call(this, t3)), "getPreSelection", function() {
      return i3.props.openToDate ? i3.props.openToDate : i3.props.selectsEnd && i3.props.startDate ? i3.props.startDate : i3.props.selectsStart && i3.props.endDate ? i3.props.endDate : Ye4();
    }), ye6(ke4(i3), "calcInitialState", function() {
      var e2, t4, r2 = null === (e2 = i3.props.holidays) || void 0 === e2 ? void 0 : e2.reduce(function(e3, t5) {
        var r3 = new Date(t5.date);
        return isValid(r3) ? [].concat(Se2(e3), [de7(de7({}, t5), {}, { date: r3 })]) : e3;
      }, []), n2 = i3.getPreSelection(), a3 = ft5(i3.props), s2 = yt4(i3.props), p6 = a3 && isBefore(n2, startOfDay(a3)) ? a3 : s2 && isAfter(n2, endOfDay(s2)) ? s2 : n2;
      return { open: i3.props.startOpen || false, preventFocus: false, preSelection: null !== (t4 = i3.props.selectsRange ? i3.props.startDate : i3.props.selected) && void 0 !== t4 ? t4 : p6, highlightDates: vt4(i3.props.highlightDates), holidays: Dt4(r2), focused: false, shouldFocusDayInline: false, isRenderAriaLiveMessage: false };
    }), ye6(ke4(i3), "clearPreventFocusTimeout", function() {
      i3.preventFocusTimeout && clearTimeout(i3.preventFocusTimeout);
    }), ye6(ke4(i3), "setFocus", function() {
      i3.input && i3.input.focus && i3.input.focus({ preventScroll: true });
    }), ye6(ke4(i3), "setBlur", function() {
      i3.input && i3.input.blur && i3.input.blur(), i3.cancelFocusInput();
    }), ye6(ke4(i3), "setOpen", function(e2) {
      var t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      i3.setState({ open: e2, preSelection: e2 && i3.state.open ? i3.state.preSelection : i3.calcInitialState().preSelection, lastPreSelectChange: nr3 }, function() {
        e2 || i3.setState(function(e3) {
          return { focused: !!t4 && e3.focused };
        }, function() {
          !t4 && i3.setBlur(), i3.setState({ inputValue: null });
        });
      });
    }), ye6(ke4(i3), "inputOk", function() {
      return isDate(i3.state.preSelection);
    }), ye6(ke4(i3), "isCalendarOpen", function() {
      return void 0 === i3.props.open ? i3.state.open && !i3.props.disabled && !i3.props.readOnly : i3.props.open;
    }), ye6(ke4(i3), "handleFocus", function(e2) {
      i3.state.preventFocus || (i3.props.onFocus(e2), i3.props.preventOpenOnFocus || i3.props.readOnly || i3.setOpen(true)), i3.setState({ focused: true });
    }), ye6(ke4(i3), "sendFocusBackToInput", function() {
      i3.preventFocusTimeout && i3.clearPreventFocusTimeout(), i3.setState({ preventFocus: true }, function() {
        i3.preventFocusTimeout = setTimeout(function() {
          i3.setFocus(), i3.setState({ preventFocus: false });
        });
      });
    }), ye6(ke4(i3), "cancelFocusInput", function() {
      clearTimeout(i3.inputFocusTimeout), i3.inputFocusTimeout = null;
    }), ye6(ke4(i3), "deferFocusInput", function() {
      i3.cancelFocusInput(), i3.inputFocusTimeout = setTimeout(function() {
        return i3.setFocus();
      }, 1);
    }), ye6(ke4(i3), "handleDropdownFocus", function() {
      i3.cancelFocusInput();
    }), ye6(ke4(i3), "handleBlur", function(e2) {
      (!i3.state.open || i3.props.withPortal || i3.props.showTimeInput) && i3.props.onBlur(e2), i3.setState({ focused: false });
    }), ye6(ke4(i3), "handleCalendarClickOutside", function(e2) {
      i3.props.inline || i3.setOpen(false), i3.props.onClickOutside(e2), i3.props.withPortal && e2.preventDefault();
    }), ye6(ke4(i3), "handleChange", function() {
      for (var e2 = arguments.length, t4 = new Array(e2), r2 = 0; r2 < e2; r2++)
        t4[r2] = arguments[r2];
      var n2 = t4[0];
      if (!i3.props.onChangeRaw || (i3.props.onChangeRaw.apply(ke4(i3), t4), "function" == typeof n2.isDefaultPrevented && !n2.isDefaultPrevented())) {
        i3.setState({ inputValue: n2.target.value, lastPreSelectChange: rr3 });
        var o2, a3, s2, p6, c3, l2, d4, u3, h5 = (o2 = n2.target.value, a3 = i3.props.dateFormat, s2 = i3.props.locale, p6 = i3.props.strictParsing, c3 = i3.props.minDate, l2 = null, d4 = Ge3(s2) || Ge3($e2()), u3 = true, Array.isArray(a3) ? (a3.forEach(function(e3) {
          var t5 = parse(o2, e3, new Date(), { locale: d4 });
          p6 && (u3 = Te2(t5, c3) && o2 === Ie4(t5, e3, s2)), Te2(t5, c3) && u3 && (l2 = t5);
        }), l2) : (l2 = parse(o2, a3, new Date(), { locale: d4 }), p6 ? u3 = Te2(l2) && o2 === Ie4(l2, a3, s2) : Te2(l2) || (a3 = a3.match(xe2).map(function(e3) {
          var t5 = e3[0];
          return "p" === t5 || "P" === t5 ? d4 ? (0, Pe2[t5])(e3, d4.formatLong) : t5 : e3;
        }).join(""), o2.length > 0 && (l2 = parse(o2, a3.slice(0, o2.length), new Date())), Te2(l2) || (l2 = new Date(o2))), Te2(l2) && u3 ? l2 : null));
        i3.props.showTimeSelectOnly && i3.props.selected && !We4(h5, i3.props.selected) && (h5 = set(i3.props.selected, null == h5 ? { hours: getHours(i3.props.selected), minutes: getMinutes(i3.props.selected), seconds: getSeconds(i3.props.selected) } : { hours: getHours(h5), minutes: getMinutes(h5), seconds: getSeconds(h5) })), !h5 && n2.target.value || i3.setSelected(h5, n2, true);
      }
    }), ye6(ke4(i3), "handleSelect", function(e2, t4, r2) {
      if (i3.props.shouldCloseOnSelect && !i3.props.showTimeSelect && i3.sendFocusBackToInput(), i3.props.onChangeRaw && i3.props.onChangeRaw(t4), i3.setSelected(e2, t4, false, r2), i3.props.showDateSelect && i3.setState({ isRenderAriaLiveMessage: true }), !i3.props.shouldCloseOnSelect || i3.props.showTimeSelect)
        i3.setPreSelection(e2);
      else if (!i3.props.inline) {
        i3.props.selectsRange || i3.setOpen(false);
        var n2 = i3.props, o2 = n2.startDate, a3 = n2.endDate;
        !o2 || a3 || isBefore(e2, o2) || i3.setOpen(false);
      }
    }), ye6(ke4(i3), "setSelected", function(e2, t4, r2, n2) {
      var o2 = e2;
      if (i3.props.showYearPicker) {
        if (null !== o2 && at5(getYear(o2), i3.props))
          return;
      } else if (i3.props.showMonthYearPicker) {
        if (null !== o2 && tt3(o2, i3.props))
          return;
      } else if (null !== o2 && Ze4(o2, i3.props))
        return;
      var a3 = i3.props, s2 = a3.onChange, p6 = a3.selectsRange, c3 = a3.startDate, l2 = a3.endDate;
      if (!Ve4(i3.props.selected, o2) || i3.props.allowSameDay || p6)
        if (null !== o2 && (!i3.props.selected || r2 && (i3.props.showTimeSelect || i3.props.showTimeSelectOnly || i3.props.showTimeInput) || (o2 = Re5(o2, { hour: getHours(i3.props.selected), minute: getMinutes(i3.props.selected), second: getSeconds(i3.props.selected) })), i3.props.inline || i3.setState({ preSelection: o2 }), i3.props.focusSelectedMonth || i3.setState({ monthSelectedIn: n2 })), p6) {
          var d4 = c3 && !l2, u3 = c3 && l2;
          !c3 && !l2 ? s2([o2, null], t4) : d4 && (isBefore(o2, c3) ? s2([o2, null], t4) : s2([c3, o2], t4)), u3 && s2([o2, null], t4);
        } else
          s2(o2, t4);
      r2 || (i3.props.onSelect(o2, t4), i3.setState({ inputValue: null }));
    }), ye6(ke4(i3), "setPreSelection", function(e2) {
      var t4 = void 0 !== i3.props.minDate, r2 = void 0 !== i3.props.maxDate, n2 = true;
      if (e2) {
        var o2 = startOfDay(e2);
        if (t4 && r2)
          n2 = qe3(e2, i3.props.minDate, i3.props.maxDate);
        else if (t4) {
          var a3 = startOfDay(i3.props.minDate);
          n2 = isAfter(e2, a3) || Ve4(o2, a3);
        } else if (r2) {
          var s2 = endOfDay(i3.props.maxDate);
          n2 = isBefore(e2, s2) || Ve4(o2, s2);
        }
      }
      n2 && i3.setState({ preSelection: e2 });
    }), ye6(ke4(i3), "handleTimeChange", function(e2) {
      var t4 = i3.props.selected ? i3.props.selected : i3.getPreSelection(), r2 = i3.props.selected ? e2 : Re5(t4, { hour: getHours(e2), minute: getMinutes(e2) });
      i3.setState({ preSelection: r2 }), i3.props.onChange(r2), i3.props.shouldCloseOnSelect && (i3.sendFocusBackToInput(), i3.setOpen(false)), i3.props.showTimeInput && i3.setOpen(true), (i3.props.showTimeSelectOnly || i3.props.showTimeSelect) && i3.setState({ isRenderAriaLiveMessage: true }), i3.setState({ inputValue: null });
    }), ye6(ke4(i3), "onInputClick", function() {
      i3.props.disabled || i3.props.readOnly || i3.setOpen(true), i3.props.onInputClick();
    }), ye6(ke4(i3), "onInputKeyDown", function(e2) {
      i3.props.onKeyDown(e2);
      var t4 = e2.key;
      if (i3.state.open || i3.props.inline || i3.props.preventOpenOnFocus) {
        if (i3.state.open) {
          if ("ArrowDown" === t4 || "ArrowUp" === t4) {
            e2.preventDefault();
            var r2 = i3.calendar.componentNode && i3.calendar.componentNode.querySelector('.react-datepicker__day[tabindex="0"]');
            return void (r2 && r2.focus({ preventScroll: true }));
          }
          var n2 = Ye4(i3.state.preSelection);
          "Enter" === t4 ? (e2.preventDefault(), i3.inputOk() && i3.state.lastPreSelectChange === nr3 ? (i3.handleSelect(n2, e2), !i3.props.shouldCloseOnSelect && i3.setPreSelection(n2)) : i3.setOpen(false)) : "Escape" === t4 ? (e2.preventDefault(), i3.sendFocusBackToInput(), i3.setOpen(false)) : "Tab" === t4 && i3.setOpen(false), i3.inputOk() || i3.props.onInputError({ code: 1, msg: er4 });
        }
      } else
        "ArrowDown" !== t4 && "ArrowUp" !== t4 && "Enter" !== t4 || i3.onInputClick();
    }), ye6(ke4(i3), "onPortalKeyDown", function(e2) {
      "Escape" === e2.key && (e2.preventDefault(), i3.setState({ preventFocus: true }, function() {
        i3.setOpen(false), setTimeout(function() {
          i3.setFocus(), i3.setState({ preventFocus: false });
        });
      }));
    }), ye6(ke4(i3), "onDayKeyDown", function(e2) {
      i3.props.onKeyDown(e2);
      var t4 = e2.key, r2 = Ye4(i3.state.preSelection);
      if ("Enter" === t4)
        e2.preventDefault(), i3.handleSelect(r2, e2), !i3.props.shouldCloseOnSelect && i3.setPreSelection(r2);
      else if ("Escape" === t4)
        e2.preventDefault(), i3.setOpen(false), i3.inputOk() || i3.props.onInputError({ code: 1, msg: er4 });
      else if (!i3.props.disabledKeyboardNavigation) {
        var n2;
        switch (t4) {
          case "ArrowLeft":
            n2 = subDays(r2, 1);
            break;
          case "ArrowRight":
            n2 = addDays(r2, 1);
            break;
          case "ArrowUp":
            n2 = subWeeks(r2, 1);
            break;
          case "ArrowDown":
            n2 = addWeeks(r2, 1);
            break;
          case "PageUp":
            n2 = subMonths(r2, 1);
            break;
          case "PageDown":
            n2 = addMonths(r2, 1);
            break;
          case "Home":
            n2 = subYears(r2, 1);
            break;
          case "End":
            n2 = addYears(r2, 1);
        }
        if (!n2)
          return void (i3.props.onInputError && i3.props.onInputError({ code: 1, msg: er4 }));
        if (e2.preventDefault(), i3.setState({ lastPreSelectChange: nr3 }), i3.props.adjustDateOnChange && i3.setSelected(n2), i3.setPreSelection(n2), i3.props.inline) {
          var o2 = getMonth(r2), a3 = getMonth(n2), s2 = getYear(r2), d4 = getYear(n2);
          o2 !== a3 || s2 !== d4 ? i3.setState({ shouldFocusDayInline: true }) : i3.setState({ shouldFocusDayInline: false });
        }
      }
    }), ye6(ke4(i3), "onPopperKeyDown", function(e2) {
      "Escape" === e2.key && (e2.preventDefault(), i3.sendFocusBackToInput());
    }), ye6(ke4(i3), "onClearClick", function(e2) {
      e2 && e2.preventDefault && e2.preventDefault(), i3.sendFocusBackToInput(), i3.props.selectsRange ? i3.props.onChange([null, null], e2) : i3.props.onChange(null, e2), i3.setState({ inputValue: null });
    }), ye6(ke4(i3), "clear", function() {
      i3.onClearClick();
    }), ye6(ke4(i3), "onScroll", function(e2) {
      "boolean" == typeof i3.props.closeOnScroll && i3.props.closeOnScroll ? e2.target !== document && e2.target !== document.documentElement && e2.target !== document.body || i3.setOpen(false) : "function" == typeof i3.props.closeOnScroll && i3.props.closeOnScroll(e2) && i3.setOpen(false);
    }), ye6(ke4(i3), "renderCalendar", function() {
      return i3.props.inline || i3.isCalendarOpen() ? import_react2.default.createElement(Zt3, { ref: function(e2) {
        i3.calendar = e2;
      }, locale: i3.props.locale, calendarStartDay: i3.props.calendarStartDay, chooseDayAriaLabelPrefix: i3.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: i3.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: i3.props.weekAriaLabelPrefix, monthAriaLabelPrefix: i3.props.monthAriaLabelPrefix, adjustDateOnChange: i3.props.adjustDateOnChange, setOpen: i3.setOpen, shouldCloseOnSelect: i3.props.shouldCloseOnSelect, dateFormat: i3.props.dateFormatCalendar, useWeekdaysShort: i3.props.useWeekdaysShort, formatWeekDay: i3.props.formatWeekDay, dropdownMode: i3.props.dropdownMode, selected: i3.props.selected, preSelection: i3.state.preSelection, onSelect: i3.handleSelect, onWeekSelect: i3.props.onWeekSelect, openToDate: i3.props.openToDate, minDate: i3.props.minDate, maxDate: i3.props.maxDate, selectsStart: i3.props.selectsStart, selectsEnd: i3.props.selectsEnd, selectsRange: i3.props.selectsRange, startDate: i3.props.startDate, endDate: i3.props.endDate, excludeDates: i3.props.excludeDates, excludeDateIntervals: i3.props.excludeDateIntervals, filterDate: i3.props.filterDate, onClickOutside: i3.handleCalendarClickOutside, formatWeekNumber: i3.props.formatWeekNumber, highlightDates: i3.state.highlightDates, holidays: i3.state.holidays, includeDates: i3.props.includeDates, includeDateIntervals: i3.props.includeDateIntervals, includeTimes: i3.props.includeTimes, injectTimes: i3.props.injectTimes, inline: i3.props.inline, shouldFocusDayInline: i3.state.shouldFocusDayInline, peekNextMonth: i3.props.peekNextMonth, showMonthDropdown: i3.props.showMonthDropdown, showPreviousMonths: i3.props.showPreviousMonths, useShortMonthInDropdown: i3.props.useShortMonthInDropdown, showMonthYearDropdown: i3.props.showMonthYearDropdown, showWeekNumbers: i3.props.showWeekNumbers, showYearDropdown: i3.props.showYearDropdown, withPortal: i3.props.withPortal, forceShowMonthNavigation: i3.props.forceShowMonthNavigation, showDisabledMonthNavigation: i3.props.showDisabledMonthNavigation, scrollableYearDropdown: i3.props.scrollableYearDropdown, scrollableMonthYearDropdown: i3.props.scrollableMonthYearDropdown, todayButton: i3.props.todayButton, weekLabel: i3.props.weekLabel, outsideClickIgnoreClass: Xt3, fixedHeight: i3.props.fixedHeight, monthsShown: i3.props.monthsShown, monthSelectedIn: i3.state.monthSelectedIn, onDropdownFocus: i3.handleDropdownFocus, onMonthChange: i3.props.onMonthChange, onYearChange: i3.props.onYearChange, dayClassName: i3.props.dayClassName, weekDayClassName: i3.props.weekDayClassName, monthClassName: i3.props.monthClassName, timeClassName: i3.props.timeClassName, showDateSelect: i3.props.showDateSelect, showTimeSelect: i3.props.showTimeSelect, showTimeSelectOnly: i3.props.showTimeSelectOnly, onTimeChange: i3.handleTimeChange, timeFormat: i3.props.timeFormat, timeIntervals: i3.props.timeIntervals, minTime: i3.props.minTime, maxTime: i3.props.maxTime, excludeTimes: i3.props.excludeTimes, filterTime: i3.props.filterTime, timeCaption: i3.props.timeCaption, className: i3.props.calendarClassName, container: i3.props.calendarContainer, yearItemNumber: i3.props.yearItemNumber, yearDropdownItemNumber: i3.props.yearDropdownItemNumber, previousMonthAriaLabel: i3.props.previousMonthAriaLabel, previousMonthButtonLabel: i3.props.previousMonthButtonLabel, nextMonthAriaLabel: i3.props.nextMonthAriaLabel, nextMonthButtonLabel: i3.props.nextMonthButtonLabel, previousYearAriaLabel: i3.props.previousYearAriaLabel, previousYearButtonLabel: i3.props.previousYearButtonLabel, nextYearAriaLabel: i3.props.nextYearAriaLabel, nextYearButtonLabel: i3.props.nextYearButtonLabel, timeInputLabel: i3.props.timeInputLabel, disabledKeyboardNavigation: i3.props.disabledKeyboardNavigation, renderCustomHeader: i3.props.renderCustomHeader, popperProps: i3.props.popperProps, renderDayContents: i3.props.renderDayContents, renderMonthContent: i3.props.renderMonthContent, renderQuarterContent: i3.props.renderQuarterContent, renderYearContent: i3.props.renderYearContent, onDayMouseEnter: i3.props.onDayMouseEnter, onMonthMouseLeave: i3.props.onMonthMouseLeave, onYearMouseEnter: i3.props.onYearMouseEnter, onYearMouseLeave: i3.props.onYearMouseLeave, selectsDisabledDaysInRange: i3.props.selectsDisabledDaysInRange, showTimeInput: i3.props.showTimeInput, showMonthYearPicker: i3.props.showMonthYearPicker, showFullMonthYearPicker: i3.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: i3.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: i3.props.showFourColumnMonthYearPicker, showYearPicker: i3.props.showYearPicker, showQuarterYearPicker: i3.props.showQuarterYearPicker, showPopperArrow: i3.props.showPopperArrow, excludeScrollbar: i3.props.excludeScrollbar, handleOnKeyDown: i3.props.onKeyDown, handleOnDayKeyDown: i3.onDayKeyDown, isInputFocused: i3.state.focused, customTimeInput: i3.props.customTimeInput, setPreSelection: i3.setPreSelection }, i3.props.children) : null;
    }), ye6(ke4(i3), "renderAriaLiveRegion", function() {
      var t4, r2 = i3.props, n2 = r2.dateFormat, o2 = r2.locale, a3 = i3.props.showTimeInput || i3.props.showTimeSelect ? "PPPPp" : "PPPP";
      return t4 = i3.props.selectsRange ? "Selected start date: ".concat(Oe(i3.props.startDate, { dateFormat: a3, locale: o2 }), ". ").concat(i3.props.endDate ? "End date: " + Oe(i3.props.endDate, { dateFormat: a3, locale: o2 }) : "") : i3.props.showTimeSelectOnly ? "Selected time: ".concat(Oe(i3.props.selected, { dateFormat: n2, locale: o2 })) : i3.props.showYearPicker ? "Selected year: ".concat(Oe(i3.props.selected, { dateFormat: "yyyy", locale: o2 })) : i3.props.showMonthYearPicker ? "Selected month: ".concat(Oe(i3.props.selected, { dateFormat: "MMMM yyyy", locale: o2 })) : i3.props.showQuarterYearPicker ? "Selected quarter: ".concat(Oe(i3.props.selected, { dateFormat: "yyyy, QQQ", locale: o2 })) : "Selected date: ".concat(Oe(i3.props.selected, { dateFormat: a3, locale: o2 })), import_react2.default.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, t4);
    }), ye6(ke4(i3), "renderDateInput", function() {
      var t4, n2 = (0, import_classnames.default)(i3.props.className, ye6({}, Xt3, i3.state.open)), o2 = i3.props.customInput || import_react2.default.createElement("input", { type: "text" }), a3 = i3.props.customInputRef || "ref", s2 = "string" == typeof i3.props.value ? i3.props.value : "string" == typeof i3.state.inputValue ? i3.state.inputValue : i3.props.selectsRange ? function(e2, t5, r2) {
        if (!e2)
          return "";
        var n3 = Oe(e2, r2), o3 = t5 ? Oe(t5, r2) : "";
        return "".concat(n3, " - ").concat(o3);
      }(i3.props.startDate, i3.props.endDate, i3.props) : Oe(i3.props.selected, i3.props);
      return import_react2.default.cloneElement(o2, (ye6(t4 = {}, a3, function(e2) {
        i3.input = e2;
      }), ye6(t4, "value", s2), ye6(t4, "onBlur", i3.handleBlur), ye6(t4, "onChange", i3.handleChange), ye6(t4, "onClick", i3.onInputClick), ye6(t4, "onFocus", i3.handleFocus), ye6(t4, "onKeyDown", i3.onInputKeyDown), ye6(t4, "id", i3.props.id), ye6(t4, "name", i3.props.name), ye6(t4, "form", i3.props.form), ye6(t4, "autoFocus", i3.props.autoFocus), ye6(t4, "placeholder", i3.props.placeholderText), ye6(t4, "disabled", i3.props.disabled), ye6(t4, "autoComplete", i3.props.autoComplete), ye6(t4, "className", (0, import_classnames.default)(o2.props.className, n2)), ye6(t4, "title", i3.props.title), ye6(t4, "readOnly", i3.props.readOnly), ye6(t4, "required", i3.props.required), ye6(t4, "tabIndex", i3.props.tabIndex), ye6(t4, "aria-describedby", i3.props.ariaDescribedBy), ye6(t4, "aria-invalid", i3.props.ariaInvalid), ye6(t4, "aria-labelledby", i3.props.ariaLabelledBy), ye6(t4, "aria-required", i3.props.ariaRequired), t4));
    }), ye6(ke4(i3), "renderClearButton", function() {
      var t4 = i3.props, r2 = t4.isClearable, n2 = t4.selected, o2 = t4.startDate, a3 = t4.endDate, s2 = t4.clearButtonTitle, p6 = t4.clearButtonClassName, c3 = void 0 === p6 ? "" : p6, l2 = t4.ariaLabelClose, d4 = void 0 === l2 ? "Close" : l2;
      return !r2 || null == n2 && null == o2 && null == a3 ? null : import_react2.default.createElement("button", { type: "button", className: "react-datepicker__close-icon ".concat(c3).trim(), "aria-label": d4, onClick: i3.onClearClick, title: s2, tabIndex: -1 });
    }), i3.state = i3.calcInitialState(), i3.preventFocusTimeout = null, i3;
  }
  return fe5(s, [{ key: "componentDidMount", value: function() {
    window.addEventListener("scroll", this.onScroll, true);
  } }, { key: "componentDidUpdate", value: function(e2, t3) {
    var r2, n2;
    e2.inline && (r2 = e2.selected, n2 = this.props.selected, r2 && n2 ? getMonth(r2) !== getMonth(n2) || getYear(r2) !== getYear(n2) : r2 !== n2) && this.setPreSelection(this.props.selected), void 0 !== this.state.monthSelectedIn && e2.monthsShown !== this.props.monthsShown && this.setState({ monthSelectedIn: 0 }), e2.highlightDates !== this.props.highlightDates && this.setState({ highlightDates: vt4(this.props.highlightDates) }), t3.focused || Ve4(e2.selected, this.props.selected) || this.setState({ inputValue: null }), t3.open !== this.state.open && (false === t3.open && true === this.state.open && this.props.onCalendarOpen(), true === t3.open && false === this.state.open && this.props.onCalendarClose());
  } }, { key: "componentWillUnmount", value: function() {
    this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, true);
  } }, { key: "renderInputContainer", value: function() {
    var t3 = this.props, r2 = t3.showIcon, n2 = t3.icon, o2 = t3.calendarIconClassname;
    return import_react2.default.createElement("div", { className: "react-datepicker__input-container".concat(r2 ? " react-datepicker__view-calendar-icon" : "") }, r2 && import_react2.default.createElement(Ut3, { icon: n2, className: o2 }), this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(), this.renderDateInput(), this.renderClearButton());
  } }, { key: "render", value: function() {
    var t3 = this.renderCalendar();
    if (this.props.inline)
      return t3;
    if (this.props.withPortal) {
      var r2 = this.state.open ? import_react2.default.createElement(Gt3, { enableTabLoop: this.props.enableTabLoop }, import_react2.default.createElement("div", { className: "react-datepicker__portal", tabIndex: -1, onKeyDown: this.onPortalKeyDown }, t3)) : null;
      return this.state.open && this.props.portalId && (r2 = import_react2.default.createElement(zt4, { portalId: this.props.portalId, portalHost: this.props.portalHost }, r2)), import_react2.default.createElement("div", null, this.renderInputContainer(), r2);
    }
    return import_react2.default.createElement(Jt3, { className: this.props.popperClassName, wrapperClassName: this.props.wrapperClassName, hidePopper: !this.isCalendarOpen(), portalId: this.props.portalId, portalHost: this.props.portalHost, popperModifiers: this.props.popperModifiers, targetComponent: this.renderInputContainer(), popperContainer: this.props.popperContainer, popperComponent: t3, popperPlacement: this.props.popperPlacement, popperProps: this.props.popperProps, popperOnKeyDown: this.onPopperKeyDown, enableTabLoop: this.props.enableTabLoop });
  } }], [{ key: "defaultProps", get: function() {
    return { allowSameDay: false, dateFormat: "MM/dd/yyyy", dateFormatCalendar: "LLLL yyyy", onChange: function() {
    }, disabled: false, disabledKeyboardNavigation: false, dropdownMode: "scroll", onFocus: function() {
    }, onBlur: function() {
    }, onKeyDown: function() {
    }, onInputClick: function() {
    }, onSelect: function() {
    }, onClickOutside: function() {
    }, onMonthChange: function() {
    }, onCalendarOpen: function() {
    }, onCalendarClose: function() {
    }, preventOpenOnFocus: false, onYearChange: function() {
    }, onInputError: function() {
    }, monthsShown: 1, readOnly: false, withPortal: false, selectsDisabledDaysInRange: false, shouldCloseOnSelect: true, showTimeSelect: false, showTimeInput: false, showPreviousMonths: false, showMonthYearPicker: false, showFullMonthYearPicker: false, showTwoColumnMonthYearPicker: false, showFourColumnMonthYearPicker: false, showYearPicker: false, showQuarterYearPicker: false, strictParsing: false, timeIntervals: 30, timeCaption: "Time", previousMonthAriaLabel: "Previous Month", previousMonthButtonLabel: "Previous Month", nextMonthAriaLabel: "Next Month", nextMonthButtonLabel: "Next Month", previousYearAriaLabel: "Previous Year", previousYearButtonLabel: "Previous Year", nextYearAriaLabel: "Next Year", nextYearButtonLabel: "Next Year", timeInputLabel: "Time", enableTabLoop: true, yearItemNumber: Ne2, focusSelectedMonth: false, showPopperArrow: true, excludeScrollbar: true, customTimeInput: null, calendarStartDay: void 0 };
  } }]), s;
}();
var rr3 = "input";
var nr3 = "navigate";

// node_modules/@daohaus/moloch-v3-fields/index.js
import "/Users/ryanhu/Development/frontier-dao/node_modules/react-datepicker/dist/react-datepicker.css";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
var check = function(it5) {
  return it5 && it5.Math == Math && it5;
};
var global$i = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || commonjsGlobal || Function("return this")();
var objectGetOwnPropertyDescriptor = {};
var fails$o = function(exec2) {
  try {
    return !!exec2();
  } catch (error) {
    return true;
  }
};
var fails$n = fails$o;
var descriptors = !fails$n(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$m = fails$o;
var functionBindNative = !fails$m(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$3 = functionBindNative;
var call$f = Function.prototype.call;
var functionCall = NATIVE_BIND$3 ? call$f.bind(call$f) : function() {
  return call$f.apply(call$f, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
  var descriptor = getOwnPropertyDescriptor$3(this, V2);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var createPropertyDescriptor$5 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND$2 = functionBindNative;
var FunctionPrototype$2 = Function.prototype;
var call$e = FunctionPrototype$2.call;
var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$2.bind.bind(call$e, call$e);
var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function(fn3) {
  return function() {
    return call$e.apply(fn3, arguments);
  };
};
var uncurryThis$o = functionUncurryThis;
var toString$d = uncurryThis$o({}.toString);
var stringSlice$7 = uncurryThis$o("".slice);
var classofRaw$2 = function(it5) {
  return stringSlice$7(toString$d(it5), 8, -1);
};
var uncurryThis$n = functionUncurryThis;
var fails$l = fails$o;
var classof$9 = classofRaw$2;
var $Object$4 = Object;
var split$1 = uncurryThis$n("".split);
var indexedObject = fails$l(function() {
  return !$Object$4("z").propertyIsEnumerable(0);
}) ? function(it5) {
  return classof$9(it5) == "String" ? split$1(it5, "") : $Object$4(it5);
} : $Object$4;
var isNullOrUndefined$7 = function(it5) {
  return it5 === null || it5 === void 0;
};
var isNullOrUndefined$6 = isNullOrUndefined$7;
var $TypeError$f = TypeError;
var requireObjectCoercible$9 = function(it5) {
  if (isNullOrUndefined$6(it5))
    throw $TypeError$f("Can't call method on " + it5);
  return it5;
};
var IndexedObject$2 = indexedObject;
var requireObjectCoercible$8 = requireObjectCoercible$9;
var toIndexedObject$5 = function(it5) {
  return IndexedObject$2(requireObjectCoercible$8(it5));
};
var documentAll$2 = typeof document == "object" && document.all;
var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA
};
var $documentAll$1 = documentAll_1;
var documentAll$1 = $documentAll$1.all;
var isCallable$j = $documentAll$1.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$1;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$i = isCallable$j;
var $documentAll = documentAll_1;
var documentAll = $documentAll.all;
var isObject$9 = $documentAll.IS_HTMLDDA ? function(it5) {
  return typeof it5 == "object" ? it5 !== null : isCallable$i(it5) || it5 === documentAll;
} : function(it5) {
  return typeof it5 == "object" ? it5 !== null : isCallable$i(it5);
};
var global$h = global$i;
var isCallable$h = isCallable$j;
var aFunction = function(argument) {
  return isCallable$h(argument) ? argument : void 0;
};
var getBuiltIn$4 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$h[namespace]) : global$h[namespace] && global$h[namespace][method];
};
var uncurryThis$m = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$m({}.isPrototypeOf);
var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
var global$g = global$i;
var userAgent$2 = engineUserAgent;
var process$1 = global$g.process;
var Deno = global$g.Deno;
var versions = process$1 && process$1.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match;
var version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent$2) {
  match = userAgent$2.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent$2.match(/Chrome\/(\d+)/);
    if (match)
      version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION = engineV8Version;
var fails$k = fails$o;
var global$f = global$i;
var $String$5 = global$f.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$k(function() {
  var symbol = Symbol();
  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});
var NATIVE_SYMBOL$2 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$3 = getBuiltIn$4;
var isCallable$g = isCallable$j;
var isPrototypeOf$3 = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$3 = Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it5) {
  return typeof it5 == "symbol";
} : function(it5) {
  var $Symbol = getBuiltIn$3("Symbol");
  return isCallable$g($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$3(it5));
};
var $String$4 = String;
var tryToString$4 = function(argument) {
  try {
    return $String$4(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$f = isCallable$j;
var tryToString$3 = tryToString$4;
var $TypeError$e = TypeError;
var aCallable$7 = function(argument) {
  if (isCallable$f(argument))
    return argument;
  throw $TypeError$e(tryToString$3(argument) + " is not a function");
};
var aCallable$6 = aCallable$7;
var isNullOrUndefined$5 = isNullOrUndefined$7;
var getMethod$5 = function(V2, P4) {
  var func = V2[P4];
  return isNullOrUndefined$5(func) ? void 0 : aCallable$6(func);
};
var call$d = functionCall;
var isCallable$e = isCallable$j;
var isObject$8 = isObject$9;
var $TypeError$d = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn3, val;
  if (pref === "string" && isCallable$e(fn3 = input.toString) && !isObject$8(val = call$d(fn3, input)))
    return val;
  if (isCallable$e(fn3 = input.valueOf) && !isObject$8(val = call$d(fn3, input)))
    return val;
  if (pref !== "string" && isCallable$e(fn3 = input.toString) && !isObject$8(val = call$d(fn3, input)))
    return val;
  throw $TypeError$d("Can't convert object to primitive value");
};
var shared$4 = { exports: {} };
var isPure = false;
var global$e = global$i;
var defineProperty$6 = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$6(global$e, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$e[key] = value;
  }
  return value;
};
var global$d = global$i;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = global$d[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$4.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.32.0",
  mode: "global",
  copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var requireObjectCoercible$7 = requireObjectCoercible$9;
var $Object$2 = Object;
var toObject$6 = function(argument) {
  return $Object$2(requireObjectCoercible$7(argument));
};
var uncurryThis$l = functionUncurryThis;
var toObject$5 = toObject$6;
var hasOwnProperty3 = uncurryThis$l({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it5, key) {
  return hasOwnProperty3(toObject$5(it5), key);
};
var uncurryThis$k = functionUncurryThis;
var id = 0;
var postfix = Math.random();
var toString$c = uncurryThis$k(1 .toString);
var uid$2 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$c(++id + postfix, 36);
};
var global$c = global$i;
var shared$3 = shared$4.exports;
var hasOwn$b = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$2 = global$c.Symbol;
var WellKnownSymbolsStore = shared$3("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$2["for"] || Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid$1;
var wellKnownSymbol$g = function(name) {
  if (!hasOwn$b(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL$1 && hasOwn$b(Symbol$2, name) ? Symbol$2[name] : createWellKnownSymbol("Symbol." + name);
  }
  return WellKnownSymbolsStore[name];
};
var call$c = functionCall;
var isObject$7 = isObject$9;
var isSymbol$1 = isSymbol$2;
var getMethod$4 = getMethod$5;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$f = wellKnownSymbol$g;
var $TypeError$c = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$f("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$7(input) || isSymbol$1(input))
    return input;
  var exoticToPrim = getMethod$4(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$c(exoticToPrim, input, pref);
    if (!isObject$7(result) || isSymbol$1(result))
      return result;
    throw $TypeError$c("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$3 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$b = global$i;
var isObject$6 = isObject$9;
var document$1 = global$b.document;
var EXISTS$1 = isObject$6(document$1) && isObject$6(document$1.createElement);
var documentCreateElement$2 = function(it5) {
  return EXISTS$1 ? document$1.createElement(it5) : {};
};
var DESCRIPTORS$c = descriptors;
var fails$j = fails$o;
var createElement5 = documentCreateElement$2;
var ie8DomDefine = !DESCRIPTORS$c && !fails$j(function() {
  return Object.defineProperty(createElement5("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$b = descriptors;
var call$b = functionCall;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$4 = createPropertyDescriptor$5;
var toIndexedObject$4 = toIndexedObject$5;
var toPropertyKey$2 = toPropertyKey$3;
var hasOwn$a = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$b ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O5, P4) {
  O5 = toIndexedObject$4(O5);
  P4 = toPropertyKey$2(P4);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$1(O5, P4);
    } catch (error) {
    }
  if (hasOwn$a(O5, P4))
    return createPropertyDescriptor$4(!call$b(propertyIsEnumerableModule$1.f, O5, P4), O5[P4]);
};
var objectDefineProperty = {};
var DESCRIPTORS$a = descriptors;
var fails$i = fails$o;
var v8PrototypeDefineBug = DESCRIPTORS$a && fails$i(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var isObject$5 = isObject$9;
var $String$3 = String;
var $TypeError$b = TypeError;
var anObject$e = function(argument) {
  if (isObject$5(argument))
    return argument;
  throw $TypeError$b($String$3(argument) + " is not an object");
};
var DESCRIPTORS$9 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$d = anObject$e;
var toPropertyKey$1 = toPropertyKey$3;
var $TypeError$a = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$9 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O5, P4, Attributes) {
  anObject$d(O5);
  P4 = toPropertyKey$1(P4);
  anObject$d(Attributes);
  if (typeof O5 === "function" && P4 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O5, P4);
    if (current && current[WRITABLE]) {
      O5[P4] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O5, P4, Attributes);
} : $defineProperty : function defineProperty2(O5, P4, Attributes) {
  anObject$d(O5);
  P4 = toPropertyKey$1(P4);
  anObject$d(Attributes);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty(O5, P4, Attributes);
    } catch (error) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError$a("Accessors not supported");
  if ("value" in Attributes)
    O5[P4] = Attributes.value;
  return O5;
};
var DESCRIPTORS$8 = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$5;
var createNonEnumerableProperty$5 = DESCRIPTORS$8 ? function(object, key, value) {
  return definePropertyModule$4.f(object, key, createPropertyDescriptor$3(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltIn$3 = { exports: {} };
var DESCRIPTORS$7 = descriptors;
var hasOwn$9 = hasOwnProperty_1;
var FunctionPrototype$1 = Function.prototype;
var getDescriptor = DESCRIPTORS$7 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$9(FunctionPrototype$1, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$7 || DESCRIPTORS$7 && getDescriptor(FunctionPrototype$1, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$j = functionUncurryThis;
var isCallable$d = isCallable$j;
var store$1 = sharedStore;
var functionToString = uncurryThis$j(Function.toString);
if (!isCallable$d(store$1.inspectSource)) {
  store$1.inspectSource = function(it5) {
    return functionToString(it5);
  };
}
var inspectSource$2 = store$1.inspectSource;
var global$a = global$i;
var isCallable$c = isCallable$j;
var WeakMap$1 = global$a.WeakMap;
var weakMapBasicDetection = isCallable$c(WeakMap$1) && /native code/.test(String(WeakMap$1));
var shared$2 = shared$4.exports;
var uid2 = uid$2;
var keys2 = shared$2("keys");
var sharedKey$3 = function(key) {
  return keys2[key] || (keys2[key] = uid2(key));
};
var hiddenKeys$4 = {};
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$9 = global$i;
var isObject$4 = isObject$9;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$5;
var hasOwn$8 = hasOwnProperty_1;
var shared$1 = sharedStore;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$3 = hiddenKeys$4;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$2 = global$9.TypeError;
var WeakMap = global$9.WeakMap;
var set2;
var get;
var has;
var enforce = function(it5) {
  return has(it5) ? get(it5) : set2(it5, {});
};
var getterFor = function(TYPE) {
  return function(it5) {
    var state;
    if (!isObject$4(it5) || (state = get(it5)).type !== TYPE) {
      throw TypeError$2("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared$1.state) {
  store = shared$1.state || (shared$1.state = new WeakMap());
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  set2 = function(it5, metadata) {
    if (store.has(it5))
      throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it5;
    store.set(it5, metadata);
    return metadata;
  };
  get = function(it5) {
    return store.get(it5) || {};
  };
  has = function(it5) {
    return store.has(it5);
  };
} else {
  STATE = sharedKey$2("state");
  hiddenKeys$3[STATE] = true;
  set2 = function(it5, metadata) {
    if (hasOwn$8(it5, STATE))
      throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it5;
    createNonEnumerableProperty$4(it5, STATE, metadata);
    return metadata;
  };
  get = function(it5) {
    return hasOwn$8(it5, STATE) ? it5[STATE] : {};
  };
  has = function(it5) {
    return hasOwn$8(it5, STATE);
  };
}
var store;
var STATE;
var internalState = {
  set: set2,
  get,
  has,
  enforce,
  getterFor
};
var uncurryThis$i = functionUncurryThis;
var fails$h = fails$o;
var isCallable$b = isCallable$j;
var hasOwn$7 = hasOwnProperty_1;
var DESCRIPTORS$6 = descriptors;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
var inspectSource$1 = inspectSource$2;
var InternalStateModule$2 = internalState;
var enforceInternalState = InternalStateModule$2.enforce;
var getInternalState$2 = InternalStateModule$2.get;
var $String$2 = String;
var defineProperty$5 = Object.defineProperty;
var stringSlice$6 = uncurryThis$i("".slice);
var replace$4 = uncurryThis$i("".replace);
var join$1 = uncurryThis$i([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS$6 && !fails$h(function() {
  return defineProperty$5(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name, options) {
  if (stringSlice$6($String$2(name), 0, 7) === "Symbol(") {
    name = "[" + replace$4($String$2(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter)
    name = "get " + name;
  if (options && options.setter)
    name = "set " + name;
  if (!hasOwn$7(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    if (DESCRIPTORS$6)
      defineProperty$5(value, "name", { value: name, configurable: true });
    else
      value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, "arity") && value.length !== options.arity) {
    defineProperty$5(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$7(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$6)
        defineProperty$5(value, "prototype", { writable: false });
    } else if (value.prototype)
      value.prototype = void 0;
  } catch (error) {
  }
  var state = enforceInternalState(value);
  if (!hasOwn$7(state, "source")) {
    state.source = join$1(TEMPLATE, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$2(function toString4() {
  return isCallable$b(this) && getInternalState$2(this).source || inspectSource$1(this);
}, "toString");
var isCallable$a = isCallable$j;
var definePropertyModule$3 = objectDefineProperty;
var makeBuiltIn$1 = makeBuiltIn$3.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$7 = function(O5, key, value, options) {
  if (!options)
    options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$a(value))
    makeBuiltIn$1(value, name, options);
  if (options.global) {
    if (simple)
      O5[key] = value;
    else
      defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe)
        delete O5[key];
      else if (O5[key])
        simple = true;
    } catch (error) {
    }
    if (simple)
      O5[key] = value;
    else
      definePropertyModule$3.f(O5, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
  }
  return O5;
};
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor$1 = Math.floor;
var mathTrunc = Math.trunc || function trunc(x6) {
  var n2 = +x6;
  return (n2 > 0 ? floor$1 : ceil)(n2);
};
var trunc2 = mathTrunc;
var toIntegerOrInfinity$3 = function(argument) {
  var number2 = +argument;
  return number2 !== number2 || number2 === 0 ? 0 : trunc2(number2);
};
var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
var max$1 = Math.max;
var min$3 = Math.min;
var toAbsoluteIndex$2 = function(index2, length) {
  var integer = toIntegerOrInfinity$2(index2);
  return integer < 0 ? max$1(integer + length, 0) : min$3(integer, length);
};
var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
var min$2 = Math.min;
var toLength$4 = function(argument) {
  return argument > 0 ? min$2(toIntegerOrInfinity$1(argument), 9007199254740991) : 0;
};
var toLength$3 = toLength$4;
var lengthOfArrayLike$6 = function(obj) {
  return toLength$3(obj.length);
};
var toIndexedObject$3 = toIndexedObject$5;
var toAbsoluteIndex$1 = toAbsoluteIndex$2;
var lengthOfArrayLike$5 = lengthOfArrayLike$6;
var createMethod$3 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O5 = toIndexedObject$3($this);
    var length = lengthOfArrayLike$5(O5);
    var index2 = toAbsoluteIndex$1(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index2) {
        value = O5[index2++];
        if (value != value)
          return true;
      }
    else
      for (; length > index2; index2++) {
        if ((IS_INCLUDES || index2 in O5) && O5[index2] === el)
          return IS_INCLUDES || index2 || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$3(true),
  indexOf: createMethod$3(false)
};
var uncurryThis$h = functionUncurryThis;
var hasOwn$6 = hasOwnProperty_1;
var toIndexedObject$2 = toIndexedObject$5;
var indexOf$1 = arrayIncludes.indexOf;
var hiddenKeys$2 = hiddenKeys$4;
var push$3 = uncurryThis$h([].push);
var objectKeysInternal = function(object, names) {
  var O5 = toIndexedObject$2(object);
  var i3 = 0;
  var result = [];
  var key;
  for (key in O5)
    !hasOwn$6(hiddenKeys$2, key) && hasOwn$6(O5, key) && push$3(result, key);
  while (names.length > i3)
    if (hasOwn$6(O5, key = names[i3++])) {
      ~indexOf$1(result, key) || push$3(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$1 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O5) {
  return internalObjectKeys$1(O5, hiddenKeys$1);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$2 = getBuiltIn$4;
var uncurryThis$g = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$c = anObject$e;
var concat$1 = uncurryThis$g([].concat);
var ownKeys$1 = getBuiltIn$2("Reflect", "ownKeys") || function ownKeys(it5) {
  var keys5 = getOwnPropertyNamesModule.f(anObject$c(it5));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
  return getOwnPropertySymbols ? concat$1(keys5, getOwnPropertySymbols(it5)) : keys5;
};
var hasOwn$5 = hasOwnProperty_1;
var ownKeys2 = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$2 = objectDefineProperty;
var copyConstructorProperties$2 = function(target, source, exceptions) {
  var keys5 = ownKeys2(source);
  var defineProperty4 = definePropertyModule$2.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i3 = 0; i3 < keys5.length; i3++) {
    var key = keys5[i3];
    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$g = fails$o;
var isCallable$9 = isCallable$j;
var replacement = /#|\.prototype\./;
var isForced$1 = function(feature, detection) {
  var value = data[normalize3(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$9(detection) ? fails$g(detection) : !!detection;
};
var normalize3 = isForced$1.normalize = function(string3) {
  return String(string3).replace(replacement, ".").toLowerCase();
};
var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = "N";
var POLYFILL = isForced$1.POLYFILL = "P";
var isForced_1 = isForced$1;
var global$8 = global$i;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$5;
var defineBuiltIn$6 = defineBuiltIn$7;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties$1 = copyConstructorProperties$2;
var isForced = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$8;
  } else if (STATIC) {
    target = global$8[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$8[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor$2(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties$1(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$3(sourceProperty, "sham", true);
      }
      defineBuiltIn$6(target, key, sourceProperty, options);
    }
};
var wellKnownSymbol$e = wellKnownSymbol$g;
var TO_STRING_TAG$3 = wellKnownSymbol$e("toStringTag");
var test$1 = {};
test$1[TO_STRING_TAG$3] = "z";
var toStringTagSupport = String(test$1) === "[object z]";
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$8 = isCallable$j;
var classofRaw$1 = classofRaw$2;
var wellKnownSymbol$d = wellKnownSymbol$g;
var TO_STRING_TAG$2 = wellKnownSymbol$d("toStringTag");
var $Object$1 = Object;
var CORRECT_ARGUMENTS = classofRaw$1(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it5, key) {
  try {
    return it5[key];
  } catch (error) {
  }
};
var classof$8 = TO_STRING_TAG_SUPPORT ? classofRaw$1 : function(it5) {
  var O5, tag, result;
  return it5 === void 0 ? "Undefined" : it5 === null ? "Null" : typeof (tag = tryGet(O5 = $Object$1(it5), TO_STRING_TAG$2)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw$1(O5) : (result = classofRaw$1(O5)) == "Object" && isCallable$8(O5.callee) ? "Arguments" : result;
};
var classof$7 = classof$8;
var $String$1 = String;
var toString$b = function(argument) {
  if (classof$7(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$1(argument);
};
var makeBuiltIn = makeBuiltIn$3.exports;
var defineProperty$4 = objectDefineProperty;
var defineBuiltInAccessor$2 = function(target, name, descriptor) {
  if (descriptor.get)
    makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set)
    makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty$4.f(target, name, descriptor);
};
var $$c = _export;
var DESCRIPTORS$5 = descriptors;
var global$7 = global$i;
var uncurryThis$f = functionUncurryThis;
var hasOwn$4 = hasOwnProperty_1;
var isCallable$7 = isCallable$j;
var isPrototypeOf$2 = objectIsPrototypeOf;
var toString$a = toString$b;
var defineBuiltInAccessor$1 = defineBuiltInAccessor$2;
var copyConstructorProperties = copyConstructorProperties$2;
var NativeSymbol = global$7.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
if (DESCRIPTORS$5 && isCallable$7(NativeSymbol) && (!("description" in SymbolPrototype) || NativeSymbol().description !== void 0)) {
  EmptyStringDescriptionStore = {};
  SymbolWrapper = function Symbol2() {
    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString$a(arguments[0]);
    var result = isPrototypeOf$2(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
    if (description === "")
      EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;
  NATIVE_SYMBOL = String(NativeSymbol("test")) == "Symbol(test)";
  thisSymbolValue = uncurryThis$f(SymbolPrototype.valueOf);
  symbolDescriptiveString = uncurryThis$f(SymbolPrototype.toString);
  regexp = /^Symbol\((.*)\)[^)]+$/;
  replace$3 = uncurryThis$f("".replace);
  stringSlice$5 = uncurryThis$f("".slice);
  defineBuiltInAccessor$1(SymbolPrototype, "description", {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn$4(EmptyStringDescriptionStore, symbol))
        return "";
      var string3 = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL ? stringSlice$5(string3, 7, -1) : replace$3(string3, regexp, "$1");
      return desc === "" ? void 0 : desc;
    }
  });
  $$c({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}
var EmptyStringDescriptionStore;
var SymbolWrapper;
var NATIVE_SYMBOL;
var thisSymbolValue;
var symbolDescriptiveString;
var regexp;
var replace$3;
var stringSlice$5;
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$2 = Object.keys || function keys3(O5) {
  return internalObjectKeys(O5, enumBugKeys$1);
};
var DESCRIPTORS$4 = descriptors;
var uncurryThis$e = functionUncurryThis;
var call$a = functionCall;
var fails$f = fails$o;
var objectKeys$1 = objectKeys$2;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$4 = toObject$6;
var IndexedObject$1 = indexedObject;
var $assign = Object.assign;
var defineProperty$3 = Object.defineProperty;
var concat2 = uncurryThis$e([].concat);
var objectAssign = !$assign || fails$f(function() {
  if (DESCRIPTORS$4 && $assign({ b: 1 }, $assign(defineProperty$3({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$3(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A2 = {};
  var B4 = {};
  var symbol = Symbol();
  var alphabet = "abcdefghijklmnopqrst";
  A2[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B4[chr] = chr;
  });
  return $assign({}, A2)[symbol] != 7 || objectKeys$1($assign({}, B4)).join("") != alphabet;
}) ? function assign(target, source) {
  var T3 = toObject$4(target);
  var argumentsLength = arguments.length;
  var index2 = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable2 = propertyIsEnumerableModule.f;
  while (argumentsLength > index2) {
    var S4 = IndexedObject$1(arguments[index2++]);
    var keys5 = getOwnPropertySymbols ? concat2(objectKeys$1(S4), getOwnPropertySymbols(S4)) : objectKeys$1(S4);
    var length = keys5.length;
    var j5 = 0;
    var key;
    while (length > j5) {
      key = keys5[j5++];
      if (!DESCRIPTORS$4 || call$a(propertyIsEnumerable2, S4, key))
        T3[key] = S4[key];
    }
  }
  return T3;
} : $assign;
var $$b = _export;
var assign2 = objectAssign;
$$b({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
  assign: assign2
});
var CollapsibleFormSegment = ({
  actionButton,
  defaultOpen,
  title,
  description,
  formArea,
  infoArea,
  error
}) => {
  return (0, import_jsx_runtime2.jsx)(CollapsibleCard, {
    children: (0, import_jsx_runtime2.jsxs)("div", {
      children: [(0, import_jsx_runtime2.jsx)(H5, Object.assign({
        className: "segment-title"
      }, {
        children: title
      })), (0, import_jsx_runtime2.jsx)(ParMd, Object.assign({
        className: "segment-description"
      }, {
        children: description
      }))]
    }),
    collapsibleActions: actionButton,
    collapsibleContent: (0, import_jsx_runtime2.jsxs)("div", {
      children: [formArea, infoArea, error]
    }),
    defaultOpen,
    triggerLabel: "",
    width: "100%"
  });
};
var objectDefineProperties = {};
var DESCRIPTORS$3 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule$1 = objectDefineProperty;
var anObject$b = anObject$e;
var toIndexedObject$1 = toIndexedObject$5;
var objectKeys = objectKeys$2;
objectDefineProperties.f = DESCRIPTORS$3 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O5, Properties) {
  anObject$b(O5);
  var props = toIndexedObject$1(Properties);
  var keys5 = objectKeys(Properties);
  var length = keys5.length;
  var index2 = 0;
  var key;
  while (length > index2)
    definePropertyModule$1.f(O5, key = keys5[index2++], props[key]);
  return O5;
};
var getBuiltIn$1 = getBuiltIn$4;
var html$1 = getBuiltIn$1("document", "documentElement");
var anObject$a = anObject$e;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys = hiddenKeys$4;
var html4 = html$1;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$1 = sharedKey$3;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$1("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content3) {
  return LT + SCRIPT + GT + content3 + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html4.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys[IE_PROTO$1] = true;
var objectCreate = Object.create || function create2(O5, Properties) {
  var result;
  if (O5 !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$a(O5);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO$1] = O5;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
};
var wellKnownSymbol$c = wellKnownSymbol$g;
var create$3 = objectCreate;
var defineProperty$2 = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol$c("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == void 0) {
  defineProperty$2(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$3(null)
  });
}
var addToUnscopables$3 = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var iterators = {};
var fails$e = fails$o;
var correctPrototypeGetter = !fails$e(function() {
  function F4() {
  }
  F4.prototype.constructor = null;
  return Object.getPrototypeOf(new F4()) !== F4.prototype;
});
var hasOwn$3 = hasOwnProperty_1;
var isCallable$6 = isCallable$j;
var toObject$3 = toObject$6;
var sharedKey4 = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey4("IE_PROTO");
var $Object = Object;
var ObjectPrototype = $Object.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O5) {
  var object = toObject$3(O5);
  if (hasOwn$3(object, IE_PROTO))
    return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$6(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof $Object ? ObjectPrototype : null;
};
var fails$d = fails$o;
var isCallable$5 = isCallable$j;
var isObject$3 = isObject$9;
var getPrototypeOf$1 = objectGetPrototypeOf;
var defineBuiltIn$5 = defineBuiltIn$7;
var wellKnownSymbol$b = wellKnownSymbol$g;
var ITERATOR$6 = wellKnownSymbol$b("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2;
var PrototypeOfArrayIteratorPrototype;
var arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject$3(IteratorPrototype$2) || fails$d(function() {
  var test2 = {};
  return IteratorPrototype$2[ITERATOR$6].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$2 = {};
if (!isCallable$5(IteratorPrototype$2[ITERATOR$6])) {
  defineBuiltIn$5(IteratorPrototype$2, ITERATOR$6, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var defineProperty$1 = objectDefineProperty.f;
var hasOwn$2 = hasOwnProperty_1;
var wellKnownSymbol$a = wellKnownSymbol$g;
var TO_STRING_TAG$1 = wellKnownSymbol$a("toStringTag");
var setToStringTag$3 = function(target, TAG, STATIC) {
  if (target && !STATIC)
    target = target.prototype;
  if (target && !hasOwn$2(target, TO_STRING_TAG$1)) {
    defineProperty$1(target, TO_STRING_TAG$1, { configurable: true, value: TAG });
  }
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create$2 = objectCreate;
var createPropertyDescriptor$2 = createPropertyDescriptor$5;
var setToStringTag$2 = setToStringTag$3;
var Iterators$3 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor, NAME, next2, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME + " Iterator";
  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next2) });
  setToStringTag$2(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$3[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var uncurryThis$d = functionUncurryThis;
var aCallable$5 = aCallable$7;
var functionUncurryThisAccessor = function(object, key, method) {
  try {
    return uncurryThis$d(aCallable$5(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) {
  }
};
var isCallable$4 = isCallable$j;
var $String = String;
var $TypeError$9 = TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$4(argument))
    return argument;
  throw $TypeError$9("Can't set " + $String(argument) + " as a prototype");
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var anObject$9 = anObject$e;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error) {
  }
  return function setPrototypeOf2(O5, proto) {
    anObject$9(O5);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O5, proto);
    else
      O5.__proto__ = proto;
    return O5;
  };
}() : void 0);
var $$a = _export;
var call$9 = functionCall;
var FunctionName = functionName;
var isCallable$3 = isCallable$j;
var createIteratorConstructor$1 = iteratorCreateConstructor;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag$1 = setToStringTag$3;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$5;
var defineBuiltIn$4 = defineBuiltIn$7;
var wellKnownSymbol$9 = wellKnownSymbol$g;
var Iterators$2 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$5 = wellKnownSymbol$9("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME, IteratorConstructor, next2, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor$1(IteratorConstructor, NAME, next2);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys5() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values4() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries2() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$5] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$5])) {
          defineBuiltIn$4(CurrentIteratorPrototype, ITERATOR$5, returnThis);
        }
      }
      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty$2(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values4() {
        return call$9(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn$4(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $$a({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$5] !== defaultIterator) {
    defineBuiltIn$4(IterablePrototype, ITERATOR$5, defaultIterator, { name: DEFAULT });
  }
  Iterators$2[NAME] = defaultIterator;
  return methods;
};
var createIterResultObject$1 = function(value, done) {
  return { value, done };
};
var toIndexedObject = toIndexedObject$5;
var addToUnscopables$2 = addToUnscopables$3;
var Iterators$1 = iterators;
var InternalStateModule$1 = internalState;
var defineProperty3 = objectDefineProperty.f;
var defineIterator = iteratorDefine;
var createIterResultObject = createIterResultObject$1;
var DESCRIPTORS$2 = descriptors;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState$1 = InternalStateModule$1.set;
var getInternalState$1 = InternalStateModule$1.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
  setInternalState$1(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    index: 0,
    kind
  });
}, function() {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index2 = state.index++;
  if (!target || index2 >= target.length) {
    state.target = void 0;
    return createIterResultObject(void 0, true);
  }
  if (kind == "keys")
    return createIterResultObject(index2, false);
  if (kind == "values")
    return createIterResultObject(target[index2], false);
  return createIterResultObject([index2, target[index2]], false);
}, "values");
var values2 = Iterators$1.Arguments = Iterators$1.Array;
addToUnscopables$2("keys");
addToUnscopables$2("values");
addToUnscopables$2("entries");
if (DESCRIPTORS$2 && values2.name !== "values")
  try {
    defineProperty3(values2, "name", { value: "values" });
  } catch (error) {
  }
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement = documentCreateElement$2;
var classList = documentCreateElement("span").classList;
var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
var global$6 = global$i;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$5;
var wellKnownSymbol$8 = wellKnownSymbol$g;
var ITERATOR$4 = wellKnownSymbol$8("iterator");
var TO_STRING_TAG = wellKnownSymbol$8("toStringTag");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR$4] !== ArrayValues)
      try {
        createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$4, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR$4] = ArrayValues;
      }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
          try {
            createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME in DOMIterables) {
  handlePrototype(global$6[COLLECTION_NAME] && global$6[COLLECTION_NAME].prototype, COLLECTION_NAME);
}
var COLLECTION_NAME;
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
var anObject$8 = anObject$e;
var regexpFlags$1 = function() {
  var that = anObject$8(this);
  var result = "";
  if (that.hasIndices)
    result += "d";
  if (that.global)
    result += "g";
  if (that.ignoreCase)
    result += "i";
  if (that.multiline)
    result += "m";
  if (that.dotAll)
    result += "s";
  if (that.unicode)
    result += "u";
  if (that.unicodeSets)
    result += "v";
  if (that.sticky)
    result += "y";
  return result;
};
var fails$c = fails$o;
var global$5 = global$i;
var $RegExp$2 = global$5.RegExp;
var UNSUPPORTED_Y$2 = fails$c(function() {
  var re4 = $RegExp$2("a", "y");
  re4.lastIndex = 2;
  return re4.exec("abcd") != null;
});
var MISSED_STICKY = UNSUPPORTED_Y$2 || fails$c(function() {
  return !$RegExp$2("a", "y").sticky;
});
var BROKEN_CARET = UNSUPPORTED_Y$2 || fails$c(function() {
  var re4 = $RegExp$2("^r", "gy");
  re4.lastIndex = 2;
  return re4.exec("str") != null;
});
var regexpStickyHelpers = {
  BROKEN_CARET,
  MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y$2
};
var fails$b = fails$o;
var global$4 = global$i;
var $RegExp$1 = global$4.RegExp;
var regexpUnsupportedDotAll = fails$b(function() {
  var re4 = $RegExp$1(".", "s");
  return !(re4.dotAll && re4.exec("\n") && re4.flags === "s");
});
var fails$a = fails$o;
var global$3 = global$i;
var $RegExp = global$3.RegExp;
var regexpUnsupportedNcg = fails$a(function() {
  var re4 = $RegExp("(?<a>b)", "g");
  return re4.exec("b").groups.a !== "b" || "b".replace(re4, "$<a>c") !== "bc";
});
var call$8 = functionCall;
var uncurryThis$c = functionUncurryThis;
var toString$9 = toString$b;
var regexpFlags = regexpFlags$1;
var stickyHelpers$1 = regexpStickyHelpers;
var shared = shared$4.exports;
var create$1 = objectCreate;
var getInternalState = internalState.get;
var UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
var UNSUPPORTED_NCG = regexpUnsupportedNcg;
var nativeReplace = shared("native-string-replace", String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt$3 = uncurryThis$c("".charAt);
var indexOf = uncurryThis$c("".indexOf);
var replace$2 = uncurryThis$c("".replace);
var stringSlice$4 = uncurryThis$c("".slice);
var UPDATES_LAST_INDEX_WRONG = function() {
  var re1 = /a/;
  var re22 = /b*/g;
  call$8(nativeExec, re1, "a");
  call$8(nativeExec, re22, "a");
  return re1.lastIndex !== 0 || re22.lastIndex !== 0;
}();
var UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
if (PATCH) {
  patchedExec = function exec2(string3) {
    var re4 = this;
    var state = getInternalState(re4);
    var str = toString$9(string3);
    var raw = state.raw;
    var result, reCopy, lastIndex, match2, i3, object, group;
    if (raw) {
      raw.lastIndex = re4.lastIndex;
      result = call$8(patchedExec, raw, str);
      re4.lastIndex = raw.lastIndex;
      return result;
    }
    var groups = state.groups;
    var sticky = UNSUPPORTED_Y$1 && re4.sticky;
    var flags = call$8(regexpFlags, re4);
    var source = re4.source;
    var charsAdded = 0;
    var strCopy = str;
    if (sticky) {
      flags = replace$2(flags, "y", "");
      if (indexOf(flags, "g") === -1) {
        flags += "g";
      }
      strCopy = stringSlice$4(str, re4.lastIndex);
      if (re4.lastIndex > 0 && (!re4.multiline || re4.multiline && charAt$3(str, re4.lastIndex - 1) !== "\n")) {
        source = "(?: " + source + ")";
        strCopy = " " + strCopy;
        charsAdded++;
      }
      reCopy = new RegExp("^(?:" + source + ")", flags);
    }
    if (NPCG_INCLUDED) {
      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
    }
    if (UPDATES_LAST_INDEX_WRONG)
      lastIndex = re4.lastIndex;
    match2 = call$8(nativeExec, sticky ? reCopy : re4, strCopy);
    if (sticky) {
      if (match2) {
        match2.input = stringSlice$4(match2.input, charsAdded);
        match2[0] = stringSlice$4(match2[0], charsAdded);
        match2.index = re4.lastIndex;
        re4.lastIndex += match2[0].length;
      } else
        re4.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match2) {
      re4.lastIndex = re4.global ? match2.index + match2[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match2 && match2.length > 1) {
      call$8(nativeReplace, match2[0], reCopy, function() {
        for (i3 = 1; i3 < arguments.length - 2; i3++) {
          if (arguments[i3] === void 0)
            match2[i3] = void 0;
        }
      });
    }
    if (match2 && groups) {
      match2.groups = object = create$1(null);
      for (i3 = 0; i3 < groups.length; i3++) {
        group = groups[i3];
        object[group[0]] = match2[group[1]];
      }
    }
    return match2;
  };
}
var regexpExec$3 = patchedExec;
var $$9 = _export;
var exec$3 = regexpExec$3;
$$9({ target: "RegExp", proto: true, forced: /./.exec !== exec$3 }, {
  exec: exec$3
});
var NATIVE_BIND$1 = functionBindNative;
var FunctionPrototype = Function.prototype;
var apply$1 = FunctionPrototype.apply;
var call$7 = FunctionPrototype.call;
var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1 ? call$7.bind(apply$1) : function() {
  return call$7.apply(apply$1, arguments);
});
var classofRaw = classofRaw$2;
var uncurryThis$b = functionUncurryThis;
var functionUncurryThisClause = function(fn3) {
  if (classofRaw(fn3) === "Function")
    return uncurryThis$b(fn3);
};
var uncurryThis$a = functionUncurryThisClause;
var defineBuiltIn$3 = defineBuiltIn$7;
var regexpExec$2 = regexpExec$3;
var fails$9 = fails$o;
var wellKnownSymbol$7 = wellKnownSymbol$g;
var createNonEnumerableProperty = createNonEnumerableProperty$5;
var SPECIES$2 = wellKnownSymbol$7("species");
var RegExpPrototype$2 = RegExp.prototype;
var fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
  var SYMBOL = wellKnownSymbol$7(KEY);
  var DELEGATES_TO_SYMBOL = !fails$9(function() {
    var O5 = {};
    O5[SYMBOL] = function() {
      return 7;
    };
    return ""[KEY](O5) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$9(function() {
    var execCalled = false;
    var re4 = /a/;
    if (KEY === "split") {
      re4 = {};
      re4.constructor = {};
      re4.constructor[SPECIES$2] = function() {
        return re4;
      };
      re4.flags = "";
      re4[SYMBOL] = /./[SYMBOL];
    }
    re4.exec = function() {
      execCalled = true;
      return null;
    };
    re4[SYMBOL]("");
    return !execCalled;
  });
  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
    var uncurriedNativeRegExpMethod = uncurryThis$a(/./[SYMBOL]);
    var methods = exec2(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis$a(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec$2 || $exec === RegExpPrototype$2.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });
    defineBuiltIn$3(String.prototype, KEY, methods[0]);
    defineBuiltIn$3(RegExpPrototype$2, SYMBOL, methods[1]);
  }
  if (SHAM)
    createNonEnumerableProperty(RegExpPrototype$2[SYMBOL], "sham", true);
};
var isObject$2 = isObject$9;
var classof$6 = classofRaw$2;
var wellKnownSymbol$6 = wellKnownSymbol$g;
var MATCH$1 = wellKnownSymbol$6("match");
var isRegexp = function(it5) {
  var isRegExp2;
  return isObject$2(it5) && ((isRegExp2 = it5[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$6(it5) == "RegExp");
};
var uncurryThis$9 = functionUncurryThis;
var fails$8 = fails$o;
var isCallable$2 = isCallable$j;
var classof$5 = classof$8;
var getBuiltIn = getBuiltIn$4;
var inspectSource = inspectSource$2;
var noop = function() {
};
var empty3 = [];
var construct = getBuiltIn("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec$2 = uncurryThis$9(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor(argument) {
  if (!isCallable$2(argument))
    return false;
  try {
    construct(noop, empty3, argument);
    return true;
  } catch (error) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor2(argument) {
  if (!isCallable$2(argument))
    return false;
  switch (classof$5(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$2 = !construct || fails$8(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var isConstructor$1 = isConstructor$2;
var tryToString$2 = tryToString$4;
var $TypeError$8 = TypeError;
var aConstructor$1 = function(argument) {
  if (isConstructor$1(argument))
    return argument;
  throw $TypeError$8(tryToString$2(argument) + " is not a constructor");
};
var anObject$7 = anObject$e;
var aConstructor = aConstructor$1;
var isNullOrUndefined$4 = isNullOrUndefined$7;
var wellKnownSymbol$5 = wellKnownSymbol$g;
var SPECIES$1 = wellKnownSymbol$5("species");
var speciesConstructor$1 = function(O5, defaultConstructor) {
  var C4 = anObject$7(O5).constructor;
  var S4;
  return C4 === void 0 || isNullOrUndefined$4(S4 = anObject$7(C4)[SPECIES$1]) ? defaultConstructor : aConstructor(S4);
};
var uncurryThis$8 = functionUncurryThis;
var toIntegerOrInfinity = toIntegerOrInfinity$3;
var toString$8 = toString$b;
var requireObjectCoercible$6 = requireObjectCoercible$9;
var charAt$2 = uncurryThis$8("".charAt);
var charCodeAt = uncurryThis$8("".charCodeAt);
var stringSlice$3 = uncurryThis$8("".slice);
var createMethod$2 = function(CONVERT_TO_STRING) {
  return function($this, pos) {
    var S4 = toString$8(requireObjectCoercible$6($this));
    var position3 = toIntegerOrInfinity(pos);
    var size2 = S4.length;
    var first, second;
    if (position3 < 0 || position3 >= size2)
      return CONVERT_TO_STRING ? "" : void 0;
    first = charCodeAt(S4, position3);
    return first < 55296 || first > 56319 || position3 + 1 === size2 || (second = charCodeAt(S4, position3 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$2(S4, position3) : first : CONVERT_TO_STRING ? stringSlice$3(S4, position3, position3 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
  };
};
var stringMultibyte = {
  codeAt: createMethod$2(false),
  charAt: createMethod$2(true)
};
var charAt$1 = stringMultibyte.charAt;
var advanceStringIndex$2 = function(S4, index2, unicode) {
  return index2 + (unicode ? charAt$1(S4, index2).length : 1);
};
var toPropertyKey = toPropertyKey$3;
var definePropertyModule = objectDefineProperty;
var createPropertyDescriptor$1 = createPropertyDescriptor$5;
var createProperty$1 = function(object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object)
    definePropertyModule.f(object, propertyKey, createPropertyDescriptor$1(0, value));
  else
    object[propertyKey] = value;
};
var toAbsoluteIndex = toAbsoluteIndex$2;
var lengthOfArrayLike$4 = lengthOfArrayLike$6;
var createProperty2 = createProperty$1;
var $Array$1 = Array;
var max3 = Math.max;
var arraySliceSimple = function(O5, start2, end2) {
  var length = lengthOfArrayLike$4(O5);
  var k4 = toAbsoluteIndex(start2, length);
  var fin = toAbsoluteIndex(end2 === void 0 ? length : end2, length);
  var result = $Array$1(max3(fin - k4, 0));
  for (var n2 = 0; k4 < fin; k4++, n2++)
    createProperty2(result, n2, O5[k4]);
  result.length = n2;
  return result;
};
var call$6 = functionCall;
var anObject$6 = anObject$e;
var isCallable$1 = isCallable$j;
var classof$4 = classofRaw$2;
var regexpExec$1 = regexpExec$3;
var $TypeError$7 = TypeError;
var regexpExecAbstract = function(R6, S4) {
  var exec2 = R6.exec;
  if (isCallable$1(exec2)) {
    var result = call$6(exec2, R6, S4);
    if (result !== null)
      anObject$6(result);
    return result;
  }
  if (classof$4(R6) === "RegExp")
    return call$6(regexpExec$1, R6, S4);
  throw $TypeError$7("RegExp#exec called on incompatible receiver");
};
var apply = functionApply;
var call$5 = functionCall;
var uncurryThis$7 = functionUncurryThis;
var fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
var anObject$5 = anObject$e;
var isNullOrUndefined$3 = isNullOrUndefined$7;
var isRegExp$1 = isRegexp;
var requireObjectCoercible$5 = requireObjectCoercible$9;
var speciesConstructor = speciesConstructor$1;
var advanceStringIndex$1 = advanceStringIndex$2;
var toLength$2 = toLength$4;
var toString$7 = toString$b;
var getMethod$3 = getMethod$5;
var arraySlice$1 = arraySliceSimple;
var callRegExpExec = regexpExecAbstract;
var regexpExec = regexpExec$3;
var stickyHelpers = regexpStickyHelpers;
var fails$7 = fails$o;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 4294967295;
var min$1 = Math.min;
var $push = [].push;
var exec$1 = uncurryThis$7(/./.exec);
var push$2 = uncurryThis$7($push);
var stringSlice$2 = uncurryThis$7("".slice);
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$7(function() {
  var re4 = /(?:)/;
  var originalExec = re4.exec;
  re4.exec = function() {
    return originalExec.apply(this, arguments);
  };
  var result = "ab".split(re4);
  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
});
fixRegExpWellKnownSymbolLogic$2("split", function(SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
    internalSplit = function(separator, limit) {
      var string3 = toString$7(requireObjectCoercible$5(this));
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (separator === void 0)
        return [string3];
      if (!isRegExp$1(separator)) {
        return call$5(nativeSplit, string3, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
      var lastLastIndex = 0;
      var separatorCopy = new RegExp(separator.source, flags + "g");
      var match2, lastIndex, lastLength;
      while (match2 = call$5(regexpExec, separatorCopy, string3)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push$2(output, stringSlice$2(string3, lastLastIndex, match2.index));
          if (match2.length > 1 && match2.index < string3.length)
            apply($push, output, arraySlice$1(match2, 1));
          lastLength = match2[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim)
            break;
        }
        if (separatorCopy.lastIndex === match2.index)
          separatorCopy.lastIndex++;
      }
      if (lastLastIndex === string3.length) {
        if (lastLength || !exec$1(separatorCopy, ""))
          push$2(output, "");
      } else
        push$2(output, stringSlice$2(string3, lastLastIndex));
      return output.length > lim ? arraySlice$1(output, 0, lim) : output;
    };
  } else if ("0".split(void 0, 0).length) {
    internalSplit = function(separator, limit) {
      return separator === void 0 && limit === 0 ? [] : call$5(nativeSplit, this, separator, limit);
    };
  } else
    internalSplit = nativeSplit;
  return [
    function split2(separator, limit) {
      var O5 = requireObjectCoercible$5(this);
      var splitter = isNullOrUndefined$3(separator) ? void 0 : getMethod$3(separator, SPLIT);
      return splitter ? call$5(splitter, separator, O5, limit) : call$5(internalSplit, toString$7(O5), separator, limit);
    },
    function(string3, limit) {
      var rx = anObject$5(this);
      var S4 = toString$7(string3);
      var res = maybeCallNative(internalSplit, rx, S4, limit, internalSplit !== nativeSplit);
      if (res.done)
        return res.value;
      var C4 = speciesConstructor(rx, RegExp);
      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
      var splitter = new C4(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
      if (lim === 0)
        return [];
      if (S4.length === 0)
        return callRegExpExec(splitter, S4) === null ? [S4] : [];
      var p6 = 0;
      var q4 = 0;
      var A2 = [];
      while (q4 < S4.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q4;
        var z3 = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice$2(S4, q4) : S4);
        var e2;
        if (z3 === null || (e2 = min$1(toLength$2(splitter.lastIndex + (UNSUPPORTED_Y ? q4 : 0)), S4.length)) === p6) {
          q4 = advanceStringIndex$1(S4, q4, unicodeMatching);
        } else {
          push$2(A2, stringSlice$2(S4, p6, q4));
          if (A2.length === lim)
            return A2;
          for (var i3 = 1; i3 <= z3.length - 1; i3++) {
            push$2(A2, z3[i3]);
            if (A2.length === lim)
              return A2;
          }
          q4 = p6 = e2;
        }
      }
      push$2(A2, stringSlice$2(S4, p6));
      return A2;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
var whitespaces$3 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
var uncurryThis$6 = functionUncurryThis;
var requireObjectCoercible$4 = requireObjectCoercible$9;
var toString$6 = toString$b;
var whitespaces$2 = whitespaces$3;
var replace$1 = uncurryThis$6("".replace);
var ltrim = RegExp("^[" + whitespaces$2 + "]+");
var rtrim = RegExp("(^|[^" + whitespaces$2 + "])[" + whitespaces$2 + "]+$");
var createMethod$1 = function(TYPE) {
  return function($this) {
    var string3 = toString$6(requireObjectCoercible$4($this));
    if (TYPE & 1)
      string3 = replace$1(string3, ltrim, "");
    if (TYPE & 2)
      string3 = replace$1(string3, rtrim, "$1");
    return string3;
  };
};
var stringTrim = {
  start: createMethod$1(1),
  end: createMethod$1(2),
  trim: createMethod$1(3)
};
var PROPER_FUNCTION_NAME$1 = functionName.PROPER;
var fails$6 = fails$o;
var whitespaces$1 = whitespaces$3;
var non = "\u200B\x85\u180E";
var stringTrimForced = function(METHOD_NAME) {
  return fails$6(function() {
    return !!whitespaces$1[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME$1 && whitespaces$1[METHOD_NAME].name !== METHOD_NAME;
  });
};
var $$8 = _export;
var $trim = stringTrim.trim;
var forcedStringTrimMethod = stringTrimForced;
$$8({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
  trim: function trim() {
    return $trim(this);
  }
});
var aCallable$4 = aCallable$7;
var toObject$2 = toObject$6;
var IndexedObject = indexedObject;
var lengthOfArrayLike$3 = lengthOfArrayLike$6;
var $TypeError$6 = TypeError;
var createMethod = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable$4(callbackfn);
    var O5 = toObject$2(that);
    var self2 = IndexedObject(O5);
    var length = lengthOfArrayLike$3(O5);
    var index2 = IS_RIGHT ? length - 1 : 0;
    var i3 = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index2 in self2) {
          memo = self2[index2];
          index2 += i3;
          break;
        }
        index2 += i3;
        if (IS_RIGHT ? index2 < 0 : length <= index2) {
          throw $TypeError$6("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i3)
      if (index2 in self2) {
        memo = callbackfn(memo, self2[index2], index2, O5);
      }
    return memo;
  };
};
var arrayReduce = {
  left: createMethod(false),
  right: createMethod(true)
};
var fails$5 = fails$o;
var arrayMethodIsStrict$2 = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails$5(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var classof$3 = classofRaw$2;
var engineIsNode = typeof process != "undefined" && classof$3(process) == "process";
var $$7 = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict$1 = arrayMethodIsStrict$2;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED$2 = CHROME_BUG || !arrayMethodIsStrict$1("reduce");
$$7({ target: "Array", proto: true, forced: FORCED$2 }, {
  reduce: function reduce(callbackfn) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
  }
});
var call$4 = functionCall;
var hasOwn$1 = hasOwnProperty_1;
var isPrototypeOf$1 = objectIsPrototypeOf;
var regExpFlags = regexpFlags$1;
var RegExpPrototype$1 = RegExp.prototype;
var regexpGetFlags = function(R6) {
  var flags = R6.flags;
  return flags === void 0 && !("flags" in RegExpPrototype$1) && !hasOwn$1(R6, "flags") && isPrototypeOf$1(RegExpPrototype$1, R6) ? call$4(regExpFlags, R6) : flags;
};
var PROPER_FUNCTION_NAME = functionName.PROPER;
var defineBuiltIn$2 = defineBuiltIn$7;
var anObject$4 = anObject$e;
var $toString$1 = toString$b;
var fails$4 = fails$o;
var getRegExpFlags = regexpGetFlags;
var TO_STRING = "toString";
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];
var NOT_GENERIC = fails$4(function() {
  return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
});
var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name != TO_STRING;
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn$2(RegExp.prototype, TO_STRING, function toString7() {
    var R6 = anObject$4(this);
    var pattern = $toString$1(R6.source);
    var flags = $toString$1(getRegExpFlags(R6));
    return "/" + pattern + "/" + flags;
  }, { unsafe: true });
}
var tryToString$1 = tryToString$4;
var $TypeError$5 = TypeError;
var deletePropertyOrThrow$1 = function(O5, P4) {
  if (!delete O5[P4])
    throw $TypeError$5("Cannot delete property " + tryToString$1(P4) + " of " + tryToString$1(O5));
};
var arraySlice = arraySliceSimple;
var floor = Math.floor;
var mergeSort = function(array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge2(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};
var insertionSort = function(array, comparefn) {
  var length = array.length;
  var i3 = 1;
  var element2, j5;
  while (i3 < length) {
    j5 = i3;
    element2 = array[i3];
    while (j5 && comparefn(array[j5 - 1], element2) > 0) {
      array[j5] = array[--j5];
    }
    if (j5 !== i3++)
      array[j5] = element2;
  }
  return array;
};
var merge2 = function(array, left2, right2, comparefn) {
  var llength = left2.length;
  var rlength = right2.length;
  var lindex = 0;
  var rindex = 0;
  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left2[lindex], right2[rindex]) <= 0 ? left2[lindex++] : right2[rindex++] : lindex < llength ? left2[lindex++] : right2[rindex++];
  }
  return array;
};
var arraySort$1 = mergeSort;
var userAgent$1 = engineUserAgent;
var firefox = userAgent$1.match(/firefox\/(\d+)/i);
var engineFfVersion = !!firefox && +firefox[1];
var UA = engineUserAgent;
var engineIsIeOrEdge = /MSIE|Trident/.test(UA);
var userAgent = engineUserAgent;
var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
var engineWebkitVersion = !!webkit && +webkit[1];
var $$6 = _export;
var uncurryThis$5 = functionUncurryThis;
var aCallable$3 = aCallable$7;
var toObject$1 = toObject$6;
var lengthOfArrayLike$2 = lengthOfArrayLike$6;
var deletePropertyOrThrow = deletePropertyOrThrow$1;
var toString$5 = toString$b;
var fails$3 = fails$o;
var internalSort = arraySort$1;
var arrayMethodIsStrict = arrayMethodIsStrict$2;
var FF = engineFfVersion;
var IE_OR_EDGE = engineIsIeOrEdge;
var V8 = engineV8Version;
var WEBKIT = engineWebkitVersion;
var test = [];
var nativeSort = uncurryThis$5(test.sort);
var push$1 = uncurryThis$5(test.push);
var FAILS_ON_UNDEFINED = fails$3(function() {
  test.sort(void 0);
});
var FAILS_ON_NULL = fails$3(function() {
  test.sort(null);
});
var STRICT_METHOD = arrayMethodIsStrict("sort");
var STABLE_SORT = !fails$3(function() {
  if (V8)
    return V8 < 70;
  if (FF && FF > 3)
    return;
  if (IE_OR_EDGE)
    return true;
  if (WEBKIT)
    return WEBKIT < 603;
  var result = "";
  var code2, chr, value, index2;
  for (code2 = 65; code2 < 76; code2++) {
    chr = String.fromCharCode(code2);
    switch (code2) {
      case 66:
      case 69:
      case 70:
      case 72:
        value = 3;
        break;
      case 68:
      case 71:
        value = 4;
        break;
      default:
        value = 2;
    }
    for (index2 = 0; index2 < 47; index2++) {
      test.push({ k: chr + index2, v: value });
    }
  }
  test.sort(function(a2, b4) {
    return b4.v - a2.v;
  });
  for (index2 = 0; index2 < test.length; index2++) {
    chr = test[index2].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr)
      result += chr;
  }
  return result !== "DGBEFHACIJK";
});
var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
var getSortCompare = function(comparefn) {
  return function(x6, y4) {
    if (y4 === void 0)
      return -1;
    if (x6 === void 0)
      return 1;
    if (comparefn !== void 0)
      return +comparefn(x6, y4) || 0;
    return toString$5(x6) > toString$5(y4) ? 1 : -1;
  };
};
$$6({ target: "Array", proto: true, forced: FORCED$1 }, {
  sort: function sort(comparefn) {
    if (comparefn !== void 0)
      aCallable$3(comparefn);
    var array = toObject$1(this);
    if (STABLE_SORT)
      return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
    var items = [];
    var arrayLength = lengthOfArrayLike$2(array);
    var itemsLength, index2;
    for (index2 = 0; index2 < arrayLength; index2++) {
      if (index2 in array)
        push$1(items, array[index2]);
    }
    internalSort(items, getSortCompare(comparefn));
    itemsLength = lengthOfArrayLike$2(items);
    index2 = 0;
    while (index2 < itemsLength)
      array[index2] = items[index2++];
    while (index2 < arrayLength)
      deletePropertyOrThrow(array, index2++);
    return array;
  }
});
var global$2 = global$i;
var fails$2 = fails$o;
var uncurryThis$4 = functionUncurryThis;
var toString$4 = toString$b;
var trim2 = stringTrim.trim;
var whitespaces = whitespaces$3;
var $parseInt$1 = global$2.parseInt;
var Symbol$1 = global$2.Symbol;
var ITERATOR$3 = Symbol$1 && Symbol$1.iterator;
var hex = /^[+-]?0x/i;
var exec = uncurryThis$4(hex.exec);
var FORCED = $parseInt$1(whitespaces + "08") !== 8 || $parseInt$1(whitespaces + "0x16") !== 22 || ITERATOR$3 && !fails$2(function() {
  $parseInt$1(Object(ITERATOR$3));
});
var numberParseInt = FORCED ? function parseInt2(string3, radix) {
  var S4 = trim2(toString$4(string3));
  return $parseInt$1(S4, radix >>> 0 || (exec(hex, S4) ? 16 : 10));
} : $parseInt$1;
var $$5 = _export;
var $parseInt = numberParseInt;
$$5({ global: true, forced: parseInt != $parseInt }, {
  parseInt: $parseInt
});
function __rest(s, e2) {
  var t2 = {};
  for (var p6 in s)
    if (Object.prototype.hasOwnProperty.call(s, p6) && e2.indexOf(p6) < 0)
      t2[p6] = s[p6];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p6 = Object.getOwnPropertySymbols(s); i3 < p6.length; i3++) {
      if (e2.indexOf(p6[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p6[i3]))
        t2[p6[i3]] = s[p6[i3]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var VAL_MSG = {
  formattingError: "Incorrect formatting. Check formatting rules in tooltip above.",
  AMOUNT_ERR: "Amounts are required and must be a number. Check formatting rules in tooltip above.",
  ADDRESS_ERR: "Recipient addresses are required and must be valid Ethereum addresses. Check formatting rules in tooltip above."
};
var validateAddressesAndAmountsData = (disperseData) => {
  if (disperseData === "")
    return true;
  const {
    recipients,
    values: values4
  } = disperseData;
  if (!(0, import_utils12.isArray)(recipients) || !(0, import_utils12.isArray)(values4))
    return VAL_MSG.formattingError;
  if (!recipients.every((address) => isAddress(address)))
    return VAL_MSG.ADDRESS_ERR;
  if (!values4.every((address) => (0, import_utils12.isNumberString)(address)))
    return VAL_MSG.AMOUNT_ERR;
  return true;
};
var transformAddressesAndAmountsData = (response) => {
  if (!(0, import_utils12.isString)(response) || response === "")
    return "";
  const recipientEntities = response.split(/[\n|,]/).map((str) => str.trim()).filter(Boolean);
  const accEntites = recipientEntities.reduce((acc, member) => {
    const splitString = member.trim().split(" ");
    const newRecipientAddress = splitString[0];
    const newAmount = splitString[1];
    const newAmountsWei = (0, import_utils12.isNumberish)(newAmount) ? (0, import_utils12.toBaseUnits)(newAmount) : newAmount;
    return {
      recipients: [...acc.recipients, newRecipientAddress],
      values: [...acc.values, newAmountsWei],
      total: (0, import_utils12.isNumberish)(newAmountsWei) ? acc.total + BigInt(newAmountsWei) : acc.total
    };
  }, {
    recipients: [],
    values: [],
    total: BigInt(0)
  });
  return Object.assign(Object.assign({}, accEntites), {
    total: accEntites.total.toString()
  });
};
var sortTokensForRageQuit = (tokens) => {
  return tokens.sort((a2, b4) => {
    return parseInt(a2.slice(2), 16) - parseInt(b4.slice(2), 16);
  });
};
var isNetworkToken = (tokenData) => {
  return !tokenData.token;
};
var getErc20s = (treasury) => {
  return treasury.tokenBalances.reduce((acc, tokenData) => {
    var _a, _b, _c;
    if (!isNetworkToken(tokenData)) {
      return [...acc, {
        daoBalance: tokenData.balance,
        decimals: ((_a = tokenData.token) === null || _a === void 0 ? void 0 : _a.decimals) || 18,
        address: tokenData.tokenAddress || "Error: Data Missing",
        name: ((_b = tokenData.token) === null || _b === void 0 ? void 0 : _b.name) || "Error: Data Missing",
        symbol: ((_c = tokenData.token) === null || _c === void 0 ? void 0 : _c.symbol) || "Error: Data Missing"
      }];
    }
    return acc;
  }, []);
};
var getNetworkToken = (daoData, daochain, safeAddress, networks = import_keychain_utils.HAUS_NETWORK_DATA) => {
  const networkData = networks[daochain];
  const treasury = daoData.vaults.find((v) => {
    if (!safeAddress)
      return v.safeAddress === daoData.safeAddress;
    return v.safeAddress === safeAddress;
  });
  const networkToken = treasury && treasury.tokenBalances.find(isNetworkToken);
  if (networkToken && networkData) {
    return {
      daoBalance: networkToken.balance,
      decimals: networkData.tokenDecimals,
      symbol: networkData.symbol,
      name: daochain === "0x1" ? "ETH" : `${networkData.symbol} on ${networkData.name}`
    };
  }
  return null;
};
var isActiveMember = ({
  daoid,
  daochain,
  address,
  setMemberLoading
}) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b, _c, _d, _e5, _f;
  try {
    setMemberLoading(true);
    const memberRes = yield (0, import_moloch_v3_data.findMember)({
      networkId: daochain,
      dao: daoid,
      memberAddress: address.toLowerCase(),
      graphApiKeys: {
        "0x1": process.env["NX_GRAPH_API_KEY_MAINNET"]
      }
    });
    if (((_a = memberRes === null || memberRes === void 0 ? void 0 : memberRes.data) === null || _a === void 0 ? void 0 : _a.member) && Number((_c = (_b = memberRes === null || memberRes === void 0 ? void 0 : memberRes.data) === null || _b === void 0 ? void 0 : _b.member) === null || _c === void 0 ? void 0 : _c.shares) > 0) {
      return {
        member: memberRes.data.member
      };
    }
    if (((_d = memberRes === null || memberRes === void 0 ? void 0 : memberRes.data) === null || _d === void 0 ? void 0 : _d.member) && Number((_f = (_e5 = memberRes === null || memberRes === void 0 ? void 0 : memberRes.data) === null || _e5 === void 0 ? void 0 : _e5.member) === null || _f === void 0 ? void 0 : _f.loot) > 0) {
      return {
        member: memberRes.data.member,
        error: {
          type: "error",
          message: `Member doesn't own any shares`
        }
      };
    }
    return {
      error: {
        type: "error",
        message: `Member not found`
      }
    };
  } catch (error) {
    console.error(error);
    return {
      error: {
        type: "error",
        message: `${error}`
      }
    };
  } finally {
    setMemberLoading(false);
  }
});
var AddressesAndAmounts = (props) => {
  const {
    watch
  } = useFormContext();
  const multipleSharesField = watch("addressesAndAmounts");
  const validFieldMsg = (0, import_react3.useMemo)(() => {
    if (multipleSharesField === "" || !multipleSharesField) {
      return void 0;
    }
    if (validateAddressesAndAmountsData(multipleSharesField)) {
      return "Formatting is valid.";
    }
    return void 0;
  }, [multipleSharesField]);
  const newRules = Object.assign(Object.assign({}, props.rules), {
    setValueAs: transformAddressesAndAmountsData,
    validate: validateAddressesAndAmountsData
  });
  return (0, import_jsx_runtime2.jsx)(WrappedTextArea, Object.assign({}, props, {
    label: "Addresses & Amounts",
    placeholder: "0x00000000000000000000000000 1",
    rules: newRules,
    helperText: validFieldMsg
  }));
};
var _$6 = (t2) => t2;
var _t$6;
var RemoveDelegate = st(ParSm)(_t$6 || (_t$6 = _$6`
  margin-top: 3rem;
  &:hover {
    cursor: pointer;
    color: ${0};
  }
`), ({
  theme
}) => theme.primary.step10);
var DelegateInput = (props) => {
  const {
    connectedMember
  } = useConnectedMember();
  const {
    dao
  } = useDaoData();
  const {
    setValue
  } = useFormContext();
  const hasCurrentDelegate = (connectedMember === null || connectedMember === void 0 ? void 0 : connectedMember.delegatingTo) !== (connectedMember === null || connectedMember === void 0 ? void 0 : connectedMember.memberAddress);
  const handleRemoveDelegate = () => {
    setValue(props.id, connectedMember === null || connectedMember === void 0 ? void 0 : connectedMember.memberAddress);
  };
  const votingPowerMessage = `${(0, import_utils12.formatValueTo)({
    value: (0, import_utils12.fromWei)((connectedMember === null || connectedMember === void 0 ? void 0 : connectedMember.shares) || "0"),
    decimals: 2,
    format: "number"
  })} ${dao === null || dao === void 0 ? void 0 : dao.shareTokenName} (${(0, import_utils12.votingPowerPercentage)((dao === null || dao === void 0 ? void 0 : dao.totalShares) || "0", (connectedMember === null || connectedMember === void 0 ? void 0 : connectedMember.shares) || "0")}% voting power) `;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(WrappedInput, Object.assign({}, props)), (0, import_jsx_runtime2.jsx)(ParMd, {
      children: "Voting token to delegate"
    }), (0, import_jsx_runtime2.jsx)(DataMd, {
      children: votingPowerMessage
    }), hasCurrentDelegate && (0, import_jsx_runtime2.jsxs)(RemoveDelegate, Object.assign({
      onClick: handleRemoveDelegate
    }, {
      children: ["Remove Existing Delegate", (0, import_jsx_runtime2.jsx)(Tooltip, {
        content: "Will reset the delegate address to your own. Then you can submit the transaction to update."
      })]
    }))]
  });
};
var _$5 = (t2) => t2;
var _t$5;
var _t2$4;
var _t3$3;
var _t4$2;
var _t5$1;
var _t6$1;
var _t7$1;
var TabsContainer = st.div(_t$5 || (_t$5 = _$5`
  display: flex;
  flex-direction: row;
  justify-content: right;
  margin-bottom: -2rem;
`));
var MarkDownContainer = st.div(_t2$4 || (_t2$4 = _$5`
  min-height: 12rem;
  max-height: 12rem;
  overflow-y: scroll;
  padding: 10px;
  margin-bottom: 5rem;
  border-radius: 5px;
  background-color: hsl(228, 43.3%, 17.5%);
  font-size: 1.5rem;
  font-family: inherit;
`));
var DialogMarkDownContainer = st.div(_t3$3 || (_t3$3 = _$5`
  height: 50rem;
  overflow-y: scroll;
  padding: 10px;
  margin-bottom: 5rem;
  border-radius: 5px;
  background-color: hsl(228, 43.3%, 17.5%);
  font-size: 1.5rem;
  font-family: inherit;
`));
var LabelContainer = st(Label$2)(_t4$2 || (_t4$2 = _$5`
  display: flex;
  align-items: center;
  margin-bottom: 12px;
  label {
    margin-right: 10px;
    margin-left: 10px;
  }
  svg {
    transform: translateY(0.1rem);
  }
`));
var DialogWrappedTextArea = st(WrappedTextArea)(_t5$1 || (_t5$1 = _$5`
  height: 50rem;
  overflow-y: scroll;
  padding: 10px;
  margin-bottom: 5rem;
  border-radius: 5px;
  font-size: 1.5rem;
  font-family: inherit;
`));
var DialogButtonWrapper = st.div(_t6$1 || (_t6$1 = _$5`
  display: flex;
  flex-direction: row;
  justify-content: right;
  margin-bottom: -2rem;
`));
var ContentWrapper = st(Card)(_t7$1 || (_t7$1 = _$5`
  border: none;
  min-width: 50vw;
  max-width: 90vw;
`));
var MarkdownField = (props) => {
  const {
    watch
  } = useFormContext();
  const value = watch(props.id);
  const [edit, setEdit] = (0, import_react3.useState)(true);
  const [toggleFullscreen, setToggleFullscreen] = (0, import_react3.useState)(false);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsxs)(TabsContainer, {
      children: [(0, import_jsx_runtime2.jsx)(Button, Object.assign({
        color: "secondary",
        variant: !edit ? "outline" : "solid",
        onClick: () => setEdit(true),
        size: "sm"
      }, {
        children: (0, import_jsx_runtime2.jsx)(BiPencil, {})
      })), (0, import_jsx_runtime2.jsx)(Button, Object.assign({
        color: "secondary",
        variant: edit ? "outline" : "solid",
        onClick: () => setEdit(false),
        size: "sm"
      }, {
        children: (0, import_jsx_runtime2.jsx)(MdPreview, {})
      })), (0, import_jsx_runtime2.jsxs)(Dialog, Object.assign({
        open: toggleFullscreen,
        onOpenChange: setToggleFullscreen
      }, {
        children: [(0, import_jsx_runtime2.jsx)(DialogTrigger, Object.assign({
          asChild: true
        }, {
          children: (0, import_jsx_runtime2.jsx)(Button, Object.assign({
            color: "secondary",
            variant: toggleFullscreen ? "outline" : "solid",
            size: "sm"
          }, {
            children: toggleFullscreen ? (0, import_jsx_runtime2.jsx)(MdFullscreen, {}) : (0, import_jsx_runtime2.jsx)(MdFullscreenExit, {})
          }))
        })), (0, import_jsx_runtime2.jsxs)(DialogContent, Object.assign({
          title: "Markdown Editor"
        }, {
          children: [(0, import_jsx_runtime2.jsxs)(DialogButtonWrapper, {
            children: [(0, import_jsx_runtime2.jsx)(Button, Object.assign({
              color: "secondary",
              variant: !edit ? "outline" : "solid",
              onClick: () => setEdit(true),
              size: "sm"
            }, {
              children: (0, import_jsx_runtime2.jsx)(BiPencil, {})
            })), (0, import_jsx_runtime2.jsx)(Button, Object.assign({
              color: "secondary",
              variant: edit ? "outline" : "solid",
              onClick: () => setEdit(false),
              size: "sm"
            }, {
              children: (0, import_jsx_runtime2.jsx)(MdPreview, {})
            }))]
          }), (0, import_jsx_runtime2.jsx)(ContentWrapper, {
            children: edit ? (0, import_jsx_runtime2.jsx)(DialogWrappedTextArea, Object.assign({}, props)) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
              children: [(0, import_jsx_runtime2.jsx)(LabelContainer, {
                children: (0, import_jsx_runtime2.jsx)(Label$2, {
                  children: "Preview"
                })
              }), (0, import_jsx_runtime2.jsx)(DialogMarkDownContainer, {
                children: (0, import_jsx_runtime2.jsx)(Markdown, {
                  children: value
                })
              })]
            })
          })]
        }))]
      }))]
    }), edit && !toggleFullscreen ? (0, import_jsx_runtime2.jsx)(WrappedTextArea, Object.assign({}, props)) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
      children: [(0, import_jsx_runtime2.jsx)(LabelContainer, {
        children: (0, import_jsx_runtime2.jsx)(Label$2, {
          children: "Preview"
        })
      }), (0, import_jsx_runtime2.jsx)(MarkDownContainer, {
        children: (0, import_jsx_runtime2.jsx)(Markdown, {
          children: value
        })
      })]
    })]
  });
};
var presetLabels = {
  github: true,
  web: true,
  discord: true,
  twitter: true,
  telegram: true,
  blog: true
};
var MetadataLink = (props) => {
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [!presetLabels[props.id] && (0, import_jsx_runtime2.jsx)(WrappedInput, {
      disabled: props.disabled,
      id: `${props.id}Label`,
      label: `${props.label} Label`
    }), (0, import_jsx_runtime2.jsx)(WrappedInput, Object.assign({}, props))]
  });
};
var $$4 = _export;
var $includes = arrayIncludes.includes;
var fails$1 = fails$o;
var addToUnscopables$1 = addToUnscopables$3;
var BROKEN_ON_SPARSE = fails$1(function() {
  return !Array(1).includes();
});
$$4({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
  }
});
addToUnscopables$1("includes");
var isRegExp = isRegexp;
var $TypeError$4 = TypeError;
var notARegexp = function(it5) {
  if (isRegExp(it5)) {
    throw $TypeError$4("The method doesn't accept regular expressions");
  }
  return it5;
};
var wellKnownSymbol$4 = wellKnownSymbol$g;
var MATCH = wellKnownSymbol$4("match");
var correctIsRegexpLogic = function(METHOD_NAME) {
  var regexp = /./;
  try {
    "/./"[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return "/./"[METHOD_NAME](regexp);
    } catch (error2) {
    }
  }
  return false;
};
var $$3 = _export;
var uncurryThis$3 = functionUncurryThis;
var notARegExp$1 = notARegexp;
var requireObjectCoercible$3 = requireObjectCoercible$9;
var toString$3 = toString$b;
var correctIsRegExpLogic$1 = correctIsRegexpLogic;
var stringIndexOf = uncurryThis$3("".indexOf);
$$3({ target: "String", proto: true, forced: !correctIsRegExpLogic$1("includes") }, {
  includes: function includes2(searchString) {
    return !!~stringIndexOf(
      toString$3(requireObjectCoercible$3(this)),
      toString$3(notARegExp$1(searchString)),
      arguments.length > 1 ? arguments[1] : void 0
    );
  }
});
var call$3 = functionCall;
var fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
var anObject$3 = anObject$e;
var isNullOrUndefined$2 = isNullOrUndefined$7;
var toLength$1 = toLength$4;
var toString$2 = toString$b;
var requireObjectCoercible$2 = requireObjectCoercible$9;
var getMethod$2 = getMethod$5;
var advanceStringIndex = advanceStringIndex$2;
var regExpExec$1 = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic$1("match", function(MATCH2, nativeMatch, maybeCallNative) {
  return [
    function match2(regexp) {
      var O5 = requireObjectCoercible$2(this);
      var matcher = isNullOrUndefined$2(regexp) ? void 0 : getMethod$2(regexp, MATCH2);
      return matcher ? call$3(matcher, regexp, O5) : new RegExp(regexp)[MATCH2](toString$2(O5));
    },
    function(string3) {
      var rx = anObject$3(this);
      var S4 = toString$2(string3);
      var res = maybeCallNative(nativeMatch, rx, S4);
      if (res.done)
        return res.value;
      if (!rx.global)
        return regExpExec$1(rx, S4);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A2 = [];
      var n2 = 0;
      var result;
      while ((result = regExpExec$1(rx, S4)) !== null) {
        var matchStr = toString$2(result[0]);
        A2[n2] = matchStr;
        if (matchStr === "")
          rx.lastIndex = advanceStringIndex(S4, toLength$1(rx.lastIndex), fullUnicode);
        n2++;
      }
      return n2 === 0 ? null : A2;
    }
  ];
});
var classof$2 = classofRaw$2;
var isArray$2 = Array.isArray || function isArray(argument) {
  return classof$2(argument) == "Array";
};
var $TypeError$3 = TypeError;
var MAX_SAFE_INTEGER = 9007199254740991;
var doesNotExceedSafeInteger$1 = function(it5) {
  if (it5 > MAX_SAFE_INTEGER)
    throw $TypeError$3("Maximum allowed index exceeded");
  return it5;
};
var uncurryThis$2 = functionUncurryThisClause;
var aCallable$2 = aCallable$7;
var NATIVE_BIND = functionBindNative;
var bind$2 = uncurryThis$2(uncurryThis$2.bind);
var functionBindContext = function(fn3, that) {
  aCallable$2(fn3);
  return that === void 0 ? fn3 : NATIVE_BIND ? bind$2(fn3, that) : function() {
    return fn3.apply(that, arguments);
  };
};
var isArray$1 = isArray$2;
var lengthOfArrayLike$1 = lengthOfArrayLike$6;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;
var bind$1 = functionBindContext;
var flattenIntoArray$1 = function(target, original, source, sourceLen, start2, depth, mapper, thisArg) {
  var targetIndex = start2;
  var sourceIndex = 0;
  var mapFn = mapper ? bind$1(mapper, thisArg) : false;
  var element2, elementLen;
  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element2 = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      if (depth > 0 && isArray$1(element2)) {
        elementLen = lengthOfArrayLike$1(element2);
        targetIndex = flattenIntoArray$1(target, original, element2, elementLen, targetIndex, depth - 1) - 1;
      } else {
        doesNotExceedSafeInteger(targetIndex + 1);
        target[targetIndex] = element2;
      }
      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};
var flattenIntoArray_1 = flattenIntoArray$1;
var isArray2 = isArray$2;
var isConstructor3 = isConstructor$2;
var isObject$1 = isObject$9;
var wellKnownSymbol$3 = wellKnownSymbol$g;
var SPECIES = wellKnownSymbol$3("species");
var $Array = Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C4;
  if (isArray2(originalArray)) {
    C4 = originalArray.constructor;
    if (isConstructor3(C4) && (C4 === $Array || isArray2(C4.prototype)))
      C4 = void 0;
    else if (isObject$1(C4)) {
      C4 = C4[SPECIES];
      if (C4 === null)
        C4 = void 0;
    }
  }
  return C4 === void 0 ? $Array : C4;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$1 = function(originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};
var $$2 = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable$1 = aCallable$7;
var toObject = toObject$6;
var lengthOfArrayLike = lengthOfArrayLike$6;
var arraySpeciesCreate = arraySpeciesCreate$1;
$$2({ target: "Array", proto: true }, {
  flatMap: function flatMap(callbackfn) {
    var O5 = toObject(this);
    var sourceLen = lengthOfArrayLike(O5);
    var A2;
    aCallable$1(callbackfn);
    A2 = arraySpeciesCreate(O5, 0);
    A2.length = flattenIntoArray(A2, O5, O5, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return A2;
  }
});
var addToUnscopables = addToUnscopables$3;
addToUnscopables("flatMap");
var fails = fails$o;
var wellKnownSymbol$2 = wellKnownSymbol$g;
var DESCRIPTORS$1 = descriptors;
var IS_PURE = isPure;
var ITERATOR$2 = wellKnownSymbol$2("iterator");
var urlConstructorDetection = !fails(function() {
  var url = new URL("b?a=1&b=2&c=3", "http://a");
  var params = url.searchParams;
  var params2 = new URLSearchParams("a=1&a=2&b=3");
  var result = "";
  url.pathname = "c%20d";
  params.forEach(function(value, key) {
    params["delete"]("b");
    result += key + value;
  });
  params2["delete"]("a", 2);
  params2["delete"]("b", void 0);
  return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS$1) || !params.sort || url.href !== "http://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR$2] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
});
var defineBuiltIn$1 = defineBuiltIn$7;
var defineBuiltIns$1 = function(target, src, options) {
  for (var key in src)
    defineBuiltIn$1(target, key, src[key], options);
  return target;
};
var isPrototypeOf = objectIsPrototypeOf;
var $TypeError$2 = TypeError;
var anInstance$1 = function(it5, Prototype) {
  if (isPrototypeOf(Prototype, it5))
    return it5;
  throw $TypeError$2("Incorrect invocation");
};
var classof$1 = classof$8;
var getMethod$1 = getMethod$5;
var isNullOrUndefined$1 = isNullOrUndefined$7;
var Iterators = iterators;
var wellKnownSymbol$1 = wellKnownSymbol$g;
var ITERATOR$1 = wellKnownSymbol$1("iterator");
var getIteratorMethod$2 = function(it5) {
  if (!isNullOrUndefined$1(it5))
    return getMethod$1(it5, ITERATOR$1) || getMethod$1(it5, "@@iterator") || Iterators[classof$1(it5)];
};
var call$2 = functionCall;
var aCallable = aCallable$7;
var anObject$2 = anObject$e;
var tryToString = tryToString$4;
var getIteratorMethod$1 = getIteratorMethod$2;
var $TypeError$1 = TypeError;
var getIterator$1 = function(argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
  if (aCallable(iteratorMethod))
    return anObject$2(call$2(iteratorMethod, argument));
  throw $TypeError$1(tryToString(argument) + " is not iterable");
};
var $TypeError = TypeError;
var validateArgumentsLength$1 = function(passed, required) {
  if (passed < required)
    throw $TypeError("Not enough arguments");
  return passed;
};
var $$1 = _export;
var global$1 = global$i;
var call$1 = functionCall;
var uncurryThis$1 = functionUncurryThis;
var DESCRIPTORS = descriptors;
var USE_NATIVE_URL = urlConstructorDetection;
var defineBuiltIn = defineBuiltIn$7;
var defineBuiltInAccessor = defineBuiltInAccessor$2;
var defineBuiltIns = defineBuiltIns$1;
var setToStringTag = setToStringTag$3;
var createIteratorConstructor = iteratorCreateConstructor;
var InternalStateModule = internalState;
var anInstance = anInstance$1;
var isCallable = isCallable$j;
var hasOwn2 = hasOwnProperty_1;
var bind = functionBindContext;
var classof = classof$8;
var anObject$1 = anObject$e;
var isObject = isObject$9;
var $toString = toString$b;
var create3 = objectCreate;
var createPropertyDescriptor = createPropertyDescriptor$5;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$2;
var validateArgumentsLength = validateArgumentsLength$1;
var wellKnownSymbol = wellKnownSymbol$g;
var arraySort = arraySort$1;
var ITERATOR = wellKnownSymbol("iterator");
var URL_SEARCH_PARAMS = "URLSearchParams";
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var safeGetBuiltIn = function(name) {
  if (!DESCRIPTORS)
    return global$1[name];
  var descriptor = getOwnPropertyDescriptor$1(global$1, name);
  return descriptor && descriptor.value;
};
var nativeFetch = safeGetBuiltIn("fetch");
var NativeRequest = safeGetBuiltIn("Request");
var Headers2 = safeGetBuiltIn("Headers");
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers2 && Headers2.prototype;
var RegExp$1 = global$1.RegExp;
var TypeError$1 = global$1.TypeError;
var decodeURIComponent2 = global$1.decodeURIComponent;
var encodeURIComponent2 = global$1.encodeURIComponent;
var charAt = uncurryThis$1("".charAt);
var join2 = uncurryThis$1([].join);
var push2 = uncurryThis$1([].push);
var replace = uncurryThis$1("".replace);
var shift = uncurryThis$1([].shift);
var splice2 = uncurryThis$1([].splice);
var split = uncurryThis$1("".split);
var stringSlice$1 = uncurryThis$1("".slice);
var plus = /\+/g;
var sequences = Array(4);
var percentSequence = function(bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp$1("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
};
var percentDecode = function(sequence) {
  try {
    return decodeURIComponent2(sequence);
  } catch (error) {
    return sequence;
  }
};
var deserialize2 = function(it5) {
  var result = replace(it5, plus, " ");
  var bytes = 4;
  try {
    return decodeURIComponent2(result);
  } catch (error) {
    while (bytes) {
      result = replace(result, percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};
var find2 = /[!'()~]|%20/g;
var replacements = {
  "!": "%21",
  "'": "%27",
  "(": "%28",
  ")": "%29",
  "~": "%7E",
  "%20": "+"
};
var replacer = function(match2) {
  return replacements[match2];
};
var serialize2 = function(it5) {
  return replace(encodeURIComponent2(it5), find2, replacer);
};
var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind
  });
}, "Iterator", function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
  }
  return step;
}, true);
var URLSearchParamsState = function(init) {
  this.entries = [];
  this.url = null;
  if (init !== void 0) {
    if (isObject(init))
      this.parseObject(init);
    else
      this.parseQuery(typeof init == "string" ? charAt(init, 0) === "?" ? stringSlice$1(init, 1) : init : $toString(init));
  }
};
URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function(url) {
    this.url = url;
    this.update();
  },
  parseObject: function(object) {
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next2, step, entryIterator, entryNext, first, second;
    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next2 = iterator.next;
      while (!(step = call$1(next2, iterator)).done) {
        entryIterator = getIterator(anObject$1(step.value));
        entryNext = entryIterator.next;
        if ((first = call$1(entryNext, entryIterator)).done || (second = call$1(entryNext, entryIterator)).done || !call$1(entryNext, entryIterator).done)
          throw TypeError$1("Expected sequence with length 2");
        push2(this.entries, { key: $toString(first.value), value: $toString(second.value) });
      }
    } else
      for (var key in object)
        if (hasOwn2(object, key)) {
          push2(this.entries, { key, value: $toString(object[key]) });
        }
  },
  parseQuery: function(query) {
    if (query) {
      var attributes = split(query, "&");
      var index2 = 0;
      var attribute, entry;
      while (index2 < attributes.length) {
        attribute = attributes[index2++];
        if (attribute.length) {
          entry = split(attribute, "=");
          push2(this.entries, {
            key: deserialize2(shift(entry)),
            value: deserialize2(join2(entry, "="))
          });
        }
      }
    }
  },
  serialize: function() {
    var entries2 = this.entries;
    var result = [];
    var index2 = 0;
    var entry;
    while (index2 < entries2.length) {
      entry = entries2[index2++];
      push2(result, serialize2(entry.key) + "=" + serialize2(entry.value));
    }
    return join2(result, "&");
  },
  update: function() {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function() {
    if (this.url)
      this.url.update();
  }
};
var URLSearchParamsConstructor = function URLSearchParams2() {
  anInstance(this, URLSearchParamsPrototype);
  var init = arguments.length > 0 ? arguments[0] : void 0;
  var state = setInternalState(this, new URLSearchParamsState(init));
  if (!DESCRIPTORS)
    this.size = state.entries.length;
};
var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
defineBuiltIns(URLSearchParamsPrototype, {
  append: function append(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 2);
    push2(state.entries, { key: $toString(name), value: $toString(value) });
    if (!DESCRIPTORS)
      this.length++;
    state.updateURL();
  },
  "delete": function(name) {
    var state = getInternalParamsState(this);
    var length = validateArgumentsLength(arguments.length, 1);
    var entries2 = state.entries;
    var key = $toString(name);
    var $value = length < 2 ? void 0 : arguments[1];
    var value = $value === void 0 ? $value : $toString($value);
    var index2 = 0;
    while (index2 < entries2.length) {
      var entry = entries2[index2];
      if (entry.key === key && (value === void 0 || entry.value === value)) {
        splice2(entries2, index2, 1);
        if (value !== void 0)
          break;
      } else
        index2++;
    }
    if (!DESCRIPTORS)
      this.size = entries2.length;
    state.updateURL();
  },
  get: function get2(name) {
    var entries2 = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var index2 = 0;
    for (; index2 < entries2.length; index2++) {
      if (entries2[index2].key === key)
        return entries2[index2].value;
    }
    return null;
  },
  getAll: function getAll(name) {
    var entries2 = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var result = [];
    var index2 = 0;
    for (; index2 < entries2.length; index2++) {
      if (entries2[index2].key === key)
        push2(result, entries2[index2].value);
    }
    return result;
  },
  has: function has2(name) {
    var entries2 = getInternalParamsState(this).entries;
    var length = validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var $value = length < 2 ? void 0 : arguments[1];
    var value = $value === void 0 ? $value : $toString($value);
    var index2 = 0;
    while (index2 < entries2.length) {
      var entry = entries2[index2++];
      if (entry.key === key && (value === void 0 || entry.value === value))
        return true;
    }
    return false;
  },
  set: function set3(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 1);
    var entries2 = state.entries;
    var found = false;
    var key = $toString(name);
    var val = $toString(value);
    var index2 = 0;
    var entry;
    for (; index2 < entries2.length; index2++) {
      entry = entries2[index2];
      if (entry.key === key) {
        if (found)
          splice2(entries2, index2--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found)
      push2(entries2, { key, value: val });
    if (!DESCRIPTORS)
      this.size = entries2.length;
    state.updateURL();
  },
  sort: function sort2() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function(a2, b4) {
      return a2.key > b4.key ? 1 : -1;
    });
    state.updateURL();
  },
  forEach: function forEach(callback) {
    var entries2 = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : void 0);
    var index2 = 0;
    var entry;
    while (index2 < entries2.length) {
      entry = entries2[index2++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  keys: function keys4() {
    return new URLSearchParamsIterator(this, "keys");
  },
  values: function values3() {
    return new URLSearchParamsIterator(this, "values");
  },
  entries: function entries() {
    return new URLSearchParamsIterator(this, "entries");
  }
}, { enumerable: true });
defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
defineBuiltIn(URLSearchParamsPrototype, "toString", function toString5() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });
if (DESCRIPTORS)
  defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
    get: function size() {
      return getInternalParamsState(this).entries.length;
    },
    configurable: true,
    enumerable: true
  });
setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$$1({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});
if (!USE_NATIVE_URL && isCallable(Headers2)) {
  headersHas = uncurryThis$1(HeadersPrototype.has);
  headersSet = uncurryThis$1(HeadersPrototype.set);
  wrapRequestOptions = function(init) {
    if (isObject(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers2(init.headers) : new Headers2();
        if (!headersHas(headers, "content-type")) {
          headersSet(headers, "content-type", "application/x-www-form-urlencoded;charset=UTF-8");
        }
        return create3(init, {
          body: createPropertyDescriptor(0, $toString(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    }
    return init;
  };
  if (isCallable(nativeFetch)) {
    $$1({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
      fetch: function fetch2(input) {
        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }
  if (isCallable(NativeRequest)) {
    RequestConstructor = function Request2(input) {
      anInstance(this, RequestPrototype);
      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };
    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;
    $$1({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}
var headersHas;
var headersSet;
var wrapRequestOptions;
var RequestConstructor;
var sameValue$1 = Object.is || function is4(x6, y4) {
  return x6 === y4 ? x6 !== 0 || 1 / x6 === 1 / y4 : x6 != x6 && y4 != y4;
};
var call = functionCall;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var anObject = anObject$e;
var isNullOrUndefined = isNullOrUndefined$7;
var requireObjectCoercible$1 = requireObjectCoercible$9;
var sameValue = sameValue$1;
var toString$1 = toString$b;
var getMethod = getMethod$5;
var regExpExec = regexpExecAbstract;
fixRegExpWellKnownSymbolLogic("search", function(SEARCH, nativeSearch, maybeCallNative) {
  return [
    function search2(regexp) {
      var O5 = requireObjectCoercible$1(this);
      var searcher = isNullOrUndefined(regexp) ? void 0 : getMethod(regexp, SEARCH);
      return searcher ? call(searcher, regexp, O5) : new RegExp(regexp)[SEARCH](toString$1(O5));
    },
    function(string3) {
      var rx = anObject(this);
      var S4 = toString$1(string3);
      var res = maybeCallNative(nativeSearch, rx, S4);
      if (res.done)
        return res.value;
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0))
        rx.lastIndex = 0;
      var result = regExpExec(rx, S4);
      if (!sameValue(rx.lastIndex, previousLastIndex))
        rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});
var _$4 = (t2) => t2;
var _t$4;
var _t2$3;
var _t3$2;
var _t4$1;
var _t52;
var _t6;
var _t7;
var MainContainer = st.div(_t$4 || (_t$4 = _$4`
  display: block;
`));
var WarningContainer = st(Card)(_t2$3 || (_t2$3 = _$4`
  display: flex;
  width: 100%;
  background-color: ${0};
  border-color: ${0};
`), ({
  theme
}) => theme.warning.step3, ({
  theme
}) => theme.warning.step7);
var StyledParXs = st(ParXs)(_t3$2 || (_t3$2 = _$4`
  color: ${0};
`), ({
  theme
}) => theme.warning.step12);
var WarningIcon = st(RiErrorWarningLine)(_t4$1 || (_t4$1 = _$4`
  color: ${0};
  height: 2.5rem;
  width: 2.5rem;
`), ({
  theme
}) => theme.warning.step9);
var IconContainer = st.div(_t52 || (_t52 = _$4`
  margin-right: 1rem;
`));
var ActionsContainer = st.div(_t6 || (_t6 = _$4``));
var ActionContainer = st.div(_t7 || (_t7 = _$4`
  margin: 2rem 0;
`));
var REGEX_ARRAY_TYPE = /\[(([1-9]*)([0-9]+))?\]/g;
var mapFieldToArgType = (fieldType) => {
  if (fieldType.includes("address"))
    return "ethAddress";
  if (fieldType.includes("int") || fieldType === "bool")
    return "number";
  if (fieldType === "tuple")
    return "object";
  return void 0;
};
var createActionField = (actionId, input) => {
  var _a, _b;
  if (!input.name || !input.type)
    return;
  const isArray3 = (_a = input.type) === null || _a === void 0 ? void 0 : _a.match(REGEX_ARRAY_TYPE);
  const inputType = input.type === "tuple" || isArray3 ? "textarea" : "input";
  const newRules = {
    required: "Value is required"
  };
  if (input.type === "tuple") {
    newRules["setValueAs"] = (val) => (0, import_utils12.isObject)(val) && typeof val === "string" ? JSON.parse(val) : val;
    newRules["validate"] = (val) => (0, import_utils12.ignoreEmptyVal)(val, (val2) => import_utils12.ValidateField.object(val2));
  }
  const fieldBase = {
    id: `tx.${actionId}.fields.${input.name}`,
    type: inputType,
    label: `${input.name} (${input.type})`,
    address: input.type === "address",
    number: input.type.includes("int"),
    rules: newRules
  };
  if (isArray3) {
    const dimensions = (_b = input.type) === null || _b === void 0 ? void 0 : _b.match(REGEX_ARRAY_TYPE);
    return Object.assign(Object.assign({}, fieldBase), {
      info: dimensions && dimensions.length > 1 ? "Multidimensional arguments should be separated by carriage return (Rows) and commas (Columns)" : "Arguments should be separated by carriage return (Enter)",
      rules: Object.assign(Object.assign({}, newRules), {
        setValueAs: (response) => {
          if (typeof response === "object" && response.length)
            return response;
          if (!dimensions || !(0, import_utils12.isString)(response) || response === "")
            return "";
          let fieldValues = [];
          for (let i3 = 0; i3 < dimensions.length; i3++) {
            fieldValues = i3 === 0 ? response.split(/[\n]/).map((str) => str.trim()).filter(Boolean) : fieldValues.map((dim) => {
              return dim.split(/[\s|,]/).map((str) => str.trim()).filter(Boolean);
            });
          }
          return fieldValues;
        },
        validate: (data2) => {
          if (!dimensions || data2 === "")
            return true;
          if (dimensions[0] !== "[]") {
            const totalItems = dimensions.map((dim) => Number(dim.substring(1, dim.length - 1))).reduce((aggr, dim) => aggr * dim, 1);
            if (totalItems !== data2.flatMap((v) => v).length) {
              return "Args size mismatch. Check field type.";
            }
          }
          if (data2.flatMap((v) => v).some((value) => {
            var _a2, _b2;
            if ((_a2 = input.type) === null || _a2 === void 0 ? void 0 : _a2.includes("address")) {
              return !(0, import_utils12.isEthAddress)(value);
            }
            if ((_b2 = input.type) === null || _b2 === void 0 ? void 0 : _b2.includes("int")) {
              return !(0, import_utils12.isNumberish)(value);
            }
            return false;
          })) {
            return "Incorrect formatting. Check field type.";
          }
          return true;
        }
      })
    });
  }
  return Object.assign(Object.assign({}, fieldBase), {
    expectType: mapFieldToArgType(input.type || "")
  });
};
var Action2 = ({
  actionId,
  index: index2
}) => {
  var _a;
  const contractAddressFieldId = `tx.${actionId}.to`;
  const abiFieldId = `tx.${actionId}.abi`;
  const valueFieldId = `tx.${actionId}.value`;
  const dataFieldId = `tx.${actionId}.data`;
  const customDataToggleFieldId = `tx.${actionId}.toggleCustomData`;
  const customDataFieldId = `tx.${actionId}.customData`;
  const contractMethodFieldId = `tx.${actionId}.contractMethod`;
  const {
    setValue,
    resetField,
    watch
  } = useFormBuilder();
  const {
    daoChain
  } = useCurrentDao();
  const [loading, setLoading] = (0, import_react3.useState)(false);
  const [actionTitle, setActionTitle] = (0, import_react3.useState)(`Action ${index2}`);
  const [isEOA, setEOA] = (0, import_react3.useState)(false);
  const [abiError, setAbiError] = (0, import_react3.useState)();
  const [methods, setMethods] = (0, import_react3.useState)([]);
  const [selectedMethod, setSelectedMethod] = (0, import_react3.useState)();
  const [argFieldsIds, setArgFieldsIds] = (0, import_react3.useState)([]);
  const [noArgs, toggleNoArgs] = (0, import_react3.useState)(false);
  const [actionError, setActionError] = (0, import_react3.useState)("");
  const [contractAddress, contractAbi, actionValue, actionData, customDataToggle, customData, abiMethod] = watch([contractAddressFieldId, abiFieldId, valueFieldId, dataFieldId, customDataToggleFieldId, customDataFieldId, contractMethodFieldId]);
  const values4 = watch();
  const extractContractMethods = (0, import_react3.useCallback)((abi) => {
    setMethods([]);
    const callableMethods = abi.filter((r2) => r2.type === "function" && r2.stateMutability && ["payable", "nonpayable"].includes(r2.stateMutability));
    if (callableMethods.length) {
      setMethods(callableMethods.map((m4) => {
        var _a2;
        const signature = `${m4.name}(${(_a2 = m4.inputs) === null || _a2 === void 0 ? void 0 : _a2.reduce((a2, b4, i3) => `${a2}${i3 > 0 ? "," : ""}${b4.type}`, "")})`;
        return {
          name: signature,
          value: JSON.stringify(m4)
        };
      }));
      return;
    }
    setAbiError({
      type: "error",
      message: "Not a valid ABI"
    });
  }, [setMethods]);
  const fetchContractAbi = (0, import_react3.useCallback)((address, fallbackAbi) => __awaiter(void 0, void 0, void 0, function* () {
    setLoading(true);
    const chainId = daoChain;
    const code2 = yield getCode({
      contractAddress: address,
      chainId
    });
    if (code2 === "0x") {
      setEOA(true);
      setActionTitle("Action: Native Transfer");
      setValue(abiFieldId, "");
      setValue(contractMethodFieldId, "");
      setLoading(false);
      return;
    }
    setEOA(false);
    const fetchedAbi = yield fetchABI({
      contractAddress: address,
      chainId: daoChain
    });
    if (!fetchedAbi) {
      setAbiError({
        type: "warning",
        message: "Contract not verified. You can manually paste the ABI but proceed with extreme caution!"
      });
    }
    if (!fetchedAbi && fallbackAbi) {
      cacheABI({
        address,
        chainId,
        abi: fallbackAbi
      });
    }
    const abi = fetchedAbi || fallbackAbi;
    if (abi) {
      setValue(abiFieldId, JSON.stringify(abi));
      extractContractMethods(abi);
      setLoading(false);
      return;
    }
  }), [abiFieldId, contractMethodFieldId, daoChain, extractContractMethods, setEOA, setValue]);
  const resetEncodedAction = (0, import_react3.useCallback)(() => {
    var _a2, _b;
    if ((_b = (_a2 = values4.tx) === null || _a2 === void 0 ? void 0 : _a2[actionId]) === null || _b === void 0 ? void 0 : _b.data) {
      setValue(dataFieldId, "0x");
      setValue(`tx.${actionId}.operation`, "0");
    }
  }, [actionId, dataFieldId, values4, setValue]);
  const encodeAction = (0, import_react3.useCallback)((argValues, oldData) => {
    setActionError("");
    try {
      const argFields = argFieldsIds.map((id2) => argValues ? argValues[id2.split(".").pop() || ""] : "");
      const metaTx = !(selectedMethod === null || selectedMethod === void 0 ? void 0 : selectedMethod.name) ? {
        to: contractAddress,
        data: "0x",
        value: actionValue,
        operation: 0
      } : txActionToMetaTx({
        abi: JSON.parse(contractAbi),
        method: selectedMethod.name,
        address: contractAddress,
        args: argFields,
        value: actionValue,
        operation: 0
      });
      if (oldData !== metaTx.data) {
        setValue(dataFieldId, metaTx.data);
        setValue(`tx.${actionId}.operation`, metaTx.operation);
      }
    } catch (error) {
      setActionError(error.message);
    }
  }, [actionId, dataFieldId, contractAddress, contractAbi, actionValue, selectedMethod, argFieldsIds, setActionError, setValue]);
  (0, import_react3.useEffect)(() => {
    setActionTitle(`Action ${index2}`);
    setAbiError(void 0);
    setMethods([]);
    if (selectedMethod) {
      resetEncodedAction();
    }
    if ((contractAbi === null || contractAbi === void 0 ? void 0 : contractAbi.length) && !(0, import_utils12.isJSON)(contractAbi)) {
      setAbiError({
        type: "error",
        message: "Not a valid ABI"
      });
      return;
    }
    if ((0, import_utils12.isEthAddress)(contractAddress)) {
      fetchContractAbi(contractAddress, (0, import_utils12.isJSON)(contractAbi) ? JSON.parse(contractAbi) : void 0);
    }
  }, [contractAddress, contractAbi, fetchContractAbi]);
  (0, import_react3.useEffect)(() => {
    var _a2, _b;
    if (abiMethod) {
      if (argFieldsIds === null || argFieldsIds === void 0 ? void 0 : argFieldsIds.length) {
        argFieldsIds === null || argFieldsIds === void 0 ? void 0 : argFieldsIds.forEach((a2) => resetField(a2));
      }
      const method = JSON.parse(abiMethod);
      setSelectedMethod(method);
      setArgFieldsIds(((_a2 = method === null || method === void 0 ? void 0 : method.inputs) === null || _a2 === void 0 ? void 0 : _a2.length) ? method.inputs.map((input) => `tx.${actionId}.fields.${input.name}`) : []);
      setActionTitle(`Action: ${(method === null || method === void 0 ? void 0 : method.name) || "Native Transfer"}`);
      toggleNoArgs(!((_b = method === null || method === void 0 ? void 0 : method.inputs) === null || _b === void 0 ? void 0 : _b.length));
      return;
    }
    setSelectedMethod(void 0);
    setArgFieldsIds([]);
  }, [abiMethod]);
  (0, import_react3.useEffect)(() => {
    if (isEOA) {
      setValue(dataFieldId, "0x");
      setValue(`tx.${actionId}.operation`, "0");
    }
  }, [isEOA]);
  (0, import_react3.useEffect)(() => {
    if (customDataToggle && customData) {
      setValue(dataFieldId, customData);
      setValue(`tx.${actionId}.operation`, 0);
    }
  }, [customDataToggle, customData]);
  (0, import_react3.useEffect)(() => {
    var _a2, _b;
    if (noArgs) {
      encodeAction(Object.assign({}, (_b = (_a2 = values4.tx) === null || _a2 === void 0 ? void 0 : _a2[actionId]) === null || _b === void 0 ? void 0 : _b.fields));
    }
  }, [noArgs]);
  (0, import_react3.useEffect)(() => {
    var _a2, _b, _c, _d, _e5, _f;
    if (selectedMethod && ((_b = (_a2 = values4.tx) === null || _a2 === void 0 ? void 0 : _a2[actionId]) === null || _b === void 0 ? void 0 : _b.contractMethod) && argFieldsIds.length && argFieldsIds.map((id2) => id2.split(".").reduce((data2, curr) => data2[curr], values4)).every((arg) => (arg === null || arg === void 0 ? void 0 : arg.length) > 0 || typeof arg === "object")) {
      encodeAction(Object.assign({}, (_d = (_c = values4.tx) === null || _c === void 0 ? void 0 : _c[actionId]) === null || _d === void 0 ? void 0 : _d.fields), (_f = (_e5 = values4.tx) === null || _e5 === void 0 ? void 0 : _e5[actionId]) === null || _f === void 0 ? void 0 : _f.data);
    }
  }, [encodeAction, values4]);
  const txFields = [{
    id: contractAddressFieldId,
    type: "input",
    label: "Address",
    placeholder: "0x1234...5678",
    rules: {
      required: "Address is required"
    },
    helperText: loading ? "Fetching Contract ABI..." : ""
  }, {
    id: abiFieldId,
    disabled: isEOA,
    type: "textarea",
    label: "ABI",
    placeholder: "[{...}]",
    error: (abiError === null || abiError === void 0 ? void 0 : abiError.type) === "error" && abiError,
    warning: (abiError === null || abiError === void 0 ? void 0 : abiError.type) === "warning" && abiError,
    rules: {
      required: !isEOA ? "ABI is required" : false
    }
  }, {
    id: valueFieldId,
    type: "input",
    label: "Value",
    defaultValue: "0",
    placeholder: "0",
    rules: {
      required: "Value is required"
    }
  }, {
    id: `${customDataToggleFieldId}Wrapper`,
    type: "switch",
    label: "Custom data?",
    disabled: isEOA,
    switches: [{
      id: customDataToggleFieldId,
      fieldLabel: "",
      defaultChecked: false
    }]
  }, {
    id: customDataFieldId,
    type: "textarea",
    label: "Data (Hex encoded)",
    hidden: !customDataToggle,
    placeholder: "0x1234...5678",
    rules: {
      required: customDataToggle ? "Data is required" : false
    },
    defaultValue: "0x"
  }, {
    id: contractMethodFieldId,
    disabled: isEOA,
    hidden: customDataToggle,
    type: "select",
    label: "Contract Function",
    options: methods,
    placeholder: "Select Function",
    rules: {
      required: !isEOA && !customDataToggle ? "Contract function is required" : false
    },
    defaultValue: selectedMethod === null || selectedMethod === void 0 ? void 0 : selectedMethod.name
  }, ...((_a = selectedMethod === null || selectedMethod === void 0 ? void 0 : selectedMethod.inputs) === null || _a === void 0 ? void 0 : _a.length) ? selectedMethod.inputs.map((input) => createActionField(actionId, input)) : [], ...["data", "operation", "deleted"].map((arg) => ({
    id: `tx.${actionId}.${arg}`,
    type: "input",
    hidden: true
  })), {
    id: `tx.${actionId}.index`,
    type: "input",
    hidden: true,
    value: index2
  }];
  return (0, import_jsx_runtime2.jsx)(CollapsibleFormSegment, {
    collapsible: true,
    defaultOpen: true,
    title: actionTitle,
    formArea: txFields.map((field) => (0, import_jsx_runtime2.jsx)(FormBuilderFactory, {
      field
    }, field.id)),
    infoArea: (actionData === null || actionData === void 0 ? void 0 : actionData.length) > 2 && (0, import_jsx_runtime2.jsxs)("div", {
      children: [(0, import_jsx_runtime2.jsx)(DataSm, Object.assign({
        className: "space"
      }, {
        children: (0, import_jsx_runtime2.jsx)(Bold, {
          children: "RAW HEX DATA"
        })
      })), (0, import_jsx_runtime2.jsx)(AddressDisplay, {
        className: "space",
        address: actionData,
        copy: true,
        truncate: true,
        txHash: true
      })]
    }),
    error: actionError && (0, import_jsx_runtime2.jsx)(ErrorText, {
      children: actionError
    })
  });
};
var MultisendActions = (props) => {
  const location = useLocation();
  const {
    dao
  } = useDaoData();
  const [actions, setActions] = (0, import_react3.useState)([{
    id: v4_default().substring(0, 8)
  }]);
  const sidecarSafeAddress = (0, import_react3.useMemo)(() => {
    const params = new URLSearchParams(location.search);
    const legoId = params.get("formLego");
    if (legoId !== "MULTICALL_SIDECAR")
      return;
    const defaultValues = params.get("defaultValues");
    if (!defaultValues)
      return;
    const data2 = JSON.parse(defaultValues);
    return data2.safeAddress;
  }, [location]);
  const vaultMessage = (0, import_react3.useMemo)(() => {
    const vault = dao === null || dao === void 0 ? void 0 : dao.vaults.find((v) => v.safeAddress === sidecarSafeAddress);
    if (vault) {
      return `Proposal Actions will interact with ${vault.name} Vault: ${sidecarSafeAddress}`;
    }
    return `Vault ${sidecarSafeAddress} is not registered for this DAO. Proceed with caution as transaction may fail.`;
  }, [dao, sidecarSafeAddress]);
  const addAction = () => {
    setActions([...actions, {
      id: v4_default().substring(0, 8)
    }]);
  };
  const onDelete = (actionId) => {
    const indexAt = actions.findIndex((a2) => a2.id === actionId);
    setActions(actions.splice(indexAt - 1, 1));
  };
  return (0, import_jsx_runtime2.jsxs)(MainContainer, {
    children: [dao && sidecarSafeAddress && (0, import_jsx_runtime2.jsxs)(WarningContainer, Object.assign({
      className: "container"
    }, {
      children: [(0, import_jsx_runtime2.jsx)(IconContainer, {
        children: (0, import_jsx_runtime2.jsx)(Icon$1, Object.assign({
          label: "Warning"
        }, {
          children: (0, import_jsx_runtime2.jsx)(WarningIcon, {})
        }))
      }), (0, import_jsx_runtime2.jsx)("div", {
        children: (0, import_jsx_runtime2.jsx)(StyledParXs, {
          children: vaultMessage
        })
      })]
    })), (0, import_jsx_runtime2.jsx)(ActionsContainer, {
      children: actions.map((action, index2) => (0, import_jsx_runtime2.jsx)(ActionContainer, {
        children: (0, import_jsx_runtime2.jsx)(Action2, {
          actionId: action.id,
          index: index2,
          onDelete: actions.length > 1 ? onDelete : void 0
        })
      }, action.id))
    }), (0, import_jsx_runtime2.jsx)(Button, Object.assign({
      onClick: addAction,
      IconLeft: RiAddCircleLine,
      variant: "ghost"
    }, {
      children: "Add Another Action"
    }))]
  });
};
var INPUT_ID = "expiryValue";
var SELECT_ID = "expiryPeriod";
var ProposalExpiry = (_a) => {
  var {
    id: id2,
    defaultValue,
    rules
  } = _a, props = __rest(_a, ["id", "defaultValue", "rules"]);
  const {
    watch,
    register,
    setValue
  } = useFormContext();
  const [periodValue, periodMultiplier] = watch([INPUT_ID, SELECT_ID]);
  const {
    dao
  } = useDaoData();
  const theme = Je();
  const expiryDateString = `${id2}String`;
  const periodSelectOpts = [{
    value: `${1}`,
    name: "Seconds"
  }, {
    value: `${60}`,
    name: "Minutes"
  }, {
    value: `${3600}`,
    name: "Hours"
  }, {
    value: `${3600 * 24}`,
    name: "Days"
  }];
  (0, import_react3.useEffect)(() => {
    if (dao) {
      const extendedPeriodSeconds = Number(periodValue || 0) * Number(periodMultiplier || 0);
      const absoluteExtendedPeriod = Number(dao.votingPeriod) + Number(dao.gracePeriod) + extendedPeriodSeconds;
      setValue(id2, absoluteExtendedPeriod);
      setValue(expiryDateString, format(((0, import_utils12.unixTimeInSeconds)() + absoluteExtendedPeriod) * 1e3, "MMM dd, yyyy 'at' hh:mmaaa OOO"));
    }
  }, [dao, expiryDateString, id2, periodValue, periodMultiplier, setValue]);
  return (0, import_jsx_runtime2.jsxs)(FieldWrapper, Object.assign({}, props, {
    id: id2,
    rules
  }, {
    children: [(0, import_jsx_runtime2.jsx)(FieldSpacer, {
      children: (0, import_jsx_runtime2.jsx)(InputSelect, Object.assign({}, props, {
        registerInput: register(INPUT_ID, rules),
        registerSelect: register(SELECT_ID),
        id: INPUT_ID,
        defaultValue,
        selectDefault: `${3600 * 24}`,
        selectId: SELECT_ID,
        options: periodSelectOpts
      }))
    }), (0, import_jsx_runtime2.jsx)(FieldSpacer, {
      children: (0, import_jsx_runtime2.jsx)(HighlightInputText, {
        id: "highlightProposalExpiry",
        description: "Expiration will be on:",
        highlightColor: theme.secondary.step11,
        highlightInputId: expiryDateString
      })
    }), (0, import_jsx_runtime2.jsx)(HighlightInputText, {
      id: "expirationDateDescription",
      description: "The expiration date includes Voting and Grace Periods. Adjust the days or hour to update the expiration."
    }), (0, import_jsx_runtime2.jsx)(WrappedInput, {
      id: id2,
      hidden: true
    }), (0, import_jsx_runtime2.jsx)(WrappedInput, {
      id: expiryDateString,
      hidden: true
    })]
  }));
};
var ProposalOffering = (props) => {
  var _a;
  const {
    id: id2 = "proposalOffering"
  } = props;
  const {
    daoChain
  } = useCurrentDao();
  const {
    networks
  } = useDHConnect();
  const {
    dao
  } = useDaoData();
  const {
    connectedMember
  } = useConnectedMember();
  const {
    register,
    setValue
  } = useFormContext();
  const [requiresOffering, setRequiresOffering] = (0, import_react3.useState)(false);
  const networkTokenSymbol = (0, import_keychain_utils.isValidNetwork)(daoChain) && ((_a = networks === null || networks === void 0 ? void 0 : networks[daoChain]) === null || _a === void 0 ? void 0 : _a.symbol);
  register(id2);
  (0, import_react3.useEffect)(() => {
    if (!dao || !id2)
      return;
    if (!connectedMember || Number(dao.sponsorThreshold) > Number(connectedMember.delegateShares)) {
      setRequiresOffering(true);
      setValue(id2, dao.proposalOffering);
      return;
    }
    setValue(id2, "0");
    setRequiresOffering(false);
    return;
  }, [dao, connectedMember, setValue, id2]);
  if (!requiresOffering || !(dao === null || dao === void 0 ? void 0 : dao.proposalOffering) || !networkTokenSymbol)
    return null;
  return (0, import_jsx_runtime2.jsxs)(ParMd, {
    children: ["Proposal Offering:", " ", (0, import_jsx_runtime2.jsxs)(TintSecondary, {
      children: [" ", (0, import_utils12.fromWei)(dao.proposalOffering), " ", networkTokenSymbol]
    })]
  });
};
var RagequitToken = (props) => {
  const {
    id: id2
  } = props;
  const {
    setValue
  } = useFormContext();
  const {
    dao
  } = useDaoData();
  const {
    connectedMember
  } = useConnectedMember();
  const daoTokenData = (0, import_react3.useMemo)(() => {
    if (!dao || !connectedMember)
      return null;
    return {
      label: id2 === "sharesToBurn" ? `Voting Tokens (${dao.shareTokenSymbol})` : `Non-Voting Tokens (${dao.lootTokenSymbol})`,
      maxAmount: id2 === "sharesToBurn" ? connectedMember.shares : connectedMember.loot
    };
  }, [connectedMember, dao, id2]);
  const setMax = () => {
    setValue(id2, (0, import_utils12.toWholeUnits)((daoTokenData === null || daoTokenData === void 0 ? void 0 : daoTokenData.maxAmount) || "0"));
  };
  const newRules = Object.assign({
    setValueAs: (value) => (0, import_utils12.handleBaseUnits)(value, 18)
  }, props.rules);
  if (!daoTokenData) {
    return null;
  }
  return (0, import_jsx_runtime2.jsx)(WrappedInput, Object.assign({}, props, {
    id: id2,
    label: daoTokenData.label,
    defaultValue: "0",
    rightAddon: (0, import_jsx_runtime2.jsxs)(Button, Object.assign({
      color: "secondary",
      size: "sm",
      onClick: setMax
    }, {
      children: ["Max: ", (0, import_utils12.toWholeUnits)(daoTokenData.maxAmount || "0")]
    })),
    rules: newRules
  }));
};
var _$3 = (t2) => t2;
var _t$3;
var _t2$2;
var _t3$1;
var TokenListContainer = st.div(_t$3 || (_t$3 = _$3`
  display: flex;
  justify-content: space-between;
`));
var Column = st.div(_t2$2 || (_t2$2 = _$3`
  width: 33%;
`));
var DataColumn = st(Column)(_t3$1 || (_t3$1 = _$3`
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
  padding-top: 0.8rem;
`));
var RagequitTokenList = (props) => {
  const {
    id: id2
  } = props;
  const {
    dao
  } = useDaoData();
  const {
    connectedMember
  } = useConnectedMember();
  const {
    daoChain
  } = useCurrentDao();
  const {
    setValue,
    watch
  } = useFormContext();
  const [sharesToBurn, lootToBurn, tokens] = watch(["sharesToBurn", "lootToBurn", "tokens"]);
  const networkData = (0, import_react3.useMemo)(() => {
    if (!daoChain)
      return null;
    return (0, import_keychain_utils.getNetwork)(daoChain);
  }, [daoChain]);
  const treasury = (0, import_react3.useMemo)(() => {
    if (dao) {
      return dao.vaults.find((v) => v.safeAddress === dao.safeAddress) || void 0;
    }
    return void 0;
  }, [dao]);
  const tokenTable = (0, import_react3.useMemo)(() => {
    if (!dao || !networkData || !connectedMember || !treasury)
      return null;
    return treasury.tokenBalances.filter((token) => Number(token.balance) > 0).reduce((acc, token) => {
      var _a, _b;
      acc.tokenCheckboxes = [...acc.tokenCheckboxes, {
        id: token.tokenAddress || import_utils12.NETWORK_TOKEN_ETH_ADDRESS,
        title: ((_a = token.token) === null || _a === void 0 ? void 0 : _a.name) || networkData.symbol,
        name: token.tokenAddress || import_utils12.NETWORK_TOKEN_ETH_ADDRESS,
        defaultChecked: true,
        disabled: false,
        required: false,
        onCheckedChange: (checked) => {
          if (checked) {
            setValue(id2, sortTokensForRageQuit([...tokens, token.tokenAddress || import_utils12.NETWORK_TOKEN_ETH_ADDRESS]));
          }
          if (!checked) {
            const targetAddress = token.tokenAddress || import_utils12.NETWORK_TOKEN_ETH_ADDRESS;
            setValue(id2, sortTokensForRageQuit(tokens.filter((t2) => t2 !== targetAddress)));
          }
          setValue(token.tokenAddress || import_utils12.NETWORK_TOKEN_ETH_ADDRESS, checked);
        }
      }];
      acc.amounts = [...acc.amounts, (0, import_jsx_runtime2.jsx)(DataSm, {
        children: (0, import_utils12.formatValueTo)({
          value: (0, import_utils12.memberTokenBalanceShare)(token.balance, dao.totalShares || 0, dao.totalLoot || 0, sharesToBurn || 0, lootToBurn || 0, ((_b = token.token) === null || _b === void 0 ? void 0 : _b.decimals) || 18),
          format: "number"
        })
      }, token.tokenAddress)];
      acc.usdValue = [...acc.usdValue, (0, import_jsx_runtime2.jsx)(DataSm, {
        children: (0, import_utils12.formatValueTo)({
          value: (0, import_utils12.memberUsdValueShare)(token.fiatBalance, dao.totalShares || 0, dao.totalLoot || 0, sharesToBurn || 0, lootToBurn || 0),
          decimals: 2,
          format: "currency"
        })
      }, token.tokenAddress)];
      return acc;
    }, {
      tokenCheckboxes: [],
      amounts: [],
      usdValue: []
    });
  }, [dao, networkData, connectedMember, sharesToBurn, lootToBurn, id2, tokens, treasury, setValue]);
  const handleSelectAll = (checked) => {
    if (checked) {
      setValue(id2, sortTokensForRageQuit((treasury === null || treasury === void 0 ? void 0 : treasury.tokenBalances.filter((token) => Number(token.balance) > 0).map((token) => token.tokenAddress || import_utils12.NETWORK_TOKEN_ETH_ADDRESS)) || []));
    } else {
      setValue(id2, []);
    }
    treasury === null || treasury === void 0 ? void 0 : treasury.tokenBalances.forEach((token) => {
      if (Number(token.balance) > 0) {
        setValue(token.tokenAddress || import_utils12.NETWORK_TOKEN_ETH_ADDRESS, checked);
      }
    });
  };
  if (!tokenTable)
    return null;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsxs)(TokenListContainer, {
      children: [(0, import_jsx_runtime2.jsx)(Column, {
        children: (0, import_jsx_runtime2.jsx)(Checkbox, {
          title: "Token",
          defaultChecked: true,
          onCheckedChange: handleSelectAll
        })
      }), (0, import_jsx_runtime2.jsx)(Column, {
        children: (0, import_jsx_runtime2.jsx)(ParSm, {
          children: "Amount"
        })
      }), (0, import_jsx_runtime2.jsx)(Column, {
        children: (0, import_jsx_runtime2.jsx)(ParSm, {
          children: "USD Value"
        })
      })]
    }), (0, import_jsx_runtime2.jsxs)(TokenListContainer, {
      children: [(0, import_jsx_runtime2.jsx)(Column, {
        children: (0, import_jsx_runtime2.jsx)(WrappedCheckbox, Object.assign({}, props, {
          id: id2,
          checkboxes: tokenTable.tokenCheckboxes
        }))
      }), (0, import_jsx_runtime2.jsx)(DataColumn, {
        children: tokenTable.amounts
      }), (0, import_jsx_runtime2.jsx)(DataColumn, {
        children: tokenTable.usdValue
      })]
    })]
  });
};
var InputStates;
(function(InputStates2) {
  InputStates2[InputStates2["Loading"] = 0] = "Loading";
  InputStates2["InvalidNetwork"] = "Invalid Network";
  InputStates2["CorruptTokenData"] = "Corrupt Token Data";
})(InputStates || (InputStates = {}));
var RequestERC20 = (props) => {
  const {
    daoChain
  } = useCurrentDao();
  const {
    amtId = "paymentTokenAmt",
    addressId = "paymentTokenAddress",
    safeAddressId = "safeAddress"
  } = props;
  const {
    dao
  } = useDaoData();
  const {
    watch,
    setValue
  } = useFormContext();
  const paymentTokenAddr = watch(addressId);
  const safeAddress = watch(safeAddressId);
  (0, import_react3.useEffect)(() => {
    if (paymentTokenAddr) {
      setValue(amtId, "0");
    }
  }, [paymentTokenAddr, setValue, amtId]);
  const erc20s = (0, import_react3.useMemo)(() => {
    if (dao && (0, import_keychain_utils.isValidNetwork)(daoChain)) {
      const selectedSafe = dao.vaults.find((v) => {
        if (!safeAddress)
          return v.safeAddress === dao.safeAddress;
        return v.safeAddress === safeAddress;
      });
      return selectedSafe && getErc20s(selectedSafe);
    }
    return null;
  }, [dao, daoChain, safeAddress]);
  const selectOptions = (0, import_react3.useMemo)(() => {
    if (!erc20s)
      return;
    const options = erc20s.map((token) => ({
      name: token.symbol,
      value: token.address
    }));
    return options;
  }, [erc20s]);
  const selectedToken = (0, import_react3.useMemo)(() => {
    if (!erc20s || !paymentTokenAddr)
      return;
    return erc20s.find(({
      address
    }) => address === paymentTokenAddr);
  }, [paymentTokenAddr, erc20s]);
  const tokenBalance = (selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.daoBalance) ? (0, import_utils12.formatValueTo)({
    value: (0, import_utils12.toWholeUnits)(selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.daoBalance, selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.decimals),
    decimals: 6,
    format: "number"
  }) : "0";
  const setMax = () => {
    if (!selectedToken)
      return;
    setValue(amtId, tokenBalance.trim());
  };
  const newRules = Object.assign({
    setValueAs: (value) => (0, import_utils12.handleBaseUnits)(value, selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.decimals),
    validate: {
      number: (value) => (0, import_utils12.ignoreEmptyVal)(value, import_utils12.ValidateField.number),
      daoHasBalance: (val) => {
        return selectedToken && (0, import_utils12.ignoreEmptyVal)(val, (val2) => Number(val2) > Number((selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.daoBalance) || 0) ? "Amount exceeds DAO Balance" : true);
      }
    }
  }, props.rules);
  return (0, import_jsx_runtime2.jsx)(WrappedInputSelect, Object.assign({}, props, {
    id: amtId,
    defaultValue: "0",
    selectId: addressId,
    selectPlaceholder: "--",
    options: selectOptions || [],
    rightAddon: (0, import_jsx_runtime2.jsxs)(Button, Object.assign({
      color: "secondary",
      size: "sm",
      onClick: setMax
    }, {
      children: ["Max: ", tokenBalance]
    })),
    rules: newRules
  }));
};
var RequestNativeToken = (props) => {
  const {
    id: id2 = "valueRequested",
    safeAddressId = "safeAddress"
  } = props;
  const {
    daoChain
  } = useCurrentDao();
  const {
    watch,
    setValue
  } = useFormContext();
  const {
    dao
  } = useDaoData();
  const safeAddress = watch(safeAddressId);
  const networkTokenData = (0, import_react3.useMemo)(() => {
    if (!dao || !(0, import_keychain_utils.isValidNetwork)(daoChain))
      return null;
    return getNetworkToken(dao, daoChain, safeAddress);
  }, [dao, daoChain, safeAddress]);
  const label = (networkTokenData === null || networkTokenData === void 0 ? void 0 : networkTokenData.name) ? `Request ${networkTokenData.name}` : `Request Network Token`;
  const setMax = () => {
    setValue(id2, (0, import_utils12.toWholeUnits)((networkTokenData === null || networkTokenData === void 0 ? void 0 : networkTokenData.daoBalance) || "0", networkTokenData === null || networkTokenData === void 0 ? void 0 : networkTokenData.decimals));
  };
  const newRules = Object.assign({
    setValueAs: (value) => (0, import_utils12.handleBaseUnits)(value, 18)
  }, props.rules);
  return (0, import_jsx_runtime2.jsx)(WrappedInput, Object.assign({}, props, {
    id: id2,
    label,
    defaultValue: "0",
    rightAddon: (0, import_jsx_runtime2.jsxs)(Button, Object.assign({
      color: "secondary",
      size: "sm",
      onClick: setMax
    }, {
      children: ["Max:", " ", (0, import_utils12.toWholeUnits)((networkTokenData === null || networkTokenData === void 0 ? void 0 : networkTokenData.daoBalance) || "0", networkTokenData === null || networkTokenData === void 0 ? void 0 : networkTokenData.decimals)]
    })),
    rules: newRules
  }));
};
var SafeSelect = (props) => {
  const {
    dao
  } = useDaoData();
  const safeOptions = (0, import_react3.useMemo)(() => {
    if (!dao)
      return null;
    return dao.vaults.filter((v) => !v.ragequittable).map((v) => {
      return {
        name: `${v.name} (${(0, import_utils12.truncateAddress)(v.safeAddress)})`,
        value: v.safeAddress
      };
    });
  }, [dao]);
  if (!safeOptions)
    return null;
  return (0, import_jsx_runtime2.jsx)(WrappedSelect, Object.assign({}, props, {
    options: safeOptions
  }));
};
var SelectApplicant = (_a) => {
  var {
    daoMemberOnly
  } = _a, props = __rest(_a, ["daoMemberOnly"]);
  const [textMode, toggleTextMode] = (0, import_react3.useState)(true);
  const [memberList, setMemberList] = (0, import_react3.useState)([]);
  const [memberLoading, setMemberLoading] = (0, import_react3.useState)(false);
  const [valError, setValError] = (0, import_react3.useState)();
  const {
    daoChain,
    daoId
  } = useCurrentDao();
  const {
    register,
    setValue,
    watch
  } = useFormContext();
  const {
    members
  } = useDaoMembers();
  const inputValue = watch(props.id);
  register("memberShares");
  register("memberLoot");
  const Component3 = textMode ? WrappedInput : WrappedSelect;
  const cleanup = (0, import_react3.useCallback)(() => {
    setValue("memberShares", "");
    setValue("memberLoot", "");
    setValError(void 0);
  }, [setValue]);
  const fetchMember = (0, import_react3.useCallback)((memberAddress, validateMember) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    if (daoChain && daoId) {
      const rs3 = yield isActiveMember({
        daochain: daoChain,
        daoid: daoId,
        address: memberAddress,
        setMemberLoading
      });
      setValue("memberShares", ((_b = rs3.member) === null || _b === void 0 ? void 0 : _b.shares) || "0");
      setValue("memberLoot", ((_c = rs3.member) === null || _c === void 0 ? void 0 : _c.loot) || "0");
      if (validateMember && rs3.error)
        setValError(rs3.error);
    }
  }), [daoChain, daoId, setValue]);
  const ToggleButton = () => {
    return (0, import_jsx_runtime2.jsx)(Button, Object.assign({
      color: "secondary",
      variant: "outline",
      size: "sm",
      onClick: () => {
        setValue(props.id, "");
        toggleTextMode(!textMode);
      }
    }, {
      children: textMode ? "Select Member" : "Input Address"
    }));
  };
  (0, import_react3.useEffect)(() => {
    if (members) {
      setMemberList(members.map((m4) => ({
        name: m4.memberAddress,
        value: m4.memberAddress
      })));
    }
  }, [members]);
  (0, import_react3.useEffect)(() => {
    cleanup();
    if (inputValue) {
      fetchMember(inputValue.toLowerCase(), !!daoMemberOnly || textMode);
    }
  }, [cleanup, daoMemberOnly, fetchMember, inputValue, textMode]);
  return (0, import_jsx_runtime2.jsx)(Component3, Object.assign({}, props, {
    error: valError,
    disabled: memberLoading,
    options: !textMode ? memberList : [],
    placeholder: !textMode ? `Choose a Member` : `0x`,
    rightAddon: (0, import_jsx_runtime2.jsx)(ToggleButton, {})
  }));
};
var _$2 = (t2) => t2;
var _t$2;
var _t2$1;
var Secondary = st.span(_t$2 || (_t$2 = _$2`
  color: ${0};
`), (props) => props.theme.secondary.step9);
var DeluxeBox = st.div(_t2$1 || (_t2$1 = _$2`
  p {
    margin-bottom: 1.2rem;
  }
`));
var ShamanDeluxe = (props) => {
  var _a, _b;
  const {
    id: id2 = "shamanPermission",
    watchAddressField = "shamanAddress"
  } = props;
  const {
    watch
  } = useFormContext();
  const {
    dao
  } = useDaoData();
  const [shamanPermission, shamanAddress] = watch([id2, watchAddressField]);
  const oldShamanLevel = (0, import_react3.useMemo)(() => {
    var _a2, _b2;
    if (!dao || !shamanPermission || !shamanAddress)
      return;
    return (_b2 = (_a2 = dao === null || dao === void 0 ? void 0 : dao.shamen) === null || _a2 === void 0 ? void 0 : _a2.find((shaman) => shaman.shamanAddress === shamanAddress)) === null || _b2 === void 0 ? void 0 : _b2.permissions;
  }, [dao, shamanPermission, shamanAddress]);
  const newRules = Object.assign({
    validate: (val) => (0, import_utils12.ignoreEmptyVal)(val, (val2) => {
      if (oldShamanLevel == null)
        return true;
      return Number(oldShamanLevel) > Number(val2) ? true : "Shaman permission level can only go down";
    })
  }, props.rules);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsx)(ShamanPermission, Object.assign({}, props, {
      rules: newRules
    })), (0, import_utils12.isNumberish)(shamanPermission) && (0, import_utils12.isNumberish)(oldShamanLevel) && (0, import_jsx_runtime2.jsxs)(DeluxeBox, {
      children: [(0, import_jsx_runtime2.jsxs)(DataSm, {
        children: [(0, import_jsx_runtime2.jsx)(Secondary, {
          children: "Shamans Old Permission Level is:"
        }), " ", (_a = import_utils12.SHAMAN_PERMISSIONS === null || import_utils12.SHAMAN_PERMISSIONS === void 0 ? void 0 : import_utils12.SHAMAN_PERMISSIONS[Number(oldShamanLevel)]) === null || _a === void 0 ? void 0 : _a.displayName]
      }), (0, import_jsx_runtime2.jsxs)(DataSm, {
        children: [(0, import_jsx_runtime2.jsx)(Secondary, {
          children: "Shamans New Permission Level is:"
        }), " ", (_b = import_utils12.SHAMAN_PERMISSIONS === null || import_utils12.SHAMAN_PERMISSIONS === void 0 ? void 0 : import_utils12.SHAMAN_PERMISSIONS[Number(shamanPermission)]) === null || _b === void 0 ? void 0 : _b.displayName, "Only"]
      })]
    })]
  });
};
var TagsInput = (props) => {
  const newRules = Object.assign(Object.assign({}, props.rules), {
    setValueAs: (val) => val.split(", ")
  });
  return (0, import_jsx_runtime2.jsx)(WrappedInput, Object.assign({}, props, {
    rules: newRules
  }));
};
var ERC_20_CONTRCT = {
  type: "static",
  contractName: "ERC20",
  abi: import_abis.LOCAL_ABI.ERC20,
  targetAddress: ".tokenAddress"
};
var APPROVE_TX = {
  id: "APPROVE_TOKEN",
  contract: ERC_20_CONTRCT,
  method: "approve",
  args: [{
    type: "singleton",
    keychain: import_keychain_utils.CONTRACT_KEYCHAINS.TRIBUTE_MINION
  }, {
    type: "static",
    value: import_utils12.MaxUint256
  }]
};
var TokenFetchStates;
(function(TokenFetchStates2) {
  TokenFetchStates2["Idle"] = "";
  TokenFetchStates2["Loading"] = "Loading Token Data...";
  TokenFetchStates2["NotEthAddress"] = "Not a valid Ethereum address";
  TokenFetchStates2["NotValidNetwork"] = "Not a valid network";
  TokenFetchStates2["NotConnected"] = "Connection Error";
  TokenFetchStates2["Error"] = "Error fetching token data";
  TokenFetchStates2["Success"] = "Success";
})(TokenFetchStates || (TokenFetchStates = {}));
var fetchUserERC20 = ({
  tokenAddress,
  chainId,
  userAddress,
  shouldUpdate,
  setFetchState,
  setTokenData,
  setNeedsApproval
}) => __awaiter(void 0, void 0, void 0, function* () {
  setFetchState(TokenFetchStates.Loading);
  if (!tokenAddress) {
    return setFetchState(TokenFetchStates.Idle);
  }
  if (!(0, import_utils12.isEthAddress)(tokenAddress))
    return setFetchState(TokenFetchStates.NotEthAddress);
  if (!(0, import_keychain_utils.isValidNetwork)(chainId) || !userAddress || !import_keychain_utils.CONTRACT_KEYCHAINS.TRIBUTE_MINION[chainId])
    return setFetchState(TokenFetchStates.NotValidNetwork);
  const spenderAddress = import_keychain_utils.CONTRACT_KEYCHAINS.TRIBUTE_MINION[chainId];
  const client = (0, import_utils12.createViemClient)({
    chainId
  });
  try {
    const balance = yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "balanceOf",
      args: [userAddress]
    });
    const decimals = yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "decimals"
    });
    const tokenName = yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "name"
    });
    const tokenSymbol = yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "symbol"
    });
    const allowance = yield client.readContract({
      abi: import_abis.LOCAL_ABI.ERC20,
      address: tokenAddress,
      functionName: "allowance",
      args: [userAddress, spenderAddress]
    });
    const tokenData = {
      allowance: allowance.toString(),
      balance: balance.toString(),
      decimals,
      tokenName,
      tokenSymbol
    };
    if (tokenData && shouldUpdate) {
      setTokenData(tokenData);
      setFetchState(TokenFetchStates.Success);
      allowance.toString() === "0" ? setNeedsApproval(true) : setNeedsApproval(false);
    }
  } catch (error) {
    console.error(error);
    setFetchState(TokenFetchStates.Error);
  }
});
var TributeInput = (props) => {
  const {
    addressId = "tokenAddress",
    amtId = "tokenAmount"
  } = props;
  const {
    control,
    setValue
  } = useFormContext();
  const {
    address,
    chainId
  } = useDHConnect();
  const tokenAddress = useWatch({
    name: addressId,
    control
  });
  const [fetchState, setFetchState] = (0, import_react3.useState)(TokenFetchStates.Idle);
  const [needsApproval, setNeedsApproval] = (0, import_react3.useState)(false);
  const [tokenData, setTokenData] = (0, import_react3.useState)(null);
  (0, import_react3.useEffect)(() => {
    let shouldUpdate = true;
    fetchUserERC20({
      tokenAddress,
      chainId,
      userAddress: address,
      setFetchState,
      setTokenData,
      setNeedsApproval,
      shouldUpdate
    });
    return () => {
      shouldUpdate = false;
    };
  }, [tokenAddress, address, chainId]);
  const tokenName = (tokenData === null || tokenData === void 0 ? void 0 : tokenData.tokenName) && fetchState === TokenFetchStates.Success ? {
    type: "success",
    message: `Token: ${tokenData.tokenName}`
  } : void 0;
  const tokenError = fetchState === TokenFetchStates.Error ? {
    type: "error",
    message: TokenFetchStates.Error
  } : void 0;
  const tokenAmtRules = Object.assign({
    required: true,
    setValueAs: (val) => {
      if (val === "")
        return "";
      return (0, import_utils12.toBaseUnits)(val, tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals);
    }
  }, props.rules);
  const tokenAddressRules = Object.assign({
    required: true
  }, props.rules);
  const handleMax = () => {
    if (tokenData) {
      setValue(amtId, (0, import_utils12.toWholeUnits)(tokenData.balance, tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals));
    }
  };
  const maxButton = (tokenData === null || tokenData === void 0 ? void 0 : tokenData.balance) && (tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals) && (0, import_jsx_runtime2.jsxs)(Button, Object.assign({
    color: "secondary",
    size: "sm",
    onClick: handleMax,
    type: "button"
  }, {
    children: ["Max:", " ", (0, import_utils12.formatValueTo)({
      value: (0, import_utils12.toWholeUnits)(tokenData === null || tokenData === void 0 ? void 0 : tokenData.balance, tokenData === null || tokenData === void 0 ? void 0 : tokenData.decimals),
      decimals: 6,
      format: "number"
    })]
  }));
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, {
    children: [(0, import_jsx_runtime2.jsxs)(FieldSpacer, {
      children: [(0, import_jsx_runtime2.jsx)(WrappedInput, {
        full: true,
        label: "Tribute Token Address",
        id: addressId,
        helperText: fetchState,
        success: tokenName,
        error: tokenError,
        rules: tokenAddressRules,
        placeholder: "0x..."
      }), needsApproval && tokenData && (0, import_jsx_runtime2.jsx)(TemporaryWarning, {
        setNeedsApproval,
        tokenName: tokenData === null || tokenData === void 0 ? void 0 : tokenData.tokenName,
        tokenAddress
      })]
    }), (0, import_jsx_runtime2.jsx)(FieldSpacer, {
      children: (0, import_jsx_runtime2.jsx)(WrappedInput, {
        full: true,
        label: "Tribute Token Amount",
        id: amtId,
        disabled: needsApproval,
        rules: tokenAmtRules,
        rightAddon: maxButton,
        defaultValue: "0"
      })
    })]
  });
};
var TxStates;
(function(TxStates2) {
  TxStates2["Idle"] = "Idle";
  TxStates2["Loading"] = "Loading";
  TxStates2["Error"] = "Error";
  TxStates2["Success"] = "Token Approved!";
})(TxStates || (TxStates = {}));
var TemporaryWarning = ({
  tokenName,
  tokenAddress,
  setNeedsApproval
}) => {
  const {
    fireTransaction
  } = useTxBuilder();
  const [txState, setTxState] = (0, import_react3.useState)(TxStates.Idle);
  const {
    errorToast,
    successToast
  } = useToast();
  const handleApprove = () => __awaiter(void 0, void 0, void 0, function* () {
    setTxState(TxStates.Loading);
    yield fireTransaction({
      tx: APPROVE_TX,
      callerState: {
        tokenAddress
      },
      lifeCycleFns: {
        onTxError(error) {
          const errMsg = (0, import_utils12.handleErrorMessage)({
            error
          });
          setTxState(TxStates.Error);
          errorToast({
            title: TxStates.Error,
            description: errMsg
          });
        },
        onTxSuccess() {
          setNeedsApproval(false);
          setTxState(TxStates.Success);
          successToast({
            title: TxStates.Success,
            description: `DAOhaus is approved to spend ${tokenName} on your behalf.`
          });
        }
      }
    });
  });
  return (0, import_jsx_runtime2.jsx)(FieldAlert, Object.assign({
    className: "warning",
    message: `You must approve ${tokenName || "Token"} to submit`
  }, {
    children: (0, import_jsx_runtime2.jsx)(Button, Object.assign({
      size: "sm",
      onClick: handleApprove
    }, {
      children: txState === TxStates.Loading ? "Loading..." : "Approve"
    }))
  }));
};
var $3 = _export;
var uncurryThis = functionUncurryThisClause;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var toLength = toLength$4;
var toString6 = toString$b;
var notARegExp = notARegexp;
var requireObjectCoercible = requireObjectCoercible$9;
var correctIsRegExpLogic = correctIsRegexpLogic;
var nativeStartsWith = uncurryThis("".startsWith);
var stringSlice = uncurryThis("".slice);
var min3 = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
var MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
  var descriptor = getOwnPropertyDescriptor2(String.prototype, "startsWith");
  return descriptor && !descriptor.writable;
}();
$3({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString) {
    var that = toString6(requireObjectCoercible(this));
    notARegExp(searchString);
    var index2 = toLength(min3(arguments.length > 1 ? arguments[1] : void 0, that.length));
    var search2 = toString6(searchString);
    return nativeStartsWith ? nativeStartsWith(that, search2, index2) : stringSlice(that, index2, index2 + search2.length) === search2;
  }
});
var WalletConnectVersion;
(function(WalletConnectVersion2) {
  WalletConnectVersion2[WalletConnectVersion2["NONE"] = 0] = "NONE";
  WalletConnectVersion2[WalletConnectVersion2["V1"] = 1] = "V1";
  WalletConnectVersion2[WalletConnectVersion2["V2"] = 2] = "V2";
})(WalletConnectVersion || (WalletConnectVersion = {}));
var getWalletConnectVersion = (uri) => {
  var _a, _b;
  const encodedURI = encodeURI(uri);
  return ((_b = (_a = encodedURI === null || encodedURI === void 0 ? void 0 : encodedURI.split("@")) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b[0]) === "1" ? WalletConnectVersion.V1 : WalletConnectVersion.V2;
};
var isObjectEIP712TypedData = (obj) => {
  return typeof obj === "object" && obj != null && "domain" in obj && "types" in obj && "message" in obj;
};
var getDecodedMessage = (message) => {
  if ((0, import_utils13.isHexString)(message)) {
    try {
      return (0, import_utils13.toUtf8String)(message);
    } catch (e2) {
    }
  }
  return message;
};
var encodeSafeSignMessage = (chainId, message) => {
  const signLibAddress = import_keychain_utils.CONTRACT_KEYCHAINS.GNOSIS_SIGNLIB[chainId];
  const signedTypedMessage = (message2) => {
    if (isObjectEIP712TypedData(message2)) {
      const typesCopy = Object.assign({}, message2.types);
      delete typesCopy.EIP712Domain;
      return import_utils13._TypedDataEncoder.hash(message2.domain, typesCopy, message2.message);
    }
    return (0, import_utils13.hashMessage)(getDecodedMessage(message2));
  };
  const msgHash = signedTypedMessage(message);
  const data2 = (0, import_utils12.encodeFunction)(import_abis.LOCAL_ABI.GNOSIS_SIGNLIB, "signMessage", [msgHash]);
  if (signLibAddress && typeof data2 === "string") {
    return {
      to: signLibAddress,
      data: data2,
      value: "0",
      operation: "1"
    };
  }
  return void 0;
};
var rejectWithMessage = (connector, id2, message) => {
  connector.rejectRequest({
    id: id2,
    error: {
      message
    }
  });
};
var useWalletConnect = () => {
  const [wcClientData, setWcClientData] = (0, import_react3.useState)();
  const [txPayload, setTxPayload] = (0, import_react3.useState)();
  const [wcConnector, setConnector] = (0, import_react3.useState)();
  const [localStorageSessionKey, setLocalStorageSessionKey] = (0, import_react3.useState)("");
  const [txError, setTxError] = (0, import_react3.useState)("");
  const wcDisconnect = (0, import_react3.useCallback)((session) => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield session.killSession();
    } catch (error) {
      console.error("Error trying to close WC session: ", error);
    } finally {
      setConnector(void 0);
      setWcClientData(void 0);
      localStorage.removeItem(localStorageSessionKey);
      setLocalStorageSessionKey("");
      setTxError("");
    }
  }), [localStorageSessionKey]);
  const wcConnect = (0, import_react3.useCallback)(({
    chainId,
    safeAddress,
    session,
    uri
  }) => __awaiter(void 0, void 0, void 0, function* () {
    const connector = new esm_default5({
      uri,
      session,
      storageId: `session_${safeAddress}`
    });
    setConnector(connector);
    setWcClientData(connector.peerMeta || void 0);
    setLocalStorageSessionKey(`session_${safeAddress}`);
    connector.on("session_request", (error, payload) => {
      if (error) {
        setTxError(error.message);
        throw error;
      }
      connector.approveSession({
        accounts: [safeAddress],
        chainId: Number(chainId)
      });
      setWcClientData(payload.params[0].peerMeta);
    });
    connector.on("call_request", (error, payload) => __awaiter(void 0, void 0, void 0, function* () {
      setTxError("");
      try {
        if (error) {
          setTxError(error.message);
          throw error;
        }
        switch (payload.method) {
          case "eth_sendTransaction": {
            setTxPayload(payload);
            break;
          }
          case "personal_sign": {
            const [message] = payload.params;
            if (message.startsWith("0x")) {
              const tx = encodeSafeSignMessage(chainId, message);
              setTxPayload(Object.assign(Object.assign({}, payload), {
                params: [tx]
              }));
            } else {
              const errorMsg = "Tx personal_sign has the wrong format";
              setTxError(errorMsg);
              rejectWithMessage(connector, payload.id, errorMsg);
            }
            break;
          }
          case "eth_signTypedData":
          case "eth_signTypedData_v4": {
            const [, typedDataString] = payload.params;
            const typedData = JSON.parse(typedDataString);
            if (isObjectEIP712TypedData(typedData)) {
              const tx = encodeSafeSignMessage(chainId, typedData);
              setTxPayload(Object.assign(Object.assign({}, payload), {
                params: [tx]
              }));
            } else {
              const errorMsg = "Tx eth_signTypedData has the wrong format";
              setTxError(errorMsg);
              rejectWithMessage(connector, payload.id, errorMsg);
            }
            break;
          }
          default: {
            const errorMsg = "Tx type not supported";
            setTxError(errorMsg);
            rejectWithMessage(connector, payload.id, errorMsg);
            break;
          }
        }
      } catch (exception) {
        const errorMsg = exception.message;
        setTxError(errorMsg);
        rejectWithMessage(connector, payload.id, errorMsg);
      }
    }));
    connector.on("disconnect", (error) => {
      if (error) {
        throw error;
      }
      setTxPayload(void 0);
      if (wcConnector)
        wcDisconnect(wcConnector);
    });
  }), [wcConnector, wcDisconnect]);
  return {
    wcConnector,
    wcClientData,
    txPayload,
    txError,
    wcConnect,
    wcDisconnect
  };
};
if (!process.env["NX_WALLET_CONNECT_ID"]) {
  throw new Error("You need to provide NX_WALLET_CONNECT_ID env variable");
}
var WALLETCONNECT_V2_PROJECT_ID = process.env["NX_WALLET_CONNECT_ID"];
var WALLET_METADATA = {
  name: "DAOHaus Admin",
  description: "Interact with external contracts and applications",
  url: "https://admin.daohaus.club",
  icons: []
};
var EVMBasedNamespaces = "eip155";
var compatibleSafeMethods = ["eth_accounts", "net_version", "eth_chainId", "personal_sign", "eth_sign", "eth_signTypedData", "eth_signTypedData_v4", "eth_sendTransaction", "eth_blockNumber", "eth_getBalance", "eth_getCode", "eth_getTransactionCount", "eth_getStorageAt", "eth_getBlockByNumber", "eth_getBlockByHash", "eth_getTransactionByHash", "eth_getTransactionReceipt", "eth_estimateGas", "eth_call", "eth_getLogs", "eth_gasPrice", "wallet_getPermissions", "wallet_requestPermissions", "safe_setSettings"];
var UNSUPPORTED_CHAIN_ERROR_CODE = 5100;
var INVALID_METHOD_ERROR_CODE = 1001;
var USER_REJECTED_REQUEST_CODE = 4001;
var USER_DISCONNECTED_CODE = 6e3;
var rejectResponse = (id2, code2, message) => {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: {
      code: code2,
      message
    }
  };
};
var useWalletConnectV2 = () => {
  const [web3wallet, setWeb3wallet] = (0, import_react3.useState)();
  const [wcSession, setWcSession] = (0, import_react3.useState)();
  const [isWallectConnectInitialized, setIsWallectConnectInitialized] = (0, import_react3.useState)(false);
  const [chainId, setChainId] = (0, import_react3.useState)();
  const [safeAddress, setSafeAddress] = (0, import_react3.useState)();
  const [txPayload, setTxPayload] = (0, import_react3.useState)();
  const [error, setError] = (0, import_react3.useState)();
  (0, import_react3.useEffect)(() => {
    const initializeWalletConnectV2Client = () => __awaiter(void 0, void 0, void 0, function* () {
      const core = new xr({
        projectId: WALLETCONNECT_V2_PROJECT_ID
      });
      const web3wallet2 = yield G5.init({
        core,
        metadata: WALLET_METADATA
      });
      setWeb3wallet(web3wallet2);
    });
    try {
      initializeWalletConnectV2Client();
    } catch (error2) {
      console.log("Error on walletconnect version 2 initialization: ", error2);
      setIsWallectConnectInitialized(true);
    }
  }, []);
  (0, import_react3.useEffect)(() => {
    if (isWallectConnectInitialized && web3wallet && wcSession) {
      web3wallet.on("session_request", (event) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const {
          topic,
          id: id2
        } = event;
        const {
          request,
          chainId: transactionChainId
        } = event.params;
        const {
          method,
          params
        } = request;
        const isSafeChainId = transactionChainId === `${EVMBasedNamespaces}:${chainId}`;
        if (!isSafeChainId) {
          const errorMessage = `Transaction rejected: the connected Dapp is not set to the correct chain.`;
          setError(errorMessage);
          yield web3wallet.respondSessionRequest({
            topic,
            response: rejectResponse(id2, UNSUPPORTED_CHAIN_ERROR_CODE, errorMessage)
          });
          return;
        }
        try {
          setError(void 0);
          switch (method) {
            case "eth_sendTransaction": {
              setTxPayload({
                id: id2,
                jsonrpc: "2.0",
                method,
                params
              });
              break;
            }
            case "personal_sign": {
              const [message] = params;
              if (message.startsWith("0x")) {
                const tx = encodeSafeSignMessage(`0x${chainId === null || chainId === void 0 ? void 0 : chainId.toString(16)}`, message);
                if (tx) {
                  setTxPayload({
                    id: id2,
                    jsonrpc: "2.0",
                    method,
                    params: [tx]
                  });
                  break;
                }
              }
              const errorMsg = "Tx personal_sign has the wrong format";
              setError(errorMsg);
              yield web3wallet.respondSessionRequest({
                topic,
                response: rejectResponse(id2, INVALID_METHOD_ERROR_CODE, errorMsg)
              });
              break;
            }
            case "eth_signTypedData":
            case "eth_signTypedData_v4": {
              const [, typedDataString] = params;
              const typedData = JSON.parse(typedDataString);
              if (isObjectEIP712TypedData(typedData)) {
                const tx = encodeSafeSignMessage(`0x${chainId === null || chainId === void 0 ? void 0 : chainId.toString(16)}`, typedData);
                if (tx) {
                  setTxPayload({
                    id: id2,
                    jsonrpc: "2.0",
                    method,
                    params: [tx]
                  });
                  break;
                }
              }
              const errorMsg = "Tx eth_signTypedData has the wrong format";
              setError(errorMsg);
              yield web3wallet.respondSessionRequest({
                topic,
                response: rejectResponse(id2, INVALID_METHOD_ERROR_CODE, errorMsg)
              });
              break;
            }
            default: {
              const errorMsg = "Tx type not supported";
              setError(errorMsg);
              yield web3wallet.respondSessionRequest({
                topic,
                response: rejectResponse(id2, INVALID_METHOD_ERROR_CODE, errorMsg)
              });
              break;
            }
          }
        } catch (error2) {
          const errorMsg = error2 === null || error2 === void 0 ? void 0 : error2.message;
          setError(errorMsg);
          const isUserRejection = (_a = errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.includes) === null || _a === void 0 ? void 0 : _a.call(errorMsg, "Transaction was rejected");
          const code2 = isUserRejection ? USER_REJECTED_REQUEST_CODE : INVALID_METHOD_ERROR_CODE;
          yield web3wallet.respondSessionRequest({
            topic,
            response: rejectResponse(id2, code2, errorMsg)
          });
        }
      }));
    }
  }, [chainId, wcSession, isWallectConnectInitialized, web3wallet]);
  (0, import_react3.useEffect)(() => {
    if (!isWallectConnectInitialized && web3wallet && chainId && safeAddress) {
      const activeSessions = web3wallet.getActiveSessions();
      const compatibleSession = Object.keys(activeSessions).map((topic) => activeSessions[topic]).find(
        (session) => session.namespaces[EVMBasedNamespaces].accounts[0] === `${EVMBasedNamespaces}:${chainId}:${safeAddress}`
      );
      if (compatibleSession) {
        setWcSession(compatibleSession);
        setIsWallectConnectInitialized(true);
      }
    }
  }, [chainId, safeAddress, web3wallet, isWallectConnectInitialized]);
  const wcConnect = (0, import_react3.useCallback)(({
    chainId: chainId2,
    safeAddress: safeAddress2,
    uri
  }) => __awaiter(void 0, void 0, void 0, function* () {
    if (web3wallet) {
      setChainId(Number(chainId2));
      setSafeAddress(safeAddress2);
      web3wallet.on("session_proposal", (proposal) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const {
          id: id2,
          params
        } = proposal;
        const {
          requiredNamespaces
        } = params;
        const safeAccount = `${EVMBasedNamespaces}:${Number(chainId2)}:${safeAddress2}`;
        const safeChain = `${EVMBasedNamespaces}:${Number(chainId2)}`;
        const safeEvents = ((_a = requiredNamespaces[EVMBasedNamespaces]) === null || _a === void 0 ? void 0 : _a.events) || [];
        try {
          const wcSession2 = yield web3wallet.approveSession({
            id: id2,
            namespaces: {
              eip155: {
                accounts: [safeAccount],
                chains: [safeChain],
                methods: compatibleSafeMethods,
                events: safeEvents
              }
            }
          });
          setWcSession(wcSession2);
          setError(void 0);
        } catch (error2) {
          console.log("session_proposal error: ", error2);
          setError(error2.message);
          const errorMessage = `Connection refused: This Safe Account is in chain ${chainId2} but the Wallet Connect session proposal is invalid as it required different chain`;
          yield web3wallet.rejectSession({
            id: proposal.id,
            reason: {
              code: UNSUPPORTED_CHAIN_ERROR_CODE,
              message: errorMessage
            }
          });
        }
      }));
      web3wallet.on("session_delete", () => __awaiter(void 0, void 0, void 0, function* () {
        setWcSession(void 0);
        setError(void 0);
      }));
      setIsWallectConnectInitialized(true);
      yield web3wallet.core.pairing.pair({
        uri
      });
    }
  }), [web3wallet]);
  const wcDisconnect = (0, import_react3.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {
    if (wcSession && web3wallet) {
      yield web3wallet.disconnectSession({
        topic: wcSession.topic,
        reason: {
          code: USER_DISCONNECTED_CODE,
          message: "User disconnected. Safe Wallet Session ended by the user"
        }
      });
      setWcSession(void 0);
      setError(void 0);
    }
  }), [web3wallet, wcSession]);
  const wcClientData = wcSession === null || wcSession === void 0 ? void 0 : wcSession.peer.metadata;
  return {
    wcConnect,
    wcClientData,
    wcDisconnect,
    txPayload,
    isWallectConnectInitialized,
    error
  };
};
var img = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8'%3f%3e%3csvg width='300px' height='185px' viewBox='0 0 300 185' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e %3ctitle%3eWalletConnect%3c/title%3e %3cdesc%3eCreated with Sketch.%3c/desc%3e %3cdefs%3e%3c/defs%3e %3cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3e %3cg id='walletconnect-logo-alt' fill='%233B99FC' fill-rule='nonzero'%3e %3cpath d='M61.4385429%2c36.2562612 C110.349767%2c-11.6319051 189.65053%2c-11.6319051 238.561752%2c36.2562612 L244.448297%2c42.0196786 C246.893858%2c44.4140867 246.893858%2c48.2961898 244.448297%2c50.690599 L224.311602%2c70.406102 C223.088821%2c71.6033071 221.106302%2c71.6033071 219.883521%2c70.406102 L211.782937%2c62.4749541 C177.661245%2c29.0669724 122.339051%2c29.0669724 88.2173582%2c62.4749541 L79.542302%2c70.9685592 C78.3195204%2c72.1657633 76.337001%2c72.1657633 75.1142214%2c70.9685592 L54.9775265%2c51.2530561 C52.5319653%2c48.8586469 52.5319653%2c44.9765439 54.9775265%2c42.5821357 L61.4385429%2c36.2562612 Z M280.206339%2c77.0300061 L298.128036%2c94.5769031 C300.573585%2c96.9713 300.573599%2c100.85338 298.128067%2c103.247793 L217.317896%2c182.368927 C214.872352%2c184.763353 210.907314%2c184.76338 208.461736%2c182.368989 C208.461726%2c182.368979 208.461714%2c182.368967 208.461704%2c182.368957 L151.107561%2c126.214385 C150.496171%2c125.615783 149.504911%2c125.615783 148.893521%2c126.214385 C148.893517%2c126.214389 148.893514%2c126.214393 148.89351%2c126.214396 L91.5405888%2c182.368927 C89.095052%2c184.763359 85.1300133%2c184.763399 82.6844276%2c182.369014 C82.6844133%2c182.369 82.684398%2c182.368986 82.6843827%2c182.36897 L1.87196327%2c103.246785 C-0.573596939%2c100.852377 -0.573596939%2c96.9702735 1.87196327%2c94.5758653 L19.7936929%2c77.028998 C22.2392531%2c74.6345898 26.2042918%2c74.6345898 28.6498531%2c77.028998 L86.0048306%2c133.184355 C86.6162214%2c133.782957 87.6074796%2c133.782957 88.2188704%2c133.184355 C88.2188796%2c133.184346 88.2188878%2c133.184338 88.2188969%2c133.184331 L145.571%2c77.028998 C148.016505%2c74.6345347 151.981544%2c74.6344449 154.427161%2c77.028798 C154.427195%2c77.0288316 154.427229%2c77.0288653 154.427262%2c77.028899 L211.782164%2c133.184331 C212.393554%2c133.782932 213.384814%2c133.782932 213.996204%2c133.184331 L271.350179%2c77.0300061 C273.79574%2c74.6355969 277.760778%2c74.6355969 280.206339%2c77.0300061 Z' id='WalletConnect'%3e%3c/path%3e %3c/g%3e %3c/g%3e%3c/svg%3e";
var _$1 = (t2) => t2;
var _t$1;
var _t22;
var _t32;
var _t42;
var Status;
(function(Status2) {
  Status2[Status2["DISCONNECTED"] = 0] = "DISCONNECTED";
  Status2[Status2["CONNECTING"] = 1] = "CONNECTING";
  Status2[Status2["CONNECTED"] = 2] = "CONNECTED";
})(Status || (Status = {}));
var WalletConectContainer = st.div(_t$1 || (_t$1 = _$1`
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  border-radius: ${0};
  border: 1px ${0} solid;
  background-color: ${0};
  padding: 2.2rem;
  img {
    margin-bottom: 2.7rem;
    width: 20%;
  }
`), ({
  theme
}) => theme.card.radius, ({
  theme
}) => theme.secondary.step5, ({
  theme
}) => theme.secondary.step3);
var BaseContainer = st.div(_t22 || (_t22 = _$1`
  display: flex;
  flex-direction: column;
  align-items: center;
  p {
    text-align: center;
    margin-bottom: 2.7rem;
  }
`));
var ButtonsContainer = st.div(_t32 || (_t32 = _$1`
  display: flex;
  justify-content: space-evenly;
  padding-top: 2.2rem;
  width: 70%;
`));
var SuccessIcon = st(BsCheckCircle)(_t42 || (_t42 = _$1`
  color: green;
  width: 30px;
  height: 30px;
  margin-bottom: 1rem;
`));
var WalletConnectLink = (_a) => {
  var _b;
  var {
    icon,
    id: id2,
    rules
  } = _a, props = __rest(_a, ["icon", "id", "rules"]);
  const {
    dao
  } = useDaoData();
  const {
    register,
    setValue,
    watch
  } = useFormContext();
  const {
    daoChain
  } = useCurrentDao();
  const {
    wcConnector,
    txPayload: txPayloadV1,
    wcClientData: wcClientDataV1,
    wcConnect: wcConnectV1,
    wcDisconnect: wcDisconnectV1,
    txError: txErrorV1
  } = useWalletConnect();
  const {
    txPayload: txPayloadV2,
    wcClientData: wcClientDataV2,
    wcConnect: wcConnectV2,
    wcDisconnect: wcDisconnectV2,
    error: txErrorV2
  } = useWalletConnectV2();
  const wcClientData = wcClientDataV1 || wcClientDataV2;
  const txPayload = txPayloadV1 || txPayloadV2;
  const txError = txErrorV1 || txErrorV2;
  const inputId = "wcLink";
  const [wcVersion, setWCVersion] = (0, import_react3.useState)();
  const [connectionStatus, setConnectionStatus] = (0, import_react3.useState)(Status.DISCONNECTED);
  const wcLink = watch(inputId);
  (0, import_react3.useEffect)(() => {
    register("txTo");
    register("txData");
    register("txValue");
    register("txOperation");
  }, [register]);
  (0, import_react3.useEffect)(() => {
    if (dao && daoChain && (wcLink === null || wcLink === void 0 ? void 0 : wcLink.startsWith("wc:")) && connectionStatus === Status.DISCONNECTED) {
      const params = {
        chainId: daoChain,
        safeAddress: dao.safeAddress,
        uri: wcLink
      };
      setConnectionStatus(Status.CONNECTING);
      const version2 = getWalletConnectVersion(wcLink);
      setWCVersion(version2);
      if (version2 === WalletConnectVersion.V1) {
        wcConnectV1(params);
      } else {
        wcConnectV2(params);
      }
    }
  }, [connectionStatus, dao, daoChain, wcConnectV1, wcConnectV2, wcLink]);
  const clean = () => {
    [inputId, "txTo", "txData", "txValue", "txOperation"].forEach((formInput) => setValue(formInput, ""));
    setConnectionStatus(Status.DISCONNECTED);
  };
  const onDisconnect = () => {
    if (wcVersion === WalletConnectVersion.V1) {
      if (wcConnector)
        wcDisconnectV1(wcConnector);
    } else {
      wcDisconnectV2();
    }
    clean();
  };
  (0, import_react3.useEffect)(() => {
    var _a2;
    if ((_a2 = txPayload === null || txPayload === void 0 ? void 0 : txPayload.params) === null || _a2 === void 0 ? void 0 : _a2.length) {
      setValue("txTo", txPayload.params[0].to);
      setValue("txData", txPayload.params[0].data);
      setValue("txValue", txPayload.params[0].value || "0");
      setValue("txOperation", txPayload.params[0].operation || "0");
    }
  }, [setValue, txPayload]);
  return (0, import_jsx_runtime2.jsxs)(FieldWrapper, Object.assign({
    id: "walletConnectWrapper",
    full: true,
    label: "WalletConnect Link"
  }, {
    children: [(0, import_jsx_runtime2.jsx)(HighlightInputText, {
      id: "walletConnectDesc",
      description: "Connect your DAO Safe to a dApp via WalletConnect and trigger transactions."
    }), (0, import_jsx_runtime2.jsx)(FieldSpacer, {}), (0, import_jsx_runtime2.jsx)(WrappedInput, Object.assign({}, props, {
      icon: FaQrcode,
      id: inputId,
      disabled: connectionStatus === Status.CONNECTED,
      rules,
      error: txError ? {
        type: "error",
        message: txError
      } : void 0
    })), (0, import_jsx_runtime2.jsxs)(WalletConectContainer, {
      children: [(0, import_jsx_runtime2.jsx)("img", {
        alt: "WalletConnect App Logo",
        src: ((_b = wcClientData === null || wcClientData === void 0 ? void 0 : wcClientData.icons) === null || _b === void 0 ? void 0 : _b.length) ? wcClientData.icons[0] : img
      }), connectionStatus === Status.DISCONNECTED && (0, import_jsx_runtime2.jsx)(ParMd, {
        children: "Add WalletConnect link to preview the transaction"
      }), connectionStatus === Status.CONNECTING && (0, import_jsx_runtime2.jsx)("div", {
        children: !wcClientData ? (0, import_jsx_runtime2.jsxs)(BaseContainer, {
          children: [(0, import_jsx_runtime2.jsx)(Loading, {
            margin: "2.2rem"
          }), (0, import_jsx_runtime2.jsx)(Button, Object.assign({
            onClick: onDisconnect
          }, {
            children: "Cancel"
          }))]
        }) : (0, import_jsx_runtime2.jsxs)(BaseContainer, {
          children: [(0, import_jsx_runtime2.jsx)(ParSm, {
            children: `Trying to connect to ${wcClientData === null || wcClientData === void 0 ? void 0 : wcClientData.name}`
          }), (0, import_jsx_runtime2.jsxs)(ButtonsContainer, {
            children: [(0, import_jsx_runtime2.jsx)(Button, Object.assign({
              onClick: () => setConnectionStatus(Status.CONNECTED)
            }, {
              children: "Continue"
            })), (0, import_jsx_runtime2.jsx)(Button, Object.assign({
              onClick: onDisconnect
            }, {
              children: "Cancel"
            }))]
          })]
        })
      }), connectionStatus === Status.CONNECTED && (0, import_jsx_runtime2.jsxs)(BaseContainer, {
        children: [(0, import_jsx_runtime2.jsx)(ParSm, {
          children: wcClientData === null || wcClientData === void 0 ? void 0 : wcClientData.name
        }), (0, import_jsx_runtime2.jsx)(ParSm, {
          children: "CONNECTED"
        }), (0, import_jsx_runtime2.jsx)(ParSm, {
          children: "You need to keep this open for transactions to pop up and be sent as a proposal."
        }), !txPayload ? (0, import_jsx_runtime2.jsxs)(BaseContainer, {
          children: [(0, import_jsx_runtime2.jsx)(Loading, {
            margin: "1rem"
          }), (0, import_jsx_runtime2.jsx)(ParSm, {
            children: "Waiting for a Tx to be triggered..."
          })]
        }) : (0, import_jsx_runtime2.jsxs)(BaseContainer, {
          children: [(0, import_jsx_runtime2.jsx)(Icon$1, {
            children: (0, import_jsx_runtime2.jsx)(SuccessIcon, {})
          }), (0, import_jsx_runtime2.jsx)(ParSm, {
            children: "Tx Ready to Submit!"
          })]
        }), (0, import_jsx_runtime2.jsx)(Button, Object.assign({
          onClick: onDisconnect
        }, {
          children: "Disconnect"
        }))]
      })]
    })]
  }));
};
var _5 = (t2) => t2;
var _t8;
var EpochDatePicker = (props) => {
  const {
    setValue
  } = useFormContext();
  const [startDate, setStartDate] = (0, import_react3.useState)(new Date());
  const handleChange = (date) => {
    setStartDate(date);
    setValue(props.id, +date / 1e3);
  };
  const DatePickerWrapperStylesLg = at(_t8 || (_t8 = _5`

  .react-datepicker {
    font-size: 2rem;
    font-family: inherit;
  }
  .react-datepicker__day-name, .react-datepicker__day, .react-datepicker__time-name {
    width: 5rem;
    height: 3rem;
  }
  .react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box, .react-datepicker__time-container {
    width: 150px;
    height: 200px;
  }
  .react-datepicker__time-container .react-datepicker__time .react-datepicker__time-box ul.react-datepicker__time-list {
    height: 200px;
  }


`));
  const CustomInput = (0, import_react3.forwardRef)(({
    value,
    onClick
  }, ref) => (0, import_jsx_runtime2.jsx)(Button, Object.assign({
    IconLeft: RiCalendar2Fill,
    IconRight: RiArrowDropDownFill,
    className: "custom-button-input",
    onClick,
    ref
  }, {
    children: value
  })));
  return (0, import_jsx_runtime2.jsxs)(FieldWrapper, Object.assign({
    id: props.id,
    label: props === null || props === void 0 ? void 0 : props.label,
    rules: props === null || props === void 0 ? void 0 : props.rules,
    helperText: props === null || props === void 0 ? void 0 : props.helperText
  }, {
    children: [(0, import_jsx_runtime2.jsx)(tr3, {
      id: props.id,
      selected: startDate,
      onChange: (date) => handleChange(date),
      showTimeSelect: true,
      customInput: (0, import_jsx_runtime2.jsx)(CustomInput, {}),
      wrapperClassName: props === null || props === void 0 ? void 0 : props.className,
      dateFormat: "Pp"
    }), (props === null || props === void 0 ? void 0 : props.className) === "lg" && (0, import_jsx_runtime2.jsx)(DatePickerWrapperStylesLg, {})]
  }));
};
var MolochFields = Object.assign(Object.assign({}, CoreFieldLookup), {
  proposalExpiry: ProposalExpiry,
  selectApplicant: SelectApplicant,
  tributeInput: TributeInput,
  requestNativeToken: RequestNativeToken,
  requestERC20: RequestERC20,
  shamanPermissionDeluxe: ShamanDeluxe,
  tagsInput: TagsInput,
  proposalOffering: ProposalOffering,
  delegateInput: DelegateInput,
  ragequitToken: RagequitToken,
  ragequitTokenList: RagequitTokenList,
  walletConnectLink: WalletConnectLink,
  metadataLink: MetadataLink,
  safeSelect: SafeSelect,
  multisendActions: MultisendActions,
  addressesAndAmounts: AddressesAndAmounts,
  epochDatePicker: EpochDatePicker,
  markdownField: MarkdownField
});

export {
  BiSearch,
  MdOutlineGavel,
  Markdown,
  CollapsibleFormSegment,
  validateAddressesAndAmountsData,
  transformAddressesAndAmountsData,
  sortTokensForRageQuit,
  getErc20s,
  getNetworkToken,
  isActiveMember,
  AddressesAndAmounts,
  DelegateInput,
  MarkdownField,
  MetadataLink,
  MultisendActions,
  ProposalExpiry,
  ProposalOffering,
  RagequitToken,
  RagequitTokenList,
  InputStates,
  RequestERC20,
  RequestNativeToken,
  SafeSelect,
  SelectApplicant,
  ShamanDeluxe,
  TagsInput,
  TributeInput,
  WalletConnectVersion,
  getWalletConnectVersion,
  isObjectEIP712TypedData,
  encodeSafeSignMessage,
  useWalletConnect,
  WalletConnectLink,
  EpochDatePicker,
  MolochFields
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/**
 * @remix-run/router v1.0.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.4.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.4.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
//# sourceMappingURL=chunk-YZTPB5VT.js.map
