import {
  require_src as require_src4,
  require_src2 as require_src5
} from "./chunk-SYS7556B.js";
import {
  require_src
} from "./chunk-R7RRHWOA.js";
import {
  createPublicClient,
  getAccount,
  init_dist,
  init_esm,
  zeroAddress
} from "./chunk-M75A2V3Z.js";
import {
  decodeFunctionData
} from "./chunk-DMOAGK44.js";
import {
  decodeAbiParameters,
  fromHex,
  getAbiItem,
  trim
} from "./chunk-JP6YUYUV.js";
import {
  require_src as require_src3
} from "./chunk-KYOZVWPW.js";
import {
  require_jsx_runtime
} from "./chunk-GYNMGCXV.js";
import {
  require_react
} from "./chunk-T5BEU6ZH.js";
import {
  require_src as require_src2
} from "./chunk-EBQ4QPBR.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-LMAYTEU7.js";

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key2}" in client code.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number2, base2, endian) {
        if (BN3.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer = window.Buffer;
        } else {
          Buffer = require_buffer().Buffer;
        }
      } catch (e) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init3(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert3(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN3.prototype._initArray = function _initArray(number2, base2, endian) {
        assert3(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {
            w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number2.length; i += 3) {
            w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert3(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r2 = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r2 |= parseHex4Bits(string, index - 1) << 4;
        }
        return r2;
      }
      BN3.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number2.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
            w = parseHexByte(number2, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r2 = 0;
        var b2 = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r2 *= mul3;
          if (c >= 49) {
            b2 = c - 49 + 10;
          } else if (c >= 17) {
            b2 = c - 17 + 10;
          } else {
            b2 = c;
          }
          assert3(c >= 0 && b2 < mul3, "Invalid character");
          r2 += b2;
        }
        return r2;
      }
      BN3.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow3 = 1;
          word = parseBase(number2, i, number2.length, base2);
          for (i = 0; i < mod2; i++) {
            pow3 *= base2;
          }
          this.imuln(pow3);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN3.prototype.copy = function copy4(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }
      BN3.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN3.prototype.clone = function clone() {
        var r2 = new BN3(null);
        this.copy(r2);
        return r2;
      };
      BN3.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e) {
          BN3.prototype.inspect = inspect4;
        }
      } else {
        BN3.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros3 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString4(base2, padding3) {
        base2 = base2 || 10;
        padding3 = padding3 | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros3[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding3 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r2 = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros3[groupSize - r2.length] + r2 + out;
            } else {
              out = r2 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding3 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber2() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer) {
        BN3.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer, endian, length);
        };
      }
      BN3.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix2 = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix2](res, byteLength);
        return res;
      };
      BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w) {
          var t = w;
          var r2 = 0;
          if (t >= 4096) {
            r2 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r2 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r2 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r2 += 2;
            t >>>= 2;
          }
          return r2 + t;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r2 = 0;
        if ((t & 8191) === 0) {
          r2 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r2 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r2 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r2 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r2++;
        }
        return r2;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r2 = 0;
        for (var i = 0; i < this.length; i++) {
          var b2 = this._zeroBits(this.words[i]);
          r2 += b2;
          if (b2 !== 26)
            break;
        }
        return r2;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos2(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos2(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b2.length;
        return this._strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a;
        var b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = a.words[i] ^ b2.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r2;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r2 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r2 = this.isub(num);
          num.negative = 1;
          return r2._normSign();
        }
        var a, b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r2 = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          this.words[i] = r2 & 67108863;
          carry = r2 >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN3.prototype.add = function add4(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r2 = this.iadd(num);
          num.negative = 1;
          return r2._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b2;
        if (cmp > 0) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r2 = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r2 = (a.words[i] | 0) + carry;
          carry = r2 >> 26;
          this.words[i] = r2 & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r2 = a * b2;
        var lo = r2 & 67108863;
        var carry = r2 / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b2 = num.words[j] | 0;
            r2 = a * b2 + rword;
            ncarry += r2 / 67108864 | 0;
            rword = r2 & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b2 = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b2 = num.words[j] | 0;
            var r2 = a * b2;
            var lo = r2 & 67108863;
            ncarry = ncarry + (r2 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N4) {
        var t = new Array(N4);
        var l = BN3.prototype._countBits(N4) - 1;
        for (var i = 0; i < N4; i++) {
          t[i] = this.revBin(i, l, N4);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N4) {
        if (x === 0 || x === N4 - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N4) {
        for (var i = 0; i < N4; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N4, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N4);
        for (var s = 1; s < N4; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N4; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m) {
        var N4 = Math.max(m, n2) | 1;
        var odd = N4 & 1;
        var i = 0;
        for (N4 = N4 / 2 | 0; N4; N4 = N4 >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N4) {
        if (N4 <= 1)
          return;
        for (var i = 0; i < N4 / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N4 - i - 1];
          rws[N4 - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N4 - i - 1];
          iws[N4 - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N4) {
        var carry = 0;
        for (var i = 0; i < N4 / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N4) * 8192 + Math.round(ws[2 * i] / N4) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N4) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N4; ++i) {
          rws[i] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N4) {
        var ph = new Array(N4);
        for (var i = 0; i < N4; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N4 = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N4);
        var _ = this.stub(N4);
        var rws = new Array(N4);
        var rwst = new Array(N4);
        var iwst = new Array(N4);
        var nrws = new Array(N4);
        var nrwst = new Array(N4);
        var niwst = new Array(N4);
        var rmws = out.words;
        rmws.length = N4;
        this.convert13b(x.words, x.length, rws, N4);
        this.convert13b(y.words, y.length, nrws, N4);
        this.transform(rws, _, rwst, iwst, N4, rbt);
        this.transform(nrws, _, nrwst, niwst, N4, rbt);
        for (var i = 0; i < N4; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N4);
        this.transform(rwst, iwst, rmws, _, N4, rbt);
        this.conjugate(rmws, _, N4);
        this.normalize13b(rmws, N4);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
      };
      BN3.prototype.mul = function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow3(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN3(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
        var i;
        if (r2 !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r2;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r2;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r2 = bits % 26;
        var s = Math.min((bits - r2) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r2 | word >>> r2;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r2 = bits % 26;
        var s = (bits - r2) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r2 !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r2 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r2 << r2;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul3;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m = a.length - b2.length;
        var q;
        if (mode !== "mod") {
          q = new BN3(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b2, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b2.length + j] | 0) * 67108864 + (a.words[b2.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b2, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b2, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN3.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN3.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN3(1);
        var B = new BN3(0);
        var C = new BN3(0);
        var D = new BN3(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN3.prototype._invmp = function _invmp(p) {
        assert3(p.negative === 0);
        assert3(!p.isZero());
        var a = this;
        var b2 = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN3(1);
        var x2 = new BN3(0);
        var delta = b2.clone();
        while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b2.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b2) >= 0) {
            a.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b2 = num.clone();
        a.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
          a.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r2 = a.cmp(b2);
          if (r2 < 0) {
            var t = a;
            a = b2;
            b2 = t;
          } else if (r2 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r2 = bit % 26;
        var s = (bit - r2) / 26;
        var q = 1 << r2;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b2 = num.words[i] | 0;
          if (a === b2)
            continue;
          if (a < b2) {
            res = -1;
          } else if (a > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN3(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r2 = num;
        var rlen;
        do {
          this.split(r2, this.tmp);
          r2 = this.imulK(r2);
          r2 = r2.iadd(this.tmp);
          rlen = r2.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
        if (cmp === 0) {
          r2.words[0] = 0;
          r2.length = 1;
        } else if (cmp > 0) {
          r2.isub(this.p);
        } else {
          if (r2.strip !== void 0) {
            r2.strip();
          } else {
            r2._strip();
          }
        }
        return r2;
      };
      MPrime.prototype.split = function split4(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split4(input, output2) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output2.words[i] = input.words[i];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask2;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN3._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert3(a.negative === 0, "red works only with positives");
        assert3(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b2) {
        assert3((a.negative | b2.negative) === 0, "red works only with positives");
        assert3(
          a.red && a.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg3(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add4(a, b2) {
        this._verify2(a, b2);
        var res = a.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b2) {
        this._verify2(a, b2);
        var res = a.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b2) {
        this._verify2(a, b2);
        var res = a.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b2) {
        this._verify2(a, b2);
        var res = a.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.imul(b2));
      };
      Red.prototype.mul = function mul3(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.mul(b2));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow3 = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a, pow3);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert3(!q.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN3(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r2 = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert3(i < m);
          var b2 = this.pow(c, new BN3(1).iushln(m - i - 1));
          r2 = r2.redMul(b2);
          c = b2.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r2;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow3(a, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r2 = num.umod(this.m);
        return r2 === num ? r2.clone() : r2;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r2 = this.imod(num.mul(this.rinv));
        r2.red = null;
        return r2;
      };
      Mont.prototype.imul = function imul(a, b2) {
        if (a.isZero() || b2.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a, b2) {
        if (a.isZero() || b2.isZero())
          return new BN3(0)._forceRed(this);
        var t = a.mul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version;
var init_version = __esm({
  "node_modules/@ethersproject/logger/lib.esm/_version.js"() {
    version = "logger/5.7.0";
  }
});

// node_modules/@ethersproject/logger/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  ErrorCode: () => ErrorCode,
  LogLevel: () => LogLevel,
  Logger: () => Logger
});
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _permanentCensorErrors, _censorErrors, LogLevels, _logLevel, _globalLogger, _normalizeError, LogLevel, ErrorCode, HEX, Logger;
var init_lib = __esm({
  "node_modules/@ethersproject/logger/lib.esm/index.js"() {
    "use strict";
    init_version();
    _permanentCensorErrors = false;
    _censorErrors = false;
    LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    _logLevel = LogLevels["default"];
    _globalLogger = null;
    _normalizeError = _checkNormalize();
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode || (ErrorCode = {}));
    HEX = "0123456789abcdef";
    Logger = class {
      constructor(version29) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version29,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(Logger.levels.DEBUG, args);
      }
      info(...args) {
        this._log(Logger.levels.INFO, args);
      }
      warn(...args) {
        this._log(Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key2) => {
          const value = params[key2];
          try {
            if (value instanceof Uint8Array) {
              let hex = "";
              for (let i = 0; i < value.length; i++) {
                hex += HEX[value[i] >> 4];
                hex += HEX[value[i] & 15];
              }
              messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
            } else {
              messageDetails.push(key2 + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key2) {
          error[key2] = params[key2];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new Logger(version);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          Logger.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version29) {
        return new Logger(version29);
      }
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
  }
});

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2;
var init_version2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/_version.js"() {
    version2 = "bytes/5.7.0";
  }
});

// node_modules/@ethersproject/bytes/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  arrayify: () => arrayify,
  concat: () => concat,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  joinSignature: () => joinSignature,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  zeroPad: () => zeroPad
});
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object2) => {
    result.set(object2, offset);
    return offset + object2.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data2) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    return null;
  }
  return (data2.length - 2) / 2;
}
function hexDataSlice(data2, offset, endOffset) {
  if (typeof data2 !== "string") {
    data2 = hexlify(data2);
  } else if (!isHexString(data2) || data2.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data2);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data2.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data2.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes3 = arrayify(signature2);
    if (bytes3.length === 64) {
      result.v = 27 + (bytes3[32] >> 7);
      bytes3[32] &= 127;
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
    } else if (bytes3.length === 65) {
      result.r = hexlify(bytes3.slice(0, 32));
      result.s = hexlify(bytes3.slice(32, 64));
      result.v = bytes3[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes3[32] |= 128;
    }
    result._vs = hexlify(bytes3.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s = hexlify(vs2);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
var logger, HexCharacters;
var init_lib2 = __esm({
  "node_modules/@ethersproject/bytes/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version2();
    logger = new Logger(version2);
    HexCharacters = "0123456789abcdef";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version3;
var init_version3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/_version.js"() {
    version3 = "bignumber/5.7.0";
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
var import_bn, BN, logger2, _constructorGuard, MAX_SAFE, _warnedToStringRadix, BigNumber;
var init_bignumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/bignumber.js"() {
    "use strict";
    import_bn = __toESM(require_bn());
    init_lib2();
    init_lib();
    init_version3();
    BN = import_bn.default.BN;
    logger2 = new Logger(version3);
    _constructorGuard = {};
    MAX_SAFE = 9007199254740991;
    _warnedToStringRadix = false;
    BigNumber = class {
      constructor(constructorGuard, hex) {
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      }
      toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
      }
      abs() {
        if (this._hex[0] === "-") {
          return BigNumber.from(this._hex.substring(1));
        }
        return this;
      }
      add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      }
      pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      }
      and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      }
      or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      }
      xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      }
      mask(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      }
      shl(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      }
      shr(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      }
      eq(other) {
        return toBN(this).eq(toBN(other));
      }
      lt(other) {
        return toBN(this).lt(toBN(other));
      }
      lte(other) {
        return toBN(this).lte(toBN(other));
      }
      gt(other) {
        return toBN(this).gt(toBN(other));
      }
      gte(other) {
        return toBN(this).gte(toBN(other));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return toBN(this).isZero();
      }
      toNumber() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch (e) {
        }
        return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      }
      toString() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(key2) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value) {
        if (value instanceof BigNumber) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new BigNumber(_constructorGuard, toHex(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new BigNumber(_constructorGuard, toHex(new BN(value)));
          }
          return logger2.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") {
          return BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
          return BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            const hex = anyValue.toHexString();
            if (typeof hex === "string") {
              return BigNumber.from(hex);
            }
          } else {
            let hex = anyValue._hex;
            if (hex == null && anyValue.type === "BigNumber") {
              hex = anyValue.hex;
            }
            if (typeof hex === "string") {
              if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
                return BigNumber.from(hex);
              }
            }
          }
        }
        return logger2.throwArgumentError("invalid BigNumber value", "value", value);
      }
      static isBigNumber(value) {
        return !!(value && value._isBigNumber);
      }
    };
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var logger3, _constructorGuard2, Zero, NegativeOne, zeros, FixedFormat, FixedNumber, ONE, BUMP;
var init_fixednumber = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version3();
    init_bignumber();
    logger3 = new Logger(version3);
    _constructorGuard2 = {};
    Zero = BigNumber.from(0);
    NegativeOne = BigNumber.from(-1);
    zeros = "0";
    while (zeros.length < 256) {
      zeros += zeros;
    }
    FixedFormat = class {
      constructor(constructorGuard, signed3, width, decimals) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.signed = signed3;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed3 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
      }
      static from(value) {
        if (value instanceof FixedFormat) {
          return value;
        }
        if (typeof value === "number") {
          value = `fixed128x${value}`;
        }
        let signed3 = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
          if (value === "fixed") {
          } else if (value === "ufixed") {
            signed3 = false;
          } else {
            const match2 = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            if (!match2) {
              logger3.throwArgumentError("invalid fixed format", "format", value);
            }
            signed3 = match2[1] !== "u";
            width = parseInt(match2[2]);
            decimals = parseInt(match2[3]);
          }
        } else if (value) {
          const check2 = (key2, type, defaultValue) => {
            if (value[key2] == null) {
              return defaultValue;
            }
            if (typeof value[key2] !== type) {
              logger3.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
            }
            return value[key2];
          };
          signed3 = check2("signed", "boolean", signed3);
          width = check2("width", "number", width);
          decimals = check2("decimals", "number", decimals);
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
          logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard2, signed3, width, decimals);
      }
    };
    FixedNumber = class {
      constructor(constructorGuard, hex, value, format) {
        if (constructorGuard !== _constructorGuard2) {
          logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
      }
      _checkFormat(other) {
        if (this.format.name !== other.format.name) {
          logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
      }
      addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b2), this.format.decimals, this.format);
      }
      subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b2), this.format.decimals, this.format);
      }
      mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
      }
      divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b2 = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
      }
      floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
          result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
          result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
      }
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        const comps = this.toString().split(".");
        if (comps.length === 1) {
          comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || decimals % 1) {
          logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
          return this;
        }
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
      }
      isZero() {
        return this._value === "0.0" || this._value === "0";
      }
      isNegative() {
        return this._value[0] === "-";
      }
      toString() {
        return this._value;
      }
      toHexString(width) {
        if (width == null) {
          return this._hex;
        }
        if (width % 8) {
          logger3.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return hexZeroPad(hex, width / 8);
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(format) {
        return FixedNumber.fromString(this._value, format);
      }
      static fromValue(value, decimals, format) {
        if (format == null && decimals != null && !isBigNumberish(decimals)) {
          format = decimals;
          decimals = null;
        }
        if (decimals == null) {
          decimals = 0;
        }
        if (format == null) {
          format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
      }
      static fromString(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
          throwFault2("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
          hex = numeric.toTwos(fixedFormat.width).toHexString();
        } else {
          hex = numeric.toHexString();
          hex = hexZeroPad(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static fromBytes(value, format) {
        if (format == null) {
          format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (arrayify(value).length > fixedFormat.width / 8) {
          throw new Error("overflow");
        }
        let numeric = BigNumber.from(value);
        if (fixedFormat.signed) {
          numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
      }
      static from(value, format) {
        if (typeof value === "string") {
          return FixedNumber.fromString(value, format);
        }
        if (isBytes(value)) {
          return FixedNumber.fromBytes(value, format);
        }
        try {
          return FixedNumber.fromValue(value, 0, format);
        } catch (error) {
          if (error.code !== Logger.errors.INVALID_ARGUMENT) {
            throw error;
          }
        }
        return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
      }
      static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
      }
    };
    ONE = FixedNumber.from(1);
    BUMP = FixedNumber.from("0.5");
  }
});

// node_modules/@ethersproject/bignumber/lib.esm/index.js
var init_lib3 = __esm({
  "node_modules/@ethersproject/bignumber/lib.esm/index.js"() {
    init_bignumber();
    init_fixednumber();
    init_bignumber();
  }
});

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version4;
var init_version4 = __esm({
  "node_modules/@ethersproject/properties/lib.esm/_version.js"() {
    version4 = "properties/5.7.0";
  }
});

// node_modules/@ethersproject/properties/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  Description: () => Description,
  checkProperties: () => checkProperties,
  deepCopy: () => deepCopy,
  defineReadOnly: () => defineReadOnly,
  getStatic: () => getStatic,
  resolveProperties: () => resolveProperties,
  shallowCopy: () => shallowCopy
});
function defineReadOnly(object2, name, value) {
  Object.defineProperty(object2, name, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object2) {
  return __awaiter(this, void 0, void 0, function* () {
    const promises = Object.keys(object2).map((key2) => {
      const value = object2[key2];
      return Promise.resolve(value).then((v) => ({ key: key2, value: v }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object2, properties) {
  if (!object2 || typeof object2 !== "object") {
    logger4.throwArgumentError("invalid object", "object", object2);
  }
  Object.keys(object2).forEach((key2) => {
    if (!properties[key2]) {
      logger4.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object2);
    }
  });
}
function shallowCopy(object2) {
  const result = {};
  for (const key2 in object2) {
    result[key2] = object2[key2];
  }
  return result;
}
function _isFrozen(object2) {
  if (object2 === void 0 || object2 === null || opaque[typeof object2]) {
    return true;
  }
  if (Array.isArray(object2) || typeof object2 === "object") {
    if (!Object.isFrozen(object2)) {
      return false;
    }
    const keys3 = Object.keys(object2);
    for (let i = 0; i < keys3.length; i++) {
      let value = null;
      try {
        value = object2[keys3[i]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function _deepCopy(object2) {
  if (_isFrozen(object2)) {
    return object2;
  }
  if (Array.isArray(object2)) {
    return Object.freeze(object2.map((item) => deepCopy(item)));
  }
  if (typeof object2 === "object") {
    const result = {};
    for (const key2 in object2) {
      const value = object2[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function deepCopy(object2) {
  return _deepCopy(object2);
}
var __awaiter, logger4, opaque, Description;
var init_lib4 = __esm({
  "node_modules/@ethersproject/properties/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version4();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger4 = new Logger(version4);
    opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
    Description = class {
      constructor(info) {
        for (const key2 in info) {
          this[key2] = deepCopy(info[key2]);
        }
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/_version.js
var version5;
var init_version5 = __esm({
  "node_modules/@ethersproject/abi/lib.esm/_version.js"() {
    version5 = "abi/5.7.0";
  }
});

// node_modules/@ethersproject/abi/lib.esm/fragments.js
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger5.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i) {
    logger5.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node3 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node3.indexed = false;
    }
    return node3;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node2 = parent;
  for (let i = 0; i < param.length; i++) {
    let c = param[i];
    switch (c) {
      case "(":
        if (node2.state.allowType && node2.type === "") {
          node2.type = "tuple";
        } else if (!node2.state.allowParams) {
          throwError2(i);
        }
        node2.state.allowType = false;
        node2.type = verifyType(node2.type);
        node2.components = [newNode(node2)];
        node2 = node2.components[0];
        break;
      case ")":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let child = node2;
        node2 = node2.parent;
        if (!node2) {
          throwError2(i);
        }
        delete child.parent;
        node2.state.allowParams = false;
        node2.state.allowName = true;
        node2.state.allowArray = true;
        break;
      case ",":
        delete node2.state;
        if (node2.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i);
          }
          node2.indexed = true;
          node2.name = "";
        }
        if (checkModifier(node2.type, node2.name)) {
          node2.name = "";
        }
        node2.type = verifyType(node2.type);
        let sibling = newNode(node2.parent);
        node2.parent.components.push(sibling);
        delete node2.parent;
        node2 = sibling;
        break;
      case " ":
        if (node2.state.allowType) {
          if (node2.type !== "") {
            node2.type = verifyType(node2.type);
            delete node2.state.allowType;
            node2.state.allowName = true;
            node2.state.allowParams = true;
          }
        }
        if (node2.state.allowName) {
          if (node2.name !== "") {
            if (node2.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i);
              }
              if (node2.indexed) {
                throwError2(i);
              }
              node2.indexed = true;
              node2.name = "";
            } else if (checkModifier(node2.type, node2.name)) {
              node2.name = "";
            } else {
              node2.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node2.state.allowArray) {
          throwError2(i);
        }
        node2.type += c;
        node2.state.allowArray = false;
        node2.state.allowName = false;
        node2.state.readArray = true;
        break;
      case "]":
        if (!node2.state.readArray) {
          throwError2(i);
        }
        node2.type += c;
        node2.state.readArray = false;
        node2.state.allowArray = true;
        node2.state.allowName = true;
        break;
      default:
        if (node2.state.allowType) {
          node2.type += c;
          node2.state.allowParams = true;
          node2.state.allowArray = true;
        } else if (node2.state.allowName) {
          node2.name += c;
          delete node2.state.allowArray;
        } else if (node2.state.readArray) {
          node2.type += c;
        } else {
          throwError2(i);
        }
    }
  }
  if (node2.parent) {
    logger5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node2.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node2.indexed) {
      throwError2(originalParam.length - 7);
    }
    node2.indexed = true;
    node2.name = "";
  } else if (checkModifier(node2.type, node2.name)) {
    node2.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object2, params) {
  for (let key2 in params) {
    defineReadOnly(object2, key2, params[key2]);
  }
}
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger5.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger5.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger5.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger5.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger5.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger5.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger5.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
var logger5, _constructorGuard3, ModifiersBytes, ModifiersNest, FormatTypes, paramTypeArray, ParamType, Fragment, EventFragment, ConstructorFragment, FunctionFragment, ErrorFragment, regexIdentifier, regexParen;
var init_fragments = __esm({
  "node_modules/@ethersproject/abi/lib.esm/fragments.js"() {
    "use strict";
    init_lib3();
    init_lib4();
    init_lib();
    init_version5();
    logger5 = new Logger(version5);
    _constructorGuard3 = {};
    ModifiersBytes = { calldata: true, memory: true, storage: true };
    ModifiersNest = { calldata: true, memory: true };
    FormatTypes = Object.freeze({
      sighash: "sighash",
      minimal: "minimal",
      full: "full",
      json: "json"
    });
    paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
    ParamType = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard3) {
          logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          });
        }
        populate(this, params);
        let match2 = this.type.match(paramTypeArray);
        if (match2) {
          populate(this, {
            arrayLength: parseInt(match2[2] || "-1"),
            arrayChildren: ParamType.fromObject({
              type: match2[1],
              components: this.components
            }),
            baseType: "array"
          });
        } else {
          populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
          });
        }
        this._isParamType = true;
        Object.freeze(this);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          let result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name: this.name || void 0
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.components) {
            result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.baseType === "array") {
          result += this.arrayChildren.format(format);
          result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else {
          if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) {
              result += this.type;
            }
            result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== FormatTypes.sighash) {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === FormatTypes.full && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      static from(value, allowIndexed) {
        if (typeof value === "string") {
          return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
      }
      static fromObject(value) {
        if (ParamType.isParamType(value)) {
          return value;
        }
        return new ParamType(_constructorGuard3, {
          name: value.name || null,
          type: verifyType(value.type),
          indexed: value.indexed == null ? null : !!value.indexed,
          components: value.components ? value.components.map(ParamType.fromObject) : null
        });
      }
      static fromString(value, allowIndexed) {
        function ParamTypify(node2) {
          return ParamType.fromObject({
            name: node2.name,
            type: node2.type,
            indexed: node2.indexed,
            components: node2.components
          });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
      }
      static isParamType(value) {
        return !!(value != null && value._isParamType);
      }
    };
    Fragment = class {
      constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard3) {
          logger5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
      }
      static from(value) {
        if (Fragment.isFragment(value)) {
          return value;
        }
        if (typeof value === "string") {
          return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
      }
      static fromObject(value) {
        if (Fragment.isFragment(value)) {
          return value;
        }
        switch (value.type) {
          case "function":
            return FunctionFragment.fromObject(value);
          case "event":
            return EventFragment.fromObject(value);
          case "constructor":
            return ConstructorFragment.fromObject(value);
          case "error":
            return ErrorFragment.fromObject(value);
          case "fallback":
          case "receive":
            return null;
        }
        return logger5.throwArgumentError("invalid fragment object", "value", value);
      }
      static fromString(value) {
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
          return EventFragment.fromString(value.substring(5).trim());
        } else if (value.split(" ")[0] === "function") {
          return FunctionFragment.fromString(value.substring(8).trim());
        } else if (value.split("(")[0].trim() === "constructor") {
          return ConstructorFragment.fromString(value.trim());
        } else if (value.split(" ")[0] === "error") {
          return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger5.throwArgumentError("unsupported fragment", "value", value);
      }
      static isFragment(value) {
        return !!(value && value._isFragment);
      }
    };
    EventFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.anonymous) {
            result += "anonymous ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
      }
      static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
          return value;
        }
        if (value.type !== "event") {
          logger5.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
          name: verifyIdentifier(value.name),
          anonymous: value.anonymous,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          type: "event"
        };
        return new EventFragment(_constructorGuard3, params);
      }
      static fromString(value) {
        let match2 = value.match(regexParen);
        if (!match2) {
          logger5.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match2[3].split(" ").forEach((modifier) => {
          switch (modifier.trim()) {
            case "anonymous":
              anonymous = true;
              break;
            case "":
              break;
            default:
              logger5.warn("unknown modifier: " + modifier);
          }
        });
        return EventFragment.fromObject({
          name: match2[1].trim(),
          anonymous,
          inputs: parseParams(match2[2], true),
          type: "event"
        });
      }
      static isEventFragment(value) {
        return value && value._isFragment && value.type === "event";
      }
    };
    ConstructorFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        if (format === FormatTypes.sighash) {
          logger5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
          return value;
        }
        if (value.type !== "constructor") {
          logger5.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
          logger5.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
          name: null,
          type: value.type,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new ConstructorFragment(_constructorGuard3, params);
      }
      static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
          logger5.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
      }
      static isConstructorFragment(value) {
        return value && value._isFragment && value.type === "constructor";
      }
    };
    FunctionFragment = class extends ConstructorFragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            outputs: this.outputs.map((output2) => JSON.parse(output2.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
          if (this.stateMutability) {
            if (this.stateMutability !== "nonpayable") {
              result += this.stateMutability + " ";
            }
          } else if (this.constant) {
            result += "view ";
          }
          if (this.outputs && this.outputs.length) {
            result += "returns (" + this.outputs.map((output2) => output2.format(format)).join(", ") + ") ";
          }
          if (this.gas != null) {
            result += "@" + this.gas.toString() + " ";
          }
        }
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
      }
      static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
          return value;
        }
        if (value.type !== "function") {
          logger5.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          constant: state.constant,
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
          outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
          payable: state.payable,
          stateMutability: state.stateMutability,
          gas: value.gas ? BigNumber.from(value.gas) : null
        };
        return new FunctionFragment(_constructorGuard3, params);
      }
      static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
          logger5.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
          logger5.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        if (comps.length > 1) {
          let returns = comps[1].match(regexParen);
          if (returns[1].trim() != "" || returns[3].trim() != "") {
            logger5.throwArgumentError("unexpected tokens", "value", value);
          }
          params.outputs = parseParams(returns[2], false);
        } else {
          params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
      }
      static isFunctionFragment(value) {
        return value && value._isFragment && value.type === "function";
      }
    };
    ErrorFragment = class extends Fragment {
      format(format) {
        if (!format) {
          format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
          logger5.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
          result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
      }
      static from(value) {
        if (typeof value === "string") {
          return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
      }
      static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
          return value;
        }
        if (value.type !== "error") {
          logger5.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
          type: value.type,
          name: verifyIdentifier(value.name),
          inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new ErrorFragment(_constructorGuard3, params));
      }
      static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
          logger5.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
          verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
      }
      static isErrorFragment(value) {
        return value && value._isFragment && value.type === "error";
      }
    };
    regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
    regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key2 in object2) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object2[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var logger6, Coder, Writer, Reader;
var init_abstract_coder = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"() {
    "use strict";
    init_lib2();
    init_lib3();
    init_lib4();
    init_lib();
    init_version5();
    logger6 = new Logger(version5);
    Coder = class {
      constructor(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
      }
      _throwError(message, value) {
        logger6.throwArgumentError(message, this.localName, value);
      }
    };
    Writer = class {
      constructor(wordSize) {
        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
      }
      get data() {
        return hexConcat(this._data);
      }
      get length() {
        return this._dataLength;
      }
      _writeData(data2) {
        this._data.push(data2);
        this._dataLength += data2.length;
        return data2.length;
      }
      appendWriter(writer) {
        return this._writeData(concat(writer._data));
      }
      writeBytes(value) {
        let bytes3 = arrayify(value);
        const paddingOffset = bytes3.length % this.wordSize;
        if (paddingOffset) {
          bytes3 = concat([bytes3, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes3);
      }
      _getValue(value) {
        let bytes3 = arrayify(BigNumber.from(value));
        if (bytes3.length > this.wordSize) {
          logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes3.length
          });
        }
        if (bytes3.length % this.wordSize) {
          bytes3 = concat([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
        }
        return bytes3;
      }
      writeValue(value) {
        return this._writeData(this._getValue(value));
      }
      writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
          this._data[offset] = this._getValue(value);
        };
      }
    };
    Reader = class {
      constructor(data2, wordSize, coerceFunc, allowLoose) {
        defineReadOnly(this, "_data", arrayify(data2));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
      }
      get data() {
        return hexlify(this._data);
      }
      get consumed() {
        return this._offset;
      }
      static coerce(name, value) {
        let match2 = name.match("^u?int([0-9]+)$");
        if (match2 && parseInt(match2[1]) <= 48) {
          value = value.toNumber();
        }
        return value;
      }
      coerce(name, value) {
        if (this._coerceFunc) {
          return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
      }
      _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
          if (this.allowLoose && loose && this._offset + length <= this._data.length) {
            alignedLength = length;
          } else {
            logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + alignedLength
            });
          }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
      }
      subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
      }
      readBytes(length, loose) {
        let bytes3 = this._peekBytes(0, length, !!loose);
        this._offset += bytes3.length;
        return bytes3.slice(0, length);
      }
      readValue() {
        return BigNumber.from(this.readBytes(this.wordSize));
      }
    };
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding3, outputType) {
        return function(message) {
          return new Keccak2(bits2, padding3, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding3, outputType) {
        return function(message, outputBits) {
          return new Keccak2(bits2, padding3, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding3, outputType) {
        return function(message, outputBits, n2, s) {
          return methods["cshake" + bits2].update(message, outputBits, n2, s)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding3, outputType) {
        return function(key2, message, outputBits, s) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod3, bits2, padding3) {
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createMethod3(bits2, padding3, type);
        }
        return method;
      };
      var createMethod2 = function(bits2, padding3) {
        var method = createOutputMethod(bits2, padding3, "hex");
        method.create = function() {
          return new Keccak2(bits2, padding3, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding3);
      };
      var createShakeMethod = function(bits2, padding3) {
        var method = createShakeOutputMethod(bits2, padding3, "hex");
        method.create = function(outputBits) {
          return new Keccak2(bits2, padding3, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding3);
      };
      var createCshakeMethod = function(bits2, padding3) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding3, "hex");
        method.create = function(outputBits, n2, s) {
          if (!n2 && !s) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak2(bits2, padding3, outputBits).bytepad([n2, s], w);
          }
        };
        method.update = function(message, outputBits, n2, s) {
          return method.create(outputBits, n2, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding3);
      };
      var createKmacMethod = function(bits2, padding3) {
        var w = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding3, "hex");
        method.create = function(key2, outputBits, s) {
          return new Kmac(bits2, padding3, outputBits).bytepad(["KMAC", s], w).bytepad([key2], w);
        };
        method.update = function(key2, message, outputBits, s) {
          return method.create(key2, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding3);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod: createMethod2 },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i = 0; i < algorithms.length; ++i) {
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for (var j = 0; j < bits.length; ++j) {
          var methodName = algorithm.name + "_" + bits[j];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak2(bits2, padding3, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding3;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i2 = 0; i2 < 50; ++i2) {
          this.s[i2] = 0;
        }
      }
      Keccak2.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i2 = 1; i2 < blockCount + 1; ++i2) {
              blocks[i2] = 0;
            }
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          if (i2 >= byteCount) {
            this.start = i2 - byteCount;
            this.block = blocks[blockCount];
            for (i2 = 0; i2 < blockCount; ++i2) {
              s[i2] ^= blocks[i2];
            }
            f2(s);
            this.reset = true;
          } else {
            this.start = i2;
          }
        }
        return this;
      };
      Keccak2.prototype.encode = function(x, right) {
        var o = x & 255, n2 = 1;
        var bytes3 = [o];
        x = x >> 8;
        o = x & 255;
        while (o > 0) {
          bytes3.unshift(o);
          x = x >> 8;
          o = x & 255;
          ++n2;
        }
        if (right) {
          bytes3.push(n2);
        } else {
          bytes3.unshift(n2);
        }
        this.update(bytes3);
        return bytes3.length;
      };
      Keccak2.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes3 = 0, length = str.length;
        if (notString) {
          bytes3 = length;
        } else {
          for (var i2 = 0; i2 < str.length; ++i2) {
            var code = str.charCodeAt(i2);
            if (code < 128) {
              bytes3 += 1;
            } else if (code < 2048) {
              bytes3 += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes3 += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
              bytes3 += 4;
            }
          }
        }
        bytes3 += this.encode(bytes3 * 8);
        this.update(str);
        return bytes3;
      };
      Keccak2.prototype.bytepad = function(strs, w) {
        var bytes3 = this.encode(w);
        for (var i2 = 0; i2 < strs.length; ++i2) {
          bytes3 += this.encodeString(strs[i2]);
        }
        var paddingBytes = w - bytes3 % w;
        var zeros3 = [];
        zeros3.length = paddingBytes;
        this.update(zeros3);
        return this;
      };
      Keccak2.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i2 >> 2] |= this.padding[i2 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i2 = 0; i2 < blockCount; ++i2) {
          s[i2] ^= blocks[i2];
        }
        f2(s);
      };
      Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var hex = "", block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            block = s[i2];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j2 % blockCount === 0) {
            f2(s);
            i2 = 0;
          }
        }
        if (extraBytes) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak2.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var bytes3 = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes3);
        }
        var array = new Uint32Array(buffer);
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            array[j2] = s[i2];
          }
          if (j2 % blockCount === 0) {
            f2(s);
          }
        }
        if (extraBytes) {
          array[i2] = s[i2];
          buffer = buffer.slice(0, bytes3);
        }
        return buffer;
      };
      Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
      Keccak2.prototype.digest = Keccak2.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
        var array = [], offset, block;
        while (j2 < outputBlocks) {
          for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
            offset = j2 << 2;
            block = s[i2];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j2 % blockCount === 0) {
            f2(s);
          }
        }
        if (extraBytes) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding3, outputBits) {
        Keccak2.call(this, bits2, padding3, outputBits);
      }
      Kmac.prototype = new Keccak2();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak2.prototype.finalize.call(this);
      };
      var f2 = function(s) {
        var h, l, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n2 = 0; n2 < 48; n2 += 2) {
          c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
          c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
          c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
          c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
          c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
          c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
          c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
          c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
          c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
          c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
          h = c8 ^ (c2 << 1 | c3 >>> 31);
          l = c9 ^ (c3 << 1 | c2 >>> 31);
          s[0] ^= h;
          s[1] ^= l;
          s[10] ^= h;
          s[11] ^= l;
          s[20] ^= h;
          s[21] ^= l;
          s[30] ^= h;
          s[31] ^= l;
          s[40] ^= h;
          s[41] ^= l;
          h = c0 ^ (c4 << 1 | c5 >>> 31);
          l = c1 ^ (c5 << 1 | c4 >>> 31);
          s[2] ^= h;
          s[3] ^= l;
          s[12] ^= h;
          s[13] ^= l;
          s[22] ^= h;
          s[23] ^= l;
          s[32] ^= h;
          s[33] ^= l;
          s[42] ^= h;
          s[43] ^= l;
          h = c2 ^ (c6 << 1 | c7 >>> 31);
          l = c3 ^ (c7 << 1 | c6 >>> 31);
          s[4] ^= h;
          s[5] ^= l;
          s[14] ^= h;
          s[15] ^= l;
          s[24] ^= h;
          s[25] ^= l;
          s[34] ^= h;
          s[35] ^= l;
          s[44] ^= h;
          s[45] ^= l;
          h = c4 ^ (c8 << 1 | c9 >>> 31);
          l = c5 ^ (c9 << 1 | c8 >>> 31);
          s[6] ^= h;
          s[7] ^= l;
          s[16] ^= h;
          s[17] ^= l;
          s[26] ^= h;
          s[27] ^= l;
          s[36] ^= h;
          s[37] ^= l;
          s[46] ^= h;
          s[47] ^= l;
          h = c6 ^ (c0 << 1 | c1 >>> 31);
          l = c7 ^ (c1 << 1 | c0 >>> 31);
          s[8] ^= h;
          s[9] ^= l;
          s[18] ^= h;
          s[19] ^= l;
          s[28] ^= h;
          s[29] ^= l;
          s[38] ^= h;
          s[39] ^= l;
          s[48] ^= h;
          s[49] ^= l;
          b0 = s[0];
          b1 = s[1];
          b32 = s[11] << 4 | s[10] >>> 28;
          b33 = s[10] << 4 | s[11] >>> 28;
          b14 = s[20] << 3 | s[21] >>> 29;
          b15 = s[21] << 3 | s[20] >>> 29;
          b46 = s[31] << 9 | s[30] >>> 23;
          b47 = s[30] << 9 | s[31] >>> 23;
          b28 = s[40] << 18 | s[41] >>> 14;
          b29 = s[41] << 18 | s[40] >>> 14;
          b20 = s[2] << 1 | s[3] >>> 31;
          b21 = s[3] << 1 | s[2] >>> 31;
          b2 = s[13] << 12 | s[12] >>> 20;
          b3 = s[12] << 12 | s[13] >>> 20;
          b34 = s[22] << 10 | s[23] >>> 22;
          b35 = s[23] << 10 | s[22] >>> 22;
          b16 = s[33] << 13 | s[32] >>> 19;
          b17 = s[32] << 13 | s[33] >>> 19;
          b48 = s[42] << 2 | s[43] >>> 30;
          b49 = s[43] << 2 | s[42] >>> 30;
          b40 = s[5] << 30 | s[4] >>> 2;
          b41 = s[4] << 30 | s[5] >>> 2;
          b22 = s[14] << 6 | s[15] >>> 26;
          b23 = s[15] << 6 | s[14] >>> 26;
          b4 = s[25] << 11 | s[24] >>> 21;
          b5 = s[24] << 11 | s[25] >>> 21;
          b36 = s[34] << 15 | s[35] >>> 17;
          b37 = s[35] << 15 | s[34] >>> 17;
          b18 = s[45] << 29 | s[44] >>> 3;
          b19 = s[44] << 29 | s[45] >>> 3;
          b10 = s[6] << 28 | s[7] >>> 4;
          b11 = s[7] << 28 | s[6] >>> 4;
          b42 = s[17] << 23 | s[16] >>> 9;
          b43 = s[16] << 23 | s[17] >>> 9;
          b24 = s[26] << 25 | s[27] >>> 7;
          b25 = s[27] << 25 | s[26] >>> 7;
          b6 = s[36] << 21 | s[37] >>> 11;
          b7 = s[37] << 21 | s[36] >>> 11;
          b38 = s[47] << 24 | s[46] >>> 8;
          b39 = s[46] << 24 | s[47] >>> 8;
          b30 = s[8] << 27 | s[9] >>> 5;
          b31 = s[9] << 27 | s[8] >>> 5;
          b12 = s[18] << 20 | s[19] >>> 12;
          b13 = s[19] << 20 | s[18] >>> 12;
          b44 = s[29] << 7 | s[28] >>> 25;
          b45 = s[28] << 7 | s[29] >>> 25;
          b26 = s[38] << 8 | s[39] >>> 24;
          b27 = s[39] << 8 | s[38] >>> 24;
          b8 = s[48] << 14 | s[49] >>> 18;
          b9 = s[49] << 14 | s[48] >>> 18;
          s[0] = b0 ^ ~b2 & b4;
          s[1] = b1 ^ ~b3 & b5;
          s[10] = b10 ^ ~b12 & b14;
          s[11] = b11 ^ ~b13 & b15;
          s[20] = b20 ^ ~b22 & b24;
          s[21] = b21 ^ ~b23 & b25;
          s[30] = b30 ^ ~b32 & b34;
          s[31] = b31 ^ ~b33 & b35;
          s[40] = b40 ^ ~b42 & b44;
          s[41] = b41 ^ ~b43 & b45;
          s[2] = b2 ^ ~b4 & b6;
          s[3] = b3 ^ ~b5 & b7;
          s[12] = b12 ^ ~b14 & b16;
          s[13] = b13 ^ ~b15 & b17;
          s[22] = b22 ^ ~b24 & b26;
          s[23] = b23 ^ ~b25 & b27;
          s[32] = b32 ^ ~b34 & b36;
          s[33] = b33 ^ ~b35 & b37;
          s[42] = b42 ^ ~b44 & b46;
          s[43] = b43 ^ ~b45 & b47;
          s[4] = b4 ^ ~b6 & b8;
          s[5] = b5 ^ ~b7 & b9;
          s[14] = b14 ^ ~b16 & b18;
          s[15] = b15 ^ ~b17 & b19;
          s[24] = b24 ^ ~b26 & b28;
          s[25] = b25 ^ ~b27 & b29;
          s[34] = b34 ^ ~b36 & b38;
          s[35] = b35 ^ ~b37 & b39;
          s[44] = b44 ^ ~b46 & b48;
          s[45] = b45 ^ ~b47 & b49;
          s[6] = b6 ^ ~b8 & b0;
          s[7] = b7 ^ ~b9 & b1;
          s[16] = b16 ^ ~b18 & b10;
          s[17] = b17 ^ ~b19 & b11;
          s[26] = b26 ^ ~b28 & b20;
          s[27] = b27 ^ ~b29 & b21;
          s[36] = b36 ^ ~b38 & b30;
          s[37] = b37 ^ ~b39 & b31;
          s[46] = b46 ^ ~b48 & b40;
          s[47] = b47 ^ ~b49 & b41;
          s[8] = b8 ^ ~b0 & b2;
          s[9] = b9 ^ ~b1 & b3;
          s[18] = b18 ^ ~b10 & b12;
          s[19] = b19 ^ ~b11 & b13;
          s[28] = b28 ^ ~b20 & b22;
          s[29] = b29 ^ ~b21 & b23;
          s[38] = b38 ^ ~b30 & b32;
          s[39] = b39 ^ ~b31 & b33;
          s[48] = b48 ^ ~b40 & b42;
          s[49] = b49 ^ ~b41 & b43;
          s[0] ^= RC[n2];
          s[1] ^= RC[n2 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i = 0; i < methodNames.length; ++i) {
          root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  keccak256: () => keccak256
});
function keccak256(data2) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data2));
}
var import_js_sha3;
var init_lib5 = __esm({
  "node_modules/@ethersproject/keccak256/lib.esm/index.js"() {
    "use strict";
    import_js_sha3 = __toESM(require_sha3());
    init_lib2();
  }
});

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version6;
var init_version6 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/_version.js"() {
    version6 = "rlp/5.7.0";
  }
});

// node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports5 = {};
__export(lib_exports5, {
  decode: () => decode,
  encode: () => encode
});
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data2, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data2[offset + i];
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object2)) {
    logger7.throwArgumentError("RLP object must be BytesLike", "object", object2);
  }
  const data2 = Array.prototype.slice.call(arrayify(object2));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length = arrayifyInteger(data2.length);
  length.unshift(183 + length.length);
  return length.concat(data2);
}
function encode(object2) {
  return hexlify(_encode(object2));
}
function _decodeChildren(data2, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode(data2, offset) {
  if (data2.length === 0) {
    logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    if (offset + 1 + lengthLength > data2.length) {
      logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data2.length) {
      logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data2[offset] >= 192) {
    const length = data2[offset] - 192;
    if (offset + 1 + length > data2.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data2, offset, offset + 1, length);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    if (offset + 1 + lengthLength > data2.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data2, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data2.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data2[offset] >= 128) {
    const length = data2[offset] - 128;
    if (offset + 1 + length > data2.length) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data2.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data2[offset]) };
}
function decode(data2) {
  const bytes3 = arrayify(data2);
  const decoded = _decode(bytes3, 0);
  if (decoded.consumed !== bytes3.length) {
    logger7.throwArgumentError("invalid rlp data", "data", data2);
  }
  return decoded.result;
}
var logger7;
var init_lib6 = __esm({
  "node_modules/@ethersproject/rlp/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version6();
    logger7 = new Logger(version6);
  }
});

// node_modules/@ethersproject/address/lib.esm/_version.js
var version7;
var init_version7 = __esm({
  "node_modules/@ethersproject/address/lib.esm/_version.js"() {
    version7 = "address/5.7.0";
  }
});

// node_modules/@ethersproject/address/lib.esm/index.js
var lib_exports6 = {};
__export(lib_exports6, {
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  isAddress: () => isAddress
});
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger8.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger8.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
  let from = null;
  try {
    from = getAddress(transaction.from);
  } catch (error) {
    logger8.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger8.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger8.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
var logger8, MAX_SAFE_INTEGER, ibanLookup, safeDigits;
var init_lib7 = __esm({
  "node_modules/@ethersproject/address/lib.esm/index.js"() {
    "use strict";
    init_lib2();
    init_lib3();
    init_lib5();
    init_lib6();
    init_lib();
    init_version7();
    logger8 = new Logger(version7);
    MAX_SAFE_INTEGER = 9007199254740991;
    ibanLookup = {};
    for (let i = 0; i < 10; i++) {
      ibanLookup[String(i)] = String(i);
    }
    for (let i = 0; i < 26; i++) {
      ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
    }
    safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder;
var init_address = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/address.js"() {
    "use strict";
    init_lib7();
    init_lib2();
    init_abstract_coder();
    AddressCoder = class extends Coder {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, value) {
        try {
          value = getAddress(value);
        } catch (error) {
          this._throwError(error.message, value);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder;
var init_anonymous = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js"() {
    "use strict";
    init_abstract_coder();
    AnonymousCoder = class extends Coder {
      constructor(coder) {
        super(coder.name, coder.type, void 0, coder.dynamic);
        this.coder = coder;
      }
      defaultValue() {
        return this.coder.defaultValue();
      }
      encode(writer, value) {
        return this.coder.encode(writer, value);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/array.js
function pack(writer, coders, values2) {
  let arrayValues = null;
  if (Array.isArray(values2)) {
    arrayValues = values2;
  } else if (values2 && typeof values2 === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      if (!name) {
        logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values2
        });
      }
      if (unique[name]) {
        logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values2
        });
      }
      unique[name] = true;
      return values2[name];
    });
  } else {
    logger9.throwArgumentError("invalid tuple value", "tuple", values2);
  }
  if (coders.length !== arrayValues.length) {
    logger9.throwArgumentError("types/value length mismatch", "tuple", values2);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values2 = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values2.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values2[name] != null) {
      return;
    }
    const value = values2[index];
    if (value instanceof Error) {
      Object.defineProperty(values2, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values2[name] = value;
    }
  });
  for (let i = 0; i < values2.length; i++) {
    const value = values2[i];
    if (value instanceof Error) {
      Object.defineProperty(values2, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values2);
}
var logger9, ArrayCoder;
var init_array = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/array.js"() {
    "use strict";
    init_lib();
    init_version5();
    init_abstract_coder();
    init_anonymous();
    logger9 = new Logger(version5);
    ArrayCoder = class extends Coder {
      constructor(coder, length, localName) {
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
      }
      defaultValue() {
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
          result.push(defaultChild);
        }
        return result;
      }
      encode(writer, value) {
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        logger9.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      }
      decode(reader) {
        let count = this.length;
        if (count === -1) {
          count = reader.readValue().toNumber();
          if (count * 32 > reader._data.length) {
            logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
              length: reader._data.length,
              count
            });
          }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
          coders.push(new AnonymousCoder(this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder;
var init_boolean = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/boolean.js"() {
    "use strict";
    init_abstract_coder();
    BooleanCoder = class extends Coder {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      defaultValue() {
        return false;
      }
      encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder, BytesCoder;
var init_bytes = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/bytes.js"() {
    "use strict";
    init_lib2();
    init_abstract_coder();
    DynamicBytesCoder = class extends Coder {
      constructor(type, localName) {
        super(type, type, localName, true);
      }
      defaultValue() {
        return "0x";
      }
      encode(writer, value) {
        value = arrayify(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
      }
      decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
      }
    };
    BytesCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(super.decode(reader)));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder;
var init_fixed_bytes = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js"() {
    "use strict";
    init_lib2();
    init_abstract_coder();
    FixedBytesCoder = class extends Coder {
      constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
      encode(writer, value) {
        let data2 = arrayify(value);
        if (data2.length !== this.size) {
          this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data2);
      }
      decode(reader) {
        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder;
var init_null = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/null.js"() {
    "use strict";
    init_abstract_coder();
    NullCoder = class extends Coder {
      constructor(localName) {
        super("null", "", localName, false);
      }
      defaultValue() {
        return null;
      }
      encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes([]);
      }
      decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
      }
    };
  }
});

// node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero;
var init_addresses = __esm({
  "node_modules/@ethersproject/constants/lib.esm/addresses.js"() {
    AddressZero = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2, Zero2, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256;
var init_bignumbers = __esm({
  "node_modules/@ethersproject/constants/lib.esm/bignumbers.js"() {
    init_lib3();
    NegativeOne2 = BigNumber.from(-1);
    Zero2 = BigNumber.from(0);
    One = BigNumber.from(1);
    Two = BigNumber.from(2);
    WeiPerEther = BigNumber.from("1000000000000000000");
    MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
    MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
});

// node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero;
var init_hashes = __esm({
  "node_modules/@ethersproject/constants/lib.esm/hashes.js"() {
    HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol;
var init_strings = __esm({
  "node_modules/@ethersproject/constants/lib.esm/strings.js"() {
    EtherSymbol = "\u039E";
  }
});

// node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports7 = {};
__export(lib_exports7, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne2,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero2
});
var init_lib8 = __esm({
  "node_modules/@ethersproject/constants/lib.esm/index.js"() {
    "use strict";
    init_addresses();
    init_bignumbers();
    init_hashes();
    init_strings();
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder;
var init_number = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/number.js"() {
    "use strict";
    init_lib3();
    init_lib8();
    init_abstract_coder();
    NumberCoder = class extends Coder {
      constructor(size, signed3, localName) {
        const name = (signed3 ? "int" : "uint") + size * 8;
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed3;
      }
      defaultValue() {
        return 0;
      }
      encode(writer, value) {
        let v = BigNumber.from(value);
        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
        if (this.signed) {
          let bounds = maxUintValue.mask(this.size * 8 - 1);
          if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne2))) {
            this._throwError("value out-of-bounds", value);
          }
        } else if (v.lt(Zero2) || v.gt(maxUintValue.mask(this.size * 8))) {
          this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
          v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
      }
      decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
          value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
      }
    };
  }
});

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version8;
var init_version8 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/_version.js"() {
    version8 = "strings/5.7.0";
  }
});

// node_modules/@ethersproject/strings/lib.esm/utf8.js
function errorFunc(reason, offset, bytes3, output2, badCodepoint) {
  return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset, bytes3, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;
    for (let o = offset + 1; o < bytes3.length; o++) {
      if (bytes3[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes3.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes3, output2, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes3, output2, badCodepoint);
}
function getUtf8CodePoints(bytes3, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes3 = arrayify(bytes3);
  const result = [];
  let i = 0;
  while (i < bytes3.length) {
    const c = bytes3[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes3, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes3, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes3.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes3, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes3[i];
      if ((nextChar & 192) != 128) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes3, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger10.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes3, onError) {
  return '"' + getUtf8CodePoints(bytes3, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
var logger10, UnicodeNormalizationForm, Utf8ErrorReason, Utf8ErrorFuncs;
var init_utf8 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/utf8.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version8();
    logger10 = new Logger(version8);
    (function(UnicodeNormalizationForm2) {
      UnicodeNormalizationForm2["current"] = "";
      UnicodeNormalizationForm2["NFC"] = "NFC";
      UnicodeNormalizationForm2["NFD"] = "NFD";
      UnicodeNormalizationForm2["NFKC"] = "NFKC";
      UnicodeNormalizationForm2["NFKD"] = "NFKD";
    })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
    (function(Utf8ErrorReason2) {
      Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
      Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
      Utf8ErrorReason2["OVERRUN"] = "string overrun";
      Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
      Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
      Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
      Utf8ErrorReason2["OVERLONG"] = "overlong representation";
    })(Utf8ErrorReason || (Utf8ErrorReason = {}));
    Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
  }
});

// node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String(text) {
  const bytes3 = toUtf8Bytes(text);
  if (bytes3.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat([bytes3, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes3) {
  const data2 = arrayify(bytes3);
  if (data2.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data2[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data2[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data2.slice(0, length));
}
var init_bytes32 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/bytes32.js"() {
    "use strict";
    init_lib8();
    init_lib2();
    init_utf8();
  }
});

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data2) {
  if (data2.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i = 0; i < data2.length; i += 4) {
    result.push(parseInt(data2.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data2, func) {
  if (!func) {
    func = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data2.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data2) {
  let hi = 0;
  return data2.split(",").map((v) => {
    let comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i = 0; i < ranges.length; i++) {
    let range = ranges[i];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
function flatten(values2) {
  return values2.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code) => {
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 65024 && code <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code) => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code) => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name = _toUtf8String(codes);
  if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name;
}
var Table_A_1_ranges, Table_B_1_flags, Table_B_2_ranges, Table_B_2_lut_abs, Table_B_2_lut_rel, Table_B_2_complex, Table_C_ranges;
var init_idna = __esm({
  "node_modules/@ethersproject/strings/lib.esm/idna.js"() {
    "use strict";
    init_utf8();
    Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
    Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
    Table_B_2_ranges = [
      { h: 25, s: 32, l: 65 },
      { h: 30, s: 32, e: [23], l: 127 },
      { h: 54, s: 1, e: [48], l: 64, d: 2 },
      { h: 14, s: 1, l: 57, d: 2 },
      { h: 44, s: 1, l: 17, d: 2 },
      { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
      { h: 16, s: 1, l: 68, d: 2 },
      { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
      { h: 26, s: 32, e: [17], l: 435 },
      { h: 22, s: 1, l: 71, d: 2 },
      { h: 15, s: 80, l: 40 },
      { h: 31, s: 32, l: 16 },
      { h: 32, s: 1, l: 80, d: 2 },
      { h: 52, s: 1, l: 42, d: 2 },
      { h: 12, s: 1, l: 55, d: 2 },
      { h: 40, s: 1, e: [38], l: 15, d: 2 },
      { h: 14, s: 1, l: 48, d: 2 },
      { h: 37, s: 48, l: 49 },
      { h: 148, s: 1, l: 6351, d: 2 },
      { h: 88, s: 1, l: 160, d: 2 },
      { h: 15, s: 16, l: 704 },
      { h: 25, s: 26, l: 854 },
      { h: 25, s: 32, l: 55915 },
      { h: 37, s: 40, l: 1247 },
      { h: 25, s: -119711, l: 53248 },
      { h: 25, s: -119763, l: 52 },
      { h: 25, s: -119815, l: 52 },
      { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
      { h: 25, s: -119919, l: 52 },
      { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
      { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
      { h: 25, s: -120075, l: 52 },
      { h: 25, s: -120127, l: 52 },
      { h: 25, s: -120179, l: 52 },
      { h: 25, s: -120231, l: 52 },
      { h: 25, s: -120283, l: 52 },
      { h: 25, s: -120335, l: 52 },
      { h: 24, s: -119543, e: [17], l: 56 },
      { h: 24, s: -119601, e: [17], l: 58 },
      { h: 24, s: -119659, e: [17], l: 58 },
      { h: 24, s: -119717, e: [17], l: 58 },
      { h: 24, s: -119775, e: [17], l: 58 }
    ];
    Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
    Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
    Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
    Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  }
});

// node_modules/@ethersproject/strings/lib.esm/index.js
var lib_exports8 = {};
__export(lib_exports8, {
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  formatBytes32String: () => formatBytes32String,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String
});
var init_lib9 = __esm({
  "node_modules/@ethersproject/strings/lib.esm/index.js"() {
    "use strict";
    init_bytes32();
    init_idna();
    init_utf8();
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder;
var init_string = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/string.js"() {
    "use strict";
    init_lib9();
    init_bytes();
    StringCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("string", localName);
      }
      defaultValue() {
        return "";
      }
      encode(writer, value) {
        return super.encode(writer, toUtf8Bytes(value));
      }
      decode(reader) {
        return toUtf8String(super.decode(reader));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder;
var init_tuple = __esm({
  "node_modules/@ethersproject/abi/lib.esm/coders/tuple.js"() {
    "use strict";
    init_abstract_coder();
    init_array();
    TupleCoder = class extends Coder {
      constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
      }
      defaultValue() {
        const values2 = [];
        this.coders.forEach((coder) => {
          values2.push(coder.defaultValue());
        });
        const uniqueNames = this.coders.reduce((accum, coder) => {
          const name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        this.coders.forEach((coder, index) => {
          let name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values2[name] != null) {
            return;
          }
          values2[name] = values2[index];
        });
        return Object.freeze(values2);
      }
      encode(writer, value) {
        return pack(writer, this.coders, value);
      }
      decode(reader) {
        return reader.coerce(this.name, unpack(reader, this.coders));
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger11, paramTypeBytes, paramTypeNumber, AbiCoder, defaultAbiCoder;
var init_abi_coder = __esm({
  "node_modules/@ethersproject/abi/lib.esm/abi-coder.js"() {
    "use strict";
    init_lib2();
    init_lib4();
    init_lib();
    init_version5();
    init_abstract_coder();
    init_address();
    init_array();
    init_boolean();
    init_bytes();
    init_fixed_bytes();
    init_null();
    init_number();
    init_string();
    init_tuple();
    init_fragments();
    logger11 = new Logger(version5);
    paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    AbiCoder = class {
      constructor(coerceFunc) {
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
      }
      _getCoder(param) {
        switch (param.baseType) {
          case "address":
            return new AddressCoder(param.name);
          case "bool":
            return new BooleanCoder(param.name);
          case "string":
            return new StringCoder(param.name);
          case "bytes":
            return new BytesCoder(param.name);
          case "array":
            return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
          case "tuple":
            return new TupleCoder((param.components || []).map((component) => {
              return this._getCoder(component);
            }), param.name);
          case "":
            return new NullCoder(param.name);
        }
        let match2 = param.type.match(paramTypeNumber);
        if (match2) {
          let size = parseInt(match2[2] || "256");
          if (size === 0 || size > 256 || size % 8 !== 0) {
            logger11.throwArgumentError("invalid " + match2[1] + " bit length", "param", param);
          }
          return new NumberCoder(size / 8, match2[1] === "int", param.name);
        }
        match2 = param.type.match(paramTypeBytes);
        if (match2) {
          let size = parseInt(match2[1]);
          if (size === 0 || size > 32) {
            logger11.throwArgumentError("invalid bytes length", "param", param);
          }
          return new FixedBytesCoder(size, param.name);
        }
        return logger11.throwArgumentError("invalid type", "type", param.type);
      }
      _getWordSize() {
        return 32;
      }
      _getReader(data2, allowLoose) {
        return new Reader(data2, this._getWordSize(), this.coerceFunc, allowLoose);
      }
      _getWriter() {
        return new Writer(this._getWordSize());
      }
      getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.defaultValue();
      }
      encode(types, values2) {
        if (types.length !== values2.length) {
          logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
            count: { types: types.length, values: values2.length },
            value: { types, values: values2 }
          });
        }
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values2);
        return writer.data;
      }
      decode(types, data2, loose) {
        const coders = types.map((type) => this._getCoder(ParamType.from(type)));
        const coder = new TupleCoder(coders, "_");
        return coder.decode(this._getReader(arrayify(data2), loose));
      }
    };
    defaultAbiCoder = new AbiCoder();
  }
});

// node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak256(toUtf8Bytes(text));
}
var init_id = __esm({
  "node_modules/@ethersproject/hash/lib.esm/id.js"() {
    init_lib5();
    init_lib9();
  }
});

// node_modules/@ethersproject/hash/lib.esm/_version.js
var version9;
var init_version9 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/_version.js"() {
    version9 = "hash/5.7.0";
  }
});

// node_modules/@ethersproject/base64/lib.esm/base64.js
function decode2(textData) {
  textData = atob(textData);
  const data2 = [];
  for (let i = 0; i < textData.length; i++) {
    data2.push(textData.charCodeAt(i));
  }
  return arrayify(data2);
}
function encode2(data2) {
  data2 = arrayify(data2);
  let textData = "";
  for (let i = 0; i < data2.length; i++) {
    textData += String.fromCharCode(data2[i]);
  }
  return btoa(textData);
}
var init_base64 = __esm({
  "node_modules/@ethersproject/base64/lib.esm/base64.js"() {
    "use strict";
    init_lib2();
  }
});

// node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports9 = {};
__export(lib_exports9, {
  decode: () => decode2,
  encode: () => encode2
});
var init_lib10 = __esm({
  "node_modules/@ethersproject/base64/lib.esm/index.js"() {
    "use strict";
    init_base64();
  }
});

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  const result = {};
  for (let i = 0; i < array.length; i++) {
    const value = array[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes3) {
  let pos = 0;
  function u16() {
    return bytes3[pos++] << 8 | bytes3[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes3[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N4 = 31;
  const FULL = Math.pow(2, N4);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N4; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 2:
        return offset + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 1:
        return offset + bytes3[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(bytes3) {
  return read_payload(decode_arithmetic(bytes3));
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n2, next) {
  let v = Array(n2);
  for (let i = 0; i < n2; i++)
    v[i] = 1 + next();
  return v;
}
function read_ascending(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = -1; i < n2; i++)
    v[i] = x += 1 + next();
  return v;
}
function read_deltas(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0; i < n2; i++)
    v[i] = x += signed(next());
  return v;
}
function read_member_array(next, lookup) {
  let v = read_ascending(next(), next);
  let n2 = next();
  let vX = read_ascending(n2, next);
  let vN = read_counts(n2, next);
  for (let i = 0; i < n2; i++) {
    for (let j = 0; j < vN[i]; j++) {
      v.push(vX[i] + j);
    }
  }
  return lookup ? v.map((x) => lookup[x]) : v;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v = [];
  while (true) {
    let i = next();
    if (i == 0)
      break;
    v.push(i);
  }
  return v;
}
function read_transposed(n2, w, next) {
  let m = Array(n2).fill(void 0).map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return flat(m.map((v, i) => {
    const x = v[0], ys = v.slice(1);
    return Array(vN[i]).fill(void 0).map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  }));
}
function read_replacement_table(w, next) {
  let n2 = 1 + next();
  let m = read_transposed(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a, b2) => a - b2);
  return read();
  function read() {
    let branches = [];
    while (true) {
      let keys3 = read_member_array(next, sorted);
      if (keys3.length == 0)
        break;
      branches.push({ set: new Set(keys3), node: read() });
    }
    branches.sort((a, b2) => b2.set.size - a.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check2 = temp == 2;
    return { branches, valid, fe0f, save, check: check2 };
  }
}
var init_decoder = __esm({
  "node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js"() {
  }
});

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js
function getData() {
  return read_compressed_payload(decode2("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
var init_include = __esm({
  "node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js"() {
    init_lib10();
    init_decoder();
  }
});

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js
function explode_cp(name) {
  return toUtf8CodePoints(name);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name) {
  for (let label of name.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
        if (cps[i] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name;
}
function ens_normalize(name) {
  return ens_normalize_post_check(normalize(name, filter_fe0f));
}
function normalize(name, emoji_filter) {
  let input = explode_cp(name).reverse();
  let output2 = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output2.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output2.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output2.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output2)));
}
function nfc(s) {
  return s.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a2;
  let node2 = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node2 = (_a2 = node2.branches.find((x) => x.set.has(cp))) === null || _a2 === void 0 ? void 0 : _a2.node;
    if (!node2)
      break;
    if (node2.save) {
      saved = cp;
    } else if (node2.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node2.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node2.valid) {
      emoji = stack.slice();
      if (node2.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
var r, VALID, IGNORED, MAPPED, EMOJI_ROOT, HYPHEN, UNDERSCORE;
var init_lib11 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js"() {
    init_lib9();
    init_include();
    init_decoder();
    r = getData();
    VALID = new Set(read_member_array(r));
    IGNORED = new Set(read_member_array(r));
    MAPPED = read_mapped_map(r);
    EMOJI_ROOT = read_emoji_trie(r);
    HYPHEN = 45;
    UNDERSCORE = 95;
  }
});

// node_modules/@ethersproject/hash/lib.esm/namehash.js
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name) {
  const bytes3 = toUtf8Bytes(ens_normalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes3.length; i++) {
    const d = bytes3[i];
    if (d === 46) {
      comps.push(checkComponent(bytes3.slice(last, i)));
      last = i + 1;
    }
  }
  if (last >= bytes3.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes3.slice(last)));
  return comps;
}
function ensNormalize(name) {
  return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(".");
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name) {
  if (typeof name !== "string") {
    logger12.throwArgumentError("invalid ENS name; not a string", "name", name);
  }
  let result = Zeros;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak256(concat([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name) {
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes3 = new Uint8Array(comp.length + 1);
    bytes3.set(comp, 1);
    bytes3[0] = bytes3.length - 1;
    return bytes3;
  }))) + "00";
}
var logger12, Zeros;
var init_namehash = __esm({
  "node_modules/@ethersproject/hash/lib.esm/namehash.js"() {
    init_lib2();
    init_lib9();
    init_lib5();
    init_lib();
    init_version9();
    init_lib11();
    logger12 = new Logger(version9);
    Zeros = new Uint8Array(32);
    Zeros.fill(0);
  }
});

// node_modules/@ethersproject/hash/lib.esm/message.js
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var messagePrefix;
var init_message = __esm({
  "node_modules/@ethersproject/hash/lib.esm/message.js"() {
    init_lib2();
    init_lib5();
    init_lib9();
    messagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/@ethersproject/hash/lib.esm/typed-data.js
function hexPadRight(value) {
  const bytes3 = arrayify(value);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return hexConcat([bytes3, padding.slice(padOffset)]);
  }
  return hexlify(bytes3);
}
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
function getBaseEncoder(type) {
  {
    const match2 = type.match(/^(u?)int(\d*)$/);
    if (match2) {
      const signed3 = match2[1] === "";
      const width = parseInt(match2[2] || "256");
      if (width % 8 !== 0 || width > 256 || match2[2] && match2[2] !== String(width)) {
        logger13.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint2562.mask(signed3 ? width - 1 : width);
      const boundsLower = signed3 ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
      return function(value) {
        const v = BigNumber.from(value);
        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger13.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }
        return hexZeroPad(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match2 = type.match(/^bytes(\d+)$/);
    if (match2) {
      const width = parseInt(match2[1]);
      if (width === 0 || width > 32 || match2[1] !== String(width)) {
        logger13.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value) {
        const bytes3 = arrayify(value);
        if (bytes3.length !== width) {
          logger13.throwArgumentError(`invalid length for ${type}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
var __awaiter2, logger13, padding, NegativeOne3, Zero3, One2, MaxUint2562, hexTrue, hexFalse, domainFieldTypes, domainFieldNames, domainChecks, TypedDataEncoder;
var init_typed_data = __esm({
  "node_modules/@ethersproject/hash/lib.esm/typed-data.js"() {
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib4();
    init_lib();
    init_version9();
    init_id();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger13 = new Logger(version9);
    padding = new Uint8Array(32);
    padding.fill(0);
    NegativeOne3 = BigNumber.from(-1);
    Zero3 = BigNumber.from(0);
    One2 = BigNumber.from(1);
    MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    hexTrue = hexZeroPad(One2.toHexString(), 32);
    hexFalse = hexZeroPad(Zero3.toHexString(), 32);
    domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(value) {
        try {
          return BigNumber.from(value).toString();
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
      },
      verifyingContract: function(value) {
        try {
          return getAddress(value).toLowerCase();
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
      },
      salt: function(value) {
        try {
          const bytes3 = arrayify(value);
          if (bytes3.length !== 32) {
            throw new Error("bad length");
          }
          return hexlify(bytes3);
        } catch (error) {
        }
        return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
      }
    };
    TypedDataEncoder = class {
      constructor(types) {
        defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
        defineReadOnly(this, "_encoderCache", {});
        defineReadOnly(this, "_types", {});
        const links = {};
        const parents = {};
        const subtypes = {};
        Object.keys(types).forEach((type) => {
          links[type] = {};
          parents[type] = [];
          subtypes[type] = {};
        });
        for (const name in types) {
          const uniqueNames = {};
          types[name].forEach((field) => {
            if (uniqueNames[field.name]) {
              logger13.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
            }
            uniqueNames[field.name] = true;
            const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
            if (baseType === name) {
              logger13.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
            }
            const encoder = getBaseEncoder(baseType);
            if (encoder) {
              return;
            }
            if (!parents[baseType]) {
              logger13.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
            }
            parents[baseType].push(name);
            links[name][baseType] = true;
          });
        }
        const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
        if (primaryTypes.length === 0) {
          logger13.throwArgumentError("missing primary type", "types", types);
        } else if (primaryTypes.length > 1) {
          logger13.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types);
        }
        defineReadOnly(this, "primaryType", primaryTypes[0]);
        function checkCircular(type, found) {
          if (found[type]) {
            logger13.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
          }
          found[type] = true;
          Object.keys(links[type]).forEach((child) => {
            if (!parents[child]) {
              return;
            }
            checkCircular(child, found);
            Object.keys(found).forEach((subtype) => {
              subtypes[subtype][child] = true;
            });
          });
          delete found[type];
        }
        checkCircular(this.primaryType, {});
        for (const name in subtypes) {
          const st = Object.keys(subtypes[name]);
          st.sort();
          this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join("");
        }
      }
      getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
          encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
      }
      _getEncoder(type) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return encoder;
          }
        }
        const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match2) {
          const subtype = match2[1];
          const subEncoder = this.getEncoder(subtype);
          const length = parseInt(match2[3]);
          return (value) => {
            if (length >= 0 && value.length !== length) {
              logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            let result = value.map(subEncoder);
            if (this._types[subtype]) {
              result = result.map(keccak256);
            }
            return keccak256(hexConcat(result));
          };
        }
        const fields = this.types[type];
        if (fields) {
          const encodedType = id(this._types[type]);
          return (value) => {
            const values2 = fields.map(({ name, type: type2 }) => {
              const result = this.getEncoder(type2)(value[name]);
              if (this._types[type2]) {
                return keccak256(result);
              }
              return result;
            });
            values2.unshift(encodedType);
            return hexConcat(values2);
          };
        }
        return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      encodeType(name) {
        const result = this._types[name];
        if (!result) {
          logger13.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        }
        return result;
      }
      encodeData(type, value) {
        return this.getEncoder(type)(value);
      }
      hashStruct(name, value) {
        return keccak256(this.encodeData(name, value));
      }
      encode(value) {
        return this.encodeData(this.primaryType, value);
      }
      hash(value) {
        return this.hashStruct(this.primaryType, value);
      }
      _visit(type, value, callback) {
        {
          const encoder = getBaseEncoder(type);
          if (encoder) {
            return callback(type, value);
          }
        }
        const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match2) {
          const subtype = match2[1];
          const length = parseInt(match2[3]);
          if (length >= 0 && value.length !== length) {
            logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          return value.map((v) => this._visit(subtype, v, callback));
        }
        const fields = this.types[type];
        if (fields) {
          return fields.reduce((accum, { name, type: type2 }) => {
            accum[name] = this._visit(type2, value[name], callback);
            return accum;
          }, {});
        }
        return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
      }
      visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
      }
      static from(types) {
        return new TypedDataEncoder(types);
      }
      static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
      }
      static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
      }
      static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
          const type = domainFieldTypes[name];
          if (!type) {
            logger13.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
          }
          domainFields.push({ name, type });
        }
        domainFields.sort((a, b2) => {
          return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
      }
      static encode(domain, types, value) {
        return hexConcat([
          "0x1901",
          TypedDataEncoder.hashDomain(domain),
          TypedDataEncoder.from(types).hash(value)
        ]);
      }
      static hash(domain, types, value) {
        return keccak256(TypedDataEncoder.encode(domain, types, value));
      }
      static resolveNames(domain, types, value, resolveName2) {
        return __awaiter2(this, void 0, void 0, function* () {
          domain = shallowCopy(domain);
          const ensCache = {};
          if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = "0x";
          }
          const encoder = TypedDataEncoder.from(types);
          encoder.visit(value, (type, value2) => {
            if (type === "address" && !isHexString(value2, 20)) {
              ensCache[value2] = "0x";
            }
            return value2;
          });
          for (const name in ensCache) {
            ensCache[name] = yield resolveName2(name);
          }
          if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
          }
          value = encoder.visit(value, (type, value2) => {
            if (type === "address" && ensCache[value2]) {
              return ensCache[value2];
            }
            return value2;
          });
          return { domain, value };
        });
      }
      static getPayload(domain, types, value) {
        TypedDataEncoder.hashDomain(domain);
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
          const value2 = domain[name];
          if (value2 == null) {
            return;
          }
          domainValues[name] = domainChecks[name](value2);
          domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = shallowCopy(types);
        if (typesWithDomain.EIP712Domain) {
          logger13.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        } else {
          typesWithDomain.EIP712Domain = domainTypes;
        }
        encoder.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder.primaryType,
          message: encoder.visit(value, (type, value2) => {
            if (type.match(/^bytes(\d*)/)) {
              return hexlify(arrayify(value2));
            }
            if (type.match(/^u?int/)) {
              return BigNumber.from(value2).toString();
            }
            switch (type) {
              case "address":
                return value2.toLowerCase();
              case "bool":
                return !!value2;
              case "string":
                if (typeof value2 !== "string") {
                  logger13.throwArgumentError(`invalid string`, "value", value2);
                }
                return value2;
            }
            return logger13.throwArgumentError("unsupported type", "type", type);
          })
        };
      }
    };
  }
});

// node_modules/@ethersproject/hash/lib.esm/index.js
var lib_exports10 = {};
__export(lib_exports10, {
  _TypedDataEncoder: () => TypedDataEncoder,
  dnsEncode: () => dnsEncode,
  ensNormalize: () => ensNormalize,
  hashMessage: () => hashMessage,
  id: () => id,
  isValidName: () => isValidName,
  messagePrefix: () => messagePrefix,
  namehash: () => namehash
});
var init_lib12 = __esm({
  "node_modules/@ethersproject/hash/lib.esm/index.js"() {
    "use strict";
    init_id();
    init_namehash();
    init_message();
    init_namehash();
    init_typed_data();
  }
});

// node_modules/@ethersproject/abi/lib.esm/interface.js
function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
var logger14, LogDescription, TransactionDescription, ErrorDescription, Indexed, BuiltinErrors, Interface;
var init_interface = __esm({
  "node_modules/@ethersproject/abi/lib.esm/interface.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib12();
    init_lib5();
    init_lib4();
    init_abi_coder();
    init_abstract_coder();
    init_fragments();
    init_lib();
    init_version5();
    logger14 = new Logger(version5);
    LogDescription = class extends Description {
    };
    TransactionDescription = class extends Description {
    };
    ErrorDescription = class extends Description {
    };
    Indexed = class extends Description {
      static isIndexed(value) {
        return !!(value && value._isIndexed);
      }
    };
    BuiltinErrors = {
      "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
      "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
    };
    Interface = class {
      constructor(fragments) {
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        defineReadOnly(this, "fragments", abi.map((fragment) => {
          return Fragment.from(fragment);
        }).filter((fragment) => fragment != null));
        defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {});
        this.fragments.forEach((fragment) => {
          let bucket = null;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                logger14.warn("duplicate definition - constructor");
                return;
              }
              defineReadOnly(this, "deploy", fragment);
              return;
            case "function":
              bucket = this.functions;
              break;
            case "event":
              bucket = this.events;
              break;
            case "error":
              bucket = this.errors;
              break;
            default:
              return;
          }
          let signature2 = fragment.format();
          if (bucket[signature2]) {
            logger14.warn("duplicate definition - " + signature2);
            return;
          }
          bucket[signature2] = fragment;
        });
        if (!this.deploy) {
          defineReadOnly(this, "deploy", ConstructorFragment.from({
            payable: false,
            type: "constructor"
          }));
        }
        defineReadOnly(this, "_isInterface", true);
      }
      format(format) {
        if (!format) {
          format = FormatTypes.full;
        }
        if (format === FormatTypes.sighash) {
          logger14.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        if (format === FormatTypes.json) {
          return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
      }
      static getAbiCoder() {
        return defaultAbiCoder;
      }
      static getAddress(address) {
        return getAddress(address);
      }
      static getSighash(fragment) {
        return hexDataSlice(id(fragment.format()), 0, 4);
      }
      static getEventTopic(eventFragment) {
        return id(eventFragment.format());
      }
      getFunction(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          for (const name in this.functions) {
            if (nameOrSignatureOrSighash === this.getSighash(name)) {
              return this.functions[name];
            }
          }
          logger14.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.functions).filter((f2) => f2.split("(")[0] === name);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching function", "name", name);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching functions", "name", name);
          }
          return this.functions[matching[0]];
        }
        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger14.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      getEvent(nameOrSignatureOrTopic) {
        if (isHexString(nameOrSignatureOrTopic)) {
          const topichash = nameOrSignatureOrTopic.toLowerCase();
          for (const name in this.events) {
            if (topichash === this.getEventTopic(name)) {
              return this.events[name];
            }
          }
          logger14.throwArgumentError("no matching event", "topichash", topichash);
        }
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
          const name = nameOrSignatureOrTopic.trim();
          const matching = Object.keys(this.events).filter((f2) => f2.split("(")[0] === name);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching event", "name", name);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching events", "name", name);
          }
          return this.events[matching[0]];
        }
        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
          logger14.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
      }
      getError(nameOrSignatureOrSighash) {
        if (isHexString(nameOrSignatureOrSighash)) {
          const getSighash = getStatic(this.constructor, "getSighash");
          for (const name in this.errors) {
            const error = this.errors[name];
            if (nameOrSignatureOrSighash === getSighash(error)) {
              return this.errors[name];
            }
          }
          logger14.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
          const name = nameOrSignatureOrSighash.trim();
          const matching = Object.keys(this.errors).filter((f2) => f2.split("(")[0] === name);
          if (matching.length === 0) {
            logger14.throwArgumentError("no matching error", "name", name);
          } else if (matching.length > 1) {
            logger14.throwArgumentError("multiple matching errors", "name", name);
          }
          return this.errors[matching[0]];
        }
        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
          logger14.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
      }
      getSighash(fragment) {
        if (typeof fragment === "string") {
          try {
            fragment = this.getFunction(fragment);
          } catch (error) {
            try {
              fragment = this.getError(fragment);
            } catch (_) {
              throw error;
            }
          }
        }
        return getStatic(this.constructor, "getSighash")(fragment);
      }
      getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        return getStatic(this.constructor, "getEventTopic")(eventFragment);
      }
      _decodeParams(params, data2) {
        return this._abiCoder.decode(params, data2);
      }
      _encodeParams(params, values2) {
        return this._abiCoder.encode(params, values2);
      }
      encodeDeploy(values2) {
        return this._encodeParams(this.deploy.inputs, values2 || []);
      }
      decodeErrorResult(fragment, data2) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        const bytes3 = arrayify(data2);
        if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(fragment)) {
          logger14.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes3));
        }
        return this._decodeParams(fragment.inputs, bytes3.slice(4));
      }
      encodeErrorResult(fragment, values2) {
        if (typeof fragment === "string") {
          fragment = this.getError(fragment);
        }
        return hexlify(concat([
          this.getSighash(fragment),
          this._encodeParams(fragment.inputs, values2 || [])
        ]));
      }
      decodeFunctionData(functionFragment, data2) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        const bytes3 = arrayify(data2);
        if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(functionFragment)) {
          logger14.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes3));
        }
        return this._decodeParams(functionFragment.inputs, bytes3.slice(4));
      }
      encodeFunctionData(functionFragment, values2) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(concat([
          this.getSighash(functionFragment),
          this._encodeParams(functionFragment.inputs, values2 || [])
        ]));
      }
      decodeFunctionResult(functionFragment, data2) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        let bytes3 = arrayify(data2);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes3.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(functionFragment.outputs, bytes3);
            } catch (error) {
            }
            break;
          case 4: {
            const selector = hexlify(bytes3.slice(0, 4));
            const builtin = BuiltinErrors[selector];
            if (builtin) {
              errorArgs = this._abiCoder.decode(builtin.inputs, bytes3.slice(4));
              errorName = builtin.name;
              errorSignature = builtin.signature;
              if (builtin.reason) {
                reason = errorArgs[0];
              }
              if (errorName === "Error") {
                message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
              } else if (errorName === "Panic") {
                message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
              }
            } else {
              try {
                const error = this.getError(selector);
                errorArgs = this._abiCoder.decode(error.inputs, bytes3.slice(4));
                errorName = error.name;
                errorSignature = error.format();
              } catch (error) {
              }
            }
            break;
          }
        }
        return logger14.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
          method: functionFragment.format(),
          data: hexlify(data2),
          errorArgs,
          errorName,
          errorSignature,
          reason
        });
      }
      encodeFunctionResult(functionFragment, values2) {
        if (typeof functionFragment === "string") {
          functionFragment = this.getFunction(functionFragment);
        }
        return hexlify(this._abiCoder.encode(functionFragment.outputs, values2 || []));
      }
      encodeFilterTopics(eventFragment, values2) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (values2.length > eventFragment.inputs.length) {
          logger14.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values2
          });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
          if (param.type === "string") {
            return id(value);
          } else if (param.type === "bytes") {
            return keccak256(hexlify(value));
          }
          if (param.type === "bool" && typeof value === "boolean") {
            value = value ? "0x01" : "0x00";
          }
          if (param.type.match(/^u?int/)) {
            value = BigNumber.from(value).toHexString();
          }
          if (param.type === "address") {
            this._abiCoder.encode(["address"], [value]);
          }
          return hexZeroPad(hexlify(value), 32);
        };
        values2.forEach((value, index) => {
          let param = eventFragment.inputs[index];
          if (!param.indexed) {
            if (value != null) {
              logger14.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            }
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            logger14.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map((value2) => encodeTopic(param, value2)));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(eventFragment, values2) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
          topics.push(this.getEventTopic(eventFragment));
        }
        if (values2.length !== eventFragment.inputs.length) {
          logger14.throwArgumentError("event arguments/values mismatch", "values", values2);
        }
        eventFragment.inputs.forEach((param, index) => {
          const value = values2[index];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push(id(value));
            } else if (param.type === "bytes") {
              topics.push(keccak256(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(this._abiCoder.encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: this._abiCoder.encode(dataTypes, dataValues),
          topics
        };
      }
      decodeEventLog(eventFragment, data2, topics) {
        if (typeof eventFragment === "string") {
          eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
          let topicHash = this.getEventTopic(eventFragment);
          if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
            logger14.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
          }
          topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data2, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (resultIndexed == null) {
              result[index] = new Indexed({ _isIndexed: true, hash: null });
            } else if (dynamic[index]) {
              result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
            } else {
              try {
                result[index] = resultIndexed[indexedIndex++];
              } catch (error) {
                result[index] = error;
              }
            }
          } else {
            try {
              result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              result[index] = error;
            }
          }
          if (param.name && result[param.name] == null) {
            const value = result[index];
            if (value instanceof Error) {
              Object.defineProperty(result, param.name, {
                enumerable: true,
                get: () => {
                  throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
                }
              });
            } else {
              result[param.name] = value;
            }
          }
        });
        for (let i = 0; i < result.length; i++) {
          const value = result[i];
          if (value instanceof Error) {
            Object.defineProperty(result, i, {
              enumerable: true,
              get: () => {
                throw wrapAccessError(`index ${i}`, value);
              }
            });
          }
        }
        return Object.freeze(result);
      }
      parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new TransactionDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
          functionFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment),
          value: BigNumber.from(tx.value || "0")
        });
      }
      parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription({
          eventFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          topic: this.getEventTopic(fragment),
          args: this.decodeEventLog(fragment, log.data, log.topics)
        });
      }
      parseError(data2) {
        const hexData = hexlify(data2);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
          return null;
        }
        return new ErrorDescription({
          args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
          errorFragment: fragment,
          name: fragment.name,
          signature: fragment.format(),
          sighash: this.getSighash(fragment)
        });
      }
      static isInterface(value) {
        return !!(value && value._isInterface);
      }
    };
  }
});

// node_modules/@ethersproject/abi/lib.esm/index.js
var lib_exports11 = {};
__export(lib_exports11, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  ParamType: () => ParamType,
  TransactionDescription: () => TransactionDescription,
  checkResultErrors: () => checkResultErrors,
  defaultAbiCoder: () => defaultAbiCoder
});
var init_lib13 = __esm({
  "node_modules/@ethersproject/abi/lib.esm/index.js"() {
    "use strict";
    init_fragments();
    init_abi_coder();
    init_interface();
  }
});

// node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version10;
var init_version10 = __esm({
  "node_modules/@ethersproject/abstract-provider/lib.esm/_version.js"() {
    version10 = "abstract-provider/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter3, logger15, ForkEvent, Provider;
var init_lib14 = __esm({
  "node_modules/@ethersproject/abstract-provider/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib();
    init_version10();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger15 = new Logger(version10);
    ForkEvent = class extends Description {
      static isForkEvent(value) {
        return !!(value && value._isForkEvent);
      }
    };
    Provider = class {
      constructor() {
        logger15.checkAbstract(new.target, Provider);
        defineReadOnly(this, "_isProvider", true);
      }
      getFeeData() {
        return __awaiter3(this, void 0, void 0, function* () {
          const { block, gasPrice } = yield resolveProperties({
            block: this.getBlock("latest"),
            gasPrice: this.getGasPrice().catch((error) => {
              return null;
            })
          });
          let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
          if (block && block.baseFeePerGas) {
            lastBaseFeePerGas = block.baseFeePerGas;
            maxPriorityFeePerGas = BigNumber.from("1500000000");
            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
          }
          return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
      }
      addListener(eventName, listener) {
        return this.on(eventName, listener);
      }
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
      static isProvider(value) {
        return !!(value && value._isProvider);
      }
    };
  }
});

// node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version11;
var init_version11 = __esm({
  "node_modules/@ethersproject/abstract-signer/lib.esm/_version.js"() {
    version11 = "abstract-signer/5.7.0";
  }
});

// node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter4, logger16, allowedTransactionKeys, forwardErrors, Signer, VoidSigner;
var init_lib15 = __esm({
  "node_modules/@ethersproject/abstract-signer/lib.esm/index.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version11();
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger16 = new Logger(version11);
    allowedTransactionKeys = [
      "accessList",
      "ccipReadEnabled",
      "chainId",
      "customData",
      "data",
      "from",
      "gasLimit",
      "gasPrice",
      "maxFeePerGas",
      "maxPriorityFeePerGas",
      "nonce",
      "to",
      "type",
      "value"
    ];
    forwardErrors = [
      Logger.errors.INSUFFICIENT_FUNDS,
      Logger.errors.NONCE_EXPIRED,
      Logger.errors.REPLACEMENT_UNDERPRICED
    ];
    Signer = class {
      constructor() {
        logger16.checkAbstract(new.target, Signer);
        defineReadOnly(this, "_isSigner", true);
      }
      getBalance(blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getBalance");
          return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
      }
      getTransactionCount(blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getTransactionCount");
          return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
      }
      estimateGas(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("estimateGas");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.estimateGas(tx);
        });
      }
      call(transaction, blockTag) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("call");
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          return yield this.provider.call(tx, blockTag);
        });
      }
      sendTransaction(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("sendTransaction");
          const tx = yield this.populateTransaction(transaction);
          const signedTx = yield this.signTransaction(tx);
          return yield this.provider.sendTransaction(signedTx);
        });
      }
      getChainId() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getChainId");
          const network = yield this.provider.getNetwork();
          return network.chainId;
        });
      }
      getGasPrice() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getGasPrice");
          return yield this.provider.getGasPrice();
        });
      }
      getFeeData() {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("getFeeData");
          return yield this.provider.getFeeData();
        });
      }
      resolveName(name) {
        return __awaiter4(this, void 0, void 0, function* () {
          this._checkProvider("resolveName");
          return yield this.provider.resolveName(name);
        });
      }
      checkTransaction(transaction) {
        for (const key2 in transaction) {
          if (allowedTransactionKeys.indexOf(key2) === -1) {
            logger16.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
          }
        }
        const tx = shallowCopy(transaction);
        if (tx.from == null) {
          tx.from = this.getAddress();
        } else {
          tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
          ]).then((result) => {
            if (result[0].toLowerCase() !== result[1].toLowerCase()) {
              logger16.throwArgumentError("from address mismatch", "transaction", transaction);
            }
            return result[0];
          });
        }
        return tx;
      }
      populateTransaction(transaction) {
        return __awaiter4(this, void 0, void 0, function* () {
          const tx = yield resolveProperties(this.checkTransaction(transaction));
          if (tx.to != null) {
            tx.to = Promise.resolve(tx.to).then((to) => __awaiter4(this, void 0, void 0, function* () {
              if (to == null) {
                return null;
              }
              const address = yield this.resolveName(to);
              if (address == null) {
                logger16.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
              }
              return address;
            }));
            tx.to.catch((error) => {
            });
          }
          const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
          if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
            logger16.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
          } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
            logger16.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
          }
          if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
            tx.type = 2;
          } else if (tx.type === 0 || tx.type === 1) {
            if (tx.gasPrice == null) {
              tx.gasPrice = this.getGasPrice();
            }
          } else {
            const feeData = yield this.getFeeData();
            if (tx.type == null) {
              if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                tx.type = 2;
                if (tx.gasPrice != null) {
                  const gasPrice = tx.gasPrice;
                  delete tx.gasPrice;
                  tx.maxFeePerGas = gasPrice;
                  tx.maxPriorityFeePerGas = gasPrice;
                } else {
                  if (tx.maxFeePerGas == null) {
                    tx.maxFeePerGas = feeData.maxFeePerGas;
                  }
                  if (tx.maxPriorityFeePerGas == null) {
                    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }
              } else if (feeData.gasPrice != null) {
                if (hasEip1559) {
                  logger16.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                  });
                }
                if (tx.gasPrice == null) {
                  tx.gasPrice = feeData.gasPrice;
                }
                tx.type = 0;
              } else {
                logger16.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "signer.getFeeData"
                });
              }
            } else if (tx.type === 2) {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          }
          if (tx.nonce == null) {
            tx.nonce = this.getTransactionCount("pending");
          }
          if (tx.gasLimit == null) {
            tx.gasLimit = this.estimateGas(tx).catch((error) => {
              if (forwardErrors.indexOf(error.code) >= 0) {
                throw error;
              }
              return logger16.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                error,
                tx
              });
            });
          }
          if (tx.chainId == null) {
            tx.chainId = this.getChainId();
          } else {
            tx.chainId = Promise.all([
              Promise.resolve(tx.chainId),
              this.getChainId()
            ]).then((results) => {
              if (results[1] !== 0 && results[0] !== results[1]) {
                logger16.throwArgumentError("chainId address mismatch", "transaction", transaction);
              }
              return results[0];
            });
          }
          return yield resolveProperties(tx);
        });
      }
      _checkProvider(operation) {
        if (!this.provider) {
          logger16.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
          });
        }
      }
      static isSigner(value) {
        return !!(value && value._isSigner);
      }
    };
    VoidSigner = class extends Signer {
      constructor(address, provider) {
        super();
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "provider", provider || null);
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      _fail(message, operation) {
        return Promise.resolve().then(() => {
          logger16.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
        });
      }
      signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
      }
      signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
      }
      _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
      }
      connect(provider) {
        return new VoidSigner(this.address, provider);
      }
    };
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert3.equal = function assertEqual2(l, r2, msg) {
      if (l != r2)
        throw new Error(msg || "Assertion failed: " + l + " != " + r2);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports.toHex = toHex2;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b2) {
      return w >>> b2 | w << 32 - b2;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b2) {
      return w << b2 | w >>> 32 - b2;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b2) {
      return a + b2 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b2, c) {
      return a + b2 + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b2, c, d) {
      return a + b2 + c + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b2, c, d, e) {
      return a + b2 + c + d + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r2 = al << 32 - num | ah >>> num;
      return r2 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r2 = ah << 32 - num | al >>> num;
      return r2 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update2(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r2 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r2, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r2, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes3 = this._delta8;
      var k = bytes3 - (len + this.padLength) % bytes3;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b2 = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b2, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b2, 30);
        b2 = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA2562() {
      if (!(this instanceof SHA2562))
        return new SHA2562();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA2562, BlockHash);
    module.exports = SHA2562;
    SHA2562.blockSize = 512;
    SHA2562.outSize = 256;
    SHA2562.hmacStrength = 192;
    SHA2562.padLength = 64;
    SHA2562.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b2 = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f2 = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert3(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T13 = sum32_5(h, s1_256(e), ch32(e, f2, g), this.k[i], W[i]);
        var T22 = sum32(s0_256(a), maj32(a, b2, c));
        h = g;
        g = f2;
        f2 = e;
        e = sum32(d, T13);
        d = c;
        c = b2;
        b2 = a;
        a = sum32(T13, T22);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f2);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA2562.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var SHA2562 = require__2();
    function SHA2242() {
      if (!(this instanceof SHA2242))
        return new SHA2242();
      SHA2562.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA2242, SHA2562);
    module.exports = SHA2242;
    SHA2242.blockSize = 512;
    SHA2242.outSize = 224;
    SHA2242.hmacStrength = 192;
    SHA2242.padLength = 64;
    SHA2242.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA5122() {
      if (!(this instanceof SHA5122))
        return new SHA5122();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA5122, BlockHash);
    module.exports = SHA5122;
    SHA5122.blockSize = 1024;
    SHA5122.outSize = 512;
    SHA5122.hmacStrength = 192;
    SHA5122.padLength = 128;
    SHA5122.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA5122.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA5122.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ ~xh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ ~xl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r2 = xh & yh ^ xh & zh ^ yh & zh;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r2 = xl & yl ^ xl & zl ^ yl & zl;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r2 = c0_hi ^ c1_hi ^ c2_hi;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r2 = c0_lo ^ c1_lo ^ c2_lo;
      if (r2 < 0)
        r2 += 4294967296;
      return r2;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var SHA5122 = require__4();
    function SHA3842() {
      if (!(this instanceof SHA3842))
        return new SHA3842();
      SHA5122.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA3842, SHA5122);
    module.exports = SHA3842;
    SHA3842.blockSize = 1024;
    SHA3842.outSize = 384;
    SHA3842.hmacStrength = 192;
    SHA3842.padLength = 128;
    SHA3842.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD1602() {
      if (!(this instanceof RIPEMD1602))
        return new RIPEMD1602();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD1602, BlockHash);
    exports.ripemd160 = RIPEMD1602;
    RIPEMD1602.blockSize = 512;
    RIPEMD1602.outSize = 160;
    RIPEMD1602.hmacStrength = 192;
    RIPEMD1602.padLength = 64;
    RIPEMD1602.prototype._update = function update2(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f2(j, B, C, D), msg[r2[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f2(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD1602.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f2(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r2 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash4, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash4, key2, enc);
      this.Hash = hash4;
      this.blockSize = hash4.blockSize / 8;
      this.outSize = hash4.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init3(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert3(key2.length <= this.blockSize);
      for (var i = key2.length; i < this.blockSize; i++)
        key2.push(0);
      for (i = 0; i < key2.length; i++)
        key2[i] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i = 0; i < key2.length; i++)
        key2[i] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update2(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash4 = exports;
    hash4.utils = require_utils();
    hash4.common = require_common();
    hash4.sha = require_sha();
    hash4.ripemd = require_ripemd();
    hash4.hmac = require_hmac();
    hash4.sha1 = hash4.sha.sha1;
    hash4.sha256 = hash4.sha.sha256;
    hash4.sha224 = hash4.sha.sha224;
    hash4.sha384 = hash4.sha.sha384;
    hash4.sha512 = hash4.sha.sha512;
    hash4.ripemd160 = hash4.ripemd.ripemd160;
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module.path : base2);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
function ShortCurve(conf) {
  base.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, "affine");
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x, 16);
    this.y = new import_bn2.default(y, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, "jacobian");
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x, 16);
    this.y = new import_bn2.default(y, 16);
    this.z = new import_bn2.default(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
function Position() {
  this.place = 0;
}
function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var import_bn2, import_hash2, minimalisticAssert, utils_1, utils_1$1, getNAF, getJSF, assert$1, base, inherits_browser, assert$2, short_1, curve_1, curves_1, hmacDrbg, assert$3, key, assert$4, signature, rand, assert$5, ec, elliptic_1, EC$1;
var init_elliptic = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/elliptic.js"() {
    import_bn2 = __toESM(require_bn());
    import_hash2 = __toESM(require_hash());
    minimalisticAssert = assert;
    assert.equal = function assertEqual(l, r2, msg) {
      if (l != r2)
        throw new Error(msg || "Assertion failed: " + l + " != " + r2);
    };
    utils_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var utils = exports;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode4(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    });
    utils_1$1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var utils = exports;
      utils.assert = minimalisticAssert;
      utils.toArray = utils_1.toArray;
      utils.zero2 = utils_1.zero2;
      utils.toHex = utils_1.toHex;
      utils.encode = utils_1.encode;
      function getNAF2(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for (var i = 0; i < naf.length; i++) {
          var z;
          var mod2 = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod2 > (ws >> 1) - 1)
              z = (ws >> 1) - mod2;
            else
              z = mod2;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF2;
      function getJSF2(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF2;
      function cachedProperty(obj, name, computer) {
        var key2 = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes3) {
        return typeof bytes3 === "string" ? utils.toArray(bytes3, "hex") : bytes3;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes3) {
        return new import_bn2.default(bytes3, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    });
    getNAF = utils_1$1.getNAF;
    getJSF = utils_1$1.getJSF;
    assert$1 = utils_1$1.assert;
    base = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert$1(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b2 = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b2 = b2.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b2 = b2.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b2);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert$1(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max2 = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b2 = i;
        if (wndWidth[a] !== 1 || wndWidth[b2] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
          max2 = Math.max(naf[a].length, max2);
          max2 = Math.max(naf[b2].length, max2);
          continue;
        }
        var comb = [
          points[a],
          null,
          null,
          points[b2]
        ];
        if (points[a].y.cmp(points[b2].y) === 0) {
          comb[1] = points[a].add(points[b2]);
          comb[2] = points[a].toJ().mixedAdd(points[b2].neg());
        } else if (points[a].y.cmp(points[b2].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b2]);
          comb[2] = points[a].add(points[b2].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b2]);
          comb[2] = points[a].toJ().mixedAdd(points[b2].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b2]);
        max2 = Math.max(jsf[0].length, max2);
        naf[a] = new Array(max2);
        naf[b2] = new Array(max2);
        for (j = 0; j < max2; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b2][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max2; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate2() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
      bytes3 = utils_1$1.toArray(bytes3, enc);
      var len = this.p.byteLength();
      if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
        if (bytes3[0] === 6)
          assert$1(bytes3[bytes3.length - 1] % 2 === 0);
        else if (bytes3[0] === 7)
          assert$1(bytes3[bytes3.length - 1] % 2 === 1);
        var res = this.point(
          bytes3.slice(1, 1 + len),
          bytes3.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
        return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode2(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode3(enc, compact) {
      return utils_1$1.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max2 = (1 << wnd) - 1;
      var dbl3 = max2 === 1 ? null : this.dbl();
      for (var i = 1; i < max2; i++)
        res[i] = res[i - 1].add(dbl3);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r2 = this;
      for (var i = 0; i < k; i++)
        r2 = r2.dbl();
      return r2;
    };
    inherits_browser = createCommonjsModule(function(module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    });
    assert$2 = utils_1$1.assert;
    inherits_browser(ShortCurve, base);
    short_1 = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new import_bn2.default(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new import_bn2.default(vec.a, 16),
            b: new import_bn2.default(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : import_bn2.default.mont(num);
      var tinv = new import_bn2.default(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new import_bn2.default(1);
      var y1 = new import_bn2.default(0);
      var x2 = new import_bn2.default(0);
      var y2 = new import_bn2.default(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r2;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r2 = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r2.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r2.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r2;
        v = u;
        u = r2;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r2.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new import_bn2.default(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate3(point3) {
      if (point3.inf)
        return true;
      var x = point3.x;
      var y = point3.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split4 = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split4.k1.negative) {
          split4.k1.ineg();
          p = p.neg(true);
        }
        if (split4.k2.negative) {
          split4.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split4.k1;
        ncoeffs[i * 2 + 1] = split4.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    inherits_browser(Point, base.BasePoint);
    ShortCurve.prototype.point = function point2(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta2() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new import_bn2.default(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq2(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    inherits_browser(JPoint, base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg2() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add2(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r2 = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r2.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r2.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r2.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp2(pow3) {
      if (pow3 === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow3)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r2 = this;
        for (i = 0; i < pow3; i++)
          r2 = r2.dbl();
        return r2;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow3; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow3)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl2() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b2 = this.y.redSqr();
        var c = b2.redSqr();
        var d = this.x.redAdd(b2).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f2 = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f2.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul2(k, kbase) {
      k = new import_bn2.default(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq3(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect2() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity2() {
      return this.z.cmpn(0) === 0;
    };
    curve_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var curve = exports;
      curve.base = base;
      curve.short = short_1;
      curve.mont = null;
      curve.edwards = null;
    });
    curves_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var curves = exports;
      var assert3 = utils_1$1.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve_1.short(options);
        else if (options.type === "edwards")
          this.curve = new curve_1.edwards(options);
        else
          this.curve = new curve_1.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert3(this.g.validate(), "Invalid curve");
        assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve
            });
            return curve;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: import_hash2.default.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: import_hash2.default.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: import_hash2.default.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = null.crash();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: import_hash2.default.sha256,
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    });
    hmacDrbg = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new import_hash2.default.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add4, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add4;
        add4 = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils_1.toArray(entropy, entropyEnc);
      add4 = utils_1.toArray(add4, addEnc);
      minimalisticAssert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add4 || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add4, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add4;
        add4 = enc;
        enc = null;
      }
      if (add4) {
        add4 = utils_1.toArray(add4, addEnc || "hex");
        this._update(add4);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add4);
      this._reseed++;
      return utils_1.encode(res, enc);
    };
    assert$3 = utils_1$1.assert;
    key = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec2, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec2, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate4() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
      this.priv = new import_bn2.default(key2, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
      if (key2.x || key2.y) {
        if (this.ec.curve.type === "mont") {
          assert$3(key2.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert$3(key2.x && key2.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key2.x, key2.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key2, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert$3(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature2) {
      return this.ec.verify(msg, signature2, this);
    };
    KeyPair.prototype.inspect = function inspect3() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    assert$4 = utils_1$1.assert;
    signature = Signature;
    Signature.prototype._importDER = function _importDER(data2, enc) {
      data2 = utils_1$1.toArray(data2, enc);
      var p = new Position();
      if (data2[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data2, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data2.length) {
        return false;
      }
      if (data2[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data2, p);
      if (rlen === false) {
        return false;
      }
      var r2 = data2.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data2[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data2, p);
      if (slen === false) {
        return false;
      }
      if (data2.length !== slen + p.place) {
        return false;
      }
      var s = data2.slice(p.place, slen + p.place);
      if (r2[0] === 0) {
        if (r2[1] & 128) {
          r2 = r2.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new import_bn2.default(r2);
      this.s = new import_bn2.default(s);
      this.recoveryParam = null;
      return true;
    };
    Signature.prototype.toDER = function toDER(enc) {
      var r2 = this.r.toArray();
      var s = this.s.toArray();
      if (r2[0] & 128)
        r2 = [0].concat(r2);
      if (s[0] & 128)
        s = [0].concat(s);
      r2 = rmPadding(r2);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r2.length);
      arr = arr.concat(r2);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils_1$1.encode(res, enc);
    };
    rand = function() {
      throw new Error("unsupported");
    };
    assert$5 = utils_1$1.assert;
    ec = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new key(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return key.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return key.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new hmacDrbg({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes3 = this.n.byteLength();
      var ns2 = this.n.sub(new import_bn2.default(2));
      for (; ; ) {
        var priv = new import_bn2.default(drbg.generate(bytes3));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key2, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key2 = this.keyFromPrivate(key2, enc);
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      var bytes3 = this.n.byteLength();
      var bkey = key2.getPrivate().toArray("be", bytes3);
      var nonce = msg.toArray("be", bytes3);
      var drbg = new hmacDrbg({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new import_bn2.default(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r2 = kpX.umod(this.n);
        if (r2.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new signature({ r: r2, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify2(msg, signature$1, key2, enc) {
      msg = this._truncateToN(new import_bn2.default(msg, 16));
      key2 = this.keyFromPublic(key2, enc);
      signature$1 = new signature(signature$1, "hex");
      var r2 = signature$1.r;
      var s = signature$1.s;
      if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r2).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key2.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r2) === 0;
      }
      p = this.g.jmulAdd(u1, key2.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r2);
    };
    EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
      assert$5((3 & j) === j, "The recovery param is more than two bits");
      signature$1 = new signature(signature$1, enc);
      var n2 = this.n;
      var e = new import_bn2.default(msg);
      var r2 = signature$1.r;
      var s = signature$1.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
      else
        r2 = this.curve.pointFromX(r2, isYOdd);
      var rInv = signature$1.r.invm(n2);
      var s1 = n2.sub(e).mul(rInv).umod(n2);
      var s2 = s.mul(rInv).umod(n2);
      return this.g.mulAdd(s1, r2, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
      signature$1 = new signature(signature$1, enc);
      if (signature$1.recoveryParam !== null)
        return signature$1.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature$1, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
    elliptic_1 = createCommonjsModule(function(module, exports) {
      "use strict";
      var elliptic = exports;
      elliptic.version = { version: "6.5.4" }.version;
      elliptic.utils = utils_1$1;
      elliptic.rand = function() {
        throw new Error("unsupported");
      };
      elliptic.curve = curve_1;
      elliptic.curves = curves_1;
      elliptic.ec = ec;
      elliptic.eddsa = null;
    });
    EC$1 = elliptic_1.ec;
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version12;
var init_version12 = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/_version.js"() {
    version12 = "signing-key/5.7.0";
  }
});

// node_modules/@ethersproject/signing-key/lib.esm/index.js
var lib_exports12 = {};
__export(lib_exports12, {
  SigningKey: () => SigningKey,
  computePublicKey: () => computePublicKey,
  recoverPublicKey: () => recoverPublicKey
});
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
function recoverPublicKey(digest, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes3 = arrayify(key2);
  if (bytes3.length === 32) {
    const signingKey = new SigningKey(bytes3);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes3).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes3.length === 33) {
    if (compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(false, "hex");
  } else if (bytes3.length === 65) {
    if (!compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(true, "hex");
  }
  return logger17.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var logger17, _curve, SigningKey;
var init_lib16 = __esm({
  "node_modules/@ethersproject/signing-key/lib.esm/index.js"() {
    "use strict";
    init_elliptic();
    init_lib2();
    init_lib4();
    init_lib();
    init_version12();
    logger17 = new Logger(version12);
    _curve = null;
    SigningKey = class {
      constructor(privateKey) {
        defineReadOnly(this, "curve", "secp256k1");
        defineReadOnly(this, "privateKey", hexlify(privateKey));
        if (hexDataLength(this.privateKey) !== 32) {
          logger17.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        }
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
        defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
        defineReadOnly(this, "_isSigningKey", true);
      }
      _addPoint(other) {
        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
        const p1 = getCurve().keyFromPublic(arrayify(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
      }
      signDigest(digest) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const digestBytes = arrayify(digest);
        if (digestBytes.length !== 32) {
          logger17.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature2 = keyPair2.sign(digestBytes, { canonical: true });
        return splitSignature({
          recoveryParam: signature2.recoveryParam,
          r: hexZeroPad("0x" + signature2.r.toString(16), 32),
          s: hexZeroPad("0x" + signature2.s.toString(16), 32)
        });
      }
      computeSharedSecret(otherKey) {
        const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
        return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
      }
      static isSigningKey(value) {
        return !!(value && value._isSigningKey);
      }
    };
  }
});

// node_modules/@ethersproject/transactions/lib.esm/_version.js
var version13;
var init_version13 = __esm({
  "node_modules/@ethersproject/transactions/lib.esm/_version.js"() {
    version13 = "transactions/5.7.0";
  }
});

// node_modules/@ethersproject/transactions/lib.esm/index.js
var lib_exports13 = {};
__export(lib_exports13, {
  TransactionTypes: () => TransactionTypes,
  accessListify: () => accessListify,
  computeAddress: () => computeAddress,
  parse: () => parse,
  recoverAddress: () => recoverAddress,
  serialize: () => serialize
});
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero2;
  }
  return BigNumber.from(value);
}
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest), signature2));
}
function formatNumber(value, name) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger18.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger18.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index) => {
      if (Array.isArray(set2)) {
        if (set2.length > 2) {
          logger18.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set2);
        }
        return accessSetify(set2[0], set2[1]);
      }
      return accessSetify(set2.address, set2.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger18.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys2);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger18.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode(raw);
  }
  const sig = splitSignature(signature2);
  let v = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v) {
      logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v) {
    logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode(raw);
}
function serialize(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger18.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize3) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger18.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest = keccak256(serialize3(tx));
    tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger18.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger18.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger18.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest = keccak256(encode(raw));
    try {
      tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
var logger18, TransactionTypes, transactionFields, allowedTransactionKeys2;
var init_lib17 = __esm({
  "node_modules/@ethersproject/transactions/lib.esm/index.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib5();
    init_lib4();
    init_lib6();
    init_lib16();
    init_lib();
    init_version13();
    logger18 = new Logger(version13);
    (function(TransactionTypes2) {
      TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
      TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
      TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
    })(TransactionTypes || (TransactionTypes = {}));
    transactionFields = [
      { name: "nonce", maxLength: 32, numeric: true },
      { name: "gasPrice", maxLength: 32, numeric: true },
      { name: "gasLimit", maxLength: 32, numeric: true },
      { name: "to", length: 20 },
      { name: "value", maxLength: 32, numeric: true },
      { name: "data" }
    ];
    allowedTransactionKeys2 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      type: true,
      value: true
    };
  }
});

// node_modules/@ethersproject/contracts/lib.esm/_version.js
var version14;
var init_version14 = __esm({
  "node_modules/@ethersproject/contracts/lib.esm/_version.js"() {
    version14 = "contracts/5.7.0";
  }
});

// node_modules/@ethersproject/contracts/lib.esm/index.js
function resolveName(resolver, nameOrPromise) {
  return __awaiter5(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;
    if (typeof name !== "string") {
      logger19.throwArgumentError("invalid address or ENS name", "name", name);
    }
    try {
      return getAddress(name);
    } catch (error) {
    }
    if (!resolver) {
      logger19.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name);
    if (address == null) {
      logger19.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger19.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter5(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger19.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check2) => __awaiter5(this, void 0, void 0, function* () {
          if (getAddress(check2.signer) !== check2.override) {
            logger19.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check2.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data2 = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data2,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes3 = arrayify(data2);
      for (let i = 0; i < bytes3.length; i++) {
        intrinsic += 4;
        if (bytes3[i]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger19.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger19.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger19.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait2 = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait2(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data2, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data2, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger19.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }
  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var __awaiter5, logger19, allowedTransactionKeys3, RunningEvent, ErrorRunningEvent, FragmentRunningEvent, WildcardRunningEvent, BaseContract, Contract, ContractFactory;
var init_lib18 = __esm({
  "node_modules/@ethersproject/contracts/lib.esm/index.js"() {
    "use strict";
    init_lib13();
    init_lib14();
    init_lib15();
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib17();
    init_lib();
    init_version14();
    __awaiter5 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger19 = new Logger(version14);
    allowedTransactionKeys3 = {
      chainId: true,
      data: true,
      from: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true,
      customData: true,
      ccipReadEnabled: true
    };
    RunningEvent = class {
      constructor(tag, filter) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "filter", filter);
        this._listeners = [];
      }
      addListener(listener, once) {
        this._listeners.push({ listener, once });
      }
      removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
          if (done || item.listener !== listener) {
            return true;
          }
          done = true;
          return false;
        });
      }
      removeAllListeners() {
        this._listeners = [];
      }
      listeners() {
        return this._listeners.map((i) => i.listener);
      }
      listenerCount() {
        return this._listeners.length;
      }
      run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
          const argsCopy = args.slice();
          setTimeout(() => {
            item.listener.apply(this, argsCopy);
          }, 0);
          return !item.once;
        });
        return listenerCount;
      }
      prepareEvent(event) {
      }
      getEmit(event) {
        return [event];
      }
    };
    ErrorRunningEvent = class extends RunningEvent {
      constructor() {
        super("error", null);
      }
    };
    FragmentRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface, fragment, topics) {
        const filter = {
          address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
          if (topic !== topics[0]) {
            logger19.throwArgumentError("topic mismatch", "topics", topics);
          }
          filter.topics = topics.slice();
        } else {
          filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
        defineReadOnly(this, "fragment", fragment);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data2, topics) => {
          return this.interface.decodeEventLog(this.fragment, data2, topics);
        };
        try {
          event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
          event.args = null;
          event.decodeError = error;
        }
      }
      getEmit(event) {
        const errors = checkResultErrors(event.args);
        if (errors.length) {
          throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
      }
    };
    WildcardRunningEvent = class extends RunningEvent {
      constructor(address, contractInterface) {
        super("*", { address });
        defineReadOnly(this, "address", address);
        defineReadOnly(this, "interface", contractInterface);
      }
      prepareEvent(event) {
        super.prepareEvent(event);
        try {
          const parsed = this.interface.parseLog(event);
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
          event.decode = (data2, topics) => {
            return this.interface.decodeEventLog(parsed.eventFragment, data2, topics);
          };
          event.args = parsed.args;
        } catch (error) {
        }
      }
    };
    BaseContract = class {
      constructor(addressOrName, contractInterface, signerOrProvider) {
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
          defineReadOnly(this, "provider", null);
          defineReadOnly(this, "signer", null);
        } else if (Signer.isSigner(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider.provider || null);
          defineReadOnly(this, "signer", signerOrProvider);
        } else if (Provider.isProvider(signerOrProvider)) {
          defineReadOnly(this, "provider", signerOrProvider);
          defineReadOnly(this, "signer", null);
        } else {
          logger19.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        defineReadOnly(this, "callStatic", {});
        defineReadOnly(this, "estimateGas", {});
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "populateTransaction", {});
        defineReadOnly(this, "filters", {});
        {
          const uniqueFilters = {};
          Object.keys(this.interface.events).forEach((eventSignature) => {
            const event = this.interface.events[eventSignature];
            defineReadOnly(this.filters, eventSignature, (...args) => {
              return {
                address: this.address,
                topics: this.interface.encodeFilterTopics(event, args)
              };
            });
            if (!uniqueFilters[event.name]) {
              uniqueFilters[event.name] = [];
            }
            uniqueFilters[event.name].push(eventSignature);
          });
          Object.keys(uniqueFilters).forEach((name) => {
            const filters = uniqueFilters[name];
            if (filters.length === 1) {
              defineReadOnly(this.filters, name, this.filters[filters[0]]);
            } else {
              logger19.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
            }
          });
        }
        defineReadOnly(this, "_runningEvents", {});
        defineReadOnly(this, "_wrappedEmits", {});
        if (addressOrName == null) {
          logger19.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        defineReadOnly(this, "address", addressOrName);
        if (this.provider) {
          defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        } else {
          try {
            defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
          } catch (error) {
            logger19.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "new Contract"
            });
          }
        }
        this.resolvedAddress.catch((e) => {
        });
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature2) => {
          const fragment = this.interface.functions[signature2];
          if (uniqueSignatures[signature2]) {
            logger19.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
            return;
          }
          uniqueSignatures[signature2] = true;
          {
            const name = fragment.name;
            if (!uniqueNames[`%${name}`]) {
              uniqueNames[`%${name}`] = [];
            }
            uniqueNames[`%${name}`].push(signature2);
          }
          if (this[signature2] == null) {
            defineReadOnly(this, signature2, buildDefault(this, fragment, true));
          }
          if (this.functions[signature2] == null) {
            defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
          }
          if (this.callStatic[signature2] == null) {
            defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
          }
          if (this.populateTransaction[signature2] == null) {
            defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
          }
          if (this.estimateGas[signature2] == null) {
            defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
          }
        });
        Object.keys(uniqueNames).forEach((name) => {
          const signatures = uniqueNames[name];
          if (signatures.length > 1) {
            return;
          }
          name = name.substring(1);
          const signature2 = signatures[0];
          try {
            if (this[name] == null) {
              defineReadOnly(this, name, this[signature2]);
            }
          } catch (e) {
          }
          if (this.functions[name] == null) {
            defineReadOnly(this.functions, name, this.functions[signature2]);
          }
          if (this.callStatic[name] == null) {
            defineReadOnly(this.callStatic, name, this.callStatic[signature2]);
          }
          if (this.populateTransaction[name] == null) {
            defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature2]);
          }
          if (this.estimateGas[name] == null) {
            defineReadOnly(this.estimateGas, name, this.estimateGas[signature2]);
          }
        });
      }
      static getContractAddress(transaction) {
        return getContractAddress(transaction);
      }
      static getInterface(contractInterface) {
        if (Interface.isInterface(contractInterface)) {
          return contractInterface;
        }
        return new Interface(contractInterface);
      }
      deployed() {
        return this._deployed();
      }
      _deployed(blockTag) {
        if (!this._deployedPromise) {
          if (this.deployTransaction) {
            this._deployedPromise = this.deployTransaction.wait().then(() => {
              return this;
            });
          } else {
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
              if (code === "0x") {
                logger19.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                  contractAddress: this.address,
                  operation: "getDeployed"
                });
              }
              return this;
            });
          }
        }
        return this._deployedPromise;
      }
      fallback(overrides) {
        if (!this.signer) {
          logger19.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = shallowCopy(overrides || {});
        ["from", "to"].forEach(function(key2) {
          if (tx[key2] == null) {
            return;
          }
          logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
          return this.signer.sendTransaction(tx);
        });
      }
      connect(signerOrProvider) {
        if (typeof signerOrProvider === "string") {
          signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
        }
        const contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
          defineReadOnly(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
      }
      attach(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
      }
      static isIndexed(value) {
        return Indexed.isIndexed(value);
      }
      _normalizeRunningEvent(runningEvent) {
        if (this._runningEvents[runningEvent.tag]) {
          return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
      }
      _getRunningEvent(eventName) {
        if (typeof eventName === "string") {
          if (eventName === "error") {
            return this._normalizeRunningEvent(new ErrorRunningEvent());
          }
          if (eventName === "event") {
            return this._normalizeRunningEvent(new RunningEvent("event", null));
          }
          if (eventName === "*") {
            return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
          }
          const fragment = this.interface.getEvent(eventName);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        if (eventName.topics && eventName.topics.length > 0) {
          try {
            const topic = eventName.topics[0];
            if (typeof topic !== "string") {
              throw new Error("invalid topic");
            }
            const fragment = this.interface.getEvent(topic);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
          } catch (error) {
          }
          const filter = {
            address: this.address,
            topics: eventName.topics
          };
          return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
          delete this._runningEvents[runningEvent.tag];
          const emit2 = this._wrappedEmits[runningEvent.tag];
          if (emit2 && runningEvent.filter) {
            this.provider.off(runningEvent.filter, emit2);
            delete this._wrappedEmits[runningEvent.tag];
          }
        }
      }
      _wrapEvent(runningEvent, log, listener) {
        const event = deepCopy(log);
        event.removeListener = () => {
          if (!listener) {
            return;
          }
          runningEvent.removeListener(listener);
          this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => {
          return this.provider.getBlock(log.blockHash);
        };
        event.getTransaction = () => {
          return this.provider.getTransaction(log.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return this.provider.getTransactionReceipt(log.transactionHash);
        };
        runningEvent.prepareEvent(event);
        return event;
      }
      _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
          logger19.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        this._runningEvents[runningEvent.tag] = runningEvent;
        if (!this._wrappedEmits[runningEvent.tag]) {
          const wrappedEmit = (log) => {
            let event = this._wrapEvent(runningEvent, log, listener);
            if (event.decodeError == null) {
              try {
                const args = runningEvent.getEmit(event);
                this.emit(runningEvent.filter, ...args);
              } catch (error) {
                event.decodeError = error.error;
              }
            }
            if (runningEvent.filter != null) {
              this.emit("event", event);
            }
            if (event.decodeError != null) {
              this.emit("error", event.decodeError, event);
            }
          };
          this._wrappedEmits[runningEvent.tag] = wrappedEmit;
          if (runningEvent.filter != null) {
            this.provider.on(runningEvent.filter, wrappedEmit);
          }
        }
      }
      queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = shallowCopy(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
          if (toBlock != null) {
            logger19.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
          }
          filter.blockHash = fromBlockOrBlockhash;
        } else {
          filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
          filter.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter).then((logs) => {
          return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
      }
      on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
      }
      once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
      }
      emit(eventName, ...args) {
        if (!this.provider) {
          return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = runningEvent.run(args) > 0;
        this._checkRunningEvents(runningEvent);
        return result;
      }
      listenerCount(eventName) {
        if (!this.provider) {
          return 0;
        }
        if (eventName == null) {
          return Object.keys(this._runningEvents).reduce((accum, key2) => {
            return accum + this._runningEvents[key2].listenerCount();
          }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
      }
      listeners(eventName) {
        if (!this.provider) {
          return [];
        }
        if (eventName == null) {
          const result = [];
          for (let tag in this._runningEvents) {
            this._runningEvents[tag].listeners().forEach((listener) => {
              result.push(listener);
            });
          }
          return result;
        }
        return this._getRunningEvent(eventName).listeners();
      }
      removeAllListeners(eventName) {
        if (!this.provider) {
          return this;
        }
        if (eventName == null) {
          for (const tag in this._runningEvents) {
            const runningEvent2 = this._runningEvents[tag];
            runningEvent2.removeAllListeners();
            this._checkRunningEvents(runningEvent2);
          }
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
      }
      off(eventName, listener) {
        if (!this.provider) {
          return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
      }
      removeListener(eventName, listener) {
        return this.off(eventName, listener);
      }
    };
    Contract = class extends BaseContract {
    };
    ContractFactory = class {
      constructor(contractInterface, bytecode, signer) {
        let bytecodeHex = null;
        if (typeof bytecode === "string") {
          bytecodeHex = bytecode;
        } else if (isBytes(bytecode)) {
          bytecodeHex = hexlify(bytecode);
        } else if (bytecode && typeof bytecode.object === "string") {
          bytecodeHex = bytecode.object;
        } else {
          bytecodeHex = "!";
        }
        if (bytecodeHex.substring(0, 2) !== "0x") {
          bytecodeHex = "0x" + bytecodeHex;
        }
        if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
          logger19.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        if (signer && !Signer.isSigner(signer)) {
          logger19.throwArgumentError("invalid signer", "signer", signer);
        }
        defineReadOnly(this, "bytecode", bytecodeHex);
        defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
        defineReadOnly(this, "signer", signer || null);
      }
      getDeployTransaction(...args) {
        let tx = {};
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          tx = shallowCopy(args.pop());
          for (const key2 in tx) {
            if (!allowedTransactionKeys3[key2]) {
              throw new Error("unknown transaction override " + key2);
            }
          }
        }
        ["data", "from", "to"].forEach((key2) => {
          if (tx[key2] == null) {
            return;
          }
          logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
        });
        if (tx.value) {
          const value = BigNumber.from(tx.value);
          if (!value.isZero() && !this.interface.deploy.payable) {
            logger19.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.value",
              value: tx.value
            });
          }
        }
        logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        tx.data = hexlify(concat([
          this.bytecode,
          this.interface.encodeDeploy(args)
        ]));
        return tx;
      }
      deploy(...args) {
        return __awaiter5(this, void 0, void 0, function* () {
          let overrides = {};
          if (args.length === this.interface.deploy.inputs.length + 1) {
            overrides = args.pop();
          }
          logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
          const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
          params.push(overrides);
          const unsignedTx = this.getDeployTransaction(...params);
          const tx = yield this.signer.sendTransaction(unsignedTx);
          const address = getStatic(this.constructor, "getContractAddress")(tx);
          const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
          addContractWait(contract, tx);
          defineReadOnly(contract, "deployTransaction", tx);
          return contract;
        });
      }
      attach(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
      }
      connect(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
      }
      static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) {
          logger19.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof compilerOutput === "string") {
          compilerOutput = JSON.parse(compilerOutput);
        }
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) {
          bytecode = compilerOutput.bytecode;
        } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
          bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi, bytecode, signer);
      }
      static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
      }
      static getContractAddress(tx) {
        return getContractAddress(tx);
      }
      static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
      }
    };
  }
});

// node_modules/@ethersproject/basex/lib.esm/index.js
var lib_exports14 = {};
__export(lib_exports14, {
  Base32: () => Base32,
  Base58: () => Base58,
  BaseX: () => BaseX
});
var BaseX, Base32, Base58;
var init_lib19 = __esm({
  "node_modules/@ethersproject/basex/lib.esm/index.js"() {
    init_lib2();
    init_lib4();
    BaseX = class {
      constructor(alphabet) {
        defineReadOnly(this, "alphabet", alphabet);
        defineReadOnly(this, "base", alphabet.length);
        defineReadOnly(this, "_alphabetMap", {});
        defineReadOnly(this, "_leader", alphabet.charAt(0));
        for (let i = 0; i < alphabet.length; i++) {
          this._alphabetMap[alphabet.charAt(i)] = i;
        }
      }
      encode(value) {
        let source = arrayify(value);
        if (source.length === 0) {
          return "";
        }
        let digits = [0];
        for (let i = 0; i < source.length; ++i) {
          let carry = source[i];
          for (let j = 0; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % this.base;
            carry = carry / this.base | 0;
          }
          while (carry > 0) {
            digits.push(carry % this.base);
            carry = carry / this.base | 0;
          }
        }
        let string = "";
        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
          string += this._leader;
        }
        for (let q = digits.length - 1; q >= 0; --q) {
          string += this.alphabet[digits[q]];
        }
        return string;
      }
      decode(value) {
        if (typeof value !== "string") {
          throw new TypeError("Expected String");
        }
        let bytes3 = [];
        if (value.length === 0) {
          return new Uint8Array(bytes3);
        }
        bytes3.push(0);
        for (let i = 0; i < value.length; i++) {
          let byte = this._alphabetMap[value[i]];
          if (byte === void 0) {
            throw new Error("Non-base" + this.base + " character");
          }
          let carry = byte;
          for (let j = 0; j < bytes3.length; ++j) {
            carry += bytes3[j] * this.base;
            bytes3[j] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes3.push(carry & 255);
            carry >>= 8;
          }
        }
        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
          bytes3.push(0);
        }
        return arrayify(new Uint8Array(bytes3.reverse()));
      }
    };
    Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
    Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  }
});

// node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
var init_types = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/types.js"() {
    (function(SupportedAlgorithm2) {
      SupportedAlgorithm2["sha256"] = "sha256";
      SupportedAlgorithm2["sha512"] = "sha512";
    })(SupportedAlgorithm || (SupportedAlgorithm = {}));
  }
});

// node_modules/@ethersproject/sha2/lib.esm/_version.js
var version15;
var init_version15 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/_version.js"() {
    version15 = "sha2/5.7.0";
  }
});

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
function ripemd160(data2) {
  return "0x" + import_hash3.default.ripemd160().update(arrayify(data2)).digest("hex");
}
function sha256(data2) {
  return "0x" + import_hash3.default.sha256().update(arrayify(data2)).digest("hex");
}
function sha512(data2) {
  return "0x" + import_hash3.default.sha512().update(arrayify(data2)).digest("hex");
}
function computeHmac(algorithm, key2, data2) {
  if (!SupportedAlgorithm[algorithm]) {
    logger20.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm], arrayify(key2)).update(arrayify(data2)).digest("hex");
}
var import_hash3, logger20;
var init_sha2 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/sha2.js"() {
    "use strict";
    import_hash3 = __toESM(require_hash());
    init_lib2();
    init_types();
    init_lib();
    init_version15();
    logger20 = new Logger(version15);
  }
});

// node_modules/@ethersproject/sha2/lib.esm/index.js
var lib_exports15 = {};
__export(lib_exports15, {
  SupportedAlgorithm: () => SupportedAlgorithm,
  computeHmac: () => computeHmac,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});
var init_lib20 = __esm({
  "node_modules/@ethersproject/sha2/lib.esm/index.js"() {
    init_sha2();
    init_types();
  }
});

// node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T;
  for (let i = 1; i <= l; i++) {
    block1[salt.length] = i >> 24 & 255;
    block1[salt.length + 1] = i >> 16 & 255;
    block1[salt.length + 2] = i >> 8 & 255;
    block1[salt.length + 3] = i & 255;
    let U = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U.length;
      T = new Uint8Array(hLen);
      l = Math.ceil(keylen / hLen);
      r2 = keylen - (l - 1) * hLen;
    }
    T.set(U);
    for (let j = 1; j < iterations; j++) {
      U = arrayify(computeHmac(hashAlgorithm, password, U));
      for (let k = 0; k < hLen; k++)
        T[k] ^= U[k];
    }
    const destPos = (i - 1) * hLen;
    const len = i === l ? r2 : hLen;
    DK.set(arrayify(T).slice(0, len), destPos);
  }
  return hexlify(DK);
}
var init_pbkdf2 = __esm({
  "node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js"() {
    "use strict";
    init_lib2();
    init_lib20();
  }
});

// node_modules/@ethersproject/pbkdf2/lib.esm/index.js
var init_lib21 = __esm({
  "node_modules/@ethersproject/pbkdf2/lib.esm/index.js"() {
    init_pbkdf2();
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version16;
var init_version16 = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/_version.js"() {
    version16 = "wordlists/5.7.0";
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist, logger21, Wordlist;
var init_wordlist = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/wordlist.js"() {
    "use strict";
    init_lib12();
    init_lib4();
    init_lib();
    init_version16();
    exportWordlist = false;
    logger21 = new Logger(version16);
    Wordlist = class {
      constructor(locale) {
        logger21.checkAbstract(new.target, Wordlist);
        defineReadOnly(this, "locale", locale);
      }
      split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
      }
      join(words3) {
        return words3.join(" ");
      }
      static check(wordlist3) {
        const words3 = [];
        for (let i = 0; i < 2048; i++) {
          const word = wordlist3.getWord(i);
          if (i !== wordlist3.getWordIndex(word)) {
            return "0x";
          }
          words3.push(word);
        }
        return id(words3.join("\n") + "\n");
      }
      static register(lang, name) {
        if (!name) {
          name = lang.locale;
        }
        if (exportWordlist) {
          try {
            const anyGlobal3 = window;
            if (anyGlobal3._ethers && anyGlobal3._ethers.wordlists) {
              if (!anyGlobal3._ethers.wordlists[name]) {
                defineReadOnly(anyGlobal3._ethers.wordlists, name, lang);
              }
            }
          } catch (error) {
          }
        }
      }
    };
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var words, wordlist, LangEn, langEn;
var init_lang_en = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/lang-en.js"() {
    "use strict";
    init_wordlist();
    words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
    wordlist = null;
    LangEn = class extends Wordlist {
      constructor() {
        super("en");
      }
      getWord(index) {
        loadWords(this);
        return wordlist[index];
      }
      getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
      }
    };
    langEn = new LangEn();
    Wordlist.register(langEn);
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists;
var init_wordlists = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/wordlists.js"() {
    "use strict";
    init_lang_en();
    wordlists = {
      en: langEn
    };
  }
});

// node_modules/@ethersproject/wordlists/lib.esm/index.js
var init_lib22 = __esm({
  "node_modules/@ethersproject/wordlists/lib.esm/index.js"() {
    "use strict";
    init_wordlist();
    init_wordlists();
  }
});

// node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version17;
var init_version17 = __esm({
  "node_modules/@ethersproject/hdnode/lib.esm/_version.js"() {
    version17 = "hdnode/5.7.0";
  }
});

// node_modules/@ethersproject/hdnode/lib.esm/index.js
var lib_exports16 = {};
__export(lib_exports16, {
  HDNode: () => HDNode,
  defaultPath: () => defaultPath,
  entropyToMnemonic: () => entropyToMnemonic,
  getAccountPath: () => getAccountPath,
  isValidMnemonic: () => isValidMnemonic,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed
});
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data2) {
  return Base58.encode(concat([data2, hexDataSlice(sha256(sha256(data2)), 0, 4)]));
}
function getWordlist(wordlist3) {
  if (wordlist3 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist3 === "string") {
    const words3 = wordlists[wordlist3];
    if (words3 == null) {
      logger22.throwArgumentError("unknown locale", "wordlist", wordlist3);
    }
    return words3;
  }
  return wordlist3;
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist3) {
  wordlist3 = getWordlist(wordlist3);
  logger22.checkNormalize();
  const words3 = wordlist3.split(mnemonic);
  if (words3.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words3.length / 8)));
  let offset = 0;
  for (let i = 0; i < words3.length; i++) {
    let index = wordlist3.getWordIndex(words3[i].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words3.length / 3;
  const checksumBits = words3.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum2 !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist3) {
  wordlist3 = getWordlist(wordlist3);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist3.join(indices.map((index) => wordlist3.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist3) {
  try {
    mnemonicToEntropy(mnemonic, wordlist3);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger22.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}
var logger22, N, MasterSecret, HardenedBit, _constructorGuard4, defaultPath, HDNode;
var init_lib23 = __esm({
  "node_modules/@ethersproject/hdnode/lib.esm/index.js"() {
    "use strict";
    init_lib19();
    init_lib2();
    init_lib3();
    init_lib9();
    init_lib21();
    init_lib4();
    init_lib16();
    init_lib20();
    init_lib17();
    init_lib22();
    init_lib();
    init_version17();
    logger22 = new Logger(version17);
    N = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    MasterSecret = toUtf8Bytes("Bitcoin seed");
    HardenedBit = 2147483648;
    _constructorGuard4 = {};
    defaultPath = "m/44'/60'/0'/0/0";
    HDNode = class {
      constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        if (constructorGuard !== _constructorGuard4) {
          throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
          const signingKey = new SigningKey(privateKey);
          defineReadOnly(this, "privateKey", signingKey.privateKey);
          defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
        } else {
          defineReadOnly(this, "privateKey", null);
          defineReadOnly(this, "publicKey", hexlify(publicKey));
        }
        defineReadOnly(this, "parentFingerprint", parentFingerprint);
        defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));
        defineReadOnly(this, "address", computeAddress(this.publicKey));
        defineReadOnly(this, "chainCode", chainCode);
        defineReadOnly(this, "index", index);
        defineReadOnly(this, "depth", depth);
        if (mnemonicOrPath == null) {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", null);
        } else if (typeof mnemonicOrPath === "string") {
          defineReadOnly(this, "mnemonic", null);
          defineReadOnly(this, "path", mnemonicOrPath);
        } else {
          defineReadOnly(this, "mnemonic", mnemonicOrPath);
          defineReadOnly(this, "path", mnemonicOrPath.path);
        }
      }
      get extendedKey() {
        if (this.depth >= 256) {
          throw new Error("Depth too large!");
        }
        return base58check(concat([
          this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
          hexlify(this.depth),
          this.parentFingerprint,
          hexZeroPad(hexlify(this.index), 4),
          this.chainCode,
          this.privateKey != null ? concat(["0x00", this.privateKey]) : this.publicKey
        ]));
      }
      neuter() {
        return new HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
      }
      _derive(index) {
        if (index > 4294967295) {
          throw new Error("invalid index - " + String(index));
        }
        let path = this.path;
        if (path) {
          path += "/" + (index & ~HardenedBit);
        }
        const data2 = new Uint8Array(37);
        if (index & HardenedBit) {
          if (!this.privateKey) {
            throw new Error("cannot derive child of neutered node");
          }
          data2.set(arrayify(this.privateKey), 1);
          if (path) {
            path += "'";
          }
        } else {
          data2.set(arrayify(this.publicKey));
        }
        for (let i = 24; i >= 0; i -= 8) {
          data2[33 + (i >> 3)] = index >> 24 - i & 255;
        }
        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data2));
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        let ki = null;
        let Ki = null;
        if (this.privateKey) {
          ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));
        } else {
          const ek = new SigningKey(hexlify(IL));
          Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
          mnemonicOrPath = Object.freeze({
            phrase: srcMnemonic.phrase,
            path,
            locale: srcMnemonic.locale || "en"
          });
        }
        return new HDNode(_constructorGuard4, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
      }
      derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
          throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
          components.shift();
        }
        let result = this;
        for (let i = 0; i < components.length; i++) {
          const component = components[i];
          if (component.match(/^[0-9]+'$/)) {
            const index = parseInt(component.substring(0, component.length - 1));
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(HardenedBit + index);
          } else if (component.match(/^[0-9]+$/)) {
            const index = parseInt(component);
            if (index >= HardenedBit) {
              throw new Error("invalid path index - " + component);
            }
            result = result._derive(index);
          } else {
            throw new Error("invalid path component - " + component);
          }
        }
        return result;
      }
      static _fromSeed(seed, mnemonic) {
        const seedArray = arrayify(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
          throw new Error("invalid seed");
        }
        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
        return new HDNode(_constructorGuard4, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
      }
      static fromMnemonic(mnemonic, password, wordlist3) {
        wordlist3 = getWordlist(wordlist3);
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist3), wordlist3);
        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
          phrase: mnemonic,
          path: "m",
          locale: wordlist3.locale
        });
      }
      static fromSeed(seed) {
        return HDNode._fromSeed(seed, null);
      }
      static fromExtendedKey(extendedKey) {
        const bytes3 = Base58.decode(extendedKey);
        if (bytes3.length !== 82 || base58check(bytes3.slice(0, 78)) !== extendedKey) {
          logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes3[4];
        const parentFingerprint = hexlify(bytes3.slice(5, 9));
        const index = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
        const chainCode = hexlify(bytes3.slice(13, 45));
        const key2 = bytes3.slice(45, 78);
        switch (hexlify(bytes3.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf":
            return new HDNode(_constructorGuard4, null, hexlify(key2), parentFingerprint, chainCode, index, depth, null);
          case "0x0488ade4":
          case "0x04358394 ":
            if (key2[0] !== 0) {
              break;
            }
            return new HDNode(_constructorGuard4, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
    };
  }
});

// node_modules/@ethersproject/random/lib.esm/_version.js
var version18;
var init_version18 = __esm({
  "node_modules/@ethersproject/random/lib.esm/_version.js"() {
    version18 = "random/5.7.0";
  }
});

// node_modules/@ethersproject/random/lib.esm/random.js
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger23.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto.getRandomValues(result);
  return arrayify(result);
}
var logger23, anyGlobal, crypto;
var init_random = __esm({
  "node_modules/@ethersproject/random/lib.esm/random.js"() {
    "use strict";
    init_lib2();
    init_lib();
    init_version18();
    logger23 = new Logger(version18);
    anyGlobal = getGlobal();
    crypto = anyGlobal.crypto || anyGlobal.msCrypto;
    if (!crypto || !crypto.getRandomValues) {
      logger23.warn("WARNING: Missing strong random number source");
      crypto = {
        getRandomValues: function(buffer) {
          return logger23.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      };
    }
  }
});

// node_modules/@ethersproject/random/lib.esm/shuffle.js
function shuffled(array) {
  array = array.slice();
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
  return array;
}
var init_shuffle = __esm({
  "node_modules/@ethersproject/random/lib.esm/shuffle.js"() {
    "use strict";
  }
});

// node_modules/@ethersproject/random/lib.esm/index.js
var lib_exports17 = {};
__export(lib_exports17, {
  randomBytes: () => randomBytes,
  shuffled: () => shuffled
});
var init_lib24 = __esm({
  "node_modules/@ethersproject/random/lib.esm/index.js"() {
    "use strict";
    init_random();
    init_shuffle();
  }
});

// node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "node_modules/aes-js/index.js"(exports, module) {
    "use strict";
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i = 0; i < arrayish.length; i++) {
          if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy4) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy4) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length) {
        return new Uint8Array(length);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes2(text) {
          var result = [], i = 0;
          text = encodeURI(text);
          while (i < text.length) {
            var c = text.charCodeAt(i++);
            if (c === 37) {
              result.push(parseInt(text.substr(i, 2), 16));
              i += 2;
            } else {
              result.push(c);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes3) {
          var result = [], i = 0;
          while (i < bytes3.length) {
            var c = bytes3[i];
            if (c < 128) {
              result.push(String.fromCharCode(c));
              i++;
            } else if (c > 191 && c < 224) {
              result.push(String.fromCharCode((c & 31) << 6 | bytes3[i + 1] & 63));
              i += 2;
            } else {
              result.push(String.fromCharCode((c & 15) << 12 | (bytes3[i + 1] & 63) << 6 | bytes3[i + 2] & 63));
              i += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes: toBytes2,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes2(text) {
          var result = [];
          for (var i = 0; i < text.length; i += 2) {
            result.push(parseInt(text.substr(i, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes3) {
          var result = [];
          for (var i = 0; i < bytes3.length; i++) {
            var v = bytes3[i];
            result.push(Hex[(v & 240) >> 4] + Hex[v & 15]);
          }
          return result.join("");
        }
        return {
          toBytes: toBytes2,
          fromBytes
        };
      }();
      var numberOfRounds2 = { 16: 10, 24: 12, 32: 14 };
      var rcon2 = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si2 = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T13 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T42 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T52 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T62 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T72 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T82 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U12 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U32 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U42 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt322(bytes3) {
        var result = [];
        for (var i = 0; i < bytes3.length; i += 4) {
          result.push(
            bytes3[i] << 24 | bytes3[i + 1] << 16 | bytes3[i + 2] << 8 | bytes3[i + 3]
          );
        }
        return result;
      }
      var AES2 = function(key2) {
        if (!(this instanceof AES2)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key2, true)
        });
        this._prepare();
      };
      AES2.prototype._prepare = function() {
        var rounds = numberOfRounds2[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i = 0; i <= rounds; i++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt322(this.key);
        var index;
        for (var i = 0; i < KC; i++) {
          index = i >> 2;
          this._Ke[index][i % 4] = tk[i];
          this._Kd[rounds - index][i % 4] = tk[i];
        }
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S2[tt >> 16 & 255] << 24 ^ S2[tt >> 8 & 255] << 16 ^ S2[tt & 255] << 8 ^ S2[tt >> 24 & 255] ^ rcon2[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i = 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          } else {
            for (var i = 1; i < KC / 2; i++) {
              tk[i] ^= tk[i - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S2[tt & 255] ^ S2[tt >> 8 & 255] << 8 ^ S2[tt >> 16 & 255] << 16 ^ S2[tt >> 24 & 255] << 24;
            for (var i = KC / 2 + 1; i < KC; i++) {
              tk[i] ^= tk[i - 1];
            }
          }
          var i = 0, r2, c;
          while (i < KC && t < roundKeyCount) {
            r2 = t >> 2;
            c = t % 4;
            this._Ke[r2][c] = tk[i];
            this._Kd[rounds - r2][c] = tk[i++];
            t++;
          }
        }
        for (var r2 = 1; r2 < rounds; r2++) {
          for (var c = 0; c < 4; c++) {
            tt = this._Kd[r2][c];
            this._Kd[r2][c] = U12[tt >> 24 & 255] ^ U22[tt >> 16 & 255] ^ U32[tt >> 8 & 255] ^ U42[tt & 255];
          }
        }
      };
      AES2.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt322(plaintext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Ke[0][i];
        }
        for (var r2 = 1; r2 < rounds; r2++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T13[t[i] >> 24 & 255] ^ T22[t[(i + 1) % 4] >> 16 & 255] ^ T32[t[(i + 2) % 4] >> 8 & 255] ^ T42[t[(i + 3) % 4] & 255] ^ this._Ke[r2][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Ke[rounds][i];
          result[4 * i] = (S2[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (S2[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (S2[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (S2[t[(i + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      AES2.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];
        var t = convertToInt322(ciphertext);
        for (var i = 0; i < 4; i++) {
          t[i] ^= this._Kd[0][i];
        }
        for (var r2 = 1; r2 < rounds; r2++) {
          for (var i = 0; i < 4; i++) {
            a[i] = T52[t[i] >> 24 & 255] ^ T62[t[(i + 3) % 4] >> 16 & 255] ^ T72[t[(i + 2) % 4] >> 8 & 255] ^ T82[t[(i + 1) % 4] & 255] ^ this._Kd[r2][i];
          }
          t = a.slice();
        }
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
          tt = this._Kd[rounds][i];
          result[4 * i] = (Si2[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (Si2[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (Si2[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (Si2[t[(i + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key2) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES2(key2);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key2, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES2(key2);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i = 0; i < plaintext.length; i += 16) {
          copyArray(plaintext, block, 0, i, i + 16);
          for (var j = 0; j < 16; j++) {
            block[j] ^= this._lastCipherblock[j];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i = 0; i < ciphertext.length; i += 16) {
          copyArray(ciphertext, block, 0, i, i + 16);
          block = this._aes.decrypt(block);
          for (var j = 0; j < 16; j++) {
            plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key2, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES2(key2);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            encrypted[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j = 0; j < this.segmentSize; j++) {
            plaintext[i + j] ^= xorSegment[j];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key2, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
          iv = createArray(16);
        } else if (iv.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES2(key2);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes3) {
        bytes3 = coerceArray(bytes3, true);
        if (bytes3.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes3;
      };
      Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
          if (this._counter[i] === 255) {
            this._counter[i] = 0;
          } else {
            this._counter[i]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key2, counter2) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter2 instanceof Counter)) {
          counter2 = new Counter(counter2);
        }
        this._counter = counter2;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES2(key2);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i = 0; i < encrypted.length; i++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data2) {
        data2 = coerceArray(data2, true);
        var padder = 16 - data2.length % 16;
        var result = createArray(data2.length + padder);
        copyArray(data2, result);
        for (var i = data2.length; i < result.length; i++) {
          result[i] = padder;
        }
        return result;
      }
      function pkcs7strip(data2) {
        data2 = coerceArray(data2, true);
        if (data2.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data2[data2.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length = data2.length - padder;
        for (var i = 0; i < padder; i++) {
          if (data2[length + i] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length);
        copyArray(data2, result, 0, 0, length);
        return result;
      }
      var aesjs = {
        AES: AES2,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version19;
var init_version19 = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/_version.js"() {
    version19 = "json-wallets/5.7.0";
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object2, path) {
  let currentChild = object2;
  const comps = path.toLowerCase().split("/");
  for (let i = 0; i < comps.length; i++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes5) {
  const bytes3 = arrayify(randomBytes5);
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value = hexlify(bytes3);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
var init_utils = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/utils.js"() {
    "use strict";
    init_lib2();
    init_lib9();
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
function decrypt(json, password) {
  const data2 = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data2, "ethaddr"));
  const encseed = looseArrayify(searchPath(data2, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger24.throwArgumentError("invalid encseed", "json", json);
  }
  const key2 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv);
  const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
var import_aes_js, logger24, CrowdsaleAccount;
var init_crowdsale = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js"() {
    "use strict";
    import_aes_js = __toESM(require_aes_js());
    init_lib7();
    init_lib2();
    init_lib5();
    init_lib21();
    init_lib9();
    init_lib4();
    init_lib();
    init_version19();
    init_utils();
    logger24 = new Logger(version19);
    CrowdsaleAccount = class extends Description {
      isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
      }
    };
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
function isCrowdsaleWallet(json) {
  let data2 = null;
  try {
    data2 = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data2.encseed && data2.ethaddr;
}
function isKeystoreWallet(json) {
  let data2 = null;
  try {
    data2 = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data2.version || parseInt(data2.version) !== data2.version || parseInt(data2.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}
var init_inspect = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/inspect.js"() {
    "use strict";
    init_lib7();
  }
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/scrypt-js/scrypt.js"(exports, module) {
    "use strict";
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA2562(m) {
        const K = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
        let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w = new Uint32Array(64);
        function blocks(p2) {
          let off = 0, len = p2.length;
          while (len >= 64) {
            let a = h0, b2 = h1, c = h2, d = h3, e = h4, f2 = h5, g = h6, h = h7, u, i2, j, t1, t2;
            for (i2 = 0; i2 < 16; i2++) {
              j = off + i2 * 4;
              w[i2] = (p2[j] & 255) << 24 | (p2[j + 1] & 255) << 16 | (p2[j + 2] & 255) << 8 | p2[j + 3] & 255;
            }
            for (i2 = 16; i2 < 64; i2++) {
              u = w[i2 - 2];
              t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
              u = w[i2 - 15];
              t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
              w[i2] = (t1 + w[i2 - 7] | 0) + (t2 + w[i2 - 16] | 0) | 0;
            }
            for (i2 = 0; i2 < 64; i2++) {
              t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f2 ^ ~e & g) | 0) + (h + (K[i2] + w[i2] | 0) | 0) | 0;
              t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b2 ^ a & c ^ b2 & c) | 0;
              h = g;
              g = f2;
              f2 = e;
              e = d + t1 | 0;
              d = c;
              c = b2;
              b2 = a;
              a = t1 + t2 | 0;
            }
            h0 = h0 + a | 0;
            h1 = h1 + b2 | 0;
            h2 = h2 + c | 0;
            h3 = h3 + d | 0;
            h4 = h4 + e | 0;
            h5 = h5 + f2 | 0;
            h6 = h6 + g | 0;
            h7 = h7 + h | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m);
        let i, bytesLeft = m.length % 64, bitLenHi = m.length / 536870912 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
        p.push(128);
        for (i = bytesLeft + 1; i < numZeros; i++) {
          p.push(0);
        }
        p.push(bitLenHi >>> 24 & 255);
        p.push(bitLenHi >>> 16 & 255);
        p.push(bitLenHi >>> 8 & 255);
        p.push(bitLenHi >>> 0 & 255);
        p.push(bitLenLo >>> 24 & 255);
        p.push(bitLenLo >>> 16 & 255);
        p.push(bitLenLo >>> 8 & 255);
        p.push(bitLenLo >>> 0 & 255);
        blocks(p);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h2 >>> 24 & 255,
          h2 >>> 16 & 255,
          h2 >>> 8 & 255,
          h2 >>> 0 & 255,
          h3 >>> 24 & 255,
          h3 >>> 16 & 255,
          h3 >>> 8 & 255,
          h3 >>> 0 & 255,
          h4 >>> 24 & 255,
          h4 >>> 16 & 255,
          h4 >>> 8 & 255,
          h4 >>> 0 & 255,
          h5 >>> 24 & 255,
          h5 >>> 16 & 255,
          h5 >>> 8 & 255,
          h5 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA2562(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i;
        let dk = [];
        for (i = 0; i < 64; i++) {
          inner[i] = 54;
        }
        for (i = 0; i < password.length; i++) {
          inner[i] ^= password[i];
        }
        for (i = 0; i < salt.length; i++) {
          inner[64 + i] = salt[i];
        }
        for (i = innerLen - 4; i < innerLen; i++) {
          inner[i] = 0;
        }
        for (i = 0; i < 64; i++)
          outerKey[i] = 92;
        for (i = 0; i < password.length; i++)
          outerKey[i] ^= password[i];
        function incrementCounter() {
          for (let i2 = innerLen - 1; i2 >= innerLen - 4; i2--) {
            inner[i2]++;
            if (inner[i2] <= 255)
              return;
            inner[i2] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi, r2, x, _X) {
        let i;
        arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r2; i++) {
          blockxor(BY, i * 16, _X, 16);
          salsa20_8(_X, x);
          arraycopy(_X, 0, BY, Yi + i * 16, 16);
        }
        for (i = 0; i < r2; i++) {
          arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
        }
        for (i = 0; i < r2; i++) {
          arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r2) * 16, 16);
        }
      }
      function R(a, b2) {
        return a << b2 | a >>> 32 - b2;
      }
      function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);
        for (let i = 8; i > 0; i -= 2) {
          x[4] ^= R(x[0] + x[12], 7);
          x[8] ^= R(x[4] + x[0], 9);
          x[12] ^= R(x[8] + x[4], 13);
          x[0] ^= R(x[12] + x[8], 18);
          x[9] ^= R(x[5] + x[1], 7);
          x[13] ^= R(x[9] + x[5], 9);
          x[1] ^= R(x[13] + x[9], 13);
          x[5] ^= R(x[1] + x[13], 18);
          x[14] ^= R(x[10] + x[6], 7);
          x[2] ^= R(x[14] + x[10], 9);
          x[6] ^= R(x[2] + x[14], 13);
          x[10] ^= R(x[6] + x[2], 18);
          x[3] ^= R(x[15] + x[11], 7);
          x[7] ^= R(x[3] + x[15], 9);
          x[11] ^= R(x[7] + x[3], 13);
          x[15] ^= R(x[11] + x[7], 18);
          x[1] ^= R(x[0] + x[3], 7);
          x[2] ^= R(x[1] + x[0], 9);
          x[3] ^= R(x[2] + x[1], 13);
          x[0] ^= R(x[3] + x[2], 18);
          x[6] ^= R(x[5] + x[4], 7);
          x[7] ^= R(x[6] + x[5], 9);
          x[4] ^= R(x[7] + x[6], 13);
          x[5] ^= R(x[4] + x[7], 18);
          x[11] ^= R(x[10] + x[9], 7);
          x[8] ^= R(x[11] + x[10], 9);
          x[9] ^= R(x[8] + x[11], 13);
          x[10] ^= R(x[9] + x[8], 18);
          x[12] ^= R(x[15] + x[14], 7);
          x[13] ^= R(x[12] + x[15], 9);
          x[14] ^= R(x[13] + x[12], 13);
          x[15] ^= R(x[14] + x[13], 18);
        }
        for (let i = 0; i < 16; ++i) {
          B[i] += x[i];
        }
      }
      function blockxor(S2, Si2, D, len) {
        for (let i = 0; i < len; i++) {
          D[i] ^= S2[Si2 + i];
        }
      }
      function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      function checkBufferish(o) {
        if (!o || typeof o.length !== "number") {
          return false;
        }
        for (let i = 0; i < o.length; i++) {
          const v = o[i];
          if (typeof v !== "number" || v % 1 || v < 0 || v >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value, name) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name);
        }
        return value;
      }
      function _scrypt(password, salt, N4, r2, p, dkLen, callback) {
        N4 = ensureInteger(N4, "N");
        r2 = ensureInteger(r2, "r");
        p = ensureInteger(p, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N4 === 0 || (N4 & N4 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N4 > MAX_VALUE / 128 / r2) {
          throw new Error("N too large");
        }
        if (r2 > MAX_VALUE / 128 / p) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b2 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r2);
        const B = new Uint32Array(p * 32 * r2);
        for (let i = 0; i < B.length; i++) {
          const j = i * 4;
          B[i] = (b2[j + 3] & 255) << 24 | (b2[j + 2] & 255) << 16 | (b2[j + 1] & 255) << 8 | (b2[j + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r2);
        const V = new Uint32Array(32 * r2 * N4);
        const Yi = 32 * r2;
        const x = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p * N4 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        const limit = callback ? parseInt(1e3 / r2) : 4294967295;
        const nextTick2 = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state) {
            case 0:
              Bi = i0 * 32 * r2;
              arraycopy(B, Bi, XY, 0, Yi);
              state = 1;
              i1 = 0;
            case 1:
              steps = N4 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i = 0; i < steps; i++) {
                arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);
                blockmix_salsa8(XY, Yi, r2, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N4) {
                break;
              }
              i1 = 0;
              state = 2;
            case 2:
              steps = N4 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i = 0; i < steps; i++) {
                const offset = (2 * r2 - 1) * 16;
                const j = XY[offset] & N4 - 1;
                blockxor(V, j * Yi, XY, Yi);
                blockmix_salsa8(XY, Yi, r2, x, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N4) {
                break;
              }
              arraycopy(XY, 0, B, Bi, Yi);
              i0++;
              if (i0 < p) {
                state = 0;
                break;
              }
              b2 = [];
              for (let i = 0; i < B.length; i++) {
                b2.push(B[i] >> 0 & 255);
                b2.push(B[i] >> 8 & 255);
                b2.push(B[i] >> 16 & 255);
                b2.push(B[i] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b2, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick2(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N4, r2, p, dkLen, progressCallback) {
          return new Promise(function(resolve2, reject2) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N4, r2, p, dkLen, function(error, progress, key2) {
              if (error) {
                reject2(error);
              } else if (key2) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve2(new Uint8Array(key2));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N4, r2, p, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N4, r2, p, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
function _decrypt(data2, key2, ciphertext) {
  const cipher = searchPath(data2, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data2, "crypto/cipherparams/iv"));
    const counter2 = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter2);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data2, key2) {
  const ciphertext = looseArrayify(searchPath(data2, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256(concat([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data2, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data2, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger25.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data2.address) {
    let check2 = data2.address.toLowerCase();
    if (check2.substring(0, 2) !== "0x") {
      check2 = "0x" + check2;
    }
    if (getAddress(check2) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data2, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data2, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data2, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data2, "x-ethers/path") || defaultPath;
    const locale = searchPath(data2, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node2 = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node2.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node2.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return arrayify(pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf22(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data2, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data2, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError2 = function(name, value) {
      return logger25.throwArgumentError("invalid key-derivation function parameters", name, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data2, "crypto/kdfparams/salt"));
      const N4 = parseInt(searchPath(data2, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data2, "crypto/kdfparams/r"));
      const p = parseInt(searchPath(data2, "crypto/kdfparams/p"));
      if (!N4 || !r2 || !p) {
        throwError2("kdf", kdf);
      }
      if ((N4 & N4 - 1) !== 0) {
        throwError2("N", N4);
      }
      const dkLen = parseInt(searchPath(data2, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N4, r2, p, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data2, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data2, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError2("prf", prf);
      }
      const count = parseInt(searchPath(data2, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data2, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }
  return logger25.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data2 = JSON.parse(json);
  const key2 = _computeKdfKey(data2, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data2, key2);
}
function decrypt2(json, password, progressCallback) {
  return __awaiter6(this, void 0, void 0, function* () {
    const data2 = JSON.parse(json);
    const key2 = yield _computeKdfKey(data2, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data2, key2);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node2 = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node2.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e) {
    return Promise.reject(e);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes(32);
    ;
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes(16);
  }
  let N4 = 1 << 17, r2 = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N4 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N4, r2, p, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter2 = new import_aes_js2.default.Counter(iv);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter2);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat([macPrefix, ciphertext]));
    const data2 = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N4,
          dklen: 32,
          p,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = new Date();
      const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data2["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp + "--" + data2.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data2);
  });
}
var import_aes_js2, import_scrypt_js, __awaiter6, logger25, KeystoreAccount;
var init_keystore = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/keystore.js"() {
    "use strict";
    import_aes_js2 = __toESM(require_aes_js());
    import_scrypt_js = __toESM(require_scrypt());
    init_lib7();
    init_lib2();
    init_lib23();
    init_lib5();
    init_lib21();
    init_lib24();
    init_lib4();
    init_lib17();
    init_utils();
    init_lib();
    init_version19();
    __awaiter6 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger25 = new Logger(version19);
    KeystoreAccount = class extends Description {
      isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
      }
    };
  }
});

// node_modules/@ethersproject/json-wallets/lib.esm/index.js
var lib_exports18 = {};
__export(lib_exports18, {
  decryptCrowdsale: () => decrypt,
  decryptJsonWallet: () => decryptJsonWallet,
  decryptJsonWalletSync: () => decryptJsonWalletSync,
  decryptKeystore: () => decrypt2,
  decryptKeystoreSync: () => decryptSync,
  encryptKeystore: () => encrypt,
  getJsonWalletAddress: () => getJsonWalletAddress,
  isCrowdsaleWallet: () => isCrowdsaleWallet,
  isKeystoreWallet: () => isKeystoreWallet
});
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}
var init_lib25 = __esm({
  "node_modules/@ethersproject/json-wallets/lib.esm/index.js"() {
    "use strict";
    init_crowdsale();
    init_inspect();
    init_keystore();
  }
});

// node_modules/@ethersproject/wallet/lib.esm/_version.js
var version20;
var init_version20 = __esm({
  "node_modules/@ethersproject/wallet/lib.esm/_version.js"() {
    version20 = "wallet/5.7.0";
  }
});

// node_modules/@ethersproject/wallet/lib.esm/index.js
var lib_exports19 = {};
__export(lib_exports19, {
  Wallet: () => Wallet,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData
});
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic2(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain, types, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature2);
}
var __awaiter7, logger26, Wallet;
var init_lib26 = __esm({
  "node_modules/@ethersproject/wallet/lib.esm/index.js"() {
    "use strict";
    init_lib7();
    init_lib14();
    init_lib15();
    init_lib2();
    init_lib12();
    init_lib23();
    init_lib5();
    init_lib4();
    init_lib24();
    init_lib16();
    init_lib25();
    init_lib17();
    init_lib();
    init_version20();
    __awaiter7 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger26 = new Logger(version20);
    Wallet = class extends Signer {
      constructor(privateKey, provider) {
        super();
        if (isAccount(privateKey)) {
          const signingKey = new SigningKey(privateKey.privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
          if (this.address !== getAddress(privateKey.address)) {
            logger26.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
          }
          if (hasMnemonic2(privateKey)) {
            const srcMnemonic = privateKey.mnemonic;
            defineReadOnly(this, "_mnemonic", () => ({
              phrase: srcMnemonic.phrase,
              path: srcMnemonic.path || defaultPath,
              locale: srcMnemonic.locale || "en"
            }));
            const mnemonic = this.mnemonic;
            const node2 = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
            if (computeAddress(node2.privateKey) !== this.address) {
              logger26.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            }
          } else {
            defineReadOnly(this, "_mnemonic", () => null);
          }
        } else {
          if (SigningKey.isSigningKey(privateKey)) {
            if (privateKey.curve !== "secp256k1") {
              logger26.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
            }
            defineReadOnly(this, "_signingKey", () => privateKey);
          } else {
            if (typeof privateKey === "string") {
              if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                privateKey = "0x" + privateKey;
              }
            }
            const signingKey = new SigningKey(privateKey);
            defineReadOnly(this, "_signingKey", () => signingKey);
          }
          defineReadOnly(this, "_mnemonic", () => null);
          defineReadOnly(this, "address", computeAddress(this.publicKey));
        }
        if (provider && !Provider.isProvider(provider)) {
          logger26.throwArgumentError("invalid provider", "provider", provider);
        }
        defineReadOnly(this, "provider", provider || null);
      }
      get mnemonic() {
        return this._mnemonic();
      }
      get privateKey() {
        return this._signingKey().privateKey;
      }
      get publicKey() {
        return this._signingKey().publicKey;
      }
      getAddress() {
        return Promise.resolve(this.address);
      }
      connect(provider) {
        return new Wallet(this, provider);
      }
      signTransaction(transaction) {
        return resolveProperties(transaction).then((tx) => {
          if (tx.from != null) {
            if (getAddress(tx.from) !== this.address) {
              logger26.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
            }
            delete tx.from;
          }
          const signature2 = this._signingKey().signDigest(keccak256(serialize(tx)));
          return serialize(tx, signature2);
        });
      }
      signMessage(message) {
        return __awaiter7(this, void 0, void 0, function* () {
          return joinSignature(this._signingKey().signDigest(hashMessage(message)));
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter7(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
            if (this.provider == null) {
              logger26.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName",
                value: name
              });
            }
            return this.provider.resolveName(name);
          });
          return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
        });
      }
      encrypt(password, options, progressCallback) {
        if (typeof options === "function" && !progressCallback) {
          progressCallback = options;
          options = {};
        }
        if (progressCallback && typeof progressCallback !== "function") {
          throw new Error("invalid callback");
        }
        if (!options) {
          options = {};
        }
        return encrypt(this, password, options, progressCallback);
      }
      static createRandom(options) {
        let entropy = randomBytes(16);
        if (!options) {
          options = {};
        }
        if (options.extraEntropy) {
          entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = entropyToMnemonic(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
      }
      static fromEncryptedJson(json, password, progressCallback) {
        return decryptJsonWallet(json, password, progressCallback).then((account) => {
          return new Wallet(account);
        });
      }
      static fromEncryptedJsonSync(json, password) {
        return new Wallet(decryptJsonWalletSync(json, password));
      }
      static fromMnemonic(mnemonic, path, wordlist3) {
        if (!path) {
          path = defaultPath;
        }
        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist3).derivePath(path));
      }
    };
  }
});

// node_modules/@ethersproject/networks/lib.esm/_version.js
var version21;
var init_version21 = __esm({
  "node_modules/@ethersproject/networks/lib.esm/_version.js"() {
    version21 = "networks/5.7.1";
  }
});

// node_modules/@ethersproject/networks/lib.esm/index.js
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func;
}
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name in networks) {
      const standard2 = networks[name];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger27.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger27.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
var logger27, homestead, ropsten, classicMordor, networks;
var init_lib27 = __esm({
  "node_modules/@ethersproject/networks/lib.esm/index.js"() {
    "use strict";
    init_lib();
    init_version21();
    logger27 = new Logger(version21);
    homestead = {
      chainId: 1,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "homestead",
      _defaultProvider: ethDefaultProvider("homestead")
    };
    ropsten = {
      chainId: 3,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "ropsten",
      _defaultProvider: ethDefaultProvider("ropsten")
    };
    classicMordor = {
      chainId: 63,
      name: "classicMordor",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
    };
    networks = {
      unspecified: { chainId: 0, name: "unspecified" },
      homestead,
      mainnet: homestead,
      morden: { chainId: 2, name: "morden" },
      ropsten,
      testnet: ropsten,
      rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
      },
      kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
      },
      goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
      },
      kintsugi: { chainId: 1337702, name: "kintsugi" },
      sepolia: {
        chainId: 11155111,
        name: "sepolia",
        _defaultProvider: ethDefaultProvider("sepolia")
      },
      classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
      },
      classicMorden: { chainId: 62, name: "classicMorden" },
      classicMordor,
      classicTestnet: classicMordor,
      classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
      },
      xdai: { chainId: 100, name: "xdai" },
      matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: ethDefaultProvider("matic")
      },
      maticmum: { chainId: 80001, name: "maticmum" },
      optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: ethDefaultProvider("optimism")
      },
      "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
      "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
      arbitrum: { chainId: 42161, name: "arbitrum" },
      "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
      "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
      bnb: { chainId: 56, name: "bnb" },
      bnbt: { chainId: 97, name: "bnbt" }
    };
  }
});

// node_modules/@ethersproject/web/lib.esm/_version.js
var version22;
var init_version22 = __esm({
  "node_modules/@ethersproject/web/lib.esm/_version.js"() {
    version22 = "web/5.7.1";
  }
});

// node_modules/@ethersproject/web/lib.esm/geturl.js
function getUrl(href, options) {
  return __awaiter8(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter8;
var init_geturl = __esm({
  "node_modules/@ethersproject/web/lib.esm/geturl.js"() {
    "use strict";
    init_lib2();
    __awaiter8 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  }
});

// node_modules/@ethersproject/web/lib.esm/index.js
var lib_exports20 = {};
__export(lib_exports20, {
  _fetchData: () => _fetchData,
  fetchJson: () => fetchJson,
  poll: () => poll
});
function staller(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
function bodyify(value, type) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all2, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger28.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger28.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger28.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger28.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode2(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData2 = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData2) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode2(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise2 = new Promise(function(resolve2, reject2) {
      if (timeout) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject2(logger28.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout,
            url
          }));
        }, timeout);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise: promise2, cancel };
  }();
  const runningFetch = function() {
    return __awaiter9(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location = response.headers.location || "";
              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall7 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall7 = parseInt(retryAfter) * 1e3;
                } else {
                  stall7 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall7);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger28.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger28.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout2);
                continue;
              }
            }
            runningTimeout.cancel();
            logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger28.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger28.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k) => k.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve2, reject2) {
    let timer2 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject2(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check2() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve2(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check2);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check2);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject2(new Error("retry limit reached"));
            }
            return;
          }
          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout < options.floor) {
            timeout = options.floor;
          }
          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }
          setTimeout(check2, timeout);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject2(error);
        }
      });
    }
    check2();
  });
}
var __awaiter9, logger28;
var init_lib28 = __esm({
  "node_modules/@ethersproject/web/lib.esm/index.js"() {
    "use strict";
    init_lib10();
    init_lib2();
    init_lib4();
    init_lib9();
    init_lib();
    init_version22();
    init_geturl();
    __awaiter9 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger28 = new Logger(version22);
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports, module) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z = 0; z < ALPHABET.length; z++) {
      x = ALPHABET.charAt(z);
      if (ALPHABET_MAP[x] !== void 0)
        throw new TypeError(x + " is ambiguous");
      ALPHABET_MAP[x] = z;
    }
    var x;
    var z;
    function polymodStep(pre) {
      var b2 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i = 0; i < prefix.length; ++i) {
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (i = 0; i < prefix.length; ++i) {
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function encode4(prefix, words3, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words3.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i = 0; i < words3.length; ++i) {
        var x2 = words3[i];
        if (x2 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x2;
        result += ALPHABET.charAt(x2);
      }
      for (i = 0; i < 6; ++i) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i = 0; i < 6; ++i) {
        var v = chk >> (5 - i) * 5 & 31;
        result += ALPHABET.charAt(v);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split4 = str.lastIndexOf("1");
      if (split4 === -1)
        return "No separator character for " + str;
      if (split4 === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split4);
      var wordChars = str.slice(split4 + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words3 = [];
      for (var i = 0; i < wordChars.length; ++i) {
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === void 0)
          return "Unknown character " + c;
        chk = polymodStep(chk) ^ v;
        if (i + 6 >= wordChars.length)
          continue;
        words3.push(v);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words: words3 };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode4(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data2, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i = 0; i < data2.length; ++i) {
        value = value << inBits | data2[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes3) {
      var res = convert(bytes3, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes3) {
      var res = convert(bytes3, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words3) {
      var res = convert(words3, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words3) {
      var res = convert(words3, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module.exports = {
      decodeUnsafe,
      decode: decode4,
      encode: encode4,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/_version.js
var version23;
var init_version23 = __esm({
  "node_modules/@ethersproject/providers/lib.esm/_version.js"() {
    version23 = "providers/5.7.2";
  }
});

// node_modules/@ethersproject/providers/lib.esm/formatter.js
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}
var logger29, Formatter, throttleMessage;
var init_formatter = __esm({
  "node_modules/@ethersproject/providers/lib.esm/formatter.js"() {
    "use strict";
    init_lib7();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib4();
    init_lib17();
    init_lib();
    init_version23();
    logger29 = new Logger(version23);
    Formatter = class {
      constructor() {
        this.formats = this.getDefaultFormats();
      }
      getDefaultFormats() {
        const formats = {};
        const address = this.address.bind(this);
        const bigNumber = this.bigNumber.bind(this);
        const blockTag = this.blockTag.bind(this);
        const data2 = this.data.bind(this);
        const hash4 = this.hash.bind(this);
        const hex = this.hex.bind(this);
        const number2 = this.number.bind(this);
        const type = this.type.bind(this);
        const strictData = (v) => {
          return this.data(v, true);
        };
        formats.transaction = {
          hash: hash4,
          type,
          accessList: Formatter.allowNull(this.accessList.bind(this), null),
          blockHash: Formatter.allowNull(hash4, null),
          blockNumber: Formatter.allowNull(number2, null),
          transactionIndex: Formatter.allowNull(number2, null),
          confirmations: Formatter.allowNull(number2, null),
          from: address,
          gasPrice: Formatter.allowNull(bigNumber),
          maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
          maxFeePerGas: Formatter.allowNull(bigNumber),
          gasLimit: bigNumber,
          to: Formatter.allowNull(address, null),
          value: bigNumber,
          nonce: number2,
          data: data2,
          r: Formatter.allowNull(this.uint256),
          s: Formatter.allowNull(this.uint256),
          v: Formatter.allowNull(number2),
          creates: Formatter.allowNull(address, null),
          raw: Formatter.allowNull(data2)
        };
        formats.transactionRequest = {
          from: Formatter.allowNull(address),
          nonce: Formatter.allowNull(number2),
          gasLimit: Formatter.allowNull(bigNumber),
          gasPrice: Formatter.allowNull(bigNumber),
          maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
          maxFeePerGas: Formatter.allowNull(bigNumber),
          to: Formatter.allowNull(address),
          value: Formatter.allowNull(bigNumber),
          data: Formatter.allowNull(strictData),
          type: Formatter.allowNull(number2),
          accessList: Formatter.allowNull(this.accessList.bind(this), null)
        };
        formats.receiptLog = {
          transactionIndex: number2,
          blockNumber: number2,
          transactionHash: hash4,
          address,
          topics: Formatter.arrayOf(hash4),
          data: data2,
          logIndex: number2,
          blockHash: hash4
        };
        formats.receipt = {
          to: Formatter.allowNull(this.address, null),
          from: Formatter.allowNull(this.address, null),
          contractAddress: Formatter.allowNull(address, null),
          transactionIndex: number2,
          root: Formatter.allowNull(hex),
          gasUsed: bigNumber,
          logsBloom: Formatter.allowNull(data2),
          blockHash: hash4,
          transactionHash: hash4,
          logs: Formatter.arrayOf(this.receiptLog.bind(this)),
          blockNumber: number2,
          confirmations: Formatter.allowNull(number2, null),
          cumulativeGasUsed: bigNumber,
          effectiveGasPrice: Formatter.allowNull(bigNumber),
          status: Formatter.allowNull(number2),
          type
        };
        formats.block = {
          hash: Formatter.allowNull(hash4),
          parentHash: hash4,
          number: number2,
          timestamp: number2,
          nonce: Formatter.allowNull(hex),
          difficulty: this.difficulty.bind(this),
          gasLimit: bigNumber,
          gasUsed: bigNumber,
          miner: Formatter.allowNull(address),
          extraData: data2,
          transactions: Formatter.allowNull(Formatter.arrayOf(hash4)),
          baseFeePerGas: Formatter.allowNull(bigNumber)
        };
        formats.blockWithTransactions = shallowCopy(formats.block);
        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
          fromBlock: Formatter.allowNull(blockTag, void 0),
          toBlock: Formatter.allowNull(blockTag, void 0),
          blockHash: Formatter.allowNull(hash4, void 0),
          address: Formatter.allowNull(address, void 0),
          topics: Formatter.allowNull(this.topics.bind(this), void 0)
        };
        formats.filterLog = {
          blockNumber: Formatter.allowNull(number2),
          blockHash: Formatter.allowNull(hash4),
          transactionIndex: number2,
          removed: Formatter.allowNull(this.boolean.bind(this)),
          address,
          data: Formatter.allowFalsish(data2, "0x"),
          topics: Formatter.arrayOf(hash4),
          transactionHash: hash4,
          logIndex: number2
        };
        return formats;
      }
      accessList(accessList) {
        return accessListify(accessList || []);
      }
      number(number2) {
        if (number2 === "0x") {
          return 0;
        }
        return BigNumber.from(number2).toNumber();
      }
      type(number2) {
        if (number2 === "0x" || number2 == null) {
          return 0;
        }
        return BigNumber.from(number2).toNumber();
      }
      bigNumber(value) {
        return BigNumber.from(value);
      }
      boolean(value) {
        if (typeof value === "boolean") {
          return value;
        }
        if (typeof value === "string") {
          value = value.toLowerCase();
          if (value === "true") {
            return true;
          }
          if (value === "false") {
            return false;
          }
        }
        throw new Error("invalid boolean - " + value);
      }
      hex(value, strict) {
        if (typeof value === "string") {
          if (!strict && value.substring(0, 2) !== "0x") {
            value = "0x" + value;
          }
          if (isHexString(value)) {
            return value.toLowerCase();
          }
        }
        return logger29.throwArgumentError("invalid hash", "value", value);
      }
      data(value, strict) {
        const result = this.hex(value, strict);
        if (result.length % 2 !== 0) {
          throw new Error("invalid data; odd-length - " + value);
        }
        return result;
      }
      address(value) {
        return getAddress(value);
      }
      callAddress(value) {
        if (!isHexString(value, 32)) {
          return null;
        }
        const address = getAddress(hexDataSlice(value, 12));
        return address === AddressZero ? null : address;
      }
      contractAddress(value) {
        return getContractAddress(value);
      }
      blockTag(blockTag) {
        if (blockTag == null) {
          return "latest";
        }
        if (blockTag === "earliest") {
          return "0x0";
        }
        switch (blockTag) {
          case "earliest":
            return "0x0";
          case "latest":
          case "pending":
          case "safe":
          case "finalized":
            return blockTag;
        }
        if (typeof blockTag === "number" || isHexString(blockTag)) {
          return hexValue(blockTag);
        }
        throw new Error("invalid blockTag");
      }
      hash(value, strict) {
        const result = this.hex(value, strict);
        if (hexDataLength(result) !== 32) {
          return logger29.throwArgumentError("invalid hash", "value", value);
        }
        return result;
      }
      difficulty(value) {
        if (value == null) {
          return null;
        }
        const v = BigNumber.from(value);
        try {
          return v.toNumber();
        } catch (error) {
        }
        return null;
      }
      uint256(value) {
        if (!isHexString(value)) {
          throw new Error("invalid uint256");
        }
        return hexZeroPad(value, 32);
      }
      _block(value, format) {
        if (value.author != null && value.miner == null) {
          value.miner = value.author;
        }
        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
        const result = Formatter.check(format, value);
        result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
        return result;
      }
      block(value) {
        return this._block(value, this.formats.block);
      }
      blockWithTransactions(value) {
        return this._block(value, this.formats.blockWithTransactions);
      }
      transactionRequest(value) {
        return Formatter.check(this.formats.transactionRequest, value);
      }
      transactionResponse(transaction) {
        if (transaction.gas != null && transaction.gasLimit == null) {
          transaction.gasLimit = transaction.gas;
        }
        if (transaction.to && BigNumber.from(transaction.to).isZero()) {
          transaction.to = "0x0000000000000000000000000000000000000000";
        }
        if (transaction.input != null && transaction.data == null) {
          transaction.data = transaction.input;
        }
        if (transaction.to == null && transaction.creates == null) {
          transaction.creates = this.contractAddress(transaction);
        }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
          transaction.accessList = [];
        }
        const result = Formatter.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
          let chainId = transaction.chainId;
          if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
          }
          result.chainId = chainId;
        } else {
          let chainId = transaction.networkId;
          if (chainId == null && result.v == null) {
            chainId = transaction.chainId;
          }
          if (isHexString(chainId)) {
            chainId = BigNumber.from(chainId).toNumber();
          }
          if (typeof chainId !== "number" && result.v != null) {
            chainId = (result.v - 35) / 2;
            if (chainId < 0) {
              chainId = 0;
            }
            chainId = parseInt(chainId);
          }
          if (typeof chainId !== "number") {
            chainId = 0;
          }
          result.chainId = chainId;
        }
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
          result.blockHash = null;
        }
        return result;
      }
      transaction(value) {
        return parse(value);
      }
      receiptLog(value) {
        return Formatter.check(this.formats.receiptLog, value);
      }
      receipt(value) {
        const result = Formatter.check(this.formats.receipt, value);
        if (result.root != null) {
          if (result.root.length <= 4) {
            const value2 = BigNumber.from(result.root).toNumber();
            if (value2 === 0 || value2 === 1) {
              if (result.status != null && result.status !== value2) {
                logger29.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
              }
              result.status = value2;
              delete result.root;
            } else {
              logger29.throwArgumentError("invalid alt-root-status", "value.root", result.root);
            }
          } else if (result.root.length !== 66) {
            logger29.throwArgumentError("invalid root hash", "value.root", result.root);
          }
        }
        if (result.status != null) {
          result.byzantium = true;
        }
        return result;
      }
      topics(value) {
        if (Array.isArray(value)) {
          return value.map((v) => this.topics(v));
        } else if (value != null) {
          return this.hash(value, true);
        }
        return null;
      }
      filter(value) {
        return Formatter.check(this.formats.filter, value);
      }
      filterLog(value) {
        return Formatter.check(this.formats.filterLog, value);
      }
      static check(format, object2) {
        const result = {};
        for (const key2 in format) {
          try {
            const value = format[key2](object2[key2]);
            if (value !== void 0) {
              result[key2] = value;
            }
          } catch (error) {
            error.checkKey = key2;
            error.checkValue = object2[key2];
            throw error;
          }
        }
        return result;
      }
      static allowNull(format, nullValue) {
        return function(value) {
          if (value == null) {
            return nullValue;
          }
          return format(value);
        };
      }
      static allowFalsish(format, replaceValue) {
        return function(value) {
          if (!value) {
            return replaceValue;
          }
          return format(value);
        };
      }
      static arrayOf(format) {
        return function(array) {
          if (!Array.isArray(array)) {
            throw new Error("not an array");
          }
          const result = [];
          array.forEach(function(value) {
            result.push(format(value));
          });
          return result;
        };
      }
    };
    throttleMessage = false;
  }
});

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger30.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data2) {
  if (data2 === "") {
    return [];
  }
  return data2.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger30.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data2) {
  return Base58.encode(concat([data2, hexDataSlice(sha256(sha256(data2)), 0, 4)]));
}
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger30.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data2 = arrayify(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data2.length));
    result.push(bytesPad(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return hexConcat(result);
}
var import_bech32, __awaiter10, logger30, MAX_CCIP_REDIRECTS, PollableEvents, Event, coinInfos, matcherIpfs, matchers, Resolver, defaultFormatter, nextPollId, BaseProvider;
var init_base_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/base-provider.js"() {
    "use strict";
    init_lib14();
    init_lib10();
    init_lib19();
    init_lib3();
    init_lib2();
    init_lib8();
    init_lib12();
    init_lib27();
    init_lib4();
    init_lib20();
    init_lib9();
    init_lib28();
    import_bech32 = __toESM(require_bech32());
    init_lib();
    init_version23();
    init_formatter();
    __awaiter10 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger30 = new Logger(version23);
    MAX_CCIP_REDIRECTS = 10;
    PollableEvents = ["block", "network", "pending", "poll"];
    Event = class {
      constructor(tag, listener, once) {
        defineReadOnly(this, "tag", tag);
        defineReadOnly(this, "listener", listener);
        defineReadOnly(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
      }
      get event() {
        switch (this.type) {
          case "tx":
            return this.hash;
          case "filter":
            return this.filter;
        }
        return this.tag;
      }
      get type() {
        return this.tag.split(":")[0];
      }
      get hash() {
        const comps = this.tag.split(":");
        if (comps[0] !== "tx") {
          return null;
        }
        return comps[1];
      }
      get filter() {
        const comps = this.tag.split(":");
        if (comps[0] !== "filter") {
          return null;
        }
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) {
          filter.topics = topics;
        }
        if (address && address !== "*") {
          filter.address = address;
        }
        return filter;
      }
      pollable() {
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
      }
    };
    coinInfos = {
      "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
      "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
      "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
      "60": { symbol: "eth", ilk: "eth" },
      "61": { symbol: "etc", ilk: "eth" },
      "700": { symbol: "xdai", ilk: "eth" }
    };
    matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
    matchers = [
      new RegExp("^(https)://(.*)$", "i"),
      new RegExp("^(data):(.*)$", "i"),
      matcherIpfs,
      new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
    ];
    Resolver = class {
      constructor(provider, address, name, resolvedAddress) {
        defineReadOnly(this, "provider", provider);
        defineReadOnly(this, "name", name);
        defineReadOnly(this, "address", provider.formatter.address(address));
        defineReadOnly(this, "_resolvedAddress", resolvedAddress);
      }
      supportsWildcard() {
        if (!this._supportsEip2544) {
          this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
          }).then((result) => {
            return BigNumber.from(result).eq(1);
          }).catch((error) => {
            if (error.code === Logger.errors.CALL_EXCEPTION) {
              return false;
            }
            this._supportsEip2544 = null;
            throw error;
          });
        }
        return this._supportsEip2544;
      }
      _fetch(selector, parameters) {
        return __awaiter10(this, void 0, void 0, function* () {
          const tx = {
            to: this.address,
            ccipReadEnabled: true,
            data: hexConcat([selector, namehash(this.name), parameters || "0x"])
          };
          let parseBytes = false;
          if (yield this.supportsWildcard()) {
            parseBytes = true;
            tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
          }
          try {
            let result = yield this.provider.call(tx);
            if (arrayify(result).length % 32 === 4) {
              logger30.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
                transaction: tx,
                data: result
              });
            }
            if (parseBytes) {
              result = _parseBytes(result, 0);
            }
            return result;
          } catch (error) {
            if (error.code === Logger.errors.CALL_EXCEPTION) {
              return null;
            }
            throw error;
          }
        });
      }
      _fetchBytes(selector, parameters) {
        return __awaiter10(this, void 0, void 0, function* () {
          const result = yield this._fetch(selector, parameters);
          if (result != null) {
            return _parseBytes(result, 0);
          }
          return null;
        });
      }
      _getAddress(coinType, hexBytes) {
        const coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) {
          logger30.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${coinType})`
          });
        }
        if (coinInfo.ilk === "eth") {
          return this.provider.formatter.address(hexBytes);
        }
        const bytes3 = arrayify(hexBytes);
        if (coinInfo.p2pkh != null) {
          const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
          if (p2pkh) {
            const length = parseInt(p2pkh[1], 16);
            if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
              return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
            }
          }
        }
        if (coinInfo.p2sh != null) {
          const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
          if (p2sh) {
            const length = parseInt(p2sh[1], 16);
            if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
              return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
            }
          }
        }
        if (coinInfo.prefix != null) {
          const length = bytes3[1];
          let version29 = bytes3[0];
          if (version29 === 0) {
            if (length !== 20 && length !== 32) {
              version29 = -1;
            }
          } else {
            version29 = -1;
          }
          if (version29 >= 0 && bytes3.length === 2 + length && length >= 1 && length <= 75) {
            const words3 = import_bech32.default.toWords(bytes3.slice(2));
            words3.unshift(version29);
            return import_bech32.default.encode(coinInfo.prefix, words3);
          }
        }
        return null;
      }
      getAddress(coinType) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (coinType == null) {
            coinType = 60;
          }
          if (coinType === 60) {
            try {
              const result = yield this._fetch("0x3b3b57de");
              if (result === "0x" || result === HashZero) {
                return null;
              }
              return this.provider.formatter.callAddress(result);
            } catch (error) {
              if (error.code === Logger.errors.CALL_EXCEPTION) {
                return null;
              }
              throw error;
            }
          }
          const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
          if (hexBytes == null || hexBytes === "0x") {
            return null;
          }
          const address = this._getAddress(coinType, hexBytes);
          if (address == null) {
            logger30.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
              operation: `getAddress(${coinType})`,
              coinType,
              data: hexBytes
            });
          }
          return address;
        });
      }
      getAvatar() {
        return __awaiter10(this, void 0, void 0, function* () {
          const linkage = [{ type: "name", content: this.name }];
          try {
            const avatar = yield this.getText("avatar");
            if (avatar == null) {
              return null;
            }
            for (let i = 0; i < matchers.length; i++) {
              const match2 = avatar.match(matchers[i]);
              if (match2 == null) {
                continue;
              }
              const scheme = match2[1].toLowerCase();
              switch (scheme) {
                case "https":
                  linkage.push({ type: "url", content: avatar });
                  return { linkage, url: avatar };
                case "data":
                  linkage.push({ type: "data", content: avatar });
                  return { linkage, url: avatar };
                case "ipfs":
                  linkage.push({ type: "ipfs", content: avatar });
                  return { linkage, url: getIpfsLink(avatar) };
                case "erc721":
                case "erc1155": {
                  const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                  linkage.push({ type: scheme, content: avatar });
                  const owner = this._resolvedAddress || (yield this.getAddress());
                  const comps = (match2[2] || "").split("/");
                  if (comps.length !== 2) {
                    return null;
                  }
                  const addr = yield this.provider.formatter.address(comps[0]);
                  const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
                  if (scheme === "erc721") {
                    const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                      to: addr,
                      data: hexConcat(["0x6352211e", tokenId])
                    }));
                    if (owner !== tokenOwner) {
                      return null;
                    }
                    linkage.push({ type: "owner", content: tokenOwner });
                  } else if (scheme === "erc1155") {
                    const balance = BigNumber.from(yield this.provider.call({
                      to: addr,
                      data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                    }));
                    if (balance.isZero()) {
                      return null;
                    }
                    linkage.push({ type: "balance", content: balance.toString() });
                  }
                  const tx = {
                    to: this.provider.formatter.address(comps[0]),
                    data: hexConcat([selector, tokenId])
                  };
                  let metadataUrl = _parseString(yield this.provider.call(tx), 0);
                  if (metadataUrl == null) {
                    return null;
                  }
                  linkage.push({ type: "metadata-url-base", content: metadataUrl });
                  if (scheme === "erc1155") {
                    metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                    linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                  }
                  if (metadataUrl.match(/^ipfs:/i)) {
                    metadataUrl = getIpfsLink(metadataUrl);
                  }
                  linkage.push({ type: "metadata-url", content: metadataUrl });
                  const metadata = yield fetchJson(metadataUrl);
                  if (!metadata) {
                    return null;
                  }
                  linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                  let imageUrl = metadata.image;
                  if (typeof imageUrl !== "string") {
                    return null;
                  }
                  if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                  } else {
                    const ipfs = imageUrl.match(matcherIpfs);
                    if (ipfs == null) {
                      return null;
                    }
                    linkage.push({ type: "url-ipfs", content: imageUrl });
                    imageUrl = getIpfsLink(imageUrl);
                  }
                  linkage.push({ type: "url", content: imageUrl });
                  return { linkage, url: imageUrl };
                }
              }
            }
          } catch (error) {
          }
          return null;
        });
      }
      getContentHash() {
        return __awaiter10(this, void 0, void 0, function* () {
          const hexBytes = yield this._fetchBytes("0xbc1c58d1");
          if (hexBytes == null || hexBytes === "0x") {
            return null;
          }
          const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
          if (ipfs) {
            const length = parseInt(ipfs[3], 16);
            if (ipfs[4].length === length * 2) {
              return "ipfs://" + Base58.encode("0x" + ipfs[1]);
            }
          }
          const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
          if (ipns) {
            const length = parseInt(ipns[3], 16);
            if (ipns[4].length === length * 2) {
              return "ipns://" + Base58.encode("0x" + ipns[1]);
            }
          }
          const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
          if (swarm) {
            if (swarm[1].length === 32 * 2) {
              return "bzz://" + swarm[1];
            }
          }
          const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
          if (skynet) {
            if (skynet[1].length === 34 * 2) {
              const urlSafe = { "=": "", "+": "-", "/": "_" };
              const hash4 = encode2("0x" + skynet[1]).replace(/[=+\/]/g, (a) => urlSafe[a]);
              return "sia://" + hash4;
            }
          }
          return logger30.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getContentHash()",
            data: hexBytes
          });
        });
      }
      getText(key2) {
        return __awaiter10(this, void 0, void 0, function* () {
          let keyBytes = toUtf8Bytes(key2);
          keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
          if (keyBytes.length % 32 !== 0) {
            keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
          }
          const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
          if (hexBytes == null || hexBytes === "0x") {
            return null;
          }
          return toUtf8String(hexBytes);
        });
      }
    };
    defaultFormatter = null;
    nextPollId = 1;
    BaseProvider = class extends Provider {
      constructor(network) {
        super();
        this._events = [];
        this._emitted = { block: -2 };
        this.disableCcipRead = false;
        this.formatter = new.target.getFormatter();
        defineReadOnly(this, "anyNetwork", network === "any");
        if (this.anyNetwork) {
          network = this.detectNetwork();
        }
        if (network instanceof Promise) {
          this._networkPromise = network;
          network.catch((error) => {
          });
          this._ready().catch((error) => {
          });
        } else {
          const knownNetwork = getStatic(new.target, "getNetwork")(network);
          if (knownNetwork) {
            defineReadOnly(this, "_network", knownNetwork);
            this.emit("network", knownNetwork, null);
          } else {
            logger30.throwArgumentError("invalid network", "network", network);
          }
        }
        this._maxInternalBlockNumber = -1024;
        this._lastBlockNumber = -2;
        this._maxFilterBlockRange = 10;
        this._pollingInterval = 4e3;
        this._fastQueryDate = 0;
      }
      _ready() {
        return __awaiter10(this, void 0, void 0, function* () {
          if (this._network == null) {
            let network = null;
            if (this._networkPromise) {
              try {
                network = yield this._networkPromise;
              } catch (error) {
              }
            }
            if (network == null) {
              network = yield this.detectNetwork();
            }
            if (!network) {
              logger30.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
            }
            if (this._network == null) {
              if (this.anyNetwork) {
                this._network = network;
              } else {
                defineReadOnly(this, "_network", network);
              }
              this.emit("network", network, null);
            }
          }
          return this._network;
        });
      }
      get ready() {
        return poll(() => {
          return this._ready().then((network) => {
            return network;
          }, (error) => {
            if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
              return void 0;
            }
            throw error;
          });
        });
      }
      static getFormatter() {
        if (defaultFormatter == null) {
          defaultFormatter = new Formatter();
        }
        return defaultFormatter;
      }
      static getNetwork(network) {
        return getNetwork(network == null ? "homestead" : network);
      }
      ccipReadFetch(tx, calldata, urls) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (this.disableCcipRead || urls.length === 0) {
            return null;
          }
          const sender = tx.to.toLowerCase();
          const data2 = calldata.toLowerCase();
          const errorMessages = [];
          for (let i = 0; i < urls.length; i++) {
            const url = urls[i];
            const href = url.replace("{sender}", sender).replace("{data}", data2);
            const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data2, sender });
            const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
              value.status = response.statusCode;
              return value;
            });
            if (result.data) {
              return result.data;
            }
            const errorMessage = result.message || "unknown error";
            if (result.status >= 400 && result.status < 500) {
              return logger30.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
            }
            errorMessages.push(errorMessage);
          }
          return logger30.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, Logger.errors.SERVER_ERROR, {
            urls,
            errorMessages
          });
        });
      }
      _getInternalBlockNumber(maxAge) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this._ready();
          if (maxAge > 0) {
            while (this._internalBlockNumber) {
              const internalBlockNumber = this._internalBlockNumber;
              try {
                const result = yield internalBlockNumber;
                if (getTime() - result.respTime <= maxAge) {
                  return result.blockNumber;
                }
                break;
              } catch (error) {
                if (this._internalBlockNumber === internalBlockNumber) {
                  break;
                }
              }
            }
          }
          const reqTime = getTime();
          const checkInternalBlockNumber = resolveProperties({
            blockNumber: this.perform("getBlockNumber", {}),
            networkError: this.getNetwork().then((network) => null, (error) => error)
          }).then(({ blockNumber, networkError }) => {
            if (networkError) {
              if (this._internalBlockNumber === checkInternalBlockNumber) {
                this._internalBlockNumber = null;
              }
              throw networkError;
            }
            const respTime = getTime();
            blockNumber = BigNumber.from(blockNumber).toNumber();
            if (blockNumber < this._maxInternalBlockNumber) {
              blockNumber = this._maxInternalBlockNumber;
            }
            this._maxInternalBlockNumber = blockNumber;
            this._setFastBlockNumber(blockNumber);
            return { blockNumber, reqTime, respTime };
          });
          this._internalBlockNumber = checkInternalBlockNumber;
          checkInternalBlockNumber.catch((error) => {
            if (this._internalBlockNumber === checkInternalBlockNumber) {
              this._internalBlockNumber = null;
            }
          });
          return (yield checkInternalBlockNumber).blockNumber;
        });
      }
      poll() {
        return __awaiter10(this, void 0, void 0, function* () {
          const pollId = nextPollId++;
          const runners = [];
          let blockNumber = null;
          try {
            blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
          } catch (error) {
            this.emit("error", error);
            return;
          }
          this._setFastBlockNumber(blockNumber);
          this.emit("poll", pollId, blockNumber);
          if (blockNumber === this._lastBlockNumber) {
            this.emit("didPoll", pollId);
            return;
          }
          if (this._emitted.block === -2) {
            this._emitted.block = blockNumber - 1;
          }
          if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
            logger30.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
            this.emit("error", logger30.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
              blockNumber,
              event: "blockSkew",
              previousBlockNumber: this._emitted.block
            }));
            this.emit("block", blockNumber);
          } else {
            for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
              this.emit("block", i);
            }
          }
          if (this._emitted.block !== blockNumber) {
            this._emitted.block = blockNumber;
            Object.keys(this._emitted).forEach((key2) => {
              if (key2 === "block") {
                return;
              }
              const eventBlockNumber = this._emitted[key2];
              if (eventBlockNumber === "pending") {
                return;
              }
              if (blockNumber - eventBlockNumber > 12) {
                delete this._emitted[key2];
              }
            });
          }
          if (this._lastBlockNumber === -2) {
            this._lastBlockNumber = blockNumber - 1;
          }
          this._events.forEach((event) => {
            switch (event.type) {
              case "tx": {
                const hash4 = event.hash;
                let runner2 = this.getTransactionReceipt(hash4).then((receipt) => {
                  if (!receipt || receipt.blockNumber == null) {
                    return null;
                  }
                  this._emitted["t:" + hash4] = receipt.blockNumber;
                  this.emit(hash4, receipt);
                  return null;
                }).catch((error) => {
                  this.emit("error", error);
                });
                runners.push(runner2);
                break;
              }
              case "filter": {
                if (!event._inflight) {
                  event._inflight = true;
                  if (event._lastBlockNumber === -2) {
                    event._lastBlockNumber = blockNumber - 1;
                  }
                  const filter = event.filter;
                  filter.fromBlock = event._lastBlockNumber + 1;
                  filter.toBlock = blockNumber;
                  const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
                  if (minFromBlock > filter.fromBlock) {
                    filter.fromBlock = minFromBlock;
                  }
                  if (filter.fromBlock < 0) {
                    filter.fromBlock = 0;
                  }
                  const runner2 = this.getLogs(filter).then((logs) => {
                    event._inflight = false;
                    if (logs.length === 0) {
                      return;
                    }
                    logs.forEach((log) => {
                      if (log.blockNumber > event._lastBlockNumber) {
                        event._lastBlockNumber = log.blockNumber;
                      }
                      this._emitted["b:" + log.blockHash] = log.blockNumber;
                      this._emitted["t:" + log.transactionHash] = log.blockNumber;
                      this.emit(filter, log);
                    });
                  }).catch((error) => {
                    this.emit("error", error);
                    event._inflight = false;
                  });
                  runners.push(runner2);
                }
                break;
              }
            }
          });
          this._lastBlockNumber = blockNumber;
          Promise.all(runners).then(() => {
            this.emit("didPoll", pollId);
          }).catch((error) => {
            this.emit("error", error);
          });
          return;
        });
      }
      resetEventsBlock(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) {
          this.poll();
        }
      }
      get network() {
        return this._network;
      }
      detectNetwork() {
        return __awaiter10(this, void 0, void 0, function* () {
          return logger30.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "provider.detectNetwork"
          });
        });
      }
      getNetwork() {
        return __awaiter10(this, void 0, void 0, function* () {
          const network = yield this._ready();
          const currentNetwork = yield this.detectNetwork();
          if (network.chainId !== currentNetwork.chainId) {
            if (this.anyNetwork) {
              this._network = currentNetwork;
              this._lastBlockNumber = -2;
              this._fastBlockNumber = null;
              this._fastBlockNumberPromise = null;
              this._fastQueryDate = 0;
              this._emitted.block = -2;
              this._maxInternalBlockNumber = -1024;
              this._internalBlockNumber = null;
              this.emit("network", currentNetwork, network);
              yield stall(0);
              return this._network;
            }
            const error = logger30.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
              event: "changed",
              network,
              detectedNetwork: currentNetwork
            });
            this.emit("error", error);
            throw error;
          }
          return network;
        });
      }
      get blockNumber() {
        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
          this._setFastBlockNumber(blockNumber);
        }, (error) => {
        });
        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
      }
      get polling() {
        return this._poller != null;
      }
      set polling(value) {
        if (value && !this._poller) {
          this._poller = setInterval(() => {
            this.poll();
          }, this.pollingInterval);
          if (!this._bootstrapPoll) {
            this._bootstrapPoll = setTimeout(() => {
              this.poll();
              this._bootstrapPoll = setTimeout(() => {
                if (!this._poller) {
                  this.poll();
                }
                this._bootstrapPoll = null;
              }, this.pollingInterval);
            }, 0);
          }
        } else if (!value && this._poller) {
          clearInterval(this._poller);
          this._poller = null;
        }
      }
      get pollingInterval() {
        return this._pollingInterval;
      }
      set pollingInterval(value) {
        if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
          throw new Error("invalid polling interval");
        }
        this._pollingInterval = value;
        if (this._poller) {
          clearInterval(this._poller);
          this._poller = setInterval(() => {
            this.poll();
          }, this._pollingInterval);
        }
      }
      _getFastBlockNumber() {
        const now2 = getTime();
        if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
          this._fastQueryDate = now2;
          this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
            if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
              this._fastBlockNumber = blockNumber;
            }
            return this._fastBlockNumber;
          });
        }
        return this._fastBlockNumberPromise;
      }
      _setFastBlockNumber(blockNumber) {
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
          return;
        }
        this._fastQueryDate = getTime();
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
          this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
      }
      waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter10(this, void 0, void 0, function* () {
          return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
        });
      }
      _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter10(this, void 0, void 0, function* () {
          const receipt = yield this.getTransactionReceipt(transactionHash);
          if ((receipt ? receipt.confirmations : 0) >= confirmations) {
            return receipt;
          }
          return new Promise((resolve2, reject2) => {
            const cancelFuncs = [];
            let done = false;
            const alreadyDone = function() {
              if (done) {
                return true;
              }
              done = true;
              cancelFuncs.forEach((func) => {
                func();
              });
              return false;
            };
            const minedHandler = (receipt2) => {
              if (receipt2.confirmations < confirmations) {
                return;
              }
              if (alreadyDone()) {
                return;
              }
              resolve2(receipt2);
            };
            this.on(transactionHash, minedHandler);
            cancelFuncs.push(() => {
              this.removeListener(transactionHash, minedHandler);
            });
            if (replaceable) {
              let lastBlockNumber = replaceable.startBlock;
              let scannedBlock = null;
              const replaceHandler = (blockNumber) => __awaiter10(this, void 0, void 0, function* () {
                if (done) {
                  return;
                }
                yield stall(1e3);
                this.getTransactionCount(replaceable.from).then((nonce) => __awaiter10(this, void 0, void 0, function* () {
                  if (done) {
                    return;
                  }
                  if (nonce <= replaceable.nonce) {
                    lastBlockNumber = blockNumber;
                  } else {
                    {
                      const mined = yield this.getTransaction(transactionHash);
                      if (mined && mined.blockNumber != null) {
                        return;
                      }
                    }
                    if (scannedBlock == null) {
                      scannedBlock = lastBlockNumber - 3;
                      if (scannedBlock < replaceable.startBlock) {
                        scannedBlock = replaceable.startBlock;
                      }
                    }
                    while (scannedBlock <= blockNumber) {
                      if (done) {
                        return;
                      }
                      const block = yield this.getBlockWithTransactions(scannedBlock);
                      for (let ti = 0; ti < block.transactions.length; ti++) {
                        const tx = block.transactions[ti];
                        if (tx.hash === transactionHash) {
                          return;
                        }
                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                          if (done) {
                            return;
                          }
                          const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                          if (alreadyDone()) {
                            return;
                          }
                          let reason = "replaced";
                          if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                            reason = "repriced";
                          } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                            reason = "cancelled";
                          }
                          reject2(logger30.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                            cancelled: reason === "replaced" || reason === "cancelled",
                            reason,
                            replacement: this._wrapTransaction(tx),
                            hash: transactionHash,
                            receipt: receipt2
                          }));
                          return;
                        }
                      }
                      scannedBlock++;
                    }
                  }
                  if (done) {
                    return;
                  }
                  this.once("block", replaceHandler);
                }), (error) => {
                  if (done) {
                    return;
                  }
                  this.once("block", replaceHandler);
                });
              });
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
              cancelFuncs.push(() => {
                this.removeListener("block", replaceHandler);
              });
            }
            if (typeof timeout === "number" && timeout > 0) {
              const timer2 = setTimeout(() => {
                if (alreadyDone()) {
                  return;
                }
                reject2(logger30.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
              }, timeout);
              if (timer2.unref) {
                timer2.unref();
              }
              cancelFuncs.push(() => {
                clearTimeout(timer2);
              });
            }
          });
        });
      }
      getBlockNumber() {
        return __awaiter10(this, void 0, void 0, function* () {
          return this._getInternalBlockNumber(0);
        });
      }
      getGasPrice() {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const result = yield this.perform("getGasPrice", {});
          try {
            return BigNumber.from(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getGasPrice",
              result,
              error
            });
          }
        });
      }
      getBalance(addressOrName, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag)
          });
          const result = yield this.perform("getBalance", params);
          try {
            return BigNumber.from(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getBalance",
              params,
              result,
              error
            });
          }
        });
      }
      getTransactionCount(addressOrName, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag)
          });
          const result = yield this.perform("getTransactionCount", params);
          try {
            return BigNumber.from(result).toNumber();
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getTransactionCount",
              params,
              result,
              error
            });
          }
        });
      }
      getCode(addressOrName, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag)
          });
          const result = yield this.perform("getCode", params);
          try {
            return hexlify(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getCode",
              params,
              result,
              error
            });
          }
        });
      }
      getStorageAt(addressOrName, position, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            address: this._getAddress(addressOrName),
            blockTag: this._getBlockTag(blockTag),
            position: Promise.resolve(position).then((p) => hexValue(p))
          });
          const result = yield this.perform("getStorageAt", params);
          try {
            return hexlify(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "getStorageAt",
              params,
              result,
              error
            });
          }
        });
      }
      _wrapTransaction(tx, hash4, startBlock) {
        if (hash4 != null && hexDataLength(hash4) !== 32) {
          throw new Error("invalid response - sendTransaction");
        }
        const result = tx;
        if (hash4 != null && tx.hash !== hash4) {
          logger30.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash4 });
        }
        result.wait = (confirms, timeout) => __awaiter10(this, void 0, void 0, function* () {
          if (confirms == null) {
            confirms = 1;
          }
          if (timeout == null) {
            timeout = 0;
          }
          let replacement2 = void 0;
          if (confirms !== 0 && startBlock != null) {
            replacement2 = {
              data: tx.data,
              from: tx.from,
              nonce: tx.nonce,
              to: tx.to,
              value: tx.value,
              startBlock
            };
          }
          const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement2);
          if (receipt == null && confirms === 0) {
            return null;
          }
          this._emitted["t:" + tx.hash] = receipt.blockNumber;
          if (receipt.status === 0) {
            logger30.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
              transactionHash: tx.hash,
              transaction: tx,
              receipt
            });
          }
          return receipt;
        });
        return result;
      }
      sendTransaction(signedTransaction) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const hexTx = yield Promise.resolve(signedTransaction).then((t) => hexlify(t));
          const tx = this.formatter.transaction(signedTransaction);
          if (tx.confirmations == null) {
            tx.confirmations = 0;
          }
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          try {
            const hash4 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
            return this._wrapTransaction(tx, hash4, blockNumber);
          } catch (error) {
            error.transaction = tx;
            error.transactionHash = tx.hash;
            throw error;
          }
        });
      }
      _getTransactionRequest(transaction) {
        return __awaiter10(this, void 0, void 0, function* () {
          const values2 = yield transaction;
          const tx = {};
          ["from", "to"].forEach((key2) => {
            if (values2[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values2[key2]).then((v) => v ? this._getAddress(v) : null);
          });
          ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
            if (values2[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values2[key2]).then((v) => v ? BigNumber.from(v) : null);
          });
          ["type"].forEach((key2) => {
            if (values2[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values2[key2]).then((v) => v != null ? v : null);
          });
          if (values2.accessList) {
            tx.accessList = this.formatter.accessList(values2.accessList);
          }
          ["data"].forEach((key2) => {
            if (values2[key2] == null) {
              return;
            }
            tx[key2] = Promise.resolve(values2[key2]).then((v) => v ? hexlify(v) : null);
          });
          return this.formatter.transactionRequest(yield resolveProperties(tx));
        });
      }
      _getFilter(filter) {
        return __awaiter10(this, void 0, void 0, function* () {
          filter = yield filter;
          const result = {};
          if (filter.address != null) {
            result.address = this._getAddress(filter.address);
          }
          ["blockHash", "topics"].forEach((key2) => {
            if (filter[key2] == null) {
              return;
            }
            result[key2] = filter[key2];
          });
          ["fromBlock", "toBlock"].forEach((key2) => {
            if (filter[key2] == null) {
              return;
            }
            result[key2] = this._getBlockTag(filter[key2]);
          });
          return this.formatter.filter(yield resolveProperties(result));
        });
      }
      _call(transaction, blockTag, attempt) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (attempt >= MAX_CCIP_REDIRECTS) {
            logger30.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
              redirects: attempt,
              transaction
            });
          }
          const txSender = transaction.to;
          const result = yield this.perform("call", { transaction, blockTag });
          if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
            try {
              const data2 = hexDataSlice(result, 4);
              const sender = hexDataSlice(data2, 0, 32);
              if (!BigNumber.from(sender).eq(txSender)) {
                logger30.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction,
                  data: result
                });
              }
              const urls = [];
              const urlsOffset = BigNumber.from(hexDataSlice(data2, 32, 64)).toNumber();
              const urlsLength = BigNumber.from(hexDataSlice(data2, urlsOffset, urlsOffset + 32)).toNumber();
              const urlsData = hexDataSlice(data2, urlsOffset + 32);
              for (let u = 0; u < urlsLength; u++) {
                const url = _parseString(urlsData, u * 32);
                if (url == null) {
                  logger30.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                  });
                }
                urls.push(url);
              }
              const calldata = _parseBytes(data2, 64);
              if (!BigNumber.from(hexDataSlice(data2, 100, 128)).isZero()) {
                logger30.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction,
                  data: result
                });
              }
              const callbackSelector = hexDataSlice(data2, 96, 100);
              const extraData = _parseBytes(data2, 128);
              const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
              if (ccipResult == null) {
                logger30.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction,
                  data: result
                });
              }
              const tx = {
                to: txSender,
                data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
              };
              return this._call(tx, blockTag, attempt + 1);
            } catch (error) {
              if (error.code === Logger.errors.SERVER_ERROR) {
                throw error;
              }
            }
          }
          try {
            return hexlify(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "call",
              params: { transaction, blockTag },
              result,
              error
            });
          }
        });
      }
      call(transaction, blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const resolved = yield resolveProperties({
            transaction: this._getTransactionRequest(transaction),
            blockTag: this._getBlockTag(blockTag),
            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
          });
          return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
        });
      }
      estimateGas(transaction) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({
            transaction: this._getTransactionRequest(transaction)
          });
          const result = yield this.perform("estimateGas", params);
          try {
            return BigNumber.from(result);
          } catch (error) {
            return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
              method: "estimateGas",
              params,
              result,
              error
            });
          }
        });
      }
      _getAddress(addressOrName) {
        return __awaiter10(this, void 0, void 0, function* () {
          addressOrName = yield addressOrName;
          if (typeof addressOrName !== "string") {
            logger30.throwArgumentError("invalid address or ENS name", "name", addressOrName);
          }
          const address = yield this.resolveName(addressOrName);
          if (address == null) {
            logger30.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: `resolveName(${JSON.stringify(addressOrName)})`
            });
          }
          return address;
        });
      }
      _getBlock(blockHashOrBlockTag, includeTransactions) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          blockHashOrBlockTag = yield blockHashOrBlockTag;
          let blockNumber = -128;
          const params = {
            includeTransactions: !!includeTransactions
          };
          if (isHexString(blockHashOrBlockTag, 32)) {
            params.blockHash = blockHashOrBlockTag;
          } else {
            try {
              params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
              if (isHexString(params.blockTag)) {
                blockNumber = parseInt(params.blockTag.substring(2), 16);
              }
            } catch (error) {
              logger30.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
            }
          }
          return poll(() => __awaiter10(this, void 0, void 0, function* () {
            const block = yield this.perform("getBlock", params);
            if (block == null) {
              if (params.blockHash != null) {
                if (this._emitted["b:" + params.blockHash] == null) {
                  return null;
                }
              }
              if (params.blockTag != null) {
                if (blockNumber > this._emitted.block) {
                  return null;
                }
              }
              return void 0;
            }
            if (includeTransactions) {
              let blockNumber2 = null;
              for (let i = 0; i < block.transactions.length; i++) {
                const tx = block.transactions[i];
                if (tx.blockNumber == null) {
                  tx.confirmations = 0;
                } else if (tx.confirmations == null) {
                  if (blockNumber2 == null) {
                    blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                  }
                  let confirmations = blockNumber2 - tx.blockNumber + 1;
                  if (confirmations <= 0) {
                    confirmations = 1;
                  }
                  tx.confirmations = confirmations;
                }
              }
              const blockWithTxs = this.formatter.blockWithTransactions(block);
              blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
              return blockWithTxs;
            }
            return this.formatter.block(block);
          }), { oncePoll: this });
        });
      }
      getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
      }
      getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
      }
      getTransaction(transactionHash) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          transactionHash = yield transactionHash;
          const params = { transactionHash: this.formatter.hash(transactionHash, true) };
          return poll(() => __awaiter10(this, void 0, void 0, function* () {
            const result = yield this.perform("getTransaction", params);
            if (result == null) {
              if (this._emitted["t:" + transactionHash] == null) {
                return null;
              }
              return void 0;
            }
            const tx = this.formatter.transactionResponse(result);
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              let confirmations = blockNumber - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
            return this._wrapTransaction(tx);
          }), { oncePoll: this });
        });
      }
      getTransactionReceipt(transactionHash) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          transactionHash = yield transactionHash;
          const params = { transactionHash: this.formatter.hash(transactionHash, true) };
          return poll(() => __awaiter10(this, void 0, void 0, function* () {
            const result = yield this.perform("getTransactionReceipt", params);
            if (result == null) {
              if (this._emitted["t:" + transactionHash] == null) {
                return null;
              }
              return void 0;
            }
            if (result.blockHash == null) {
              return void 0;
            }
            const receipt = this.formatter.receipt(result);
            if (receipt.blockNumber == null) {
              receipt.confirmations = 0;
            } else if (receipt.confirmations == null) {
              const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              let confirmations = blockNumber - receipt.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              receipt.confirmations = confirmations;
            }
            return receipt;
          }), { oncePoll: this });
        });
      }
      getLogs(filter) {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          const params = yield resolveProperties({ filter: this._getFilter(filter) });
          const logs = yield this.perform("getLogs", params);
          logs.forEach((log) => {
            if (log.removed == null) {
              log.removed = false;
            }
          });
          return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
        });
      }
      getEtherPrice() {
        return __awaiter10(this, void 0, void 0, function* () {
          yield this.getNetwork();
          return this.perform("getEtherPrice", {});
        });
      }
      _getBlockTag(blockTag) {
        return __awaiter10(this, void 0, void 0, function* () {
          blockTag = yield blockTag;
          if (typeof blockTag === "number" && blockTag < 0) {
            if (blockTag % 1) {
              logger30.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
            }
            let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            blockNumber += blockTag;
            if (blockNumber < 0) {
              blockNumber = 0;
            }
            return this.formatter.blockTag(blockNumber);
          }
          return this.formatter.blockTag(blockTag);
        });
      }
      getResolver(name) {
        return __awaiter10(this, void 0, void 0, function* () {
          let currentName = name;
          while (true) {
            if (currentName === "" || currentName === ".") {
              return null;
            }
            if (name !== "eth" && currentName === "eth") {
              return null;
            }
            const addr = yield this._getResolver(currentName, "getResolver");
            if (addr != null) {
              const resolver = new Resolver(this, addr, name);
              if (currentName !== name && !(yield resolver.supportsWildcard())) {
                return null;
              }
              return resolver;
            }
            currentName = currentName.split(".").slice(1).join(".");
          }
        });
      }
      _getResolver(name, operation) {
        return __awaiter10(this, void 0, void 0, function* () {
          if (operation == null) {
            operation = "ENS";
          }
          const network = yield this.getNetwork();
          if (!network.ensAddress) {
            logger30.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
          }
          try {
            const addrData = yield this.call({
              to: network.ensAddress,
              data: "0x0178b8bf" + namehash(name).substring(2)
            });
            return this.formatter.callAddress(addrData);
          } catch (error) {
          }
          return null;
        });
      }
      resolveName(name) {
        return __awaiter10(this, void 0, void 0, function* () {
          name = yield name;
          try {
            return Promise.resolve(this.formatter.address(name));
          } catch (error) {
            if (isHexString(name)) {
              throw error;
            }
          }
          if (typeof name !== "string") {
            logger30.throwArgumentError("invalid ENS name", "name", name);
          }
          const resolver = yield this.getResolver(name);
          if (!resolver) {
            return null;
          }
          return yield resolver.getAddress();
        });
      }
      lookupAddress(address) {
        return __awaiter10(this, void 0, void 0, function* () {
          address = yield address;
          address = this.formatter.address(address);
          const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
          const resolverAddr = yield this._getResolver(node2, "lookupAddress");
          if (resolverAddr == null) {
            return null;
          }
          const name = _parseString(yield this.call({
            to: resolverAddr,
            data: "0x691f3431" + namehash(node2).substring(2)
          }), 0);
          const addr = yield this.resolveName(name);
          if (addr != address) {
            return null;
          }
          return name;
        });
      }
      getAvatar(nameOrAddress) {
        return __awaiter10(this, void 0, void 0, function* () {
          let resolver = null;
          if (isHexString(nameOrAddress)) {
            const address = this.formatter.address(nameOrAddress);
            const node2 = address.substring(2).toLowerCase() + ".addr.reverse";
            const resolverAddress = yield this._getResolver(node2, "getAvatar");
            if (!resolverAddress) {
              return null;
            }
            resolver = new Resolver(this, resolverAddress, node2);
            try {
              const avatar2 = yield resolver.getAvatar();
              if (avatar2) {
                return avatar2.url;
              }
            } catch (error) {
              if (error.code !== Logger.errors.CALL_EXCEPTION) {
                throw error;
              }
            }
            try {
              const name = _parseString(yield this.call({
                to: resolverAddress,
                data: "0x691f3431" + namehash(node2).substring(2)
              }), 0);
              resolver = yield this.getResolver(name);
            } catch (error) {
              if (error.code !== Logger.errors.CALL_EXCEPTION) {
                throw error;
              }
              return null;
            }
          } else {
            resolver = yield this.getResolver(nameOrAddress);
            if (!resolver) {
              return null;
            }
          }
          const avatar = yield resolver.getAvatar();
          if (avatar == null) {
            return null;
          }
          return avatar.url;
        });
      }
      perform(method, params) {
        return logger30.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      _startEvent(event) {
        this.polling = this._events.filter((e) => e.pollable()).length > 0;
      }
      _stopEvent(event) {
        this.polling = this._events.filter((e) => e.pollable()).length > 0;
      }
      _addEventListener(eventName, listener, once) {
        const event = new Event(getEventTag2(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
      }
      on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
      }
      once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
      }
      emit(eventName, ...args) {
        let result = false;
        let stopped = [];
        let eventTag = getEventTag2(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag) {
            return true;
          }
          setTimeout(() => {
            event.listener.apply(this, args);
          }, 0);
          result = true;
          if (event.once) {
            stopped.push(event);
            return false;
          }
          return true;
        });
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return result;
      }
      listenerCount(eventName) {
        if (!eventName) {
          return this._events.length;
        }
        let eventTag = getEventTag2(eventName);
        return this._events.filter((event) => {
          return event.tag === eventTag;
        }).length;
      }
      listeners(eventName) {
        if (eventName == null) {
          return this._events.map((event) => event.listener);
        }
        let eventTag = getEventTag2(eventName);
        return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
      }
      off(eventName, listener) {
        if (listener == null) {
          return this.removeAllListeners(eventName);
        }
        const stopped = [];
        let found = false;
        let eventTag = getEventTag2(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag || event.listener != listener) {
            return true;
          }
          if (found) {
            return true;
          }
          found = true;
          stopped.push(event);
          return false;
        });
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return this;
      }
      removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
          stopped = this._events;
          this._events = [];
        } else {
          const eventTag = getEventTag2(eventName);
          this._events = this._events.filter((event) => {
            if (event.tag !== eventTag) {
              return true;
            }
            stopped.push(event);
            return false;
          });
        }
        stopped.forEach((event) => {
          this._stopEvent(event);
        });
        return this;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data2 = isHexString(value.data) ? value.data : null;
    if (!requireData || data2) {
      return { message: value.message, data: data2 };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger31.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger31.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger31.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger31.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger31.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout) {
  return new Promise(function(resolve2) {
    setTimeout(resolve2, timeout);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var __awaiter11, logger31, errorGas, _constructorGuard5, JsonRpcSigner, UncheckedJsonRpcSigner, allowedTransactionKeys4, JsonRpcProvider;
var init_json_rpc_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js"() {
    "use strict";
    init_lib15();
    init_lib3();
    init_lib2();
    init_lib12();
    init_lib4();
    init_lib9();
    init_lib17();
    init_lib28();
    init_lib();
    init_version23();
    init_base_provider();
    __awaiter11 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger31 = new Logger(version23);
    errorGas = ["call", "estimateGas"];
    _constructorGuard5 = {};
    JsonRpcSigner = class extends Signer {
      constructor(constructorGuard, provider, addressOrIndex) {
        super();
        if (constructorGuard !== _constructorGuard5) {
          throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        }
        defineReadOnly(this, "provider", provider);
        if (addressOrIndex == null) {
          addressOrIndex = 0;
        }
        if (typeof addressOrIndex === "string") {
          defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
          defineReadOnly(this, "_index", null);
        } else if (typeof addressOrIndex === "number") {
          defineReadOnly(this, "_index", addressOrIndex);
          defineReadOnly(this, "_address", null);
        } else {
          logger31.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
        }
      }
      connect(provider) {
        return logger31.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "connect"
        });
      }
      connectUnchecked() {
        return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
      }
      getAddress() {
        if (this._address) {
          return Promise.resolve(this._address);
        }
        return this.provider.send("eth_accounts", []).then((accounts) => {
          if (accounts.length <= this._index) {
            logger31.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "getAddress"
            });
          }
          return this.provider.formatter.address(accounts[this._index]);
        });
      }
      sendUncheckedTransaction(transaction) {
        transaction = shallowCopy(transaction);
        const fromAddress = this.getAddress().then((address) => {
          if (address) {
            address = address.toLowerCase();
          }
          return address;
        });
        if (transaction.gasLimit == null) {
          const estimate = shallowCopy(transaction);
          estimate.from = fromAddress;
          transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) {
          transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter11(this, void 0, void 0, function* () {
            if (to == null) {
              return null;
            }
            const address = yield this.provider.resolveName(to);
            if (address == null) {
              logger31.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
            }
            return address;
          }));
        }
        return resolveProperties({
          tx: resolveProperties(transaction),
          sender: fromAddress
        }).then(({ tx, sender }) => {
          if (tx.from != null) {
            if (tx.from.toLowerCase() !== sender) {
              logger31.throwArgumentError("from address mismatch", "transaction", transaction);
            }
          } else {
            tx.from = sender;
          }
          const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
          return this.provider.send("eth_sendTransaction", [hexTx]).then((hash4) => {
            return hash4;
          }, (error) => {
            if (typeof error.message === "string" && error.message.match(/user denied/i)) {
              logger31.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
                action: "sendTransaction",
                transaction: tx
              });
            }
            return checkError("sendTransaction", error, hexTx);
          });
        });
      }
      signTransaction(transaction) {
        return logger31.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "signTransaction"
        });
      }
      sendTransaction(transaction) {
        return __awaiter11(this, void 0, void 0, function* () {
          const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
          const hash4 = yield this.sendUncheckedTransaction(transaction);
          try {
            return yield poll(() => __awaiter11(this, void 0, void 0, function* () {
              const tx = yield this.provider.getTransaction(hash4);
              if (tx === null) {
                return void 0;
              }
              return this.provider._wrapTransaction(tx, hash4, blockNumber);
            }), { oncePoll: this.provider });
          } catch (error) {
            error.transactionHash = hash4;
            throw error;
          }
        });
      }
      signMessage(message) {
        return __awaiter11(this, void 0, void 0, function* () {
          const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
          const address = yield this.getAddress();
          try {
            return yield this.provider.send("personal_sign", [hexlify(data2), address.toLowerCase()]);
          } catch (error) {
            if (typeof error.message === "string" && error.message.match(/user denied/i)) {
              logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
                action: "signMessage",
                from: address,
                messageData: message
              });
            }
            throw error;
          }
        });
      }
      _legacySignMessage(message) {
        return __awaiter11(this, void 0, void 0, function* () {
          const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
          const address = yield this.getAddress();
          try {
            return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data2)]);
          } catch (error) {
            if (typeof error.message === "string" && error.message.match(/user denied/i)) {
              logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
                action: "_legacySignMessage",
                from: address,
                messageData: message
              });
            }
            throw error;
          }
        });
      }
      _signTypedData(domain, types, value) {
        return __awaiter11(this, void 0, void 0, function* () {
          const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {
            return this.provider.resolveName(name);
          });
          const address = yield this.getAddress();
          try {
            return yield this.provider.send("eth_signTypedData_v4", [
              address.toLowerCase(),
              JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
            ]);
          } catch (error) {
            if (typeof error.message === "string" && error.message.match(/user denied/i)) {
              logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
                action: "_signTypedData",
                from: address,
                messageData: { domain: populated.domain, types, value: populated.value }
              });
            }
            throw error;
          }
        });
      }
      unlock(password) {
        return __awaiter11(this, void 0, void 0, function* () {
          const provider = this.provider;
          const address = yield this.getAddress();
          return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
        });
      }
    };
    UncheckedJsonRpcSigner = class extends JsonRpcSigner {
      sendTransaction(transaction) {
        return this.sendUncheckedTransaction(transaction).then((hash4) => {
          return {
            hash: hash4,
            nonce: null,
            gasLimit: null,
            gasPrice: null,
            data: null,
            value: null,
            chainId: null,
            confirmations: 0,
            from: null,
            wait: (confirmations) => {
              return this.provider.waitForTransaction(hash4, confirmations);
            }
          };
        });
      }
    };
    allowedTransactionKeys4 = {
      chainId: true,
      data: true,
      gasLimit: true,
      gasPrice: true,
      nonce: true,
      to: true,
      value: true,
      type: true,
      accessList: true,
      maxFeePerGas: true,
      maxPriorityFeePerGas: true
    };
    JsonRpcProvider = class extends BaseProvider {
      constructor(url, network) {
        let networkOrReady = network;
        if (networkOrReady == null) {
          networkOrReady = new Promise((resolve2, reject2) => {
            setTimeout(() => {
              this.detectNetwork().then((network2) => {
                resolve2(network2);
              }, (error) => {
                reject2(error);
              });
            }, 0);
          });
        }
        super(networkOrReady);
        if (!url) {
          url = getStatic(this.constructor, "defaultUrl")();
        }
        if (typeof url === "string") {
          defineReadOnly(this, "connection", Object.freeze({
            url
          }));
        } else {
          defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
        }
        this._nextId = 42;
      }
      get _cache() {
        if (this._eventLoopCache == null) {
          this._eventLoopCache = {};
        }
        return this._eventLoopCache;
      }
      static defaultUrl() {
        return "http://localhost:8545";
      }
      detectNetwork() {
        if (!this._cache["detectNetwork"]) {
          this._cache["detectNetwork"] = this._uncachedDetectNetwork();
          setTimeout(() => {
            this._cache["detectNetwork"] = null;
          }, 0);
        }
        return this._cache["detectNetwork"];
      }
      _uncachedDetectNetwork() {
        return __awaiter11(this, void 0, void 0, function* () {
          yield timer(0);
          let chainId = null;
          try {
            chainId = yield this.send("eth_chainId", []);
          } catch (error) {
            try {
              chainId = yield this.send("net_version", []);
            } catch (error2) {
            }
          }
          if (chainId != null) {
            const getNetwork2 = getStatic(this.constructor, "getNetwork");
            try {
              return getNetwork2(BigNumber.from(chainId).toNumber());
            } catch (error) {
              return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
                chainId,
                event: "invalidNetwork",
                serverError: error
              });
            }
          }
          return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            event: "noNetwork"
          });
        });
      }
      getSigner(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
      }
      getUncheckedSigner(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
      }
      listAccounts() {
        return this.send("eth_accounts", []).then((accounts) => {
          return accounts.map((a) => this.formatter.address(a));
        });
      }
      send(method, params) {
        const request = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        this.emit("debug", {
          action: "request",
          request: deepCopy(request),
          provider: this
        });
        const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
        if (cache && this._cache[method]) {
          return this._cache[method];
        }
        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
          this.emit("debug", {
            action: "response",
            request,
            response: result2,
            provider: this
          });
          return result2;
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request,
            provider: this
          });
          throw error;
        });
        if (cache) {
          this._cache[method] = result;
          setTimeout(() => {
            this._cache[method] = null;
          }, 0);
        }
        return result;
      }
      prepareRequest(method, params) {
        switch (method) {
          case "getBlockNumber":
            return ["eth_blockNumber", []];
          case "getGasPrice":
            return ["eth_gasPrice", []];
          case "getBalance":
            return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
          case "getTransactionCount":
            return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
          case "getCode":
            return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
          case "getStorageAt":
            return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
          case "sendTransaction":
            return ["eth_sendRawTransaction", [params.signedTransaction]];
          case "getBlock":
            if (params.blockTag) {
              return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
            } else if (params.blockHash) {
              return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
            }
            return null;
          case "getTransaction":
            return ["eth_getTransactionByHash", [params.transactionHash]];
          case "getTransactionReceipt":
            return ["eth_getTransactionReceipt", [params.transactionHash]];
          case "call": {
            const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
            return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
          }
          case "estimateGas": {
            const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
            return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
          }
          case "getLogs":
            if (params.filter && params.filter.address != null) {
              params.filter.address = getLowerCase(params.filter.address);
            }
            return ["eth_getLogs", [params.filter]];
          default:
            break;
        }
        return null;
      }
      perform(method, params) {
        return __awaiter11(this, void 0, void 0, function* () {
          if (method === "call" || method === "estimateGas") {
            const tx = params.transaction;
            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
              if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                const feeData = yield this.getFeeData();
                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  params = shallowCopy(params);
                  params.transaction = shallowCopy(tx);
                  delete params.transaction.type;
                }
              }
            }
          }
          const args = this.prepareRequest(method, params);
          if (args == null) {
            logger31.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
          }
          try {
            return yield this.send(args[0], args[1]);
          } catch (error) {
            return checkError(method, error, params);
          }
        });
      }
      _startEvent(event) {
        if (event.tag === "pending") {
          this._startPending();
        }
        super._startEvent(event);
      }
      _startPending() {
        if (this._pendingFilter != null) {
          return;
        }
        const self2 = this;
        const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function(filterId) {
          function poll2() {
            self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
              if (self2._pendingFilter != pendingFilter) {
                return null;
              }
              let seq = Promise.resolve();
              hashes.forEach(function(hash4) {
                self2._emitted["t:" + hash4.toLowerCase()] = "pending";
                seq = seq.then(function() {
                  return self2.getTransaction(hash4).then(function(tx) {
                    self2.emit("pending", tx);
                    return null;
                  });
                });
              });
              return seq.then(function() {
                return timer(1e3);
              });
            }).then(function() {
              if (self2._pendingFilter != pendingFilter) {
                self2.send("eth_uninstallFilter", [filterId]);
                return;
              }
              setTimeout(function() {
                poll2();
              }, 0);
              return null;
            }).catch((error) => {
            });
          }
          poll2();
          return filterId;
        }).catch((error) => {
        });
      }
      _stopEvent(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) {
          this._pendingFilter = null;
        }
        super._stopEvent(event);
      }
      static hexlifyTransaction(transaction, allowExtra) {
        const allowed = shallowCopy(allowedTransactionKeys4);
        if (allowExtra) {
          for (const key2 in allowExtra) {
            if (allowExtra[key2]) {
              allowed[key2] = true;
            }
          }
        }
        checkProperties(transaction, allowed);
        const result = {};
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          const value = hexValue(BigNumber.from(transaction[key2]));
          if (key2 === "gasLimit") {
            key2 = "gas";
          }
          result[key2] = value;
        });
        ["from", "to", "data"].forEach(function(key2) {
          if (transaction[key2] == null) {
            return;
          }
          result[key2] = hexlify(transaction[key2]);
        });
        if (transaction.accessList) {
          result["accessList"] = accessListify(transaction.accessList);
        }
        return result;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/ws.js
var WS;
var init_ws = __esm({
  "node_modules/@ethersproject/providers/lib.esm/ws.js"() {
    "use strict";
    init_lib();
    init_version23();
    WS = null;
    try {
      WS = WebSocket;
      if (WS == null) {
        throw new Error("inject please");
      }
    } catch (error) {
      const logger47 = new Logger(version23);
      WS = function() {
        logger47.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new WebSocket()"
        });
      };
    }
  }
});

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var __awaiter12, logger32, NextId, WebSocketProvider;
var init_websocket_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/websocket-provider.js"() {
    "use strict";
    init_lib3();
    init_lib4();
    init_json_rpc_provider();
    init_ws();
    init_lib();
    init_version23();
    __awaiter12 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger32 = new Logger(version23);
    NextId = 1;
    WebSocketProvider = class extends JsonRpcProvider {
      constructor(url, network) {
        if (network === "any") {
          logger32.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "network:any"
          });
        }
        if (typeof url === "string") {
          super(url, network);
        } else {
          super("_websocket", network);
        }
        this._pollingInterval = -1;
        this._wsReady = false;
        if (typeof url === "string") {
          defineReadOnly(this, "_websocket", new WS(this.connection.url));
        } else {
          defineReadOnly(this, "_websocket", url);
        }
        defineReadOnly(this, "_requests", {});
        defineReadOnly(this, "_subs", {});
        defineReadOnly(this, "_subIds", {});
        defineReadOnly(this, "_detectNetwork", super.detectNetwork());
        this.websocket.onopen = () => {
          this._wsReady = true;
          Object.keys(this._requests).forEach((id4) => {
            this.websocket.send(this._requests[id4].payload);
          });
        };
        this.websocket.onmessage = (messageEvent) => {
          const data2 = messageEvent.data;
          const result = JSON.parse(data2);
          if (result.id != null) {
            const id4 = String(result.id);
            const request = this._requests[id4];
            delete this._requests[id4];
            if (result.result !== void 0) {
              request.callback(null, result.result);
              this.emit("debug", {
                action: "response",
                request: JSON.parse(request.payload),
                response: result.result,
                provider: this
              });
            } else {
              let error = null;
              if (result.error) {
                error = new Error(result.error.message || "unknown error");
                defineReadOnly(error, "code", result.error.code || null);
                defineReadOnly(error, "response", data2);
              } else {
                error = new Error("unknown error");
              }
              request.callback(error, void 0);
              this.emit("debug", {
                action: "response",
                error,
                request: JSON.parse(request.payload),
                provider: this
              });
            }
          } else if (result.method === "eth_subscription") {
            const sub = this._subs[result.params.subscription];
            if (sub) {
              sub.processFunc(result.params.result);
            }
          } else {
            console.warn("this should not happen");
          }
        };
        const fauxPoll = setInterval(() => {
          this.emit("poll");
        }, 1e3);
        if (fauxPoll.unref) {
          fauxPoll.unref();
        }
      }
      get websocket() {
        return this._websocket;
      }
      detectNetwork() {
        return this._detectNetwork;
      }
      get pollingInterval() {
        return 0;
      }
      resetEventsBlock(blockNumber) {
        logger32.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resetEventBlock"
        });
      }
      set pollingInterval(value) {
        logger32.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setPollingInterval"
        });
      }
      poll() {
        return __awaiter12(this, void 0, void 0, function* () {
          return null;
        });
      }
      set polling(value) {
        if (!value) {
          return;
        }
        logger32.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setPolling"
        });
      }
      send(method, params) {
        const rid = NextId++;
        return new Promise((resolve2, reject2) => {
          function callback(error, result) {
            if (error) {
              return reject2(error);
            }
            return resolve2(result);
          }
          const payload = JSON.stringify({
            method,
            params,
            id: rid,
            jsonrpc: "2.0"
          });
          this.emit("debug", {
            action: "request",
            request: JSON.parse(payload),
            provider: this
          });
          this._requests[String(rid)] = { callback, payload };
          if (this._wsReady) {
            this.websocket.send(payload);
          }
        });
      }
      static defaultUrl() {
        return "ws://localhost:8546";
      }
      _subscribe(tag, param, processFunc) {
        return __awaiter12(this, void 0, void 0, function* () {
          let subIdPromise = this._subIds[tag];
          if (subIdPromise == null) {
            subIdPromise = Promise.all(param).then((param2) => {
              return this.send("eth_subscribe", param2);
            });
            this._subIds[tag] = subIdPromise;
          }
          const subId = yield subIdPromise;
          this._subs[subId] = { tag, processFunc };
        });
      }
      _startEvent(event) {
        switch (event.type) {
          case "block":
            this._subscribe("block", ["newHeads"], (result) => {
              const blockNumber = BigNumber.from(result.number).toNumber();
              this._emitted.block = blockNumber;
              this.emit("block", blockNumber);
            });
            break;
          case "pending":
            this._subscribe("pending", ["newPendingTransactions"], (result) => {
              this.emit("pending", result);
            });
            break;
          case "filter":
            this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
              if (result.removed == null) {
                result.removed = false;
              }
              this.emit(event.filter, this.formatter.filterLog(result));
            });
            break;
          case "tx": {
            const emitReceipt = (event2) => {
              const hash4 = event2.hash;
              this.getTransactionReceipt(hash4).then((receipt) => {
                if (!receipt) {
                  return;
                }
                this.emit(hash4, receipt);
              });
            };
            emitReceipt(event);
            this._subscribe("tx", ["newHeads"], (result) => {
              this._events.filter((e) => e.type === "tx").forEach(emitReceipt);
            });
            break;
          }
          case "debug":
          case "poll":
          case "willPoll":
          case "didPoll":
          case "error":
            break;
          default:
            console.log("unhandled:", event);
            break;
        }
      }
      _stopEvent(event) {
        let tag = event.tag;
        if (event.type === "tx") {
          if (this._events.filter((e) => e.type === "tx").length) {
            return;
          }
          tag = "tx";
        } else if (this.listenerCount(event.event)) {
          return;
        }
        const subId = this._subIds[tag];
        if (!subId) {
          return;
        }
        delete this._subIds[tag];
        subId.then((subId2) => {
          if (!this._subs[subId2]) {
            return;
          }
          delete this._subs[subId2];
          this.send("eth_unsubscribe", [subId2]);
        });
      }
      destroy() {
        return __awaiter12(this, void 0, void 0, function* () {
          if (this.websocket.readyState === WS.CONNECTING) {
            yield new Promise((resolve2) => {
              this.websocket.onopen = function() {
                resolve2(true);
              };
              this.websocket.onerror = function() {
                resolve2(false);
              };
            });
          }
          this.websocket.close(1e3);
        });
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
var __awaiter13, logger33, StaticJsonRpcProvider, UrlJsonRpcProvider;
var init_url_json_rpc_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version23();
    init_json_rpc_provider();
    __awaiter13 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger33 = new Logger(version23);
    StaticJsonRpcProvider = class extends JsonRpcProvider {
      detectNetwork() {
        const _super = Object.create(null, {
          detectNetwork: { get: () => super.detectNetwork }
        });
        return __awaiter13(this, void 0, void 0, function* () {
          let network = this.network;
          if (network == null) {
            network = yield _super.detectNetwork.call(this);
            if (!network) {
              logger33.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
            }
            if (this._network == null) {
              defineReadOnly(this, "_network", network);
              this.emit("network", network, null);
            }
          }
          return network;
        });
      }
    };
    UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
      constructor(network, apiKey) {
        logger33.checkAbstract(new.target, UrlJsonRpcProvider);
        network = getStatic(new.target, "getNetwork")(network);
        apiKey = getStatic(new.target, "getApiKey")(apiKey);
        const connection = getStatic(new.target, "getUrl")(network, apiKey);
        super(connection, network);
        if (typeof apiKey === "string") {
          defineReadOnly(this, "apiKey", apiKey);
        } else if (apiKey != null) {
          Object.keys(apiKey).forEach((key2) => {
            defineReadOnly(this, key2, apiKey[key2]);
          });
        }
      }
      _startPending() {
        logger33.warn("WARNING: API provider does not support pending filters");
      }
      isCommunityResource() {
        return false;
      }
      getSigner(address) {
        return logger33.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
      }
      listAccounts() {
        return Promise.resolve([]);
      }
      static getApiKey(apiKey) {
        return apiKey;
      }
      static getUrl(network, apiKey) {
        return logger33.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
          operation: "getUrl"
        });
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger34, defaultApiKey, AlchemyWebSocketProvider, AlchemyProvider;
var init_alchemy_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js"() {
    "use strict";
    init_lib4();
    init_formatter();
    init_websocket_provider();
    init_lib();
    init_version23();
    init_url_json_rpc_provider();
    logger34 = new Logger(version23);
    defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
    AlchemyWebSocketProvider = class extends WebSocketProvider {
      constructor(network, apiKey) {
        const provider = new AlchemyProvider(network, apiKey);
        const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
        super(url, provider.network);
        defineReadOnly(this, "apiKey", provider.apiKey);
      }
      isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
    };
    AlchemyProvider = class extends UrlJsonRpcProvider {
      static getWebSocketProvider(network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
      }
      static getApiKey(apiKey) {
        if (apiKey == null) {
          return defaultApiKey;
        }
        if (apiKey && typeof apiKey !== "string") {
          logger34.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
          case "homestead":
            host = "eth-mainnet.alchemyapi.io/v2/";
            break;
          case "goerli":
            host = "eth-goerli.g.alchemy.com/v2/";
            break;
          case "matic":
            host = "polygon-mainnet.g.alchemy.com/v2/";
            break;
          case "maticmum":
            host = "polygon-mumbai.g.alchemy.com/v2/";
            break;
          case "arbitrum":
            host = "arb-mainnet.g.alchemy.com/v2/";
            break;
          case "arbitrum-goerli":
            host = "arb-goerli.g.alchemy.com/v2/";
            break;
          case "optimism":
            host = "opt-mainnet.g.alchemy.com/v2/";
            break;
          case "optimism-goerli":
            host = "opt-goerli.g.alchemy.com/v2/";
            break;
          default:
            logger34.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
          allowGzip: true,
          url: "https://" + host + apiKey,
          throttleCallback: (attempt, url) => {
            if (apiKey === defaultApiKey) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
      }
      isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
function getHost(name) {
  switch (name) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger35.throwArgumentError("unsupported network", "name", name);
}
var logger35, defaultApiKey2, AnkrProvider;
var init_ankr_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/ankr-provider.js"() {
    init_formatter();
    init_url_json_rpc_provider();
    init_lib();
    init_version23();
    logger35 = new Logger(version23);
    defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
    AnkrProvider = class extends UrlJsonRpcProvider {
      isCommunityResource() {
        return this.apiKey === defaultApiKey2;
      }
      static getApiKey(apiKey) {
        if (apiKey == null) {
          return defaultApiKey2;
        }
        return apiKey;
      }
      static getUrl(network, apiKey) {
        if (apiKey == null) {
          apiKey = defaultApiKey2;
        }
        const connection = {
          allowGzip: true,
          url: "https://" + getHost(network.name) + apiKey,
          throttleCallback: (attempt, url) => {
            if (apiKey.apiKey === defaultApiKey2) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
        if (apiKey.projectSecret != null) {
          connection.user = "";
          connection.password = apiKey.projectSecret;
        }
        return connection;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
var __awaiter14, logger36, CloudflareProvider;
var init_cloudflare_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js"() {
    "use strict";
    init_url_json_rpc_provider();
    init_lib();
    init_version23();
    __awaiter14 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger36 = new Logger(version23);
    CloudflareProvider = class extends UrlJsonRpcProvider {
      static getApiKey(apiKey) {
        if (apiKey != null) {
          logger36.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        }
        return null;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
          case "homestead":
            host = "https://cloudflare-eth.com/";
            break;
          default:
            logger36.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
      }
      perform(method, params) {
        const _super = Object.create(null, {
          perform: { get: () => super.perform }
        });
        return __awaiter14(this, void 0, void 0, function* () {
          if (method === "getBlockNumber") {
            const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
            return block.number;
          }
          return _super.perform.call(this, method, params);
        });
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
function getTransactionPostData(transaction) {
  const result = {};
  for (let key2 in transaction) {
    if (transaction[key2] == null) {
      continue;
    }
    let value = transaction[key2];
    if (key2 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
      value = hexValue(hexlify(value));
    } else if (key2 === "accessList") {
      value = "[" + accessListify(value).map((set2) => {
        return `{address:"${set2.address}",storageKeys:["${set2.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key2] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e = error.error;
    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      let data2 = e.data;
      if (data2) {
        data2 = "0x" + data2.replace(/^.*0x/i, "");
      }
      if (isHexString(data2)) {
        return data2;
      }
      logger37.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger37.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger37.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger37.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger37.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var __awaiter15, logger37, EtherscanProvider;
var init_etherscan_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js"() {
    "use strict";
    init_lib2();
    init_lib4();
    init_lib17();
    init_lib28();
    init_formatter();
    init_lib();
    init_version23();
    init_base_provider();
    __awaiter15 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger37 = new Logger(version23);
    EtherscanProvider = class extends BaseProvider {
      constructor(network, apiKey) {
        super(network);
        defineReadOnly(this, "baseUrl", this.getBaseUrl());
        defineReadOnly(this, "apiKey", apiKey || null);
      }
      getBaseUrl() {
        switch (this.network ? this.network.name : "invalid") {
          case "homestead":
            return "https://api.etherscan.io";
          case "goerli":
            return "https://api-goerli.etherscan.io";
          case "sepolia":
            return "https://api-sepolia.etherscan.io";
          case "matic":
            return "https://api.polygonscan.com";
          case "maticmum":
            return "https://api-testnet.polygonscan.com";
          case "arbitrum":
            return "https://api.arbiscan.io";
          case "arbitrum-goerli":
            return "https://api-goerli.arbiscan.io";
          case "optimism":
            return "https://api-optimistic.etherscan.io";
          case "optimism-goerli":
            return "https://api-goerli-optimistic.etherscan.io";
          default:
        }
        return logger37.throwArgumentError("unsupported network", "network", this.network.name);
      }
      getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key2) => {
          const value = params[key2];
          if (value != null) {
            accum += `&${key2}=${value}`;
          }
          return accum;
        }, "");
        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
      }
      getPostUrl() {
        return `${this.baseUrl}/api`;
      }
      getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
      }
      fetch(module, params, post) {
        return __awaiter15(this, void 0, void 0, function* () {
          const url = post ? this.getPostUrl() : this.getUrl(module, params);
          const payload = post ? this.getPostData(module, params) : null;
          const procFunc = module === "proxy" ? getJsonResult : getResult2;
          this.emit("debug", {
            action: "request",
            request: url,
            provider: this
          });
          const connection = {
            url,
            throttleSlotInterval: 1e3,
            throttleCallback: (attempt, url2) => {
              if (this.isCommunityResource()) {
                showThrottleMessage();
              }
              return Promise.resolve(true);
            }
          };
          let payloadStr = null;
          if (payload) {
            connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
            payloadStr = Object.keys(payload).map((key2) => {
              return `${key2}=${payload[key2]}`;
            }).join("&");
          }
          const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
          this.emit("debug", {
            action: "response",
            request: url,
            response: deepCopy(result),
            provider: this
          });
          return result;
        });
      }
      detectNetwork() {
        return __awaiter15(this, void 0, void 0, function* () {
          return this.network;
        });
      }
      perform(method, params) {
        const _super = Object.create(null, {
          perform: { get: () => super.perform }
        });
        return __awaiter15(this, void 0, void 0, function* () {
          switch (method) {
            case "getBlockNumber":
              return this.fetch("proxy", { action: "eth_blockNumber" });
            case "getGasPrice":
              return this.fetch("proxy", { action: "eth_gasPrice" });
            case "getBalance":
              return this.fetch("account", {
                action: "balance",
                address: params.address,
                tag: params.blockTag
              });
            case "getTransactionCount":
              return this.fetch("proxy", {
                action: "eth_getTransactionCount",
                address: params.address,
                tag: params.blockTag
              });
            case "getCode":
              return this.fetch("proxy", {
                action: "eth_getCode",
                address: params.address,
                tag: params.blockTag
              });
            case "getStorageAt":
              return this.fetch("proxy", {
                action: "eth_getStorageAt",
                address: params.address,
                position: params.position,
                tag: params.blockTag
              });
            case "sendTransaction":
              return this.fetch("proxy", {
                action: "eth_sendRawTransaction",
                hex: params.signedTransaction
              }, true).catch((error) => {
                return checkError2("sendTransaction", error, params.signedTransaction);
              });
            case "getBlock":
              if (params.blockTag) {
                return this.fetch("proxy", {
                  action: "eth_getBlockByNumber",
                  tag: params.blockTag,
                  boolean: params.includeTransactions ? "true" : "false"
                });
              }
              throw new Error("getBlock by blockHash not implemented");
            case "getTransaction":
              return this.fetch("proxy", {
                action: "eth_getTransactionByHash",
                txhash: params.transactionHash
              });
            case "getTransactionReceipt":
              return this.fetch("proxy", {
                action: "eth_getTransactionReceipt",
                txhash: params.transactionHash
              });
            case "call": {
              if (params.blockTag !== "latest") {
                throw new Error("EtherscanProvider does not support blockTag for call");
              }
              const postData = getTransactionPostData(params.transaction);
              postData.module = "proxy";
              postData.action = "eth_call";
              try {
                return yield this.fetch("proxy", postData, true);
              } catch (error) {
                return checkError2("call", error, params.transaction);
              }
            }
            case "estimateGas": {
              const postData = getTransactionPostData(params.transaction);
              postData.module = "proxy";
              postData.action = "eth_estimateGas";
              try {
                return yield this.fetch("proxy", postData, true);
              } catch (error) {
                return checkError2("estimateGas", error, params.transaction);
              }
            }
            case "getLogs": {
              const args = { action: "getLogs" };
              if (params.filter.fromBlock) {
                args.fromBlock = checkLogTag(params.filter.fromBlock);
              }
              if (params.filter.toBlock) {
                args.toBlock = checkLogTag(params.filter.toBlock);
              }
              if (params.filter.address) {
                args.address = params.filter.address;
              }
              if (params.filter.topics && params.filter.topics.length > 0) {
                if (params.filter.topics.length > 1) {
                  logger37.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                }
                if (params.filter.topics.length === 1) {
                  const topic0 = params.filter.topics[0];
                  if (typeof topic0 !== "string" || topic0.length !== 66) {
                    logger37.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
                  }
                  args.topic0 = topic0;
                }
              }
              const logs = yield this.fetch("logs", args);
              let blocks = {};
              for (let i = 0; i < logs.length; i++) {
                const log = logs[i];
                if (log.blockHash != null) {
                  continue;
                }
                if (blocks[log.blockNumber] == null) {
                  const block = yield this.getBlock(log.blockNumber);
                  if (block) {
                    blocks[log.blockNumber] = block.hash;
                  }
                }
                log.blockHash = blocks[log.blockNumber];
              }
              return logs;
            }
            case "getEtherPrice":
              if (this.network.name !== "homestead") {
                return 0;
              }
              return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
            default:
              break;
          }
          return _super.perform.call(this, method, params);
        });
      }
      getHistory(addressOrName, startBlock, endBlock) {
        return __awaiter15(this, void 0, void 0, function* () {
          const params = {
            action: "txlist",
            address: yield this.resolveName(addressOrName),
            startblock: startBlock == null ? 0 : startBlock,
            endblock: endBlock == null ? 99999999 : endBlock,
            sort: "asc"
          };
          const result = yield this.fetch("account", params);
          return result.map((tx) => {
            ["contractAddress", "to"].forEach(function(key2) {
              if (tx[key2] == "") {
                delete tx[key2];
              }
            });
            if (tx.creates == null && tx.contractAddress != null) {
              tx.creates = tx.contractAddress;
            }
            const item = this.formatter.transactionResponse(tx);
            if (tx.timeStamp) {
              item.timestamp = parseInt(tx.timeStamp);
            }
            return item;
          });
        });
      }
      isCommunityResource() {
        return this.apiKey == null;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
function now() {
  return new Date().getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i = 0; i < networks2.length; i++) {
    const network = networks2[i];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger38.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values2, maxDelta) {
  values2 = values2.slice().sort();
  const middle = Math.floor(values2.length / 2);
  if (values2.length % 2) {
    return values2[middle];
  }
  const a = values2[middle - 1], b2 = values2[middle];
  if (maxDelta != null && Math.abs(a - b2) > maxDelta) {
    return null;
  }
  return (a + b2) / 2;
}
function serialize2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i) => serialize2(i)));
  } else if (typeof value === "object") {
    const keys3 = Object.keys(value);
    keys3.sort();
    return "{" + keys3.map((key2) => {
      let v = value[key2];
      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize2(v);
      }
      return JSON.stringify(key2) + ":" + v;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
function stall2(duration) {
  let cancel = null;
  let timer2 = null;
  let promise2 = new Promise((resolve2) => {
    cancel = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
      }
      resolve2();
    };
    timer2 = setTimeout(cancel, duration);
  });
  const wait2 = (func) => {
    promise2 = promise2.then(func);
    return promise2;
  };
  function getPromise() {
    return promise2;
  }
  return { cancel, getPromise, wait: wait2 };
}
function exposeDebugConfig(config, now2) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", { get: () => config.provider });
  if (config.start) {
    result.start = config.start;
  }
  if (now2) {
    result.duration = now2 - config.start;
  }
  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize3, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c) => {
      const value = normalize3(c.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c.result };
      }
      tally[value].count++;
    });
    const keys3 = Object.keys(tally);
    for (let i = 0; i < keys3.length; i++) {
      const check2 = tally[keys3[i]];
      if (check2.count >= quorum) {
        return check2.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize3 = serialize2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values2 = configs.map((c) => c.result);
        let blockNumber = median(configs.map((c) => c.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values2.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values2 = configs.map((c) => c.result);
        values2.sort();
        return values2[Math.floor(values2.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c) => c.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize3 = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize3 = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        };
      } else {
        normalize3 = function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize3, provider.quorum);
}
function waitForSync(config, blockNumber) {
  return __awaiter16(this, void 0, void 0, function* () {
    const provider = config.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve2, reject2) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve2(provider);
          }
          if (config.cancelled) {
            return resolve2(null);
          }
          return resolve2(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter16(this, void 0, void 0, function* () {
    let provider = config.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter = params.filter;
        if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }
        return provider.getLogs(filter);
      }
    }
    return logger38.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var __awaiter16, logger38, nextRid, ForwardErrors, ForwardProperties, FallbackProvider;
var init_fallback_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/fallback-provider.js"() {
    "use strict";
    init_lib14();
    init_lib3();
    init_lib2();
    init_lib4();
    init_lib24();
    init_lib28();
    init_base_provider();
    init_formatter();
    init_lib();
    init_version23();
    __awaiter16 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    logger38 = new Logger(version23);
    nextRid = 1;
    ForwardErrors = [
      Logger.errors.CALL_EXCEPTION,
      Logger.errors.INSUFFICIENT_FUNDS,
      Logger.errors.NONCE_EXPIRED,
      Logger.errors.REPLACEMENT_UNDERPRICED,
      Logger.errors.UNPREDICTABLE_GAS_LIMIT
    ];
    ForwardProperties = [
      "address",
      "args",
      "errorArgs",
      "errorSignature",
      "method",
      "transaction"
    ];
    FallbackProvider = class extends BaseProvider {
      constructor(providers, quorum) {
        if (providers.length === 0) {
          logger38.throwArgumentError("missing providers", "providers", providers);
        }
        const providerConfigs = providers.map((configOrProvider, index) => {
          if (Provider.isProvider(configOrProvider)) {
            const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
            const priority = 1;
            return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
          }
          const config = shallowCopy(configOrProvider);
          if (config.priority == null) {
            config.priority = 1;
          }
          if (config.stallTimeout == null) {
            config.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
          }
          if (config.weight == null) {
            config.weight = 1;
          }
          const weight = config.weight;
          if (weight % 1 || weight > 512 || weight < 1) {
            logger38.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
          }
          return Object.freeze(config);
        });
        const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);
        if (quorum == null) {
          quorum = total / 2;
        } else if (quorum > total) {
          logger38.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        }
        let networkOrReady = checkNetworks(providerConfigs.map((c) => c.provider.network));
        if (networkOrReady == null) {
          networkOrReady = new Promise((resolve2, reject2) => {
            setTimeout(() => {
              this.detectNetwork().then(resolve2, reject2);
            }, 0);
          });
        }
        super(networkOrReady);
        defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
        defineReadOnly(this, "quorum", quorum);
        this._highestBlockNumber = -1;
      }
      detectNetwork() {
        return __awaiter16(this, void 0, void 0, function* () {
          const networks2 = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));
          return checkNetworks(networks2);
        });
      }
      perform(method, params) {
        return __awaiter16(this, void 0, void 0, function* () {
          if (method === "sendTransaction") {
            const results = yield Promise.all(this.providerConfigs.map((c) => {
              return c.provider.sendTransaction(params.signedTransaction).then((result) => {
                return result.hash;
              }, (error) => {
                return error;
              });
            }));
            for (let i2 = 0; i2 < results.length; i2++) {
              const result = results[i2];
              if (typeof result === "string") {
                return result;
              }
            }
            throw results[0];
          }
          if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
            yield this.getBlockNumber();
          }
          const processFunc = getProcessFunc(this, method, params);
          const configs = shuffled(this.providerConfigs.map(shallowCopy));
          configs.sort((a, b2) => a.priority - b2.priority);
          const currentBlockNumber = this._highestBlockNumber;
          let i = 0;
          let first = true;
          while (true) {
            const t0 = now();
            let inflightWeight = configs.filter((c) => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0);
            while (inflightWeight < this.quorum && i < configs.length) {
              const config = configs[i++];
              const rid = nextRid++;
              config.start = now();
              config.staller = stall2(config.stallTimeout);
              config.staller.wait(() => {
                config.staller = null;
              });
              config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
                config.done = true;
                config.result = result;
                if (this.listenerCount("debug")) {
                  this.emit("debug", {
                    action: "request",
                    rid,
                    backend: exposeDebugConfig(config, now()),
                    request: { method, params: deepCopy(params) },
                    provider: this
                  });
                }
              }, (error) => {
                config.done = true;
                config.error = error;
                if (this.listenerCount("debug")) {
                  this.emit("debug", {
                    action: "request",
                    rid,
                    backend: exposeDebugConfig(config, now()),
                    request: { method, params: deepCopy(params) },
                    provider: this
                  });
                }
              });
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config, null),
                  request: { method, params: deepCopy(params) },
                  provider: this
                });
              }
              inflightWeight += config.weight;
            }
            const waiting = [];
            configs.forEach((c) => {
              if (c.done || !c.runner) {
                return;
              }
              waiting.push(c.runner);
              if (c.staller) {
                waiting.push(c.staller.getPromise());
              }
            });
            if (waiting.length) {
              yield Promise.race(waiting);
            }
            const results = configs.filter((c) => c.done && c.error == null);
            if (results.length >= this.quorum) {
              const result = processFunc(results);
              if (result !== void 0) {
                configs.forEach((c) => {
                  if (c.staller) {
                    c.staller.cancel();
                  }
                  c.cancelled = true;
                });
                return result;
              }
              if (!first) {
                yield stall2(100).getPromise();
              }
              first = false;
            }
            const errors = configs.reduce((accum, c) => {
              if (!c.done || c.error == null) {
                return accum;
              }
              const code = c.error.code;
              if (ForwardErrors.indexOf(code) >= 0) {
                if (!accum[code]) {
                  accum[code] = { error: c.error, weight: 0 };
                }
                accum[code].weight += c.weight;
              }
              return accum;
            }, {});
            Object.keys(errors).forEach((errorCode) => {
              const tally = errors[errorCode];
              if (tally.weight < this.quorum) {
                return;
              }
              configs.forEach((c) => {
                if (c.staller) {
                  c.staller.cancel();
                }
                c.cancelled = true;
              });
              const e = tally.error;
              const props = {};
              ForwardProperties.forEach((name) => {
                if (e[name] == null) {
                  return;
                }
                props[name] = e[name];
              });
              logger38.throwError(e.reason || e.message, errorCode, props);
            });
            if (configs.filter((c) => !c.done).length === 0) {
              break;
            }
          }
          configs.forEach((c) => {
            if (c.staller) {
              c.staller.cancel();
            }
            c.cancelled = true;
          });
          return logger38.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
            method,
            params,
            results: configs.map((c) => exposeDebugConfig(c)),
            provider: this
          });
        });
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
var IpcProvider;
var init_ipc_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/ipc-provider.js"() {
    "use strict";
    IpcProvider = null;
  }
});

// node_modules/@ethersproject/providers/lib.esm/infura-provider.js
var logger39, defaultProjectId, InfuraWebSocketProvider, InfuraProvider;
var init_infura_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/infura-provider.js"() {
    "use strict";
    init_lib4();
    init_websocket_provider();
    init_formatter();
    init_lib();
    init_version23();
    init_url_json_rpc_provider();
    logger39 = new Logger(version23);
    defaultProjectId = "84842078b09946638c03157f83405213";
    InfuraWebSocketProvider = class extends WebSocketProvider {
      constructor(network, apiKey) {
        const provider = new InfuraProvider(network, apiKey);
        const connection = provider.connection;
        if (connection.password) {
          logger39.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "InfuraProvider.getWebSocketProvider()"
          });
        }
        const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, network);
        defineReadOnly(this, "apiKey", provider.projectId);
        defineReadOnly(this, "projectId", provider.projectId);
        defineReadOnly(this, "projectSecret", provider.projectSecret);
      }
      isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
    };
    InfuraProvider = class extends UrlJsonRpcProvider {
      static getWebSocketProvider(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
      }
      static getApiKey(apiKey) {
        const apiKeyObj = {
          apiKey: defaultProjectId,
          projectId: defaultProjectId,
          projectSecret: null
        };
        if (apiKey == null) {
          return apiKeyObj;
        }
        if (typeof apiKey === "string") {
          apiKeyObj.projectId = apiKey;
        } else if (apiKey.projectSecret != null) {
          logger39.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
          logger39.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
          apiKeyObj.projectId = apiKey.projectId;
          apiKeyObj.projectSecret = apiKey.projectSecret;
        } else if (apiKey.projectId) {
          apiKeyObj.projectId = apiKey.projectId;
        }
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
          case "homestead":
            host = "mainnet.infura.io";
            break;
          case "goerli":
            host = "goerli.infura.io";
            break;
          case "sepolia":
            host = "sepolia.infura.io";
            break;
          case "matic":
            host = "polygon-mainnet.infura.io";
            break;
          case "maticmum":
            host = "polygon-mumbai.infura.io";
            break;
          case "optimism":
            host = "optimism-mainnet.infura.io";
            break;
          case "optimism-goerli":
            host = "optimism-goerli.infura.io";
            break;
          case "arbitrum":
            host = "arbitrum-mainnet.infura.io";
            break;
          case "arbitrum-goerli":
            host = "arbitrum-goerli.infura.io";
            break;
          default:
            logger39.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        const connection = {
          allowGzip: true,
          url: "https://" + host + "/v3/" + apiKey.projectId,
          throttleCallback: (attempt, url) => {
            if (apiKey.projectId === defaultProjectId) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
        if (apiKey.projectSecret != null) {
          connection.user = "";
          connection.password = apiKey.projectSecret;
        }
        return connection;
      }
      isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
var JsonRpcBatchProvider;
var init_json_rpc_batch_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js"() {
    init_lib4();
    init_lib28();
    init_json_rpc_provider();
    JsonRpcBatchProvider = class extends JsonRpcProvider {
      send(method, params) {
        const request = {
          method,
          params,
          id: this._nextId++,
          jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) {
          this._pendingBatch = [];
        }
        const inflightRequest = { request, resolve: null, reject: null };
        const promise2 = new Promise((resolve2, reject2) => {
          inflightRequest.resolve = resolve2;
          inflightRequest.reject = reject2;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) {
          this._pendingBatchAggregator = setTimeout(() => {
            const batch = this._pendingBatch;
            this._pendingBatch = null;
            this._pendingBatchAggregator = null;
            const request2 = batch.map((inflight) => inflight.request);
            this.emit("debug", {
              action: "requestBatch",
              request: deepCopy(request2),
              provider: this
            });
            return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
              this.emit("debug", {
                action: "response",
                request: request2,
                response: result,
                provider: this
              });
              batch.forEach((inflightRequest2, index) => {
                const payload = result[index];
                if (payload.error) {
                  const error = new Error(payload.error.message);
                  error.code = payload.error.code;
                  error.data = payload.error.data;
                  inflightRequest2.reject(error);
                } else {
                  inflightRequest2.resolve(payload.result);
                }
              });
            }, (error) => {
              this.emit("debug", {
                action: "response",
                error,
                request: request2,
                provider: this
              });
              batch.forEach((inflightRequest2) => {
                inflightRequest2.reject(error);
              });
            });
          }, 10);
        }
        return promise2;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
var logger40, defaultApiKey3, NodesmithProvider;
var init_nodesmith_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js"() {
    "use strict";
    init_url_json_rpc_provider();
    init_lib();
    init_version23();
    logger40 = new Logger(version23);
    defaultApiKey3 = "ETHERS_JS_SHARED";
    NodesmithProvider = class extends UrlJsonRpcProvider {
      static getApiKey(apiKey) {
        if (apiKey && typeof apiKey !== "string") {
          logger40.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey || defaultApiKey3;
      }
      static getUrl(network, apiKey) {
        logger40.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        let host = null;
        switch (network.name) {
          case "homestead":
            host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
            break;
          case "ropsten":
            host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
            break;
          case "rinkeby":
            host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
            break;
          case "goerli":
            host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
            break;
          case "kovan":
            host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
            break;
          default:
            logger40.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host + "?apiKey=" + apiKey;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
var logger41, defaultApplicationId, PocketProvider;
var init_pocket_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/pocket-provider.js"() {
    "use strict";
    init_lib();
    init_version23();
    init_url_json_rpc_provider();
    logger41 = new Logger(version23);
    defaultApplicationId = "62e1ad51b37b8e00394bda3b";
    PocketProvider = class extends UrlJsonRpcProvider {
      static getApiKey(apiKey) {
        const apiKeyObj = {
          applicationId: null,
          loadBalancer: true,
          applicationSecretKey: null
        };
        if (apiKey == null) {
          apiKeyObj.applicationId = defaultApplicationId;
        } else if (typeof apiKey === "string") {
          apiKeyObj.applicationId = apiKey;
        } else if (apiKey.applicationSecretKey != null) {
          apiKeyObj.applicationId = apiKey.applicationId;
          apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
        } else if (apiKey.applicationId) {
          apiKeyObj.applicationId = apiKey.applicationId;
        } else {
          logger41.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        }
        return apiKeyObj;
      }
      static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
          case "goerli":
            host = "eth-goerli.gateway.pokt.network";
            break;
          case "homestead":
            host = "eth-mainnet.gateway.pokt.network";
            break;
          case "kovan":
            host = "poa-kovan.gateway.pokt.network";
            break;
          case "matic":
            host = "poly-mainnet.gateway.pokt.network";
            break;
          case "maticmum":
            host = "polygon-mumbai-rpc.gateway.pokt.network";
            break;
          case "rinkeby":
            host = "eth-rinkeby.gateway.pokt.network";
            break;
          case "ropsten":
            host = "eth-ropsten.gateway.pokt.network";
            break;
          default:
            logger41.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
              argument: "network",
              value: network
            });
        }
        const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
        const connection = { headers: {}, url };
        if (apiKey.applicationSecretKey != null) {
          connection.user = "";
          connection.password = apiKey.applicationSecretKey;
        }
        return connection;
      }
      isCommunityResource() {
        return this.applicationId === defaultApplicationId;
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/web3-provider.js
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve2, reject2) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject2(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject2(error2);
        }
        resolve2(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var logger42, _nextId, Web3Provider;
var init_web3_provider = __esm({
  "node_modules/@ethersproject/providers/lib.esm/web3-provider.js"() {
    "use strict";
    init_lib4();
    init_lib();
    init_version23();
    init_json_rpc_provider();
    logger42 = new Logger(version23);
    _nextId = 1;
    Web3Provider = class extends JsonRpcProvider {
      constructor(provider, network) {
        if (provider == null) {
          logger42.throwArgumentError("missing provider", "provider", provider);
        }
        let path = null;
        let jsonRpcFetchFunc = null;
        let subprovider = null;
        if (typeof provider === "function") {
          path = "unknown:";
          jsonRpcFetchFunc = provider;
        } else {
          path = provider.host || provider.path || "";
          if (!path && provider.isMetaMask) {
            path = "metamask";
          }
          subprovider = provider;
          if (provider.request) {
            if (path === "") {
              path = "eip-1193:";
            }
            jsonRpcFetchFunc = buildEip1193Fetcher(provider);
          } else if (provider.sendAsync) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
          } else if (provider.send) {
            jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
          } else {
            logger42.throwArgumentError("unsupported provider", "provider", provider);
          }
          if (!path) {
            path = "unknown:";
          }
        }
        super(path, network);
        defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        defineReadOnly(this, "provider", subprovider);
      }
      send(method, params) {
        return this.jsonRpcFetchFunc(method, params);
      }
    };
  }
});

// node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports21 = {};
__export(lib_exports21, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  AnkrProvider: () => AnkrProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match2 = network.match(/^(ws|http)s?:/i);
    if (match2) {
      switch (match2[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger43.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n2 = getNetwork(network);
  if (!n2 || !n2._defaultProvider) {
    logger43.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n2._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}
var logger43;
var init_lib29 = __esm({
  "node_modules/@ethersproject/providers/lib.esm/index.js"() {
    "use strict";
    init_lib14();
    init_lib27();
    init_base_provider();
    init_alchemy_provider();
    init_ankr_provider();
    init_cloudflare_provider();
    init_etherscan_provider();
    init_fallback_provider();
    init_ipc_provider();
    init_infura_provider();
    init_json_rpc_provider();
    init_json_rpc_batch_provider();
    init_nodesmith_provider();
    init_pocket_provider();
    init_url_json_rpc_provider();
    init_web3_provider();
    init_websocket_provider();
    init_formatter();
    init_lib();
    init_version23();
    logger43 = new Logger(version23);
  }
});

// node_modules/@ethersproject/solidity/lib.esm/_version.js
var version24;
var init_version24 = __esm({
  "node_modules/@ethersproject/solidity/lib.esm/_version.js"() {
    version24 = "solidity/5.7.0";
  }
});

// node_modules/@ethersproject/solidity/lib.esm/index.js
var lib_exports22 = {};
__export(lib_exports22, {
  keccak256: () => keccak2562,
  pack: () => pack2,
  sha256: () => sha2562
});
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match2 = type.match(regexNumber);
  if (match2) {
    let size = parseInt(match2[2] || "256");
    if (match2[2] && String(size) !== match2[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger44.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray) {
      size = 256;
    }
    value = BigNumber.from(value).toTwos(size);
    return zeroPad(value, size / 8);
  }
  match2 = type.match(regexBytes);
  if (match2) {
    const size = parseInt(match2[1]);
    if (String(size) !== match2[1] || size === 0 || size > 32) {
      logger44.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value).byteLength !== size) {
      logger44.throwArgumentError(`invalid value for ${type}`, "value", value);
    }
    if (isArray) {
      return arrayify((value + Zeros2).substring(0, 66));
    }
    return value;
  }
  match2 = type.match(regexArray);
  if (match2 && Array.isArray(value)) {
    const baseType = match2[1];
    const count = parseInt(match2[2] || String(value.length));
    if (count != value.length) {
      logger44.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat(result);
  }
  return logger44.throwArgumentError("invalid type", "type", type);
}
function pack2(types, values2) {
  if (types.length != values2.length) {
    logger44.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values2);
  }
  const tight = [];
  types.forEach(function(type, index) {
    tight.push(_pack(type, values2[index]));
  });
  return hexlify(concat(tight));
}
function keccak2562(types, values2) {
  return keccak256(pack2(types, values2));
}
function sha2562(types, values2) {
  return sha256(pack2(types, values2));
}
var regexBytes, regexNumber, regexArray, Zeros2, logger44;
var init_lib30 = __esm({
  "node_modules/@ethersproject/solidity/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib2();
    init_lib5();
    init_lib20();
    init_lib9();
    init_lib();
    init_version24();
    regexBytes = new RegExp("^bytes([0-9]+)$");
    regexNumber = new RegExp("^(u?int)([0-9]*)$");
    regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
    logger44 = new Logger(version24);
  }
});

// node_modules/@ethersproject/units/lib.esm/_version.js
var version25;
var init_version25 = __esm({
  "node_modules/@ethersproject/units/lib.esm/_version.js"() {
    version25 = "units/5.7.0";
  }
});

// node_modules/@ethersproject/units/lib.esm/index.js
var lib_exports23 = {};
__export(lib_exports23, {
  commify: () => commify,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  parseEther: () => parseEther,
  parseUnits: () => parseUnits
});
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger45.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger45.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var logger45, names;
var init_lib31 = __esm({
  "node_modules/@ethersproject/units/lib.esm/index.js"() {
    "use strict";
    init_lib3();
    init_lib();
    init_version25();
    logger45 = new Logger(version25);
    names = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
  }
});

// node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports5,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports9,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha256,
  sha512: () => sha512,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack2,
  soliditySha256: () => sha2562,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});
var init_utils2 = __esm({
  "node_modules/ethers/lib.esm/utils.js"() {
    "use strict";
    init_lib13();
    init_lib7();
    init_lib10();
    init_lib19();
    init_lib2();
    init_lib12();
    init_lib23();
    init_lib25();
    init_lib5();
    init_lib();
    init_lib20();
    init_lib30();
    init_lib24();
    init_lib4();
    init_lib6();
    init_lib16();
    init_lib9();
    init_lib17();
    init_lib31();
    init_lib26();
    init_lib28();
    init_lib20();
    init_lib9();
  }
});

// node_modules/ethers/lib.esm/_version.js
var version26;
var init_version26 = __esm({
  "node_modules/ethers/lib.esm/_version.js"() {
    version26 = "ethers/5.7.2";
  }
});

// node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports7,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger46,
  providers: () => lib_exports21,
  utils: () => utils_exports,
  version: () => version26,
  wordlists: () => wordlists
});
var logger46;
var init_ethers = __esm({
  "node_modules/ethers/lib.esm/ethers.js"() {
    "use strict";
    init_lib18();
    init_lib3();
    init_lib15();
    init_lib26();
    init_lib8();
    init_lib29();
    init_lib29();
    init_lib22();
    init_utils2();
    init_lib();
    init_version26();
    logger46 = new Logger(version26);
  }
});

// node_modules/ethers/lib.esm/index.js
var lib_exports24 = {};
__export(lib_exports24, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports7,
  errors: () => ErrorCode,
  ethers: () => ethers_exports,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger46,
  providers: () => lib_exports21,
  utils: () => utils_exports,
  version: () => version26,
  wordlists: () => wordlists
});
var init_lib32 = __esm({
  "node_modules/ethers/lib.esm/index.js"() {
    "use strict";
    init_ethers();
    init_ethers();
    try {
      const anyGlobal3 = window;
      if (anyGlobal3._ethers == null) {
        anyGlobal3._ethers = ethers_exports;
      }
    } catch (error) {
    }
  }
});

// node_modules/@gnosis.pm/safe-contracts/dist/utils/proxies.js
var require_proxies = __commonJS({
  "node_modules/@gnosis.pm/safe-contracts/dist/utils/proxies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateProxyAddressWithCallback = exports.calculateProxyAddress = void 0;
    var ethers_1 = (init_lib32(), __toCommonJS(lib_exports24));
    var calculateProxyAddress = async (factory, singleton, inititalizer, nonce) => {
      const deploymentCode = ethers_1.ethers.utils.solidityPack(["bytes", "uint256"], [await factory.proxyCreationCode(), singleton]);
      const salt = ethers_1.ethers.utils.solidityKeccak256(["bytes32", "uint256"], [ethers_1.ethers.utils.solidityKeccak256(["bytes"], [inititalizer]), nonce]);
      return ethers_1.ethers.utils.getCreate2Address(factory.address, salt, ethers_1.ethers.utils.keccak256(deploymentCode));
    };
    exports.calculateProxyAddress = calculateProxyAddress;
    var calculateProxyAddressWithCallback = async (factory, singleton, inititalizer, nonce, callback) => {
      const saltNonceWithCallback = ethers_1.ethers.utils.solidityKeccak256(["uint256", "address"], [nonce, callback]);
      return exports.calculateProxyAddress(factory, singleton, inititalizer, saltNonceWithCallback);
    };
    exports.calculateProxyAddressWithCallback = calculateProxyAddressWithCallback;
  }
});

// node_modules/@gnosis.pm/safe-contracts/dist/utils/constants.js
var require_constants = __commonJS({
  "node_modules/@gnosis.pm/safe-contracts/dist/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressOne = void 0;
    exports.AddressOne = "0x0000000000000000000000000000000000000001";
  }
});

// node_modules/@gnosis.pm/safe-contracts/dist/utils/execution.js
var require_execution = __commonJS({
  "node_modules/@gnosis.pm/safe-contracts/dist/utils/execution.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildSafeTransaction = exports.executeContractCallWithSigners = exports.executeTxWithSigners = exports.buildContractCall = exports.populateExecuteTx = exports.executeTx = exports.logGas = exports.buildSignatureBytes = exports.safeSignMessage = exports.signHash = exports.safeSignTypedData = exports.safeApproveHash = exports.calculateSafeMessageHash = exports.calculateSafeTransactionHash = exports.preimageSafeTransactionHash = exports.calculateSafeDomainSeparator = exports.EIP712_SAFE_MESSAGE_TYPE = exports.EIP712_SAFE_TX_TYPE = exports.EIP_DOMAIN = void 0;
    var ethers_1 = (init_lib32(), __toCommonJS(lib_exports24));
    var constants_1 = (init_lib8(), __toCommonJS(lib_exports7));
    exports.EIP_DOMAIN = {
      EIP712Domain: [
        { type: "uint256", name: "chainId" },
        { type: "address", name: "verifyingContract" }
      ]
    };
    exports.EIP712_SAFE_TX_TYPE = {
      SafeTx: [
        { type: "address", name: "to" },
        { type: "uint256", name: "value" },
        { type: "bytes", name: "data" },
        { type: "uint8", name: "operation" },
        { type: "uint256", name: "safeTxGas" },
        { type: "uint256", name: "baseGas" },
        { type: "uint256", name: "gasPrice" },
        { type: "address", name: "gasToken" },
        { type: "address", name: "refundReceiver" },
        { type: "uint256", name: "nonce" }
      ]
    };
    exports.EIP712_SAFE_MESSAGE_TYPE = {
      SafeMessage: [
        { type: "bytes", name: "message" }
      ]
    };
    var calculateSafeDomainSeparator = (safe, chainId) => {
      return ethers_1.utils._TypedDataEncoder.hashDomain({ verifyingContract: safe.address, chainId });
    };
    exports.calculateSafeDomainSeparator = calculateSafeDomainSeparator;
    var preimageSafeTransactionHash = (safe, safeTx, chainId) => {
      return ethers_1.utils._TypedDataEncoder.encode({ verifyingContract: safe.address, chainId }, exports.EIP712_SAFE_TX_TYPE, safeTx);
    };
    exports.preimageSafeTransactionHash = preimageSafeTransactionHash;
    var calculateSafeTransactionHash = (safe, safeTx, chainId) => {
      return ethers_1.utils._TypedDataEncoder.hash({ verifyingContract: safe.address, chainId }, exports.EIP712_SAFE_TX_TYPE, safeTx);
    };
    exports.calculateSafeTransactionHash = calculateSafeTransactionHash;
    var calculateSafeMessageHash = (safe, message, chainId) => {
      return ethers_1.utils._TypedDataEncoder.hash({ verifyingContract: safe.address, chainId }, exports.EIP712_SAFE_MESSAGE_TYPE, { message });
    };
    exports.calculateSafeMessageHash = calculateSafeMessageHash;
    var safeApproveHash = async (signer, safe, safeTx, skipOnChainApproval) => {
      if (!skipOnChainApproval) {
        if (!signer.provider)
          throw Error("Provider required for on-chain approval");
        const chainId = (await signer.provider.getNetwork()).chainId;
        const typedDataHash = ethers_1.utils.arrayify(exports.calculateSafeTransactionHash(safe, safeTx, chainId));
        const signerSafe = safe.connect(signer);
        await signerSafe.approveHash(typedDataHash);
      }
      const signerAddress = await signer.getAddress();
      return {
        signer: signerAddress,
        data: "0x000000000000000000000000" + signerAddress.slice(2) + "000000000000000000000000000000000000000000000000000000000000000001"
      };
    };
    exports.safeApproveHash = safeApproveHash;
    var safeSignTypedData = async (signer, safe, safeTx, chainId) => {
      if (!chainId && !signer.provider)
        throw Error("Provider required to retrieve chainId");
      const cid = chainId || (await signer.provider.getNetwork()).chainId;
      const signerAddress = await signer.getAddress();
      return {
        signer: signerAddress,
        data: await signer._signTypedData({ verifyingContract: safe.address, chainId: cid }, exports.EIP712_SAFE_TX_TYPE, safeTx)
      };
    };
    exports.safeSignTypedData = safeSignTypedData;
    var signHash = async (signer, hash4) => {
      const typedDataHash = ethers_1.utils.arrayify(hash4);
      const signerAddress = await signer.getAddress();
      return {
        signer: signerAddress,
        data: (await signer.signMessage(typedDataHash)).replace(/1b$/, "1f").replace(/1c$/, "20")
      };
    };
    exports.signHash = signHash;
    var safeSignMessage = async (signer, safe, safeTx, chainId) => {
      const cid = chainId || (await signer.provider.getNetwork()).chainId;
      return exports.signHash(signer, exports.calculateSafeTransactionHash(safe, safeTx, cid));
    };
    exports.safeSignMessage = safeSignMessage;
    var buildSignatureBytes = (signatures) => {
      signatures.sort((left, right) => left.signer.toLowerCase().localeCompare(right.signer.toLowerCase()));
      let signatureBytes = "0x";
      for (const sig of signatures) {
        signatureBytes += sig.data.slice(2);
      }
      return signatureBytes;
    };
    exports.buildSignatureBytes = buildSignatureBytes;
    var logGas = async (message, tx, skip) => {
      return tx.then(async (result) => {
        const receipt = await result.wait();
        if (!skip)
          console.log("           Used", receipt.gasUsed.toNumber(), `gas for >${message}<`);
        return result;
      });
    };
    exports.logGas = logGas;
    var executeTx2 = async (safe, safeTx, signatures, overrides) => {
      const signatureBytes = exports.buildSignatureBytes(signatures);
      return safe.execTransaction(safeTx.to, safeTx.value, safeTx.data, safeTx.operation, safeTx.safeTxGas, safeTx.baseGas, safeTx.gasPrice, safeTx.gasToken, safeTx.refundReceiver, signatureBytes, overrides || {});
    };
    exports.executeTx = executeTx2;
    var populateExecuteTx = async (safe, safeTx, signatures, overrides) => {
      const signatureBytes = exports.buildSignatureBytes(signatures);
      return safe.populateTransaction.execTransaction(safeTx.to, safeTx.value, safeTx.data, safeTx.operation, safeTx.safeTxGas, safeTx.baseGas, safeTx.gasPrice, safeTx.gasToken, safeTx.refundReceiver, signatureBytes, overrides || {});
    };
    exports.populateExecuteTx = populateExecuteTx;
    var buildContractCall = (contract, method, params, nonce, delegateCall, overrides) => {
      const data2 = contract.interface.encodeFunctionData(method, params);
      return exports.buildSafeTransaction(Object.assign({
        to: contract.address,
        data: data2,
        operation: delegateCall ? 1 : 0,
        nonce
      }, overrides));
    };
    exports.buildContractCall = buildContractCall;
    var executeTxWithSigners = async (safe, tx, signers, overrides) => {
      const sigs = await Promise.all(signers.map((signer) => exports.safeSignTypedData(signer, safe, tx)));
      return exports.executeTx(safe, tx, sigs, overrides);
    };
    exports.executeTxWithSigners = executeTxWithSigners;
    var executeContractCallWithSigners = async (safe, contract, method, params, signers, delegateCall, overrides) => {
      const tx = exports.buildContractCall(contract, method, params, await safe.nonce(), delegateCall, overrides);
      return exports.executeTxWithSigners(safe, tx, signers);
    };
    exports.executeContractCallWithSigners = executeContractCallWithSigners;
    var buildSafeTransaction = (template) => {
      return {
        to: template.to,
        value: template.value || 0,
        data: template.data || "0x",
        operation: template.operation || 0,
        safeTxGas: template.safeTxGas || 0,
        baseGas: template.baseGas || 0,
        gasPrice: template.gasPrice || 0,
        gasToken: template.gasToken || constants_1.AddressZero,
        refundReceiver: template.refundReceiver || constants_1.AddressZero,
        nonce: template.nonce
      };
    };
    exports.buildSafeTransaction = buildSafeTransaction;
  }
});

// node_modules/@gnosis.pm/safe-contracts/dist/utils/multisend.js
var require_multisend = __commonJS({
  "node_modules/@gnosis.pm/safe-contracts/dist/utils/multisend.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildMultiSendSafeTx = exports.encodeMultiSend = void 0;
    var ethers_1 = (init_lib32(), __toCommonJS(lib_exports24));
    var execution_1 = require_execution();
    var encodeMetaTransaction = (tx) => {
      const data2 = ethers_1.utils.arrayify(tx.data);
      const encoded = ethers_1.utils.solidityPack(["uint8", "address", "uint256", "uint256", "bytes"], [tx.operation, tx.to, tx.value, data2.length, data2]);
      return encoded.slice(2);
    };
    var encodeMultiSend2 = (txs) => {
      return "0x" + txs.map((tx) => encodeMetaTransaction(tx)).join("");
    };
    exports.encodeMultiSend = encodeMultiSend2;
    var buildMultiSendSafeTx = (multiSend, txs, nonce, overrides) => {
      return execution_1.buildContractCall(multiSend, "multiSend", [exports.encodeMultiSend(txs)], nonce, true, overrides);
    };
    exports.buildMultiSendSafeTx = buildMultiSendSafeTx;
  }
});

// node_modules/@gnosis.pm/safe-contracts/dist/index.js
var require_dist = __commonJS({
  "node_modules/@gnosis.pm/safe-contracts/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_proxies(), exports);
    __exportStar(require_constants(), exports);
    __exportStar(require_execution(), exports);
    __exportStar(require_multisend(), exports);
  }
});

// node_modules/ethers-multisend/build/esm/types.js
var TransactionType, OperationType;
var init_types2 = __esm({
  "node_modules/ethers-multisend/build/esm/types.js"() {
    (function(TransactionType2) {
      TransactionType2["transferFunds"] = "transferFunds";
      TransactionType2["transferCollectible"] = "transferCollectible";
      TransactionType2["callContract"] = "callContract";
      TransactionType2["raw"] = "raw";
    })(TransactionType || (TransactionType = {}));
    (function(OperationType2) {
      OperationType2[OperationType2["Call"] = 0] = "Call";
      OperationType2[OperationType2["DelegateCall"] = 1] = "DelegateCall";
    })(OperationType || (OperationType = {}));
  }
});

// node_modules/ethers-multisend/build/esm/encodeMulti.js
var MULTI_SEND_ABI;
var init_encodeMulti = __esm({
  "node_modules/ethers-multisend/build/esm/encodeMulti.js"() {
    init_lib13();
    init_lib2();
    init_lib30();
    init_types2();
    MULTI_SEND_ABI = ["function multiSend(bytes memory transactions)"];
  }
});

// node_modules/ethers-multisend/build/esm/decodeMulti.js
var unpack2, decodeMulti;
var init_decodeMulti = __esm({
  "node_modules/ethers-multisend/build/esm/decodeMulti.js"() {
    init_lib13();
    init_lib7();
    init_lib3();
    init_encodeMulti();
    unpack2 = (packed, startIndex) => {
      const operation = parseInt(packed.substring(startIndex, startIndex + 2), 16);
      const to = getAddress(`0x${packed.substring(startIndex + 2, startIndex + 42)}`);
      const value = BigNumber.from(`0x${packed.substring(startIndex + 42, startIndex + 106)}`).toHexString();
      const hexDataLength2 = parseInt(packed.substring(startIndex + 106, startIndex + 170), 16);
      const endIndex = startIndex + 170 + hexDataLength2 * 2;
      const data2 = `0x${packed.substring(startIndex + 170, endIndex)}`;
      return {
        operation,
        to,
        value,
        data: data2,
        endIndex
      };
    };
    decodeMulti = (data2) => {
      const multiSendContract = new Interface(MULTI_SEND_ABI);
      const tx = multiSendContract.parseTransaction({ data: data2 });
      const [transactionsEncoded] = tx.args;
      const result = [];
      let startIndex = 2;
      while (startIndex < transactionsEncoded.length) {
        const { endIndex, ...tx2 } = unpack2(transactionsEncoded, startIndex);
        result.push(tx2);
        startIndex = endIndex;
      }
      return result;
    };
  }
});

// node_modules/ethers-multisend/build/esm/interfaces.js
var erc20Interface, erc20TransferFragment, erc721Interface, erc721TransferFragment;
var init_interfaces = __esm({
  "node_modules/ethers-multisend/build/esm/interfaces.js"() {
    init_lib13();
    erc20Interface = new Interface([
      "function transfer(address recipient, uint256 amount) public returns (bool)",
      "function decimals() public view returns (uint8)"
    ]);
    erc20TransferFragment = Object.keys(erc20Interface.functions)[0];
    erc721Interface = new Interface([
      "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable"
    ]);
    erc721TransferFragment = Object.keys(erc721Interface.functions)[0];
  }
});

// node_modules/ethers-multisend/build/esm/encodeSingle.js
var abiCoder;
var init_encodeSingle = __esm({
  "node_modules/ethers-multisend/build/esm/encodeSingle.js"() {
    init_lib13();
    init_lib3();
    init_lib31();
    init_interfaces();
    init_types2();
    abiCoder = new AbiCoder();
  }
});

// node_modules/ethers-multisend/build/esm/decodeSingle.js
var abiCoder2;
var init_decodeSingle = __esm({
  "node_modules/ethers-multisend/build/esm/decodeSingle.js"() {
    init_lib13();
    init_lib3();
    init_lib18();
    init_lib31();
    init_interfaces();
    init_types2();
    abiCoder2 = new AbiCoder((name, value) => {
      if (!BigNumber.isBigNumber(value))
        return value;
      const match2 = name.match("^u?int([0-9]+)$");
      if (match2 && parseInt(match2[1]) <= 48) {
        return value.toNumber();
      }
      return value.toString();
    });
  }
});

// node_modules/ethers-multisend/build/esm/createTransaction.js
var init_createTransaction = __esm({
  "node_modules/ethers-multisend/build/esm/createTransaction.js"() {
    init_types2();
  }
});

// node_modules/ethers-multisend/build/esm/isValid.js
var init_isValid = __esm({
  "node_modules/ethers-multisend/build/esm/isValid.js"() {
    init_lib7();
    init_encodeSingle();
  }
});

// node_modules/ethers-multisend/build/esm/index.js
var init_esm2 = __esm({
  "node_modules/ethers-multisend/build/esm/index.js"() {
    init_encodeMulti();
    init_decodeMulti();
    init_encodeSingle();
    init_decodeSingle();
    init_createTransaction();
    init_isValid();
    init_types2();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/_version.js
var version27;
var init_version27 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/_version.js"() {
    version27 = "6.8.1";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/properties.js
function checkType(value, type, name) {
  const types = type.split("|").map((t) => t.trim());
  for (let i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
}
async function resolveProperties2(value) {
  const keys3 = Object.keys(value);
  const results = await Promise.all(keys3.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys3[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values2, types) {
  for (let key2 in values2) {
    let value = values2[key2];
    const type = types ? types[key2] : null;
    if (type) {
      checkType(value, type, key2);
    }
    Object.defineProperty(target, key2, { enumerable: true, value, writable: false });
  }
}
var init_properties = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/properties.js"() {
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/errors.js
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX2 = "0123456789abcdef";
    let result = "0x";
    for (let i = 0; i < value.length; i++) {
      result += HEX2[value[i] >> 4];
      result += HEX2[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys3 = Object.keys(value);
      keys3.sort();
      return "{ " + keys3.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
}
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  let shortMessage = message;
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key2 in info) {
        if (key2 === "shortMessage") {
          continue;
        }
        const value = info[key2];
        details.push(key2 + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version27}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    defineProperties(error, { shortMessage });
  }
  return error;
}
function assert2(check2, message, code, info) {
  if (!check2) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check2, message, name, value) {
  assert2(check2, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert2(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert2(count <= expectedCount, "too many arguemnts" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
function assertNormalize(form) {
  assert2(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert2(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
var _normalizeForms;
var init_errors = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/errors.js"() {
    init_version27();
    init_properties();
    _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad");
        }
        ;
        if (form === "NFD") {
          const check2 = String.fromCharCode(233).normalize("NFD");
          const expected = String.fromCharCode(101, 769);
          if (check2 !== expected) {
            throw new Error("broken");
          }
        }
        accum.push(form);
      } catch (error) {
      }
      return accum;
    }, []);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/data.js
function _getBytes(value, name, copy4) {
  if (value instanceof Uint8Array) {
    if (copy4) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
}
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike2(value) {
  return isHexString2(value, true) || value instanceof Uint8Array;
}
function hexlify2(data2) {
  const bytes3 = getBytes(data2);
  let result = "0x";
  for (let i = 0; i < bytes3.length; i++) {
    const v = bytes3[i];
    result += HexCharacters2[(v & 240) >> 4] + HexCharacters2[v & 15];
  }
  return result;
}
function concat2(datas) {
  return "0x" + datas.map((d) => hexlify2(d).substring(2)).join("");
}
function dataLength(data2) {
  if (isHexString2(data2, true)) {
    return (data2.length - 2) / 2;
  }
  return getBytes(data2).length;
}
function dataSlice(data2, start, end) {
  const bytes3 = getBytes(data2);
  if (end != null && end > bytes3.length) {
    assert2(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes3,
      length: bytes3.length,
      offset: end
    });
  }
  return hexlify2(bytes3.slice(start == null ? 0 : start, end == null ? bytes3.length : end));
}
function zeroPad2(data2, length, left) {
  const bytes3 = getBytes(data2);
  assert2(length >= bytes3.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes3),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes3, length - bytes3.length);
  } else {
    result.set(bytes3, 0);
  }
  return hexlify2(result);
}
function zeroPadValue(data2, length) {
  return zeroPad2(data2, length, true);
}
function zeroPadBytes(data2, length) {
  return zeroPad2(data2, length, false);
}
var HexCharacters2;
var init_data = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/data.js"() {
    init_errors();
    HexCharacters2 = "0123456789abcdef";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/maths.js
function fromTwos(_value2, _width) {
  const value = getUint(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert2(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value2
  });
  if (value >> width - BN_1) {
    const mask2 = (BN_1 << width) - BN_1;
    return -((~value & mask2) + BN_1);
  }
  return value;
}
function toTwos(_value2, _width) {
  let value = getBigInt(_value2, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1 << width - BN_1;
  if (value < BN_0) {
    value = -value;
    assert2(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
    const mask2 = (BN_1 << width) - BN_1;
    return (~value & mask2) + BN_1;
  } else {
    assert2(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value2
    });
  }
  return value;
}
function mask(_value2, _bits) {
  const value = getUint(_value2, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1 << bits) - BN_1;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert2(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber(value) {
  return getNumber(toBigInt(value));
}
function toBeHex(_value2, _width) {
  const value = getUint(_value2, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert2(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value2
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value2) {
  const value = getUint(_value2, "value");
  if (value === BN_0) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0; i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify2(isBytesLike2(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
var BN_0, BN_1, maxValue, Nibbles;
var init_maths = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/maths.js"() {
    init_data();
    init_errors();
    BN_0 = BigInt(0);
    BN_1 = BigInt(1);
    maxValue = 9007199254740991;
    Nibbles = "0123456789abcdef";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/base58.js
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
}
function encodeBase58(_value2) {
  let value = toBigInt(getBytes(_value2));
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_02;
  for (let i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
var Alphabet, Lookup, BN_02, BN_58;
var init_base58 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/base58.js"() {
    init_data();
    init_errors();
    init_maths();
    Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    Lookup = null;
    BN_02 = BigInt(0);
    BN_58 = BigInt(58);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/base64-browser.js
function decodeBase64(textData) {
  textData = atob(textData);
  const data2 = new Uint8Array(textData.length);
  for (let i = 0; i < textData.length; i++) {
    data2[i] = textData.charCodeAt(i);
  }
  return getBytes(data2);
}
function encodeBase64(_data5) {
  const data2 = getBytes(_data5);
  let textData = "";
  for (let i = 0; i < data2.length; i++) {
    textData += String.fromCharCode(data2[i]);
  }
  return btoa(textData);
}
var init_base64_browser = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/base64-browser.js"() {
    init_data();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/events.js
var _listener, EventPayload;
var init_events = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/events.js"() {
    init_properties();
    EventPayload = class {
      constructor(emitter, listener, filter) {
        __publicField(this, "filter");
        __publicField(this, "emitter");
        __privateAdd(this, _listener, void 0);
        __privateSet(this, _listener, listener);
        defineProperties(this, { emitter, filter });
      }
      async removeListener() {
        if (__privateGet(this, _listener) == null) {
          return;
        }
        await this.emitter.off(this.filter, __privateGet(this, _listener));
      }
    };
    _listener = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/utf8.js
function errorFunc2(reason, offset, bytes3, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc2(reason, offset, bytes3, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1; o < bytes3.length; o++) {
      if (bytes3[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes3.length - offset - 1;
  }
  return 0;
}
function replaceFunc2(reason, offset, bytes3, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc2(reason, offset, bytes3, output2, badCodepoint);
}
function getUtf8CodePoints2(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs2.error;
  }
  const bytes3 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes3.length) {
    const c = bytes3[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes3, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes3, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes3.length) {
      i += onError("OVERRUN", i - 1, bytes3, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes3[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes3, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes2(str, form) {
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
function _toUtf8String2(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String2(bytes3, onError) {
  return _toUtf8String2(getUtf8CodePoints2(bytes3, onError));
}
var Utf8ErrorFuncs2;
var init_utf82 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/utf8.js"() {
    init_data();
    init_errors();
    Utf8ErrorFuncs2 = Object.freeze({
      error: errorFunc2,
      ignore: ignoreFunc2,
      replace: replaceFunc2
    });
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/geturl-browser.js
function createGetUrl(options) {
  async function getUrl2(req, _signal2) {
    const protocol = req.url.split(":")[0].toLowerCase();
    assert2(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
      info: { protocol },
      operation: "request"
    });
    assert2(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
      operation: "request"
    });
    let signal = void 0;
    if (_signal2) {
      const controller = new AbortController();
      signal = controller.signal;
      _signal2.addListener(() => {
        controller.abort();
      });
    }
    const init3 = {
      method: req.method,
      headers: new Headers(Array.from(req)),
      body: req.body || void 0,
      signal
    };
    const resp = await fetch(req.url, init3);
    const headers = {};
    resp.headers.forEach((value, key2) => {
      headers[key2.toLowerCase()] = value;
    });
    const respBody = await resp.arrayBuffer();
    const body = respBody == null ? null : new Uint8Array(respBody);
    return {
      statusCode: resp.status,
      statusMessage: resp.statusText,
      headers,
      body
    };
  }
  return getUrl2;
}
var defaultGetUrl;
var init_geturl_browser = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/geturl-browser.js"() {
    init_errors();
    defaultGetUrl = createGetUrl({});
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/fetch.js
async function dataGatewayFunc(url, signal) {
  try {
    const match2 = url.match(reData);
    if (!match2) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match2[1] || "text/plain"
    }, match2[2] ? decodeBase64(match2[3]) : unpercent2(match2[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
function getIpfsGatewayFunc(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match2 = url.match(reIpfs);
      if (!match2) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match2[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
}
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
function getTime2() {
  return new Date().getTime();
}
function unpercent2(value) {
  return toUtf8Bytes2(value.replace(/%([0-9a-f][0-9a-f])/gi, (all2, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise((resolve2) => setTimeout(resolve2, delay));
}
var MAX_ATTEMPTS, SLOT_INTERVAL, defaultGetUrlFunc, reData, reIpfs, locked, Gateways, fetchSignals, _listeners, _cancelled, FetchCancelSignal, _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _send, send_fn, _FetchRequest, FetchRequest, _statusCode, _statusMessage, _headers2, _body2, _request, _error, _FetchResponse, FetchResponse;
var init_fetch = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/fetch.js"() {
    init_base64_browser();
    init_data();
    init_errors();
    init_properties();
    init_utf82();
    init_geturl_browser();
    MAX_ATTEMPTS = 12;
    SLOT_INTERVAL = 250;
    defaultGetUrlFunc = createGetUrl();
    reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
    reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
    locked = false;
    Gateways = {
      "data": dataGatewayFunc,
      "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
    };
    fetchSignals = /* @__PURE__ */ new WeakMap();
    FetchCancelSignal = class {
      constructor(request) {
        __privateAdd(this, _listeners, void 0);
        __privateAdd(this, _cancelled, void 0);
        __privateSet(this, _listeners, []);
        __privateSet(this, _cancelled, false);
        fetchSignals.set(request, () => {
          if (__privateGet(this, _cancelled)) {
            return;
          }
          __privateSet(this, _cancelled, true);
          for (const listener of __privateGet(this, _listeners)) {
            setTimeout(() => {
              listener();
            }, 0);
          }
          __privateSet(this, _listeners, []);
        });
      }
      addListener(listener) {
        assert2(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
          operation: "fetchCancelSignal.addCancelListener"
        });
        __privateGet(this, _listeners).push(listener);
      }
      get cancelled() {
        return __privateGet(this, _cancelled);
      }
      checkSignal() {
        assert2(!this.cancelled, "cancelled", "CANCELLED", {});
      }
    };
    _listeners = new WeakMap();
    _cancelled = new WeakMap();
    _FetchRequest = class {
      constructor(url) {
        __privateAdd(this, _send);
        __privateAdd(this, _allowInsecure, void 0);
        __privateAdd(this, _gzip, void 0);
        __privateAdd(this, _headers, void 0);
        __privateAdd(this, _method, void 0);
        __privateAdd(this, _timeout, void 0);
        __privateAdd(this, _url, void 0);
        __privateAdd(this, _body, void 0);
        __privateAdd(this, _bodyType, void 0);
        __privateAdd(this, _creds, void 0);
        __privateAdd(this, _preflight, void 0);
        __privateAdd(this, _process, void 0);
        __privateAdd(this, _retry, void 0);
        __privateAdd(this, _signal, void 0);
        __privateAdd(this, _throttle, void 0);
        __privateAdd(this, _getUrlFunc, void 0);
        __privateSet(this, _url, String(url));
        __privateSet(this, _allowInsecure, false);
        __privateSet(this, _gzip, true);
        __privateSet(this, _headers, {});
        __privateSet(this, _method, "");
        __privateSet(this, _timeout, 3e5);
        __privateSet(this, _throttle, {
          slotInterval: SLOT_INTERVAL,
          maxAttempts: MAX_ATTEMPTS
        });
        __privateSet(this, _getUrlFunc, null);
      }
      get url() {
        return __privateGet(this, _url);
      }
      set url(url) {
        __privateSet(this, _url, String(url));
      }
      get body() {
        if (__privateGet(this, _body) == null) {
          return null;
        }
        return new Uint8Array(__privateGet(this, _body));
      }
      set body(body) {
        if (body == null) {
          __privateSet(this, _body, void 0);
          __privateSet(this, _bodyType, void 0);
        } else if (typeof body === "string") {
          __privateSet(this, _body, toUtf8Bytes2(body));
          __privateSet(this, _bodyType, "text/plain");
        } else if (body instanceof Uint8Array) {
          __privateSet(this, _body, body);
          __privateSet(this, _bodyType, "application/octet-stream");
        } else if (typeof body === "object") {
          __privateSet(this, _body, toUtf8Bytes2(JSON.stringify(body)));
          __privateSet(this, _bodyType, "application/json");
        } else {
          throw new Error("invalid body");
        }
      }
      hasBody() {
        return __privateGet(this, _body) != null;
      }
      get method() {
        if (__privateGet(this, _method)) {
          return __privateGet(this, _method);
        }
        if (this.hasBody()) {
          return "POST";
        }
        return "GET";
      }
      set method(method) {
        if (method == null) {
          method = "";
        }
        __privateSet(this, _method, String(method).toUpperCase());
      }
      get headers() {
        const headers = Object.assign({}, __privateGet(this, _headers));
        if (__privateGet(this, _creds)) {
          headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes2(__privateGet(this, _creds)))}`;
        }
        ;
        if (this.allowGzip) {
          headers["accept-encoding"] = "gzip";
        }
        if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
          headers["content-type"] = __privateGet(this, _bodyType);
        }
        if (this.body) {
          headers["content-length"] = String(this.body.length);
        }
        return headers;
      }
      getHeader(key2) {
        return this.headers[key2.toLowerCase()];
      }
      setHeader(key2, value) {
        __privateGet(this, _headers)[String(key2).toLowerCase()] = String(value);
      }
      clearHeaders() {
        __privateSet(this, _headers, {});
      }
      [Symbol.iterator]() {
        const headers = this.headers;
        const keys3 = Object.keys(headers);
        let index = 0;
        return {
          next: () => {
            if (index < keys3.length) {
              const key2 = keys3[index++];
              return {
                value: [key2, headers[key2]],
                done: false
              };
            }
            return { value: void 0, done: true };
          }
        };
      }
      get credentials() {
        return __privateGet(this, _creds) || null;
      }
      setCredentials(username, password) {
        assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
        __privateSet(this, _creds, `${username}:${password}`);
      }
      get allowGzip() {
        return __privateGet(this, _gzip);
      }
      set allowGzip(value) {
        __privateSet(this, _gzip, !!value);
      }
      get allowInsecureAuthentication() {
        return !!__privateGet(this, _allowInsecure);
      }
      set allowInsecureAuthentication(value) {
        __privateSet(this, _allowInsecure, !!value);
      }
      get timeout() {
        return __privateGet(this, _timeout);
      }
      set timeout(timeout) {
        assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
        __privateSet(this, _timeout, timeout);
      }
      get preflightFunc() {
        return __privateGet(this, _preflight) || null;
      }
      set preflightFunc(preflight) {
        __privateSet(this, _preflight, preflight);
      }
      get processFunc() {
        return __privateGet(this, _process) || null;
      }
      set processFunc(process2) {
        __privateSet(this, _process, process2);
      }
      get retryFunc() {
        return __privateGet(this, _retry) || null;
      }
      set retryFunc(retry) {
        __privateSet(this, _retry, retry);
      }
      get getUrlFunc() {
        return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
      }
      set getUrlFunc(value) {
        __privateSet(this, _getUrlFunc, value);
      }
      toString() {
        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? hexlify2(__privateGet(this, _body)) : "null"}>`;
      }
      setThrottleParams(params) {
        if (params.slotInterval != null) {
          __privateGet(this, _throttle).slotInterval = params.slotInterval;
        }
        if (params.maxAttempts != null) {
          __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
        }
      }
      send() {
        assert2(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
        __privateSet(this, _signal, new FetchCancelSignal(this));
        return __privateMethod(this, _send, send_fn).call(this, 0, getTime2() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
      }
      cancel() {
        assert2(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
        const signal = fetchSignals.get(this);
        if (!signal) {
          throw new Error("missing signal; should not happen");
        }
        signal();
      }
      redirect(location) {
        const current = this.url.split(":")[0].toLowerCase();
        const target = location.split(":")[0].toLowerCase();
        assert2(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
          operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
        });
        const req = new _FetchRequest(location);
        req.method = "GET";
        req.allowGzip = this.allowGzip;
        req.timeout = this.timeout;
        __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
        if (__privateGet(this, _body)) {
          __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
        }
        __privateSet(req, _bodyType, __privateGet(this, _bodyType));
        return req;
      }
      clone() {
        const clone = new _FetchRequest(this.url);
        __privateSet(clone, _method, __privateGet(this, _method));
        if (__privateGet(this, _body)) {
          __privateSet(clone, _body, __privateGet(this, _body));
        }
        __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
        __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
        __privateSet(clone, _creds, __privateGet(this, _creds));
        if (this.allowGzip) {
          clone.allowGzip = true;
        }
        clone.timeout = this.timeout;
        if (this.allowInsecureAuthentication) {
          clone.allowInsecureAuthentication = true;
        }
        __privateSet(clone, _preflight, __privateGet(this, _preflight));
        __privateSet(clone, _process, __privateGet(this, _process));
        __privateSet(clone, _retry, __privateGet(this, _retry));
        __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
        return clone;
      }
      static lockConfig() {
        locked = true;
      }
      static getGateway(scheme) {
        return Gateways[scheme.toLowerCase()] || null;
      }
      static registerGateway(scheme, func) {
        scheme = scheme.toLowerCase();
        if (scheme === "http" || scheme === "https") {
          throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
        }
        if (locked) {
          throw new Error("gateways locked");
        }
        Gateways[scheme] = func;
      }
      static registerGetUrl(getUrl2) {
        if (locked) {
          throw new Error("gateways locked");
        }
        defaultGetUrlFunc = getUrl2;
      }
      static createGetUrlFunc(options) {
        return createGetUrl(options);
      }
      static createDataGateway() {
        return dataGatewayFunc;
      }
      static createIpfsGatewayFunc(baseUrl) {
        return getIpfsGatewayFunc(baseUrl);
      }
    };
    FetchRequest = _FetchRequest;
    _allowInsecure = new WeakMap();
    _gzip = new WeakMap();
    _headers = new WeakMap();
    _method = new WeakMap();
    _timeout = new WeakMap();
    _url = new WeakMap();
    _body = new WeakMap();
    _bodyType = new WeakMap();
    _creds = new WeakMap();
    _preflight = new WeakMap();
    _process = new WeakMap();
    _retry = new WeakMap();
    _signal = new WeakMap();
    _throttle = new WeakMap();
    _getUrlFunc = new WeakMap();
    _send = new WeakSet();
    send_fn = async function(attempt, expires, delay, _request3, _response) {
      var _a2, _b, _c;
      if (attempt >= __privateGet(this, _throttle).maxAttempts) {
        return _response.makeServerError("exceeded maximum retry limit");
      }
      assert2(getTime2() <= expires, "timeout", "TIMEOUT", {
        operation: "request.send",
        reason: "timeout",
        request: _request3
      });
      if (delay > 0) {
        await wait(delay);
      }
      let req = this.clone();
      const scheme = (req.url.split(":")[0] || "").toLowerCase();
      if (scheme in Gateways) {
        const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request3, _signal)));
        if (result instanceof FetchResponse) {
          let response2 = result;
          if (this.processFunc) {
            checkSignal(__privateGet(_request3, _signal));
            try {
              response2 = await this.processFunc(req, response2);
            } catch (error) {
              if (error.throttle == null || typeof error.stall !== "number") {
                response2.makeServerError("error in post-processing function", error).assertOk();
              }
            }
          }
          return response2;
        }
        req = result;
      }
      if (this.preflightFunc) {
        req = await this.preflightFunc(req);
      }
      const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request3, _signal)));
      let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request3);
      if (response.statusCode === 301 || response.statusCode === 302) {
        try {
          const location = response.headers.location || "";
          return __privateMethod(_a2 = req.redirect(location), _send, send_fn).call(_a2, attempt + 1, expires, 0, _request3, response);
        } catch (error) {
        }
        return response;
      } else if (response.statusCode === 429) {
        if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
          const retryAfter = response.headers["retry-after"];
          let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
            delay2 = parseInt(retryAfter);
          }
          return __privateMethod(_b = req.clone(), _send, send_fn).call(_b, attempt + 1, expires, delay2, _request3, response);
        }
      }
      if (this.processFunc) {
        checkSignal(__privateGet(_request3, _signal));
        try {
          response = await this.processFunc(req, response);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response.makeServerError("error in post-processing function", error).assertOk();
          }
          let delay2 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          ;
          if (error.stall >= 0) {
            delay2 = error.stall;
          }
          return __privateMethod(_c = req.clone(), _send, send_fn).call(_c, attempt + 1, expires, delay2, _request3, response);
        }
      }
      return response;
    };
    _FetchResponse = class {
      constructor(statusCode, statusMessage, headers, body, request) {
        __privateAdd(this, _statusCode, void 0);
        __privateAdd(this, _statusMessage, void 0);
        __privateAdd(this, _headers2, void 0);
        __privateAdd(this, _body2, void 0);
        __privateAdd(this, _request, void 0);
        __privateAdd(this, _error, void 0);
        __privateSet(this, _statusCode, statusCode);
        __privateSet(this, _statusMessage, statusMessage);
        __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k) => {
          accum[k.toLowerCase()] = String(headers[k]);
          return accum;
        }, {}));
        __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
        __privateSet(this, _request, request || null);
        __privateSet(this, _error, { message: "" });
      }
      toString() {
        return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? hexlify2(__privateGet(this, _body2)) : "null"}>`;
      }
      get statusCode() {
        return __privateGet(this, _statusCode);
      }
      get statusMessage() {
        return __privateGet(this, _statusMessage);
      }
      get headers() {
        return Object.assign({}, __privateGet(this, _headers2));
      }
      get body() {
        return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
      }
      get bodyText() {
        try {
          return __privateGet(this, _body2) == null ? "" : toUtf8String2(__privateGet(this, _body2));
        } catch (error) {
          assert2(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
            operation: "bodyText",
            info: { response: this }
          });
        }
      }
      get bodyJson() {
        try {
          return JSON.parse(this.bodyText);
        } catch (error) {
          assert2(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
            operation: "bodyJson",
            info: { response: this }
          });
        }
      }
      [Symbol.iterator]() {
        const headers = this.headers;
        const keys3 = Object.keys(headers);
        let index = 0;
        return {
          next: () => {
            if (index < keys3.length) {
              const key2 = keys3[index++];
              return {
                value: [key2, headers[key2]],
                done: false
              };
            }
            return { value: void 0, done: true };
          }
        };
      }
      makeServerError(message, error) {
        let statusMessage;
        if (!message) {
          message = `${this.statusCode} ${this.statusMessage}`;
          statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
        } else {
          statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
        }
        const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
        __privateSet(response, _error, { message, error });
        return response;
      }
      throwThrottleError(message, stall7) {
        if (stall7 == null) {
          stall7 = -1;
        } else {
          assertArgument(Number.isInteger(stall7) && stall7 >= 0, "invalid stall timeout", "stall", stall7);
        }
        const error = new Error(message || "throttling requests");
        defineProperties(error, { stall: stall7, throttle: true });
        throw error;
      }
      getHeader(key2) {
        return this.headers[key2.toLowerCase()];
      }
      hasBody() {
        return __privateGet(this, _body2) != null;
      }
      get request() {
        return __privateGet(this, _request);
      }
      ok() {
        return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
      }
      assertOk() {
        if (this.ok()) {
          return;
        }
        let { message, error } = __privateGet(this, _error);
        if (message === "") {
          message = `server response ${this.statusCode} ${this.statusMessage}`;
        }
        assert2(false, message, "SERVER_ERROR", {
          request: this.request || "unknown request",
          response: this,
          error
        });
      }
    };
    FetchResponse = _FetchResponse;
    _statusCode = new WeakMap();
    _statusMessage = new WeakMap();
    _headers2 = new WeakMap();
    _body2 = new WeakMap();
    _request = new WeakMap();
    _error = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/fixednumber.js
function getTens(decimals) {
  let result = Zeros3;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  const width = BigInt(format.width);
  if (format.signed) {
    const limit = BN_12 << width - BN_12;
    assert2(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_03) {
      val = fromTwos(mask(val, width), width);
    } else {
      val = -fromTwos(mask(-val, width), width);
    }
  } else {
    const limit = BN_12 << width;
    assert2(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_12;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed3 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") {
    } else if (value === "ufixed") {
      signed3 = false;
    } else {
      const match2 = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match2, "invalid fixed format", "format", value);
      signed3 = match2[1] !== "u";
      width = parseInt(match2[2]);
      decimals = parseInt(match2[3]);
    }
  } else if (value) {
    const v = value;
    const check2 = (key2, type, defaultValue) => {
      if (v[key2] == null) {
        return defaultValue;
      }
      assertArgument(typeof v[key2] === type, "invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, v[key2]);
      return v[key2];
    };
    signed3 = check2("signed", "boolean", signed3);
    width = check2("width", "number", width);
    decimals = check2("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed3 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed3, width, decimals, name };
}
function toString(val, decimals) {
  let negative = "";
  if (val < BN_03) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros3 + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
var BN_N1, BN_03, BN_12, BN_5, _guard, Zeros3, _format, _val, _tens, _checkFormat, checkFormat_fn, _checkValue, checkValue_fn, _add, add_fn, _sub, sub_fn, _mul, mul_fn, _div, div_fn, _FixedNumber, FixedNumber2;
var init_fixednumber2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/fixednumber.js"() {
    init_data();
    init_errors();
    init_maths();
    init_properties();
    BN_N1 = BigInt(-1);
    BN_03 = BigInt(0);
    BN_12 = BigInt(1);
    BN_5 = BigInt(5);
    _guard = {};
    Zeros3 = "0000";
    while (Zeros3.length < 80) {
      Zeros3 += Zeros3;
    }
    _FixedNumber = class {
      constructor(guard, value, format) {
        __privateAdd(this, _checkFormat);
        __privateAdd(this, _checkValue);
        __privateAdd(this, _add);
        __privateAdd(this, _sub);
        __privateAdd(this, _mul);
        __privateAdd(this, _div);
        __publicField(this, "format");
        __privateAdd(this, _format, void 0);
        __privateAdd(this, _val, void 0);
        __privateAdd(this, _tens, void 0);
        __publicField(this, "_value");
        assertPrivate(guard, _guard, "FixedNumber");
        __privateSet(this, _val, value);
        __privateSet(this, _format, format);
        const _value2 = toString(value, format.decimals);
        defineProperties(this, { format: format.name, _value: _value2 });
        __privateSet(this, _tens, getTens(format.decimals));
      }
      get signed() {
        return __privateGet(this, _format).signed;
      }
      get width() {
        return __privateGet(this, _format).width;
      }
      get decimals() {
        return __privateGet(this, _format).decimals;
      }
      get value() {
        return __privateGet(this, _val);
      }
      addUnsafe(other) {
        return __privateMethod(this, _add, add_fn).call(this, other);
      }
      add(other) {
        return __privateMethod(this, _add, add_fn).call(this, other, "add");
      }
      subUnsafe(other) {
        return __privateMethod(this, _sub, sub_fn).call(this, other);
      }
      sub(other) {
        return __privateMethod(this, _sub, sub_fn).call(this, other, "sub");
      }
      mulUnsafe(other) {
        return __privateMethod(this, _mul, mul_fn).call(this, other);
      }
      mul(other) {
        return __privateMethod(this, _mul, mul_fn).call(this, other, "mul");
      }
      mulSignal(other) {
        __privateMethod(this, _checkFormat, checkFormat_fn).call(this, other);
        const value = __privateGet(this, _val) * __privateGet(other, _val);
        assert2(value % __privateGet(this, _tens) === BN_03, "precision lost during signalling mul", "NUMERIC_FAULT", {
          operation: "mulSignal",
          fault: "underflow",
          value: this
        });
        return __privateMethod(this, _checkValue, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
      }
      divUnsafe(other) {
        return __privateMethod(this, _div, div_fn).call(this, other);
      }
      div(other) {
        return __privateMethod(this, _div, div_fn).call(this, other, "div");
      }
      divSignal(other) {
        assert2(__privateGet(other, _val) !== BN_03, "division by zero", "NUMERIC_FAULT", {
          operation: "div",
          fault: "divide-by-zero",
          value: this
        });
        __privateMethod(this, _checkFormat, checkFormat_fn).call(this, other);
        const value = __privateGet(this, _val) * __privateGet(this, _tens);
        assert2(value % __privateGet(other, _val) === BN_03, "precision lost during signalling div", "NUMERIC_FAULT", {
          operation: "divSignal",
          fault: "underflow",
          value: this
        });
        return __privateMethod(this, _checkValue, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
      }
      cmp(other) {
        let a = this.value, b2 = other.value;
        const delta = this.decimals - other.decimals;
        if (delta > 0) {
          b2 *= getTens(delta);
        } else if (delta < 0) {
          a *= getTens(-delta);
        }
        if (a < b2) {
          return -1;
        }
        if (a > b2) {
          return 1;
        }
        return 0;
      }
      eq(other) {
        return this.cmp(other) === 0;
      }
      lt(other) {
        return this.cmp(other) < 0;
      }
      lte(other) {
        return this.cmp(other) <= 0;
      }
      gt(other) {
        return this.cmp(other) > 0;
      }
      gte(other) {
        return this.cmp(other) >= 0;
      }
      floor() {
        let val = __privateGet(this, _val);
        if (__privateGet(this, _val) < BN_03) {
          val -= __privateGet(this, _tens) - BN_12;
        }
        val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
        return __privateMethod(this, _checkValue, checkValue_fn).call(this, val, "floor");
      }
      ceiling() {
        let val = __privateGet(this, _val);
        if (__privateGet(this, _val) > BN_03) {
          val += __privateGet(this, _tens) - BN_12;
        }
        val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
        return __privateMethod(this, _checkValue, checkValue_fn).call(this, val, "ceiling");
      }
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        if (decimals >= this.decimals) {
          return this;
        }
        const delta = this.decimals - decimals;
        const bump = BN_5 * getTens(delta - 1);
        let value = this.value + bump;
        const tens = getTens(delta);
        value = value / tens * tens;
        checkValue(value, __privateGet(this, _format), "round");
        return new _FixedNumber(_guard, value, __privateGet(this, _format));
      }
      isZero() {
        return __privateGet(this, _val) === BN_03;
      }
      isNegative() {
        return __privateGet(this, _val) < BN_03;
      }
      toString() {
        return this._value;
      }
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      toFormat(format) {
        return _FixedNumber.fromString(this.toString(), format);
      }
      static fromValue(_value2, _decimals, _format2) {
        const decimals = _decimals == null ? 0 : getNumber(_decimals);
        const format = getFormat(_format2);
        let value = getBigInt(_value2, "value");
        const delta = decimals - format.decimals;
        if (delta > 0) {
          const tens = getTens(delta);
          assert2(value % tens === BN_03, "value loses precision for format", "NUMERIC_FAULT", {
            operation: "fromValue",
            fault: "underflow",
            value: _value2
          });
          value /= tens;
        } else if (delta < 0) {
          value *= getTens(-delta);
        }
        checkValue(value, format, "fromValue");
        return new _FixedNumber(_guard, value, format);
      }
      static fromString(_value2, _format2) {
        const match2 = _value2.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        assertArgument(match2 && match2[2].length + match2[3].length > 0, "invalid FixedNumber string value", "value", _value2);
        const format = getFormat(_format2);
        let whole = match2[2] || "0", decimal = match2[3] || "";
        while (decimal.length < format.decimals) {
          decimal += Zeros3;
        }
        assert2(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
          operation: "fromString",
          fault: "underflow",
          value: _value2
        });
        decimal = decimal.substring(0, format.decimals);
        const value = BigInt(match2[1] + whole + decimal);
        checkValue(value, format, "fromString");
        return new _FixedNumber(_guard, value, format);
      }
      static fromBytes(_value2, _format2) {
        let value = toBigInt(getBytes(_value2, "value"));
        const format = getFormat(_format2);
        if (format.signed) {
          value = fromTwos(value, format.width);
        }
        checkValue(value, format, "fromBytes");
        return new _FixedNumber(_guard, value, format);
      }
    };
    FixedNumber2 = _FixedNumber;
    _format = new WeakMap();
    _val = new WeakMap();
    _tens = new WeakMap();
    _checkFormat = new WeakSet();
    checkFormat_fn = function(other) {
      assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
    };
    _checkValue = new WeakSet();
    checkValue_fn = function(val, safeOp) {
      val = checkValue(val, __privateGet(this, _format), safeOp);
      return new _FixedNumber(_guard, val, __privateGet(this, _format));
    };
    _add = new WeakSet();
    add_fn = function(o, safeOp) {
      __privateMethod(this, _checkFormat, checkFormat_fn).call(this, o);
      return __privateMethod(this, _checkValue, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o, _val), safeOp);
    };
    _sub = new WeakSet();
    sub_fn = function(o, safeOp) {
      __privateMethod(this, _checkFormat, checkFormat_fn).call(this, o);
      return __privateMethod(this, _checkValue, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o, _val), safeOp);
    };
    _mul = new WeakSet();
    mul_fn = function(o, safeOp) {
      __privateMethod(this, _checkFormat, checkFormat_fn).call(this, o);
      return __privateMethod(this, _checkValue, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o, _val) / __privateGet(this, _tens), safeOp);
    };
    _div = new WeakSet();
    div_fn = function(o, safeOp) {
      assert2(__privateGet(o, _val) !== BN_03, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this
      });
      __privateMethod(this, _checkFormat, checkFormat_fn).call(this, o);
      return __privateMethod(this, _checkValue, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o, _val), safeOp);
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/rlp-decode.js
function hexlifyByte(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger2(data2, offset, length) {
  let result = 0;
  for (let i = 0; i < length; i++) {
    result = result * 256 + data2[offset + i];
  }
  return result;
}
function _decodeChildren2(data2, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode2(data2, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert2(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data2,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
}
function _decode2(data2, offset) {
  assert2(data2.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data2,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert2(offset2 <= data2.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data2,
      length: data2.length,
      offset: offset2
    });
  };
  if (data2[offset] >= 248) {
    const lengthLength = data2[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger2(data2, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren2(data2, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data2[offset] >= 192) {
    const length = data2[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren2(data2, offset, offset + 1, length);
  } else if (data2[offset] >= 184) {
    const lengthLength = data2[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger2(data2, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify2(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data2[offset] >= 128) {
    const length = data2[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify2(data2.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data2[offset]) };
}
function decodeRlp(_data5) {
  const data2 = getBytes(_data5, "data");
  const decoded = _decode2(data2, 0);
  assertArgument(decoded.consumed === data2.length, "unexpected junk after rlp payload", "data", _data5);
  return decoded.result;
}
var init_rlp_decode = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/rlp-decode.js"() {
    init_data();
    init_errors();
    init_data();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/rlp-encode.js
function arrayifyInteger2(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function _encode3(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode3(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger2(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data2 = Array.prototype.slice.call(getBytes(object2, "object"));
  if (data2.length === 1 && data2[0] <= 127) {
    return data2;
  } else if (data2.length <= 55) {
    data2.unshift(128 + data2.length);
    return data2;
  }
  const length = arrayifyInteger2(data2.length);
  length.unshift(183 + length.length);
  return length.concat(data2);
}
function encodeRlp(object2) {
  let result = "0x";
  for (const v of _encode3(object2)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}
var nibbles;
var init_rlp_encode = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/rlp-encode.js"() {
    init_data();
    nibbles = "0123456789abcdef";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/units.js
var init_units = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/units.js"() {
    init_errors();
    init_fixednumber2();
    init_maths();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/uuid.js
function uuidV42(randomBytes5) {
  const bytes3 = getBytes(randomBytes5, "randomBytes");
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value = hexlify2(bytes3);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
var init_uuid = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/uuid.js"() {
    init_data();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/index.js
var init_utils3 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/utils/index.js"() {
    init_base58();
    init_base64_browser();
    init_data();
    init_errors();
    init_events();
    init_fetch();
    init_fixednumber2();
    init_maths();
    init_properties();
    init_rlp_decode();
    init_rlp_encode();
    init_units();
    init_utf82();
    init_uuid();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
function throwError(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
}
function getValue(value) {
  let bytes3 = toBeArray(value);
  assert2(bytes3.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes3, length: WordSize, offset: bytes3.length });
  if (bytes3.length !== WordSize) {
    bytes3 = getBytesCopy(concat2([Padding.slice(bytes3.length % WordSize), bytes3]));
  }
  return bytes3;
}
var WordSize, Padding, passProperties, _guard2, _names, _Result, Result, Coder2, _data, _dataLength, _writeData, writeData_fn, Writer2, _data2, _offset, _peekBytes, peekBytes_fn, _Reader, Reader2;
var init_abstract_coder2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/abstract-coder.js"() {
    init_utils3();
    WordSize = 32;
    Padding = new Uint8Array(WordSize);
    passProperties = ["then"];
    _guard2 = {};
    _Result = class extends Array {
      constructor(...args) {
        const guard = args[0];
        let items = args[1];
        let names2 = (args[2] || []).slice();
        let wrap = true;
        if (guard !== _guard2) {
          items = args;
          names2 = [];
          wrap = false;
        }
        super(items.length);
        __privateAdd(this, _names, void 0);
        items.forEach((item, index) => {
          this[index] = item;
        });
        const nameCounts = names2.reduce((accum, name) => {
          if (typeof name === "string") {
            accum.set(name, (accum.get(name) || 0) + 1);
          }
          return accum;
        }, /* @__PURE__ */ new Map());
        __privateSet(this, _names, Object.freeze(items.map((item, index) => {
          const name = names2[index];
          if (name != null && nameCounts.get(name) === 1) {
            return name;
          }
          return null;
        })));
        if (!wrap) {
          return;
        }
        Object.freeze(this);
        return new Proxy(this, {
          get: (target, prop, receiver) => {
            if (typeof prop === "string") {
              if (prop.match(/^[0-9]+$/)) {
                const index = getNumber(prop, "%index");
                if (index < 0 || index >= this.length) {
                  throw new RangeError("out of result range");
                }
                const item = target[index];
                if (item instanceof Error) {
                  throwError(`index ${index}`, item);
                }
                return item;
              }
              if (passProperties.indexOf(prop) >= 0) {
                return Reflect.get(target, prop, receiver);
              }
              const value = target[prop];
              if (value instanceof Function) {
                return function(...args2) {
                  return value.apply(this === receiver ? target : this, args2);
                };
              } else if (!(prop in target)) {
                return target.getValue.apply(this === receiver ? target : this, [prop]);
              }
            }
            return Reflect.get(target, prop, receiver);
          }
        });
      }
      toArray() {
        const result = [];
        this.forEach((item, index) => {
          if (item instanceof Error) {
            throwError(`index ${index}`, item);
          }
          result.push(item);
        });
        return result;
      }
      toObject() {
        return __privateGet(this, _names).reduce((accum, name, index) => {
          assert2(name != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
            operation: "toObject()"
          });
          if (!(name in accum)) {
            accum[name] = this.getValue(name);
          }
          return accum;
        }, {});
      }
      slice(start, end) {
        if (start == null) {
          start = 0;
        }
        if (start < 0) {
          start += this.length;
          if (start < 0) {
            start = 0;
          }
        }
        if (end == null) {
          end = this.length;
        }
        if (end < 0) {
          end += this.length;
          if (end < 0) {
            end = 0;
          }
        }
        if (end > this.length) {
          end = this.length;
        }
        const result = [], names2 = [];
        for (let i = start; i < end; i++) {
          result.push(this[i]);
          names2.push(__privateGet(this, _names)[i]);
        }
        return new _Result(_guard2, result, names2);
      }
      filter(callback, thisArg) {
        const result = [], names2 = [];
        for (let i = 0; i < this.length; i++) {
          const item = this[i];
          if (item instanceof Error) {
            throwError(`index ${i}`, item);
          }
          if (callback.call(thisArg, item, i, this)) {
            result.push(item);
            names2.push(__privateGet(this, _names)[i]);
          }
        }
        return new _Result(_guard2, result, names2);
      }
      map(callback, thisArg) {
        const result = [];
        for (let i = 0; i < this.length; i++) {
          const item = this[i];
          if (item instanceof Error) {
            throwError(`index ${i}`, item);
          }
          result.push(callback.call(thisArg, item, i, this));
        }
        return result;
      }
      getValue(name) {
        const index = __privateGet(this, _names).indexOf(name);
        if (index === -1) {
          return void 0;
        }
        const value = this[index];
        if (value instanceof Error) {
          throwError(`property ${JSON.stringify(name)}`, value.error);
        }
        return value;
      }
      static fromItems(items, keys3) {
        return new _Result(_guard2, items, keys3);
      }
    };
    Result = _Result;
    _names = new WeakMap();
    Coder2 = class {
      constructor(name, type, localName, dynamic) {
        __publicField(this, "name");
        __publicField(this, "type");
        __publicField(this, "localName");
        __publicField(this, "dynamic");
        defineProperties(this, { name, type, localName, dynamic }, {
          name: "string",
          type: "string",
          localName: "string",
          dynamic: "boolean"
        });
      }
      _throwError(message, value) {
        assertArgument(false, message, this.localName, value);
      }
    };
    Writer2 = class {
      constructor() {
        __privateAdd(this, _writeData);
        __privateAdd(this, _data, void 0);
        __privateAdd(this, _dataLength, void 0);
        __privateSet(this, _data, []);
        __privateSet(this, _dataLength, 0);
      }
      get data() {
        return concat2(__privateGet(this, _data));
      }
      get length() {
        return __privateGet(this, _dataLength);
      }
      appendWriter(writer) {
        return __privateMethod(this, _writeData, writeData_fn).call(this, getBytesCopy(writer.data));
      }
      writeBytes(value) {
        let bytes3 = getBytesCopy(value);
        const paddingOffset = bytes3.length % WordSize;
        if (paddingOffset) {
          bytes3 = getBytesCopy(concat2([bytes3, Padding.slice(paddingOffset)]));
        }
        return __privateMethod(this, _writeData, writeData_fn).call(this, bytes3);
      }
      writeValue(value) {
        return __privateMethod(this, _writeData, writeData_fn).call(this, getValue(value));
      }
      writeUpdatableValue() {
        const offset = __privateGet(this, _data).length;
        __privateGet(this, _data).push(Padding);
        __privateSet(this, _dataLength, __privateGet(this, _dataLength) + WordSize);
        return (value) => {
          __privateGet(this, _data)[offset] = getValue(value);
        };
      }
    };
    _data = new WeakMap();
    _dataLength = new WeakMap();
    _writeData = new WeakSet();
    writeData_fn = function(data2) {
      __privateGet(this, _data).push(data2);
      __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data2.length);
      return data2.length;
    };
    _Reader = class {
      constructor(data2, allowLoose) {
        __privateAdd(this, _peekBytes);
        __publicField(this, "allowLoose");
        __privateAdd(this, _data2, void 0);
        __privateAdd(this, _offset, void 0);
        defineProperties(this, { allowLoose: !!allowLoose });
        __privateSet(this, _data2, getBytesCopy(data2));
        __privateSet(this, _offset, 0);
      }
      get data() {
        return hexlify2(__privateGet(this, _data2));
      }
      get dataLength() {
        return __privateGet(this, _data2).length;
      }
      get consumed() {
        return __privateGet(this, _offset);
      }
      get bytes() {
        return new Uint8Array(__privateGet(this, _data2));
      }
      subReader(offset) {
        return new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose);
      }
      readBytes(length, loose) {
        let bytes3 = __privateMethod(this, _peekBytes, peekBytes_fn).call(this, 0, length, !!loose);
        __privateSet(this, _offset, __privateGet(this, _offset) + bytes3.length);
        return bytes3.slice(0, length);
      }
      readValue() {
        return toBigInt(this.readBytes(WordSize));
      }
      readIndex() {
        return toNumber(this.readBytes(WordSize));
      }
    };
    Reader2 = _Reader;
    _data2 = new WeakMap();
    _offset = new WeakMap();
    _peekBytes = new WeakSet();
    peekBytes_fn = function(offset, length, loose) {
      let alignedLength = Math.ceil(length / WordSize) * WordSize;
      if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
        if (this.allowLoose && loose && __privateGet(this, _offset) + length <= __privateGet(this, _data2).length) {
          alignedLength = length;
        } else {
          assert2(false, "data out-of-bounds", "BUFFER_OVERRUN", {
            buffer: getBytesCopy(__privateGet(this, _data2)),
            length: __privateGet(this, _data2).length,
            offset: __privateGet(this, _offset) + alignedLength
          });
        }
      }
      return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
    };
  }
});

// node_modules/@noble/hashes/esm/_assert.js
function number(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error(`Wrong positive integer: ${n2}`);
}
function bytes(b2, ...lengths) {
  if (!(b2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash3(hash4) {
  if (typeof hash4 !== "function" || typeof hash4.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash4.outputLen);
  number(hash4.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
var init_assert = __esm({
  "node_modules/@noble/hashes/esm/_assert.js"() {
  }
});

// node_modules/@noble/hashes/esm/crypto.js
var crypto2;
var init_crypto = __esm({
  "node_modules/@noble/hashes/esm/crypto.js"() {
    crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/esm/utils.js
async function asyncLoop(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0; i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data2) {
  if (typeof data2 === "string")
    data2 = utf8ToBytes(data2);
  if (!u8a(data2))
    throw new Error(`expected Uint8Array, got ${typeof data2}`);
  return data2;
}
function concatBytes(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r2.set(a, pad);
    pad += a.length;
  });
  return r2;
}
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
var u8a, u32, createView, rotr, isLE, hexes, nextTick, Hash, toStr;
var init_utils4 = __esm({
  "node_modules/@noble/hashes/esm/utils.js"() {
    init_crypto();
    u8a = (a) => a instanceof Uint8Array;
    u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    rotr = (word, shift) => word << 32 - shift | word >>> shift;
    isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!isLE)
      throw new Error("Non little-endian hardware is not supported");
    hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    nextTick = async () => {
    };
    Hash = class {
      clone() {
        return this._cloneInto();
      }
    };
    toStr = {}.toString;
  }
});

// node_modules/@noble/hashes/esm/hmac.js
var HMAC, hmac2;
var init_hmac = __esm({
  "node_modules/@noble/hashes/esm/hmac.js"() {
    init_assert();
    init_utils4();
    HMAC = class extends Hash {
      constructor(hash4, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        hash3(hash4);
        const key2 = toBytes(_key);
        this.iHash = hash4.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key2.length > blockLen ? hash4.create().update(key2).digest() : key2);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash4.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        exists(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        exists(this);
        bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    hmac2 = (hash4, key2, message) => new HMAC(hash4, key2).update(message).digest();
    hmac2.create = (hash4, key2) => new HMAC(hash4, key2);
  }
});

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash4, _password, _salt, _opts) {
  hash3(hash4);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac2.create(hash4, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf23(hash4, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash4, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
var init_pbkdf22 = __esm({
  "node_modules/@noble/hashes/esm/pbkdf2.js"() {
    init_assert();
    init_hmac();
    init_utils4();
  }
});

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2;
var init_sha22 = __esm({
  "node_modules/@noble/hashes/esm/_sha2.js"() {
    init_assert();
    init_utils4();
    SHA2 = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data2) {
        exists(this);
        const { view, buffer, blockLen } = this;
        data2 = toBytes(data2);
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data2);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data2.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        exists(this);
        output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
  }
});

// node_modules/@noble/hashes/esm/sha256.js
var Chi, Maj, SHA256_K, IV, SHA256_W, SHA256, SHA224, sha2563, sha224;
var init_sha256 = __esm({
  "node_modules/@noble/hashes/esm/sha256.js"() {
    init_sha22();
    init_utils4();
    Chi = (a, b2, c) => a & b2 ^ ~a & c;
    Maj = (a, b2, c) => a & b2 ^ a & c ^ b2 & c;
    SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA256_W = new Uint32Array(64);
    SHA256 = class extends SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T13 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          const T22 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T13 | 0;
          D = C;
          C = B;
          B = A;
          A = T13 + T22 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    sha2563 = wrapConstructor(() => new SHA256());
    sha224 = wrapConstructor(() => new SHA224());
  }
});

// node_modules/@noble/hashes/esm/_u64.js
function fromBig(n2, le = false) {
  if (le)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
function add3(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var U32_MASK64, _32n, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H, u64, u64_default;
var init_u64 = __esm({
  "node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK64 = BigInt(2 ** 32 - 1);
    _32n = BigInt(32);
    toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    shrSH = (h, _l, s) => h >>> s;
    shrSL = (h, l, s) => h << 32 - s | l >>> s;
    rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    rotr32H = (_h, l) => l;
    rotr32L = (h, _l) => h;
    rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add: add3,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    u64_default = u64;
  }
});

// node_modules/@noble/hashes/esm/sha512.js
var SHA512_Kh, SHA512_Kl, SHA512_W_H, SHA512_W_L, SHA512, SHA512_224, SHA512_256, SHA384, sha5122, sha512_224, sha512_256, sha384;
var init_sha512 = __esm({
  "node_modules/@noble/hashes/esm/sha512.js"() {
    init_sha22();
    init_u64();
    init_utils4();
    [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n2) => BigInt(n2))))();
    SHA512_W_H = new Uint32Array(80);
    SHA512_W_L = new Uint32Array(80);
    SHA512 = class extends SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
          const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
          const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
          const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
          const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
          const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = u64_default.add3L(T1l, sigma0l, MAJl);
          Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    sha5122 = wrapConstructor(() => new SHA512());
    sha512_224 = wrapConstructor(() => new SHA512_224());
    sha512_256 = wrapConstructor(() => new SHA512_256());
    sha384 = wrapConstructor(() => new SHA384());
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/crypto-browser.js
function getGlobal2() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha2563.create();
    case "sha512":
      return sha5122.create();
  }
  assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
}
function createHmac(_algo, key2) {
  const algo = { sha256: sha2563, sha512: sha5122 }[_algo];
  assertArgument(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac2.create(algo, key2);
}
function pbkdf2Sync2(password, salt, iterations, keylen, _algo) {
  const algo = { sha256: sha2563, sha512: sha5122 }[_algo];
  assertArgument(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return pbkdf23(algo, password, salt, { c: iterations, dkLen: keylen });
}
function randomBytes3(length) {
  assert2(crypto3 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  assertArgument(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  const result = new Uint8Array(length);
  crypto3.getRandomValues(result);
  return result;
}
var anyGlobal2, crypto3;
var init_crypto_browser = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/crypto-browser.js"() {
    init_hmac();
    init_pbkdf22();
    init_sha256();
    init_sha512();
    init_utils3();
    anyGlobal2 = getGlobal2();
    crypto3 = anyGlobal2.crypto || anyGlobal2.msCrypto;
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/hmac.js
function computeHmac2(algorithm, _key, _data5) {
  const key2 = getBytes(_key, "key");
  const data2 = getBytes(_data5, "data");
  return hexlify2(__computeHmac(algorithm, key2, data2));
}
var locked2, _computeHmac, __computeHmac;
var init_hmac2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/hmac.js"() {
    init_crypto_browser();
    init_utils3();
    locked2 = false;
    _computeHmac = function(algorithm, key2, data2) {
      return createHmac(algorithm, key2).update(data2).digest();
    };
    __computeHmac = _computeHmac;
    computeHmac2._ = _computeHmac;
    computeHmac2.lock = function() {
      locked2 = true;
    };
    computeHmac2.register = function(func) {
      if (locked2) {
        throw new Error("computeHmac is locked");
      }
      __computeHmac = func;
    };
    Object.freeze(computeHmac2);
  }
});

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
var init_sha3 = __esm({
  "node_modules/@noble/hashes/esm/sha3.js"() {
    init_assert();
    init_u64();
    init_utils4();
    [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    _0n = BigInt(0);
    _1n = BigInt(1);
    _2n = BigInt(2);
    _7n = BigInt(7);
    _256n = BigInt(256);
    _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
    rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
    rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
    Keccak = class extends Hash {
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        number(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data2) {
        exists(this);
        const { blockLen, state } = this;
        data2 = toBytes(data2);
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data2[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        exists(this, false);
        bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes3) {
        number(bytes3);
        return this.xofInto(new Uint8Array(bytes3));
      }
      digestInto(out) {
        output(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
    sha3_224 = gen(6, 144, 224 / 8);
    sha3_256 = gen(6, 136, 256 / 8);
    sha3_384 = gen(6, 104, 384 / 8);
    sha3_512 = gen(6, 72, 512 / 8);
    keccak_224 = gen(1, 144, 224 / 8);
    keccak_256 = gen(1, 136, 256 / 8);
    keccak_384 = gen(1, 104, 384 / 8);
    keccak_512 = gen(1, 72, 512 / 8);
    genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    shake128 = genShake(31, 168, 128 / 8);
    shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/keccak.js
function keccak2563(_data5) {
  const data2 = getBytes(_data5, "data");
  return hexlify2(__keccak256(data2));
}
var locked3, _keccak256, __keccak256;
var init_keccak = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/keccak.js"() {
    init_sha3();
    init_utils3();
    locked3 = false;
    _keccak256 = function(data2) {
      return keccak_256(data2);
    };
    __keccak256 = _keccak256;
    keccak2563._ = _keccak256;
    keccak2563.lock = function() {
      locked3 = true;
    };
    keccak2563.register = function(func) {
      if (locked3) {
        throw new TypeError("keccak256 is locked");
      }
      __keccak256 = func;
    };
    Object.freeze(keccak2563);
  }
});

// node_modules/@noble/hashes/esm/ripemd160.js
function f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  else if (group === 1)
    return x & y | ~x & z;
  else if (group === 2)
    return (x | ~y) ^ z;
  else if (group === 3)
    return x & z | y & ~z;
  else
    return x ^ (y | ~z);
}
var Rho, Id, Pi, idxL, idxR, shifts, shiftsL, shiftsR, Kl, Kr, rotl, BUF, RIPEMD160, ripemd1602;
var init_ripemd160 = __esm({
  "node_modules/@noble/hashes/esm/ripemd160.js"() {
    init_sha22();
    init_utils4();
    Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    Id = Uint8Array.from({ length: 16 }, (_, i) => i);
    Pi = Id.map((i) => (9 * i + 5) % 16);
    idxL = [Id];
    idxR = [Pi];
    for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
    shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => new Uint8Array(i));
    shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    Kl = new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    Kr = new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    rotl = (word, shift) => word << shift | word >>> 32 - shift;
    BUF = new Uint32Array(16);
    RIPEMD160 = class extends SHA2 {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i = 0; i < 16; i++) {
            const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    ripemd1602 = wrapConstructor(() => new RIPEMD160());
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/ripemd160.js
function ripemd1603(_data5) {
  const data2 = getBytes(_data5, "data");
  return hexlify2(__ripemd160(data2));
}
var locked4, _ripemd160, __ripemd160;
var init_ripemd1602 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/ripemd160.js"() {
    init_ripemd160();
    init_utils3();
    locked4 = false;
    _ripemd160 = function(data2) {
      return ripemd1602(data2);
    };
    __ripemd160 = _ripemd160;
    ripemd1603._ = _ripemd160;
    ripemd1603.lock = function() {
      locked4 = true;
    };
    ripemd1603.register = function(func) {
      if (locked4) {
        throw new TypeError("ripemd160 is locked");
      }
      __ripemd160 = func;
    };
    Object.freeze(ripemd1603);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/pbkdf2.js
function pbkdf24(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify2(__pbkdf2(password, salt, iterations, keylen, algo));
}
var locked5, _pbkdf2, __pbkdf2;
var init_pbkdf23 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/pbkdf2.js"() {
    init_crypto_browser();
    init_utils3();
    locked5 = false;
    _pbkdf2 = function(password, salt, iterations, keylen, algo) {
      return pbkdf2Sync2(password, salt, iterations, keylen, algo);
    };
    __pbkdf2 = _pbkdf2;
    pbkdf24._ = _pbkdf2;
    pbkdf24.lock = function() {
      locked5 = true;
    };
    pbkdf24.register = function(func) {
      if (locked5) {
        throw new Error("pbkdf2 is locked");
      }
      __pbkdf2 = func;
    };
    Object.freeze(pbkdf24);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/random.js
function randomBytes4(length) {
  return __randomBytes(length);
}
var locked6, _randomBytes, __randomBytes;
var init_random2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/random.js"() {
    init_crypto_browser();
    locked6 = false;
    _randomBytes = function(length) {
      return new Uint8Array(randomBytes3(length));
    };
    __randomBytes = _randomBytes;
    randomBytes4._ = _randomBytes;
    randomBytes4.lock = function() {
      locked6 = true;
    };
    randomBytes4.register = function(func) {
      if (locked6) {
        throw new Error("randomBytes is locked");
      }
      __randomBytes = func;
    };
    Object.freeze(randomBytes4);
  }
});

// node_modules/@noble/hashes/esm/scrypt.js
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl2(x00 + x12 | 0, 7);
    x08 ^= rotl2(x04 + x00 | 0, 9);
    x12 ^= rotl2(x08 + x04 | 0, 13);
    x00 ^= rotl2(x12 + x08 | 0, 18);
    x09 ^= rotl2(x05 + x01 | 0, 7);
    x13 ^= rotl2(x09 + x05 | 0, 9);
    x01 ^= rotl2(x13 + x09 | 0, 13);
    x05 ^= rotl2(x01 + x13 | 0, 18);
    x14 ^= rotl2(x10 + x06 | 0, 7);
    x02 ^= rotl2(x14 + x10 | 0, 9);
    x06 ^= rotl2(x02 + x14 | 0, 13);
    x10 ^= rotl2(x06 + x02 | 0, 18);
    x03 ^= rotl2(x15 + x11 | 0, 7);
    x07 ^= rotl2(x03 + x15 | 0, 9);
    x11 ^= rotl2(x07 + x03 | 0, 13);
    x15 ^= rotl2(x11 + x07 | 0, 18);
    x01 ^= rotl2(x00 + x03 | 0, 7);
    x02 ^= rotl2(x01 + x00 | 0, 9);
    x03 ^= rotl2(x02 + x01 | 0, 13);
    x00 ^= rotl2(x03 + x02 | 0, 18);
    x06 ^= rotl2(x05 + x04 | 0, 7);
    x07 ^= rotl2(x06 + x05 | 0, 9);
    x04 ^= rotl2(x07 + x06 | 0, 13);
    x05 ^= rotl2(x04 + x07 | 0, 18);
    x11 ^= rotl2(x10 + x09 | 0, 7);
    x08 ^= rotl2(x11 + x10 | 0, 9);
    x09 ^= rotl2(x08 + x11 | 0, 13);
    x10 ^= rotl2(x09 + x08 | 0, 18);
    x12 ^= rotl2(x15 + x14 | 0, 7);
    x13 ^= rotl2(x12 + x15 | 0, 9);
    x14 ^= rotl2(x13 + x12 | 0, 13);
    x15 ^= rotl2(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r2) {
  let head = oi + 0;
  let tail = oi + 16 * r2;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r2 - 1) * 16 + i];
  for (let i = 0; i < r2; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N: N4, r: r2, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N4);
  number(r2);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r2;
  const blockSize32 = blockSize / 4;
  if (N4 <= 1 || (N4 & N4 - 1) !== 0 || N4 >= 2 ** (blockSize / 8) || N4 > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N4 + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf23(sha2563, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N4));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N4 * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N: N4, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf23(sha2563, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt2(password, salt, opts) {
  const { N: N4, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0; i < N4 - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r2);
      blockMixCb();
    }
    BlockMix(V, (N4 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    for (let i = 0; i < N4; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N4;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N: N4, r: r2, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop(N4 - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r2);
      blockMixCb();
    });
    BlockMix(V, (N4 - 1) * blockSize32, B32, Pi2, r2);
    blockMixCb();
    await asyncLoop(N4, asyncTick, () => {
      const j = B32[Pi2 + blockSize32 - 16] % N4;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi2, r2);
      blockMixCb();
    });
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
var rotl2;
var init_scrypt = __esm({
  "node_modules/@noble/hashes/esm/scrypt.js"() {
    init_assert();
    init_sha256();
    init_pbkdf22();
    init_utils4();
    rotl2 = (a, b2) => a << b2 | a >>> 32 - b2;
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/scrypt.js
async function scrypt3(_passwd, _salt, N4, r2, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify2(await __scryptAsync(passwd, salt, N4, r2, p, dkLen, progress));
}
function scryptSync(_passwd, _salt, N4, r2, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify2(__scryptSync(passwd, salt, N4, r2, p, dkLen));
}
var lockedSync, lockedAsync, _scryptAsync, _scryptSync, __scryptAsync, __scryptSync;
var init_scrypt2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/scrypt.js"() {
    init_scrypt();
    init_utils3();
    lockedSync = false;
    lockedAsync = false;
    _scryptAsync = async function(passwd, salt, N4, r2, p, dkLen, onProgress) {
      return await scryptAsync(passwd, salt, { N: N4, r: r2, p, dkLen, onProgress });
    };
    _scryptSync = function(passwd, salt, N4, r2, p, dkLen) {
      return scrypt2(passwd, salt, { N: N4, r: r2, p, dkLen });
    };
    __scryptAsync = _scryptAsync;
    __scryptSync = _scryptSync;
    scrypt3._ = _scryptAsync;
    scrypt3.lock = function() {
      lockedAsync = true;
    };
    scrypt3.register = function(func) {
      if (lockedAsync) {
        throw new Error("scrypt is locked");
      }
      __scryptAsync = func;
    };
    Object.freeze(scrypt3);
    scryptSync._ = _scryptSync;
    scryptSync.lock = function() {
      lockedSync = true;
    };
    scryptSync.register = function(func) {
      if (lockedSync) {
        throw new Error("scryptSync is locked");
      }
      __scryptSync = func;
    };
    Object.freeze(scryptSync);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/sha2.js
function sha2564(_data5) {
  const data2 = getBytes(_data5, "data");
  return hexlify2(__sha256(data2));
}
function sha5123(_data5) {
  const data2 = getBytes(_data5, "data");
  return hexlify2(__sha512(data2));
}
var _sha256, _sha512, __sha256, __sha512, locked256, locked512;
var init_sha23 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/sha2.js"() {
    init_crypto_browser();
    init_utils3();
    _sha256 = function(data2) {
      return createHash("sha256").update(data2).digest();
    };
    _sha512 = function(data2) {
      return createHash("sha512").update(data2).digest();
    };
    __sha256 = _sha256;
    __sha512 = _sha512;
    locked256 = false;
    locked512 = false;
    sha2564._ = _sha256;
    sha2564.lock = function() {
      locked256 = true;
    };
    sha2564.register = function(func) {
      if (locked256) {
        throw new Error("sha256 is locked");
      }
      __sha256 = func;
    };
    Object.freeze(sha2564);
    sha5123._ = _sha512;
    sha5123.lock = function() {
      locked512 = true;
    };
    sha5123.register = function(func) {
      if (locked512) {
        throw new Error("sha512 is locked");
      }
      __sha512 = func;
    };
    Object.freeze(sha2564);
  }
});

// node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
function bytesToHex(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes2[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  if (!u8a2(bytes3))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n2, len) {
  return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n2, len) {
  return numberToBytesBE(n2, len).reverse();
}
function numberToVarBytesBE(n2) {
  return hexToBytes(numberToHexUnpadded(n2));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r2 = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r2.set(a, pad);
    pad += a.length;
  });
  return r2;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n2) {
  let len;
  for (len = 0; n2 > _0n2; n2 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n2, pos) {
  return n2 >> BigInt(pos) & _1n2;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b2) => hmacFn(k, v, ...b2);
  const reseed2 = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed2(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed2();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
var _0n2, _1n2, _2n2, u8a2, hexes2, bitSet, bitMask, u8n, u8fr, validatorFns;
var init_utils5 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/utils.js"() {
    _0n2 = BigInt(0);
    _1n2 = BigInt(1);
    _2n2 = BigInt(2);
    u8a2 = (a) => a instanceof Uint8Array;
    hexes2 = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    bitSet = (n2, pos, value) => {
      return n2 | (value ? _1n2 : _0n2) << BigInt(pos);
    };
    bitMask = (n2) => (_2n2 << BigInt(n2 - 1)) - _1n2;
    u8n = (data2) => new Uint8Array(data2);
    u8fr = (arr) => Uint8Array.from(arr);
    validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object2) => object2.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n3 ? result : b2 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b2 = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b2 / a;
    const r2 = b2 % a;
    const m = x - u * q;
    const n2 = y - v * q;
    b2 = a, a = r2, x = u, y = v, u = m, v = n2;
  }
  const gcd = b2;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S2, Z;
  for (Q = P - _1n3, S2 = 0; Q % _2n3 === _0n3; Q /= _2n3, S2++)
    ;
  for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S2 === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp2, n2) {
    if (Fp2.pow(n2, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r2 = S2;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n2, Q1div2);
    let b2 = Fp2.pow(n2, Q);
    while (!Fp2.eql(b2, Fp2.ONE)) {
      if (Fp2.eql(b2, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b2); m < r2; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n3 << BigInt(r2 - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b2 = Fp2.mul(b2, g);
      r2 = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp2, n2) {
      const root = Fp2.pow(n2, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n2) {
      const n22 = Fp2.mul(n2, _2n3);
      const v = Fp2.pow(n22, c1);
      const nv = Fp2.mul(n2, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n3), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n2))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f2, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f2.ONE;
  if (power === _1n3)
    return num;
  let p = f2.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f2.mul(p, d);
    d = f2.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f2, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = acc;
    return f2.mul(acc, num);
  }, f2.ONE);
  const inverted = f2.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f2.is0(num))
      return acc;
    tmp[i] = f2.mul(acc, tmp[i]);
    return f2.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n2, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f2 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n2) => sqrtP(f2, n2)),
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    cmov: (a, b2, c) => c ? b2 : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE2 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key2, fieldOrder, isLE2 = false) {
  const len = key2.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key2) : bytesToNumberLE(key2);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
var _0n3, _1n3, _2n3, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;
var init_modular = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/modular.js"() {
    init_utils5();
    _0n3 = BigInt(0);
    _1n3 = BigInt(1);
    _2n3 = BigInt(2);
    _3n = BigInt(3);
    _4n = BigInt(4);
    _5n = BigInt(5);
    _8n = BigInt(8);
    _9n = BigInt(9);
    _16n = BigInt(16);
    FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
  }
});

// node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/curve.js
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg3 = item.negate();
    return condition ? neg3 : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n2) {
      let p = c.ZERO;
      let d = elm;
      while (n2 > _0n4) {
        if (n2 & _1n4)
          p = p.add(d);
        d = d.double();
        n2 >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    wNAF(W, precomputes, n2) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f2 = c.BASE;
      const mask2 = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n2 & mask2);
        n2 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n2 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f: f2 };
    },
    wNAFCached(P, precomputesMap, n2, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n2);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
var _0n4, _1n4;
var init_curve = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/curve.js"() {
    init_modular();
    init_utils5();
    _0n4 = BigInt(0);
    _1n4 = BigInt(1);
  }
});

// node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point3, _isCompressed) => {
    const a = point3.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b: b2 } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b2);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key2) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
    if (lengths && typeof key2 !== "bigint") {
      if (key2 instanceof Uint8Array)
        key2 = bytesToHex(key2);
      if (typeof key2 !== "string" || !lengths.includes(key2.length))
        throw new Error("Invalid key");
      key2 = key2.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key2 === "bigint" ? key2 : bytesToNumberBE(ensureBytes("private key", key2, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key2}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n2);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point3.ZERO;
      return new Point3(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
    }
    static fromHex(hex) {
      const P = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U12 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U12 && U22;
    }
    negate() {
      return new Point3(this.px, Fp2.neg(this.py), this.pz);
    }
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n2) {
      return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
      });
    }
    multiplyUnsafe(n2) {
      const I = Point3.ZERO;
      if (n2 === _0n5)
        return I;
      assertGE(n2);
      if (n2 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n2);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n2 = scalar;
      let point3, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n2);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point3 = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(n2);
        point3 = p;
        fake = f2;
      }
      return Point3.normalizeZ([point3, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b2) {
      const G = Point3.BASE;
      const mul3 = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul3(this, a).add(mul3(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point3, isCompressed) {
      const a = point3.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point3.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature3 {
    constructor(r2, s, recovery) {
      this.r = r2;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature3(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r: r2, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature3(r2, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature3(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r2, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature3(this.r, modN2(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point3 = Point3.BASE) {
      point3._setWindowSize(windowSize);
      point3.multiply(BigInt(3));
      return point3;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b2 = Point3.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN2(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash4, randomBytes: randomBytes5 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash4(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes5(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r2 = modN2(q.x);
      if (r2 === _0n5)
        return;
      const s = modN2(ik * modN2(m + r2 * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r2 ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature3(r2, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign3(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify3(signature2, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature2;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig2 = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig2 = Signature3.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig2 = Signature3.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r3, s: s2 } = sg;
        _sig2 = new Signature3(r3, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point3.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig2.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r2, s } = _sig2;
    const h = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN2(h * is2);
    const u2 = modN2(r2 * is2);
    const R = Point3.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r2;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign3,
    verify: verify3,
    ProjectivePoint: Point3,
    Signature: Signature3,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n5;
  for (let o = q - _1n5; o % _2n4 === _0n5; o /= _2n4)
    l += _1n5;
  const c1 = l;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c2 = (q - _1n5) / _2n_pow_c1;
  const c3 = (c2 - _1n5) / _2n4;
  const c4 = _2n_pow_c1 - _1n5;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n5) / _2n4);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i = c1; i > _1n5; i--) {
      let tv52 = i - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid: isValid2, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid2);
    y = Fp2.cmov(y, value, isValid2);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    x = Fp2.div(x, tv4);
    return { x, y };
  };
}
var b2n, h2b, DER, _0n5, _1n5, _2n4, _3n2, _4n2;
var init_weierstrass = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/weierstrass.js"() {
    init_modular();
    init_utils5();
    init_utils5();
    init_curve();
    ({ bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports2);
    DER = {
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data2) {
        const { Err: E } = DER;
        if (data2.length < 2 || data2[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data2[1];
        const res = data2.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data2.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = DER;
        const data2 = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data2 instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data2.length;
        if (l < 2 || data2[0] != 48)
          throw new E("Invalid signature tag");
        if (data2[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r2, l: sBytes } = DER._parseInt(data2.subarray(2));
        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r: r2, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r2 = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r2.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r2}02${sl}${s}`;
      }
    };
    _0n5 = BigInt(0);
    _1n5 = BigInt(1);
    _2n4 = BigInt(2);
    _3n2 = BigInt(3);
    _4n2 = BigInt(4);
  }
});

// node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i = length - 1; i >= 0; i--) {
    res[i] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b2) {
  const arr = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b2[i];
  }
  return arr;
}
function isBytes2(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  isBytes2(msg);
  isBytes2(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b2 = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b2[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i = 1; i <= ell; i++) {
    const args = [strxor(b_0, b2[i - 1]), i2osp(i + 1, 1), DST_prime];
    b2[i] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b2);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  isBytes2(msg);
  isBytes2(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash4, expand, DST: _DST } = options;
  isBytes2(msg);
  isNum(count);
  const DST = validateDST(_DST);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count * m * L;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash4);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash4);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count);
  for (let i = 0; i < count; i++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i) => Array.from(i).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point3, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u[0]));
      const u1 = Point3.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point3.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}
var os2ip;
var init_hash_to_curve = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/abstract/hash-to-curve.js"() {
    init_modular();
    init_utils5();
    os2ip = bytesToNumberBE;
  }
});

// node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash4) {
  return {
    hash: hash4,
    hmac: (key2, ...msgs) => hmac2(hash4, key2, concatBytes(...msgs)),
    randomBytes: randomBytes2
  };
}
function createCurve(curveDef, defHash) {
  const create3 = (hash4) => weierstrass({ ...curveDef, ...getHash(hash4) });
  return Object.freeze({ ...create3(defHash), create: create3 });
}
var init_shortw_utils = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/_shortw_utils.js"() {
    init_hmac();
    init_utils4();
    init_weierstrass();
  }
});

// node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/secp256k1.js
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2563(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2563(concatBytes2(tagP, ...messages));
}
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point2.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n5 !== _0n6)
    y = modP(-y);
  const p = new Point2(x, y, _1n6);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes2(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand2 = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand2));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature2, message, publicKey) {
  const sig = ensureBytes("signature", signature2, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r2 = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r2))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r2), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r2)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var secp256k1P, secp256k1N, _1n6, _2n5, divNearest, Fp, secp256k1, _0n6, fe, ge, TAGGED_HASH_PREFIXES, pointToBytes, numTo32b, modP, modN, Point2, GmulAdd, schnorr, isoMap, mapSWU, htf, hashToCurve, encodeToCurve;
var init_secp256k1 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@noble/curves/esm/secp256k1.js"() {
    init_sha256();
    init_utils4();
    init_modular();
    init_weierstrass();
    init_utils5();
    init_hash_to_curve();
    init_shortw_utils();
    secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    _1n6 = BigInt(1);
    _2n5 = BigInt(2);
    divNearest = (a, b2) => (a + b2 / _2n5) / b2;
    Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    secp256k1 = createCurve({
      a: BigInt(0),
      b: BigInt(7),
      Fp,
      n: secp256k1N,
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n2 = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n2);
          const c2 = divNearest(-b1 * k, n2);
          let k1 = mod(k - c1 * a1 - c2 * a2, n2);
          let k2 = mod(-c1 * b1 - c2 * b2, n2);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n2 - k1;
          if (k2neg)
            k2 = n2 - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha2563);
    _0n6 = BigInt(0);
    fe = (x) => typeof x === "bigint" && _0n6 < x && x < secp256k1P;
    ge = (x) => typeof x === "bigint" && _0n6 < x && x < secp256k1N;
    TAGGED_HASH_PREFIXES = {};
    pointToBytes = (point3) => point3.toRawBytes(true).slice(1);
    numTo32b = (n2) => numberToBytesBE(n2, 32);
    modP = (x) => mod(x, secp256k1P);
    modN = (x) => mod(x, secp256k1N);
    Point2 = secp256k1.ProjectivePoint;
    GmulAdd = (Q, a, b2) => Point2.BASE.multiplyAndAddUnsafe(Q, a, b2);
    schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE,
        bytesToNumberBE,
        taggedHash,
        mod
      }
    }))();
    isoMap = (() => isogenyMap(Fp, [
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
      ],
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    mapSWU = (() => mapToCurveSimpleSWU(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2563
    }))();
    hashToCurve = (() => htf.hashToCurve)();
    encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress;
var init_addresses2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/addresses.js"() {
    ZeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash;
var init_hashes2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/hashes.js"() {
    ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/numbers.js
var N2, WeiPerEther2, MaxUint2563, MinInt2562, MaxInt2562;
var init_numbers = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/numbers.js"() {
    N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    WeiPerEther2 = BigInt("1000000000000000000");
    MaxUint2563 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    MinInt2562 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
    MaxInt2562 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/strings.js
var MessagePrefix;
var init_strings2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/strings.js"() {
    MessagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/index.js
var init_constants = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/constants/index.js"() {
    init_addresses2();
    init_hashes2();
    init_numbers();
    init_strings2();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/signature.js
function toUint256(value) {
  return zeroPadValue(toBeArray(value), 32);
}
var BN_04, BN_13, BN_2, BN_27, BN_28, BN_35, _guard3, _r, _s, _v, _networkV, _Signature, Signature2;
var init_signature = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/signature.js"() {
    init_constants();
    init_utils3();
    BN_04 = BigInt(0);
    BN_13 = BigInt(1);
    BN_2 = BigInt(2);
    BN_27 = BigInt(27);
    BN_28 = BigInt(28);
    BN_35 = BigInt(35);
    _guard3 = {};
    _Signature = class {
      constructor(guard, r2, s, v) {
        __privateAdd(this, _r, void 0);
        __privateAdd(this, _s, void 0);
        __privateAdd(this, _v, void 0);
        __privateAdd(this, _networkV, void 0);
        assertPrivate(guard, _guard3, "Signature");
        __privateSet(this, _r, r2);
        __privateSet(this, _s, s);
        __privateSet(this, _v, v);
        __privateSet(this, _networkV, null);
      }
      get r() {
        return __privateGet(this, _r);
      }
      set r(value) {
        assertArgument(dataLength(value) === 32, "invalid r", "value", value);
        __privateSet(this, _r, hexlify2(value));
      }
      get s() {
        return __privateGet(this, _s);
      }
      set s(_value2) {
        assertArgument(dataLength(_value2) === 32, "invalid s", "value", _value2);
        const value = hexlify2(_value2);
        assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
        __privateSet(this, _s, value);
      }
      get v() {
        return __privateGet(this, _v);
      }
      set v(value) {
        const v = getNumber(value, "value");
        assertArgument(v === 27 || v === 28, "invalid v", "v", value);
        __privateSet(this, _v, v);
      }
      get networkV() {
        return __privateGet(this, _networkV);
      }
      get legacyChainId() {
        const v = this.networkV;
        if (v == null) {
          return null;
        }
        return _Signature.getChainId(v);
      }
      get yParity() {
        return this.v === 27 ? 0 : 1;
      }
      get yParityAndS() {
        const yParityAndS = getBytes(this.s);
        if (this.yParity) {
          yParityAndS[0] |= 128;
        }
        return hexlify2(yParityAndS);
      }
      get compactSerialized() {
        return concat2([this.r, this.yParityAndS]);
      }
      get serialized() {
        return concat2([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
      }
      clone() {
        const clone = new _Signature(_guard3, this.r, this.s, this.v);
        if (this.networkV) {
          __privateSet(clone, _networkV, this.networkV);
        }
        return clone;
      }
      toJSON() {
        const networkV = this.networkV;
        return {
          _type: "signature",
          networkV: networkV != null ? networkV.toString() : null,
          r: this.r,
          s: this.s,
          v: this.v
        };
      }
      static getChainId(v) {
        const bv = getBigInt(v, "v");
        if (bv == BN_27 || bv == BN_28) {
          return BN_04;
        }
        assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v);
        return (bv - BN_35) / BN_2;
      }
      static getChainIdV(chainId, v) {
        return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
      }
      static getNormalizedV(v) {
        const bv = getBigInt(v);
        if (bv === BN_04 || bv === BN_27) {
          return 27;
        }
        if (bv === BN_13 || bv === BN_28) {
          return 28;
        }
        assertArgument(bv >= BN_35, "invalid v", "v", v);
        return bv & BN_13 ? 27 : 28;
      }
      static from(sig) {
        function assertError(check2, message) {
          assertArgument(check2, message, "signature", sig);
        }
        ;
        if (sig == null) {
          return new _Signature(_guard3, ZeroHash, ZeroHash, 27);
        }
        if (typeof sig === "string") {
          const bytes3 = getBytes(sig, "signature");
          if (bytes3.length === 64) {
            const r3 = hexlify2(bytes3.slice(0, 32));
            const s2 = bytes3.slice(32, 64);
            const v2 = s2[0] & 128 ? 28 : 27;
            s2[0] &= 127;
            return new _Signature(_guard3, r3, hexlify2(s2), v2);
          }
          if (bytes3.length === 65) {
            const r3 = hexlify2(bytes3.slice(0, 32));
            const s2 = bytes3.slice(32, 64);
            assertError((s2[0] & 128) === 0, "non-canonical s");
            const v2 = _Signature.getNormalizedV(bytes3[64]);
            return new _Signature(_guard3, r3, hexlify2(s2), v2);
          }
          assertError(false, "invalid raw signature length");
        }
        if (sig instanceof _Signature) {
          return sig.clone();
        }
        const _r2 = sig.r;
        assertError(_r2 != null, "missing r");
        const r2 = toUint256(_r2);
        const s = function(s2, yParityAndS) {
          if (s2 != null) {
            return toUint256(s2);
          }
          if (yParityAndS != null) {
            assertError(isHexString2(yParityAndS, 32), "invalid yParityAndS");
            const bytes3 = getBytes(yParityAndS);
            bytes3[0] &= 127;
            return hexlify2(bytes3);
          }
          assertError(false, "missing s");
        }(sig.s, sig.yParityAndS);
        assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
        const { networkV, v } = function(_v2, yParityAndS, yParity) {
          if (_v2 != null) {
            const v2 = getBigInt(_v2);
            return {
              networkV: v2 >= BN_35 ? v2 : void 0,
              v: _Signature.getNormalizedV(v2)
            };
          }
          if (yParityAndS != null) {
            assertError(isHexString2(yParityAndS, 32), "invalid yParityAndS");
            return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
          }
          if (yParity != null) {
            switch (getNumber(yParity, "sig.yParity")) {
              case 0:
                return { v: 27 };
              case 1:
                return { v: 28 };
            }
            assertError(false, "invalid yParity");
          }
          assertError(false, "missing v");
        }(sig.v, sig.yParityAndS, sig.yParity);
        const result = new _Signature(_guard3, r2, s, v);
        if (networkV) {
          __privateSet(result, _networkV, networkV);
        }
        assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
        assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
        return result;
      }
    };
    Signature2 = _Signature;
    _r = new WeakMap();
    _s = new WeakMap();
    _v = new WeakMap();
    _networkV = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/signing-key.js
var _privateKey, _SigningKey, SigningKey2;
var init_signing_key = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/signing-key.js"() {
    init_secp256k1();
    init_utils3();
    init_signature();
    _SigningKey = class {
      constructor(privateKey) {
        __privateAdd(this, _privateKey, void 0);
        assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
        __privateSet(this, _privateKey, hexlify2(privateKey));
      }
      get privateKey() {
        return __privateGet(this, _privateKey);
      }
      get publicKey() {
        return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
      }
      get compressedPublicKey() {
        return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
      }
      sign(digest) {
        assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
        const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(__privateGet(this, _privateKey)), {
          lowS: true
        });
        return Signature2.from({
          r: toBeHex(sig.r, 32),
          s: toBeHex(sig.s, 32),
          v: sig.recovery ? 28 : 27
        });
      }
      computeSharedSecret(other) {
        const pubKey = _SigningKey.computePublicKey(other);
        return hexlify2(secp256k1.getSharedSecret(getBytesCopy(__privateGet(this, _privateKey)), getBytes(pubKey), false));
      }
      static computePublicKey(key2, compressed) {
        let bytes3 = getBytes(key2, "key");
        if (bytes3.length === 32) {
          const pubKey = secp256k1.getPublicKey(bytes3, !!compressed);
          return hexlify2(pubKey);
        }
        if (bytes3.length === 64) {
          const pub = new Uint8Array(65);
          pub[0] = 4;
          pub.set(bytes3, 1);
          bytes3 = pub;
        }
        const point3 = secp256k1.ProjectivePoint.fromHex(bytes3);
        return hexlify2(point3.toRawBytes(compressed));
      }
      static recoverPublicKey(digest, signature2) {
        assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
        const sig = Signature2.from(signature2);
        let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat2([sig.r, sig.s])));
        secpSig = secpSig.addRecoveryBit(sig.yParity);
        const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
        assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature2);
        return "0x" + pubKey.toHex(false);
      }
      static addPoints(p0, p1, compressed) {
        const pub0 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
        const pub1 = secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
        return "0x" + pub0.add(pub1).toHex(!!compressed);
      }
    };
    SigningKey2 = _SigningKey;
    _privateKey = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/index.js
var init_crypto2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/crypto/index.js"() {
    init_hmac2();
    init_keccak();
    init_ripemd1602();
    init_pbkdf23();
    init_random2();
    init_scrypt2();
    init_sha23();
    init_signing_key();
    init_signature();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/address.js
function getChecksumAddress2(address) {
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak2563(expanded));
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
function ibanChecksum2(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c) => {
    return ibanLookup2[c];
  }).join("");
  while (expanded.length >= safeDigits2) {
    let block = expanded.substring(0, safeDigits2);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum2 = String(98 - parseInt(expanded, 10) % 97);
  while (checksum2.length < 2) {
    checksum2 = "0" + checksum2;
  }
  return checksum2;
}
function fromBase36(value) {
  value = value.toLowerCase();
  let result = BN_05;
  for (let i = 0; i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
}
function getAddress2(address) {
  assertArgument(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    const result = getChecksumAddress2(address);
    assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address.substring(2, 4) === ibanChecksum2(address), "bad icap checksum", "address", address);
    let result = fromBase36(address.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress2("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address);
}
var BN_05, BN_36, ibanLookup2, safeDigits2, Base36;
var init_address2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/address.js"() {
    init_crypto2();
    init_utils3();
    BN_05 = BigInt(0);
    BN_36 = BigInt(36);
    ibanLookup2 = {};
    for (let i = 0; i < 10; i++) {
      ibanLookup2[String(i)] = String(i);
    }
    for (let i = 0; i < 26; i++) {
      ibanLookup2[String.fromCharCode(65 + i)] = String(10 + i);
    }
    safeDigits2 = 15;
    Base36 = function() {
      ;
      const result = {};
      for (let i = 0; i < 36; i++) {
        const key2 = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
        result[key2] = BigInt(i);
      }
      return result;
    }();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress(tx) {
  const from = getAddress2(tx.from);
  const nonce = getBigInt(tx.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress2(dataSlice(keccak2563(encodeRlp([from, nonceHex])), 12));
}
var init_contract_address = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/contract-address.js"() {
    init_crypto2();
    init_utils3();
    init_address2();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/checks.js
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
async function checkAddress(target, promise2) {
  const result = await promise2;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert2(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress2(result);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress2(target);
    }
    assert2(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
var init_checks = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/checks.js"() {
    init_utils3();
    init_address2();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/index.js
var init_address3 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/address/index.js"() {
    init_address2();
    init_contract_address();
    init_checks();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/typed.js
function n(value, width) {
  let signed3 = false;
  if (width < 0) {
    signed3 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed3 ? "" : "u"}int${width}`, value, { signed: signed3, width });
}
function b(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
}
var _gaurd, _typedSymbol, _options, _Typed, Typed;
var init_typed = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/typed.js"() {
    init_utils3();
    _gaurd = {};
    _typedSymbol = Symbol.for("_ethers_typed");
    _Typed = class {
      constructor(gaurd, type, value, options) {
        __publicField(this, "type");
        __publicField(this, "value");
        __privateAdd(this, _options, void 0);
        __publicField(this, "_typedSymbol");
        if (options == null) {
          options = null;
        }
        assertPrivate(_gaurd, gaurd, "Typed");
        defineProperties(this, { _typedSymbol, type, value });
        __privateSet(this, _options, options);
        this.format();
      }
      format() {
        if (this.type === "array") {
          throw new Error("");
        } else if (this.type === "dynamicArray") {
          throw new Error("");
        } else if (this.type === "tuple") {
          return `tuple(${this.value.map((v) => v.format()).join(",")})`;
        }
        return this.type;
      }
      defaultValue() {
        return 0;
      }
      minValue() {
        return 0;
      }
      maxValue() {
        return 0;
      }
      isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/);
      }
      isData() {
        return this.type.startsWith("bytes");
      }
      isString() {
        return this.type === "string";
      }
      get tupleName() {
        if (this.type !== "tuple") {
          throw TypeError("not a tuple");
        }
        return __privateGet(this, _options);
      }
      get arrayLength() {
        if (this.type !== "array") {
          throw TypeError("not an array");
        }
        if (__privateGet(this, _options) === true) {
          return -1;
        }
        if (__privateGet(this, _options) === false) {
          return this.value.length;
        }
        return null;
      }
      static from(type, value) {
        return new _Typed(_gaurd, type, value);
      }
      static uint8(v) {
        return n(v, 8);
      }
      static uint16(v) {
        return n(v, 16);
      }
      static uint24(v) {
        return n(v, 24);
      }
      static uint32(v) {
        return n(v, 32);
      }
      static uint40(v) {
        return n(v, 40);
      }
      static uint48(v) {
        return n(v, 48);
      }
      static uint56(v) {
        return n(v, 56);
      }
      static uint64(v) {
        return n(v, 64);
      }
      static uint72(v) {
        return n(v, 72);
      }
      static uint80(v) {
        return n(v, 80);
      }
      static uint88(v) {
        return n(v, 88);
      }
      static uint96(v) {
        return n(v, 96);
      }
      static uint104(v) {
        return n(v, 104);
      }
      static uint112(v) {
        return n(v, 112);
      }
      static uint120(v) {
        return n(v, 120);
      }
      static uint128(v) {
        return n(v, 128);
      }
      static uint136(v) {
        return n(v, 136);
      }
      static uint144(v) {
        return n(v, 144);
      }
      static uint152(v) {
        return n(v, 152);
      }
      static uint160(v) {
        return n(v, 160);
      }
      static uint168(v) {
        return n(v, 168);
      }
      static uint176(v) {
        return n(v, 176);
      }
      static uint184(v) {
        return n(v, 184);
      }
      static uint192(v) {
        return n(v, 192);
      }
      static uint200(v) {
        return n(v, 200);
      }
      static uint208(v) {
        return n(v, 208);
      }
      static uint216(v) {
        return n(v, 216);
      }
      static uint224(v) {
        return n(v, 224);
      }
      static uint232(v) {
        return n(v, 232);
      }
      static uint240(v) {
        return n(v, 240);
      }
      static uint248(v) {
        return n(v, 248);
      }
      static uint256(v) {
        return n(v, 256);
      }
      static uint(v) {
        return n(v, 256);
      }
      static int8(v) {
        return n(v, -8);
      }
      static int16(v) {
        return n(v, -16);
      }
      static int24(v) {
        return n(v, -24);
      }
      static int32(v) {
        return n(v, -32);
      }
      static int40(v) {
        return n(v, -40);
      }
      static int48(v) {
        return n(v, -48);
      }
      static int56(v) {
        return n(v, -56);
      }
      static int64(v) {
        return n(v, -64);
      }
      static int72(v) {
        return n(v, -72);
      }
      static int80(v) {
        return n(v, -80);
      }
      static int88(v) {
        return n(v, -88);
      }
      static int96(v) {
        return n(v, -96);
      }
      static int104(v) {
        return n(v, -104);
      }
      static int112(v) {
        return n(v, -112);
      }
      static int120(v) {
        return n(v, -120);
      }
      static int128(v) {
        return n(v, -128);
      }
      static int136(v) {
        return n(v, -136);
      }
      static int144(v) {
        return n(v, -144);
      }
      static int152(v) {
        return n(v, -152);
      }
      static int160(v) {
        return n(v, -160);
      }
      static int168(v) {
        return n(v, -168);
      }
      static int176(v) {
        return n(v, -176);
      }
      static int184(v) {
        return n(v, -184);
      }
      static int192(v) {
        return n(v, -192);
      }
      static int200(v) {
        return n(v, -200);
      }
      static int208(v) {
        return n(v, -208);
      }
      static int216(v) {
        return n(v, -216);
      }
      static int224(v) {
        return n(v, -224);
      }
      static int232(v) {
        return n(v, -232);
      }
      static int240(v) {
        return n(v, -240);
      }
      static int248(v) {
        return n(v, -248);
      }
      static int256(v) {
        return n(v, -256);
      }
      static int(v) {
        return n(v, -256);
      }
      static bytes1(v) {
        return b(v, 1);
      }
      static bytes2(v) {
        return b(v, 2);
      }
      static bytes3(v) {
        return b(v, 3);
      }
      static bytes4(v) {
        return b(v, 4);
      }
      static bytes5(v) {
        return b(v, 5);
      }
      static bytes6(v) {
        return b(v, 6);
      }
      static bytes7(v) {
        return b(v, 7);
      }
      static bytes8(v) {
        return b(v, 8);
      }
      static bytes9(v) {
        return b(v, 9);
      }
      static bytes10(v) {
        return b(v, 10);
      }
      static bytes11(v) {
        return b(v, 11);
      }
      static bytes12(v) {
        return b(v, 12);
      }
      static bytes13(v) {
        return b(v, 13);
      }
      static bytes14(v) {
        return b(v, 14);
      }
      static bytes15(v) {
        return b(v, 15);
      }
      static bytes16(v) {
        return b(v, 16);
      }
      static bytes17(v) {
        return b(v, 17);
      }
      static bytes18(v) {
        return b(v, 18);
      }
      static bytes19(v) {
        return b(v, 19);
      }
      static bytes20(v) {
        return b(v, 20);
      }
      static bytes21(v) {
        return b(v, 21);
      }
      static bytes22(v) {
        return b(v, 22);
      }
      static bytes23(v) {
        return b(v, 23);
      }
      static bytes24(v) {
        return b(v, 24);
      }
      static bytes25(v) {
        return b(v, 25);
      }
      static bytes26(v) {
        return b(v, 26);
      }
      static bytes27(v) {
        return b(v, 27);
      }
      static bytes28(v) {
        return b(v, 28);
      }
      static bytes29(v) {
        return b(v, 29);
      }
      static bytes30(v) {
        return b(v, 30);
      }
      static bytes31(v) {
        return b(v, 31);
      }
      static bytes32(v) {
        return b(v, 32);
      }
      static address(v) {
        return new _Typed(_gaurd, "address", v);
      }
      static bool(v) {
        return new _Typed(_gaurd, "bool", !!v);
      }
      static bytes(v) {
        return new _Typed(_gaurd, "bytes", v);
      }
      static string(v) {
        return new _Typed(_gaurd, "string", v);
      }
      static array(v, dynamic) {
        throw new Error("not implemented yet");
        return new _Typed(_gaurd, "array", v, dynamic);
      }
      static tuple(v, name) {
        throw new Error("not implemented yet");
        return new _Typed(_gaurd, "tuple", v, name);
      }
      static overrides(v) {
        return new _Typed(_gaurd, "overrides", Object.assign({}, v));
      }
      static isTyped(value) {
        return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
      }
      static dereference(value, type) {
        if (_Typed.isTyped(value)) {
          if (value.type !== type) {
            throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
          }
          return value.value;
        }
        return value;
      }
    };
    Typed = _Typed;
    _options = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/address.js
var AddressCoder2;
var init_address4 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/address.js"() {
    init_address3();
    init_maths();
    init_typed();
    init_abstract_coder2();
    AddressCoder2 = class extends Coder2 {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, _value2) {
        let value = Typed.dereference(_value2, "string");
        try {
          value = getAddress2(value);
        } catch (error) {
          return this._throwError(error.message, _value2);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        return getAddress2(toBeHex(reader.readValue(), 20));
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/anonymous.js
var AnonymousCoder2;
var init_anonymous2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/anonymous.js"() {
    init_abstract_coder2();
    AnonymousCoder2 = class extends Coder2 {
      constructor(coder) {
        super(coder.name, coder.type, "_", coder.dynamic);
        __publicField(this, "coder");
        this.coder = coder;
      }
      defaultValue() {
        return this.coder.defaultValue();
      }
      encode(writer, value) {
        return this.coder.encode(writer, value);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/array.js
function pack3(writer, coders, values2) {
  let arrayValues = [];
  if (Array.isArray(values2)) {
    arrayValues = values2;
  } else if (values2 && typeof values2 === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert2(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values2 });
      assert2(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values2 });
      unique[name] = true;
      return values2[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values2);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values2);
  let staticWriter = new Writer2();
  let dynamicWriter = new Writer2();
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack3(reader, coders) {
  let values2 = [];
  let keys3 = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == void 0) {
      throw new Error("investigate");
    }
    values2.push(value);
    keys3.push(coder.localName || null);
  });
  return Result.fromItems(values2, keys3);
}
var ArrayCoder2;
var init_array2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/array.js"() {
    init_utils3();
    init_typed();
    init_abstract_coder2();
    init_anonymous2();
    ArrayCoder2 = class extends Coder2 {
      constructor(coder, length, localName) {
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        __publicField(this, "coder");
        __publicField(this, "length");
        defineProperties(this, { coder, length });
      }
      defaultValue() {
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
          result.push(defaultChild);
        }
        return result;
      }
      encode(writer, _value2) {
        const value = Typed.dereference(_value2, "array");
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
          coders.push(this.coder);
        }
        return pack3(writer, coders, value);
      }
      decode(reader) {
        let count = this.length;
        if (count === -1) {
          count = reader.readIndex();
          assert2(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
          coders.push(new AnonymousCoder2(this.coder));
        }
        return unpack3(reader, coders);
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/boolean.js
var BooleanCoder2;
var init_boolean2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/boolean.js"() {
    init_typed();
    init_abstract_coder2();
    BooleanCoder2 = class extends Coder2 {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      defaultValue() {
        return false;
      }
      encode(writer, _value2) {
        const value = Typed.dereference(_value2, "bool");
        return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
        return !!reader.readValue();
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/bytes.js
var DynamicBytesCoder2, BytesCoder2;
var init_bytes2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/bytes.js"() {
    init_utils3();
    init_abstract_coder2();
    DynamicBytesCoder2 = class extends Coder2 {
      constructor(type, localName) {
        super(type, type, localName, true);
      }
      defaultValue() {
        return "0x";
      }
      encode(writer, value) {
        value = getBytesCopy(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
      }
      decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
      }
    };
    BytesCoder2 = class extends DynamicBytesCoder2 {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return hexlify2(super.decode(reader));
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
var FixedBytesCoder2;
var init_fixed_bytes2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js"() {
    init_utils3();
    init_typed();
    init_abstract_coder2();
    FixedBytesCoder2 = class extends Coder2 {
      constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        __publicField(this, "size");
        defineProperties(this, { size }, { size: "number" });
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
      encode(writer, _value2) {
        let data2 = getBytesCopy(Typed.dereference(_value2, this.type));
        if (data2.length !== this.size) {
          this._throwError("incorrect data length", _value2);
        }
        return writer.writeBytes(data2);
      }
      decode(reader) {
        return hexlify2(reader.readBytes(this.size));
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/null.js
var Empty, NullCoder2;
var init_null2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/null.js"() {
    init_abstract_coder2();
    Empty = new Uint8Array([]);
    NullCoder2 = class extends Coder2 {
      constructor(localName) {
        super("null", "", localName, false);
      }
      defaultValue() {
        return null;
      }
      encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
      }
      decode(reader) {
        reader.readBytes(0);
        return null;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/number.js
var BN_06, BN_14, BN_MAX_UINT256, NumberCoder2;
var init_number2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/number.js"() {
    init_utils3();
    init_typed();
    init_abstract_coder2();
    BN_06 = BigInt(0);
    BN_14 = BigInt(1);
    BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    NumberCoder2 = class extends Coder2 {
      constructor(size, signed3, localName) {
        const name = (signed3 ? "int" : "uint") + size * 8;
        super(name, name, localName, false);
        __publicField(this, "size");
        __publicField(this, "signed");
        defineProperties(this, { size, signed: signed3 }, { size: "number", signed: "boolean" });
      }
      defaultValue() {
        return 0;
      }
      encode(writer, _value2) {
        let value = getBigInt(Typed.dereference(_value2, this.type));
        let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);
        if (this.signed) {
          let bounds = mask(maxUintValue, this.size * 8 - 1);
          if (value > bounds || value < -(bounds + BN_14)) {
            this._throwError("value out-of-bounds", _value2);
          }
          value = toTwos(value, 8 * WordSize);
        } else if (value < BN_06 || value > mask(maxUintValue, this.size * 8)) {
          this._throwError("value out-of-bounds", _value2);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        let value = mask(reader.readValue(), this.size * 8);
        if (this.signed) {
          value = fromTwos(value, this.size * 8);
        }
        return value;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/string.js
var StringCoder2;
var init_string2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/string.js"() {
    init_utf82();
    init_typed();
    init_bytes2();
    StringCoder2 = class extends DynamicBytesCoder2 {
      constructor(localName) {
        super("string", localName);
      }
      defaultValue() {
        return "";
      }
      encode(writer, _value2) {
        return super.encode(writer, toUtf8Bytes2(Typed.dereference(_value2, "string")));
      }
      decode(reader) {
        return toUtf8String2(super.decode(reader));
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/tuple.js
var TupleCoder2;
var init_tuple2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/coders/tuple.js"() {
    init_properties();
    init_typed();
    init_abstract_coder2();
    init_array2();
    TupleCoder2 = class extends Coder2 {
      constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        __publicField(this, "coders");
        defineProperties(this, { coders: Object.freeze(coders.slice()) });
      }
      defaultValue() {
        const values2 = [];
        this.coders.forEach((coder) => {
          values2.push(coder.defaultValue());
        });
        const uniqueNames = this.coders.reduce((accum, coder) => {
          const name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        this.coders.forEach((coder, index) => {
          let name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values2[name] != null) {
            return;
          }
          values2[name] = values2[index];
        });
        return Object.freeze(values2);
      }
      encode(writer, _value2) {
        const value = Typed.dereference(_value2, "tuple");
        return pack3(writer, this.coders, value);
      }
      decode(reader) {
        return unpack3(reader, this.coders);
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/id.js
function id2(value) {
  return keccak2563(toUtf8Bytes2(value));
}
var init_id2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/id.js"() {
    init_crypto2();
    init_utils3();
  }
});

// node_modules/@shazow/whatsabi/node_modules/@adraffy/ens-normalize/dist/index.mjs
function decode_arithmetic2(bytes3) {
  let pos = 0;
  function u16() {
    return bytes3[pos++] << 8 | bytes3[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes3[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N4 = 31;
  const FULL = 2 ** N4;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N4; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 2:
        return offset + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
      case 1:
        return offset + bytes3[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload2(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload2(s) {
  return read_payload2(decode_arithmetic2(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n2 = s.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n2; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed2(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas2(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0; i < n2; i++)
    v[i] = x += signed2(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n2 = next();
    if (!n2)
      break;
    prev += x;
    for (let i = 0; i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length)
      return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table2(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table2(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x)
      break;
    v.push(x);
  }
  return v;
}
function read_transposed2(n2, w, next) {
  let m = Array(n2).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas2(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table2(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed2(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table2(w, next) {
  let n2 = 1 + next();
  let m = read_transposed2(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode4([]), []);
  return ret;
  function decode4(Q) {
    let S2 = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length)
        return decode4(cps);
    });
    return { S: S2, B, Q };
  }
  function expand({ S: S2, B }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1])
      return;
    if (S2 & 2)
      saved = cps[cps.length - 1];
    if (S2 & 1)
      ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp2(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a, b2) {
  let n2 = a.length;
  let c = n2 - b2.length;
  for (let i = 0; c == 0 && i < n2; i++)
    c = a[i] - b2[i];
  return c;
}
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
function init$1() {
  let r2 = read_compressed_payload2(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r2).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r2));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r2)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b2] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a, bucket);
      }
      bucket.set(b2, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b2) {
  if (a >= L0 && a < L1 && b2 >= V0 && b2 < V1) {
    return S0 + (a - L0) * N_COUNT + (b2 - V0) * T_COUNT;
  } else if (is_hangul(a) && b2 > T0 && b2 < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b2 - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK)
    init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add4(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add4(L0 + l_index);
        add4(V0 + v_index);
        if (t_index > 0)
          add4(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add4(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc2(cps) {
  return composed_from_decomposed(decomposed(cps));
}
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
function init2() {
  if (MAPPED2)
    return;
  let r2 = read_compressed_payload2(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r2);
  const read_sorted_set = () => new Set(read_sorted_array());
  MAPPED2 = new Map(read_mapped(r2));
  IGNORED2 = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r2);
  let unrestricted = r2();
  const read_chunked = () => new Set(read_sorted_array().flatMap((i) => chunks[i]).concat(read_sorted_array()));
  GROUPS = read_array_while((i) => {
    let N4 = read_array_while(r2).map((x) => x + 96);
    if (N4.length) {
      let R = i >= unrestricted;
      N4[0] -= 32;
      N4 = str_from_cps(N4);
      if (R)
        N4 = `Restricted[${N4}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r2();
      return { N: N4, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b2) => a - b2);
  wholes.forEach((cp, i) => {
    let d = r2();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      gs.forEach((g) => rec.G.add(g));
    }
    let union2 = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union2.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  let union = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => union.has(cp) ? multi.add(cp) : union.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P)
      add_to_union(cp);
    for (let cp of g.Q)
      add_to_union(cp);
  }
  for (let cp of union) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  VALID2 = new Set(Array_from(union).concat(Array_from(nfd(union))));
  EMOJI_LIST = read_trie(r2).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT2 = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT2];
    for (let cp of cps) {
      let next = prev.map((node2) => {
        let child = node2.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node2.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"\u200E`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN2 && cps[3] == HYPHEN2) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE2 = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE2); i > 0; ) {
    if (cps[--i] !== UNDERSCORE2) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i = 1; i < n2; i++) {
    cp = cps[i];
    let match2 = FENCED.get(cp);
    if (match2) {
      if (last == i)
        throw error_placement(`${prev} + ${match2}`);
      last = i + 1;
      prev = match2;
    }
  }
  if (last == n2)
    throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("\u25CC");
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0; i < n2; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp) {
  init2();
  return CM.has(cp);
}
function should_escape(cp) {
  init2();
  return ESCAPE.has(cp);
}
function ens_normalize2(name) {
  return flatten2(split2(name, nfc2, filter_fe0f2));
}
function split2(name, nf, ef) {
  if (!name)
    return [];
  init2();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp2(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0]))
            throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared2 = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set2 = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set2.has(g)) : Array_from(set2);
      if (!maker.length)
        return;
    } else {
      shared2.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared2.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
}
function flatten2(split4) {
  return split4.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split4.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed2(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID2.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED2.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED2.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f2(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed2(cps, eaten) {
  let node2 = EMOJI_ROOT2;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node2 = node2.get(cps[--pos]);
    if (!node2)
      break;
    let { V } = node2;
    if (V) {
      emoji = V;
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
var COMPRESSED$1, FENCED, NSM_MAX, COMPRESSED, S0, L0, V0, T0, L_COUNT, V_COUNT, T_COUNT, N_COUNT, S_COUNT, S1, L1, V1, T1, SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP, HYPHEN2, STOP_CH, FE0F, UNIQUE_PH, Array_from, Emoji, MAPPED2, IGNORED2, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID2, EMOJI_LIST, EMOJI_ROOT2;
var init_dist2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/@adraffy/ens-normalize/dist/index.mjs"() {
    COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
    FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
    NSM_MAX = 4;
    COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
    S0 = 44032;
    L0 = 4352;
    V0 = 4449;
    T0 = 4519;
    L_COUNT = 19;
    V_COUNT = 21;
    T_COUNT = 28;
    N_COUNT = V_COUNT * T_COUNT;
    S_COUNT = L_COUNT * N_COUNT;
    S1 = S0 + S_COUNT;
    L1 = L0 + L_COUNT;
    V1 = V0 + V_COUNT;
    T1 = T0 + T_COUNT;
    HYPHEN2 = 45;
    STOP_CH = ".";
    FE0F = 65039;
    UNIQUE_PH = 1;
    Array_from = (x) => Array.from(x);
    Emoji = class extends Array {
      get is_emoji() {
        return true;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/namehash.js
function checkComponent2(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit2(name) {
  const bytes3 = toUtf8Bytes2(ensNormalize2(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0; i < bytes3.length; i++) {
    const d = bytes3[i];
    if (d === 46) {
      comps.push(checkComponent2(bytes3.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes3.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent2(bytes3.slice(last)));
  return comps;
}
function ensNormalize2(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return ens_normalize2(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function namehash2(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
  let result = Zeros4;
  const comps = ensNameSplit2(name);
  while (comps.length) {
    result = keccak2563(concat2([result, keccak2563(comps.pop())]));
  }
  return hexlify2(result);
}
function dnsEncode2(name) {
  return hexlify2(concat2(ensNameSplit2(name).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes3 = new Uint8Array(comp.length + 1);
    bytes3.set(comp, 1);
    bytes3[0] = bytes3.length - 1;
    return bytes3;
  }))) + "00";
}
var Zeros4;
var init_namehash2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/namehash.js"() {
    init_crypto2();
    init_utils3();
    init_dist2();
    Zeros4 = new Uint8Array(32);
    Zeros4.fill(0);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/accesslist.js
function accessSetify2(addr, storageKeys) {
  return {
    address: getAddress2(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString2(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
}
function accessListify2(value) {
  if (Array.isArray(value)) {
    return value.map((set2, index) => {
      if (Array.isArray(set2)) {
        assertArgument(set2.length === 2, "invalid slot set", `value[${index}]`, set2);
        return accessSetify2(set2[0], set2[1]);
      }
      assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value);
      return accessSetify2(set2.address, set2.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify2(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
var init_accesslist = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/accesslist.js"() {
    init_address3();
    init_utils3();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/address.js
function computeAddress2(key2) {
  let pubkey;
  if (typeof key2 === "string") {
    pubkey = SigningKey2.computePublicKey(key2, false);
  } else {
    pubkey = key2.publicKey;
  }
  return getAddress2(keccak2563("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress2(digest, signature2) {
  return computeAddress2(SigningKey2.recoverPublicKey(digest, signature2));
}
var init_address5 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/address.js"() {
    init_address3();
    init_crypto2();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/transaction.js
function handleAddress2(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress2(value);
}
function handleAccessList(value, param) {
  try {
    return accessListify2(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
}
function handleNumber2(_value2, param) {
  if (_value2 === "0x") {
    return 0;
  }
  return getNumber(_value2, param);
}
function handleUint(_value2, param) {
  if (_value2 === "0x") {
    return BN_07;
  }
  const value = getBigInt(_value2, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber2(_value2, name) {
  const value = getBigInt(_value2, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
}
function formatAccessList2(value) {
  return accessListify2(value).map((set2) => [set2.address, set2.storageKeys]);
}
function _parseLegacy(data2) {
  const fields = decodeRlp(data2);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data2);
  const tx = {
    type: 0,
    nonce: handleNumber2(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress2(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify2(fields[5]),
    chainId: BN_07
  };
  if (fields.length === 6) {
    return tx;
  }
  const v = handleUint(fields[6], "v");
  const r2 = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r2 === BN_07 && s === BN_07) {
    tx.chainId = v;
  } else {
    let chainId = (v - BN_352) / BN_22;
    if (chainId < BN_07) {
      chainId = BN_07;
    }
    tx.chainId = chainId;
    assertArgument(chainId !== BN_07 || (v === BN_272 || v === BN_282), "non-canonical legacy v", "v", fields[6]);
    tx.signature = Signature2.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
    tx.hash = keccak2563(data2);
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  const fields = [
    formatNumber2(tx.nonce || 0, "nonce"),
    formatNumber2(tx.gasPrice || 0, "gasPrice"),
    formatNumber2(tx.gasLimit || 0, "gasLimit"),
    tx.to != null ? getAddress2(tx.to) : "0x",
    formatNumber2(tx.value || 0, "value"),
    tx.data || "0x"
  ];
  let chainId = BN_07;
  if (tx.chainId != BN_07) {
    chainId = getBigInt(tx.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    const legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_07) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_07) {
    v = Signature2.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
}
function _parseEipSignature2(tx, fields) {
  let yParity;
  try {
    yParity = handleNumber2(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r2 = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature2 = Signature2.from({ r: r2, s, yParity });
  tx.signature = signature2;
}
function _parseEip15592(data2) {
  const fields = decodeRlp(getBytes(data2).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify2(data2));
  const maxPriorityFeePerGas = handleUint(fields[2], "maxPriorityFeePerGas");
  const maxFeePerGas = handleUint(fields[3], "maxFeePerGas");
  const tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress2(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify2(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx;
  }
  tx.hash = keccak2563(data2);
  _parseEipSignature2(tx, fields.slice(9));
  return tx;
}
function _serializeEip15592(tx, sig) {
  const fields = [
    formatNumber2(tx.chainId || 0, "chainId"),
    formatNumber2(tx.nonce || 0, "nonce"),
    formatNumber2(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber2(tx.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber2(tx.gasLimit || 0, "gasLimit"),
    tx.to != null ? getAddress2(tx.to) : "0x",
    formatNumber2(tx.value || 0, "value"),
    tx.data || "0x",
    formatAccessList2(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat2(["0x02", encodeRlp(fields)]);
}
function _parseEip29302(data2) {
  const fields = decodeRlp(getBytes(data2).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify2(data2));
  const tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber2(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress2(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify2(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx;
  }
  tx.hash = keccak2563(data2);
  _parseEipSignature2(tx, fields.slice(8));
  return tx;
}
function _serializeEip29302(tx, sig) {
  const fields = [
    formatNumber2(tx.chainId || 0, "chainId"),
    formatNumber2(tx.nonce || 0, "nonce"),
    formatNumber2(tx.gasPrice || 0, "gasPrice"),
    formatNumber2(tx.gasLimit || 0, "gasLimit"),
    tx.to != null ? getAddress2(tx.to) : "0x",
    formatNumber2(tx.value || 0, "value"),
    tx.data || "0x",
    formatAccessList2(tx.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber2(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat2(["0x01", encodeRlp(fields)]);
}
var BN_07, BN_22, BN_272, BN_282, BN_352, BN_MAX_UINT, _type, _to, _data3, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _Transaction, Transaction;
var init_transaction = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/transaction.js"() {
    init_address3();
    init_crypto2();
    init_utils3();
    init_accesslist();
    init_address5();
    BN_07 = BigInt(0);
    BN_22 = BigInt(2);
    BN_272 = BigInt(27);
    BN_282 = BigInt(28);
    BN_352 = BigInt(35);
    BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    _Transaction = class {
      constructor() {
        __privateAdd(this, _type, void 0);
        __privateAdd(this, _to, void 0);
        __privateAdd(this, _data3, void 0);
        __privateAdd(this, _nonce, void 0);
        __privateAdd(this, _gasLimit, void 0);
        __privateAdd(this, _gasPrice, void 0);
        __privateAdd(this, _maxPriorityFeePerGas, void 0);
        __privateAdd(this, _maxFeePerGas, void 0);
        __privateAdd(this, _value, void 0);
        __privateAdd(this, _chainId, void 0);
        __privateAdd(this, _sig, void 0);
        __privateAdd(this, _accessList, void 0);
        __privateSet(this, _type, null);
        __privateSet(this, _to, null);
        __privateSet(this, _nonce, 0);
        __privateSet(this, _gasLimit, BigInt(0));
        __privateSet(this, _gasPrice, null);
        __privateSet(this, _maxPriorityFeePerGas, null);
        __privateSet(this, _maxFeePerGas, null);
        __privateSet(this, _data3, "0x");
        __privateSet(this, _value, BigInt(0));
        __privateSet(this, _chainId, BigInt(0));
        __privateSet(this, _sig, null);
        __privateSet(this, _accessList, null);
      }
      get type() {
        return __privateGet(this, _type);
      }
      set type(value) {
        switch (value) {
          case null:
            __privateSet(this, _type, null);
            break;
          case 0:
          case "legacy":
            __privateSet(this, _type, 0);
            break;
          case 1:
          case "berlin":
          case "eip-2930":
            __privateSet(this, _type, 1);
            break;
          case 2:
          case "london":
          case "eip-1559":
            __privateSet(this, _type, 2);
            break;
          default:
            assertArgument(false, "unsupported transaction type", "type", value);
        }
      }
      get typeName() {
        switch (this.type) {
          case 0:
            return "legacy";
          case 1:
            return "eip-2930";
          case 2:
            return "eip-1559";
        }
        return null;
      }
      get to() {
        return __privateGet(this, _to);
      }
      set to(value) {
        __privateSet(this, _to, value == null ? null : getAddress2(value));
      }
      get nonce() {
        return __privateGet(this, _nonce);
      }
      set nonce(value) {
        __privateSet(this, _nonce, getNumber(value, "value"));
      }
      get gasLimit() {
        return __privateGet(this, _gasLimit);
      }
      set gasLimit(value) {
        __privateSet(this, _gasLimit, getBigInt(value));
      }
      get gasPrice() {
        const value = __privateGet(this, _gasPrice);
        if (value == null && (this.type === 0 || this.type === 1)) {
          return BN_07;
        }
        return value;
      }
      set gasPrice(value) {
        __privateSet(this, _gasPrice, value == null ? null : getBigInt(value, "gasPrice"));
      }
      get maxPriorityFeePerGas() {
        const value = __privateGet(this, _maxPriorityFeePerGas);
        if (value == null) {
          if (this.type === 2) {
            return BN_07;
          }
          return null;
        }
        return value;
      }
      set maxPriorityFeePerGas(value) {
        __privateSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, "maxPriorityFeePerGas"));
      }
      get maxFeePerGas() {
        const value = __privateGet(this, _maxFeePerGas);
        if (value == null) {
          if (this.type === 2) {
            return BN_07;
          }
          return null;
        }
        return value;
      }
      set maxFeePerGas(value) {
        __privateSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, "maxFeePerGas"));
      }
      get data() {
        return __privateGet(this, _data3);
      }
      set data(value) {
        __privateSet(this, _data3, hexlify2(value));
      }
      get value() {
        return __privateGet(this, _value);
      }
      set value(value) {
        __privateSet(this, _value, getBigInt(value, "value"));
      }
      get chainId() {
        return __privateGet(this, _chainId);
      }
      set chainId(value) {
        __privateSet(this, _chainId, getBigInt(value));
      }
      get signature() {
        return __privateGet(this, _sig) || null;
      }
      set signature(value) {
        __privateSet(this, _sig, value == null ? null : Signature2.from(value));
      }
      get accessList() {
        const value = __privateGet(this, _accessList) || null;
        if (value == null) {
          if (this.type === 1 || this.type === 2) {
            return [];
          }
          return null;
        }
        return value;
      }
      set accessList(value) {
        __privateSet(this, _accessList, value == null ? null : accessListify2(value));
      }
      get hash() {
        if (this.signature == null) {
          return null;
        }
        return keccak2563(this.serialized);
      }
      get unsignedHash() {
        return keccak2563(this.unsignedSerialized);
      }
      get from() {
        if (this.signature == null) {
          return null;
        }
        return recoverAddress2(this.unsignedHash, this.signature);
      }
      get fromPublicKey() {
        if (this.signature == null) {
          return null;
        }
        return SigningKey2.recoverPublicKey(this.unsignedHash, this.signature);
      }
      isSigned() {
        return this.signature != null;
      }
      get serialized() {
        assert2(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
        switch (this.inferType()) {
          case 0:
            return _serializeLegacy(this, this.signature);
          case 1:
            return _serializeEip29302(this, this.signature);
          case 2:
            return _serializeEip15592(this, this.signature);
        }
        assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
      }
      get unsignedSerialized() {
        switch (this.inferType()) {
          case 0:
            return _serializeLegacy(this);
          case 1:
            return _serializeEip29302(this);
          case 2:
            return _serializeEip15592(this);
        }
        assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".unsignedSerialized" });
      }
      inferType() {
        return this.inferTypes().pop();
      }
      inferTypes() {
        const hasGasPrice = this.gasPrice != null;
        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
        const hasAccessList = this.accessList != null;
        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
          assert2(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
        }
        assert2(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
        assert2(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
        const types = [];
        if (this.type != null) {
          types.push(this.type);
        } else {
          if (hasFee) {
            types.push(2);
          } else if (hasGasPrice) {
            types.push(1);
            if (!hasAccessList) {
              types.push(0);
            }
          } else if (hasAccessList) {
            types.push(1);
            types.push(2);
          } else {
            types.push(0);
            types.push(1);
            types.push(2);
          }
        }
        types.sort();
        return types;
      }
      isLegacy() {
        return this.type === 0;
      }
      isBerlin() {
        return this.type === 1;
      }
      isLondon() {
        return this.type === 2;
      }
      clone() {
        return _Transaction.from(this);
      }
      toJSON() {
        const s = (v) => {
          if (v == null) {
            return null;
          }
          return v.toString();
        };
        return {
          type: this.type,
          to: this.to,
          data: this.data,
          nonce: this.nonce,
          gasLimit: s(this.gasLimit),
          gasPrice: s(this.gasPrice),
          maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
          maxFeePerGas: s(this.maxFeePerGas),
          value: s(this.value),
          chainId: s(this.chainId),
          sig: this.signature ? this.signature.toJSON() : null,
          accessList: this.accessList
        };
      }
      static from(tx) {
        if (tx == null) {
          return new _Transaction();
        }
        if (typeof tx === "string") {
          const payload = getBytes(tx);
          if (payload[0] >= 127) {
            return _Transaction.from(_parseLegacy(payload));
          }
          switch (payload[0]) {
            case 1:
              return _Transaction.from(_parseEip29302(payload));
            case 2:
              return _Transaction.from(_parseEip15592(payload));
          }
          assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
        }
        const result = new _Transaction();
        if (tx.type != null) {
          result.type = tx.type;
        }
        if (tx.to != null) {
          result.to = tx.to;
        }
        if (tx.nonce != null) {
          result.nonce = tx.nonce;
        }
        if (tx.gasLimit != null) {
          result.gasLimit = tx.gasLimit;
        }
        if (tx.gasPrice != null) {
          result.gasPrice = tx.gasPrice;
        }
        if (tx.maxPriorityFeePerGas != null) {
          result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
        }
        if (tx.maxFeePerGas != null) {
          result.maxFeePerGas = tx.maxFeePerGas;
        }
        if (tx.data != null) {
          result.data = tx.data;
        }
        if (tx.value != null) {
          result.value = tx.value;
        }
        if (tx.chainId != null) {
          result.chainId = tx.chainId;
        }
        if (tx.signature != null) {
          result.signature = Signature2.from(tx.signature);
        }
        if (tx.accessList != null) {
          result.accessList = tx.accessList;
        }
        if (tx.hash != null) {
          assertArgument(result.isSigned(), "unsigned transaction cannot define hash", "tx", tx);
          assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
        }
        if (tx.from != null) {
          assertArgument(result.isSigned(), "unsigned transaction cannot define from", "tx", tx);
          assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
        }
        return result;
      }
    };
    Transaction = _Transaction;
    _type = new WeakMap();
    _to = new WeakMap();
    _data3 = new WeakMap();
    _nonce = new WeakMap();
    _gasLimit = new WeakMap();
    _gasPrice = new WeakMap();
    _maxPriorityFeePerGas = new WeakMap();
    _maxFeePerGas = new WeakMap();
    _value = new WeakMap();
    _chainId = new WeakMap();
    _sig = new WeakMap();
    _accessList = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/index.js
var init_transaction2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/transaction/index.js"() {
    init_accesslist();
    init_address5();
    init_transaction();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/message.js
function hashMessage2(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes2(message);
  }
  return keccak2563(concat2([
    toUtf8Bytes2(MessagePrefix),
    toUtf8Bytes2(String(message.length)),
    message
  ]));
}
var init_message2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/message.js"() {
    init_crypto2();
    init_constants();
    init_transaction2();
    init_utils3();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/solidity.js
var regexBytes2, regexNumber2, regexArray2;
var init_solidity = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/solidity.js"() {
    init_address3();
    init_crypto2();
    init_utils3();
    regexBytes2 = new RegExp("^bytes([0-9]+)$");
    regexNumber2 = new RegExp("^(u?int)([0-9]*)$");
    regexArray2 = new RegExp("^(.*)\\[([0-9]*)\\]$");
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/typed-data.js
function hexPadRight2(value) {
  const bytes3 = getBytes(value);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return concat2([bytes3, padding2.slice(padOffset)]);
  }
  return hexlify2(bytes3);
}
function checkString2(key2) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    return value;
  };
}
function getBaseEncoder2(type) {
  {
    const match2 = type.match(/^(u?)int(\d*)$/);
    if (match2) {
      const signed3 = match2[1] === "";
      const width = parseInt(match2[2] || "256");
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match2[2] == null || match2[2] === String(width)), "invalid numeric width", "type", type);
      const boundsUpper = mask(BN_MAX_UINT2562, signed3 ? width - 1 : width);
      const boundsLower = signed3 ? (boundsUpper + BN_15) * BN__1 : BN_08;
      return function(_value2) {
        const value = getBigInt(_value2, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed3 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match2 = type.match(/^bytes(\d+)$/);
    if (match2) {
      const width = parseInt(match2[1]);
      assertArgument(width !== 0 && width <= 32 && match2[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes3 = getBytes(value);
        assertArgument(bytes3.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight2(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress2(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse2 : hexTrue2;
      };
    case "bytes":
      return function(value) {
        return keccak2563(value);
      };
    case "string":
      return function(value) {
        return id2(value);
      };
  }
  return null;
}
function encodeType2(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
}
var padding2, BN__1, BN_08, BN_15, BN_MAX_UINT2562, hexTrue2, hexFalse2, domainFieldTypes2, domainFieldNames2, domainChecks2, _types, _fullTypes, _encoderCache, _getEncoder, getEncoder_fn, _TypedDataEncoder, TypedDataEncoder2;
var init_typed_data2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/typed-data.js"() {
    init_address3();
    init_crypto2();
    init_transaction2();
    init_utils3();
    init_id2();
    padding2 = new Uint8Array(32);
    padding2.fill(0);
    BN__1 = BigInt(-1);
    BN_08 = BigInt(0);
    BN_15 = BigInt(1);
    BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    hexTrue2 = toBeHex(BN_15, 32);
    hexFalse2 = toBeHex(BN_08, 32);
    domainFieldTypes2 = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    domainFieldNames2 = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    domainChecks2 = {
      name: checkString2("name"),
      version: checkString2("version"),
      chainId: function(_value2) {
        const value = getBigInt(_value2, "domain.chainId");
        assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value2);
        if (Number.isSafeInteger(value)) {
          return Number(value);
        }
        return toQuantity(value);
      },
      verifyingContract: function(value) {
        try {
          return getAddress2(value).toLowerCase();
        } catch (error) {
        }
        assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
      },
      salt: function(value) {
        const bytes3 = getBytes(value, "domain.salt");
        assertArgument(bytes3.length === 32, `invalid domain value "salt"`, "domain.salt", value);
        return hexlify2(bytes3);
      }
    };
    _TypedDataEncoder = class {
      constructor(types) {
        __privateAdd(this, _getEncoder);
        __publicField(this, "primaryType");
        __privateAdd(this, _types, void 0);
        __privateAdd(this, _fullTypes, void 0);
        __privateAdd(this, _encoderCache, void 0);
        __privateSet(this, _types, JSON.stringify(types));
        __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
        __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
        const links = /* @__PURE__ */ new Map();
        const parents = /* @__PURE__ */ new Map();
        const subtypes = /* @__PURE__ */ new Map();
        Object.keys(types).forEach((type) => {
          links.set(type, /* @__PURE__ */ new Set());
          parents.set(type, []);
          subtypes.set(type, /* @__PURE__ */ new Set());
        });
        for (const name in types) {
          const uniqueNames = /* @__PURE__ */ new Set();
          for (const field of types[name]) {
            assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
            uniqueNames.add(field.name);
            const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
            assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", types);
            const encoder = getBaseEncoder2(baseType);
            if (encoder) {
              continue;
            }
            assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", types);
            parents.get(baseType).push(name);
            links.get(name).add(baseType);
          }
        }
        const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
        assertArgument(primaryTypes.length !== 0, "missing primary type", "types", types);
        assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types);
        defineProperties(this, { primaryType: primaryTypes[0] });
        function checkCircular(type, found) {
          assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", types);
          found.add(type);
          for (const child of links.get(type)) {
            if (!parents.has(child)) {
              continue;
            }
            checkCircular(child, found);
            for (const subtype of found) {
              subtypes.get(subtype).add(child);
            }
          }
          found.delete(type);
        }
        checkCircular(this.primaryType, /* @__PURE__ */ new Set());
        for (const [name, set2] of subtypes) {
          const st = Array.from(set2);
          st.sort();
          __privateGet(this, _fullTypes).set(name, encodeType2(name, types[name]) + st.map((t) => encodeType2(t, types[t])).join(""));
        }
      }
      get types() {
        return JSON.parse(__privateGet(this, _types));
      }
      getEncoder(type) {
        let encoder = __privateGet(this, _encoderCache).get(type);
        if (!encoder) {
          encoder = __privateMethod(this, _getEncoder, getEncoder_fn).call(this, type);
          __privateGet(this, _encoderCache).set(type, encoder);
        }
        return encoder;
      }
      encodeType(name) {
        const result = __privateGet(this, _fullTypes).get(name);
        assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
        return result;
      }
      encodeData(type, value) {
        return this.getEncoder(type)(value);
      }
      hashStruct(name, value) {
        return keccak2563(this.encodeData(name, value));
      }
      encode(value) {
        return this.encodeData(this.primaryType, value);
      }
      hash(value) {
        return this.hashStruct(this.primaryType, value);
      }
      _visit(type, value, callback) {
        {
          const encoder = getBaseEncoder2(type);
          if (encoder) {
            return callback(type, value);
          }
        }
        const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match2) {
          assertArgument(!match2[3] || parseInt(match2[3]) === value.length, `array length mismatch; expected length ${parseInt(match2[3])}`, "value", value);
          return value.map((v) => this._visit(match2[1], v, callback));
        }
        const fields = this.types[type];
        if (fields) {
          return fields.reduce((accum, { name, type: type2 }) => {
            accum[name] = this._visit(type2, value[name], callback);
            return accum;
          }, {});
        }
        assertArgument(false, `unknown type: ${type}`, "type", type);
      }
      visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
      }
      static from(types) {
        return new _TypedDataEncoder(types);
      }
      static getPrimaryType(types) {
        return _TypedDataEncoder.from(types).primaryType;
      }
      static hashStruct(name, types, value) {
        return _TypedDataEncoder.from(types).hashStruct(name, value);
      }
      static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
          if (domain[name] == null) {
            continue;
          }
          const type = domainFieldTypes2[name];
          assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
          domainFields.push({ name, type });
        }
        domainFields.sort((a, b2) => {
          return domainFieldNames2.indexOf(a.name) - domainFieldNames2.indexOf(b2.name);
        });
        return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
      }
      static encode(domain, types, value) {
        return concat2([
          "0x1901",
          _TypedDataEncoder.hashDomain(domain),
          _TypedDataEncoder.from(types).hash(value)
        ]);
      }
      static hash(domain, types, value) {
        return keccak2563(_TypedDataEncoder.encode(domain, types, value));
      }
      static async resolveNames(domain, types, value, resolveName2) {
        domain = Object.assign({}, domain);
        for (const key2 in domain) {
          if (domain[key2] == null) {
            delete domain[key2];
          }
        }
        const ensCache = {};
        if (domain.verifyingContract && !isHexString2(domain.verifyingContract, 20)) {
          ensCache[domain.verifyingContract] = "0x";
        }
        const encoder = _TypedDataEncoder.from(types);
        encoder.visit(value, (type, value2) => {
          if (type === "address" && !isHexString2(value2, 20)) {
            ensCache[value2] = "0x";
          }
          return value2;
        });
        for (const name in ensCache) {
          ensCache[name] = await resolveName2(name);
        }
        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
          domain.verifyingContract = ensCache[domain.verifyingContract];
        }
        value = encoder.visit(value, (type, value2) => {
          if (type === "address" && ensCache[value2]) {
            return ensCache[value2];
          }
          return value2;
        });
        return { domain, value };
      }
      static getPayload(domain, types, value) {
        _TypedDataEncoder.hashDomain(domain);
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames2.forEach((name) => {
          const value2 = domain[name];
          if (value2 == null) {
            return;
          }
          domainValues[name] = domainChecks2[name](value2);
          domainTypes.push({ name, type: domainFieldTypes2[name] });
        });
        const encoder = _TypedDataEncoder.from(types);
        const typesWithDomain = Object.assign({}, types);
        assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
        typesWithDomain.EIP712Domain = domainTypes;
        encoder.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder.primaryType,
          message: encoder.visit(value, (type, value2) => {
            if (type.match(/^bytes(\d*)/)) {
              return hexlify2(getBytes(value2));
            }
            if (type.match(/^u?int/)) {
              return getBigInt(value2).toString();
            }
            switch (type) {
              case "address":
                return value2.toLowerCase();
              case "bool":
                return !!value2;
              case "string":
                assertArgument(typeof value2 === "string", "invalid string", "value", value2);
                return value2;
            }
            assertArgument(false, "unsupported type", "type", type);
          })
        };
      }
    };
    TypedDataEncoder2 = _TypedDataEncoder;
    _types = new WeakMap();
    _fullTypes = new WeakMap();
    _encoderCache = new WeakMap();
    _getEncoder = new WeakSet();
    getEncoder_fn = function(type) {
      {
        const encoder = getBaseEncoder2(type);
        if (encoder) {
          return encoder;
        }
      }
      const match2 = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match2) {
        const subtype = match2[1];
        const subEncoder = this.getEncoder(subtype);
        return (value) => {
          assertArgument(!match2[3] || parseInt(match2[3]) === value.length, `array length mismatch; expected length ${parseInt(match2[3])}`, "value", value);
          let result = value.map(subEncoder);
          if (__privateGet(this, _fullTypes).has(subtype)) {
            result = result.map(keccak2563);
          }
          return keccak2563(concat2(result));
        };
      }
      const fields = this.types[type];
      if (fields) {
        const encodedType = id2(__privateGet(this, _fullTypes).get(type));
        return (value) => {
          const values2 = fields.map(({ name, type: type2 }) => {
            const result = this.getEncoder(type2)(value[name]);
            if (__privateGet(this, _fullTypes).has(type2)) {
              return keccak2563(result);
            }
            return result;
          });
          values2.unshift(encodedType);
          return concat2(values2);
        };
      }
      assertArgument(false, `unknown type: ${type}`, "type", type);
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/index.js
var init_hash = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/hash/index.js"() {
    init_id2();
    init_namehash2();
    init_message2();
    init_solidity();
    init_typed_data2();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/fragments.js
function setify(items) {
  const result = /* @__PURE__ */ new Set();
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
}
function lex(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match2 = cur.match(regexWhitespacePrefix);
    if (match2) {
      offset += match2[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match2 = cur.match(regexIdPrefix);
    if (match2) {
      token.text = match2[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match2 = cur.match(regexNumberPrefix);
    if (match2) {
      token.text = match2[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
}
function allowSingle(set2, allowed) {
  let included = [];
  for (const key2 in allowed.keys()) {
    if (set2.has(key2)) {
      included.push(key2);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
}
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
}
function consumeKeywords(tokens, allowed) {
  const keywords = /* @__PURE__ */ new Set();
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
function consumeMutability(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType2.from(t, allowIndexed));
}
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens: ${tokens.toString()}`);
  }
}
function verifyBasicType(type) {
  const match2 = type.match(regexType);
  assertArgument(match2, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match2[2]) {
    const length = parseInt(match2[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match2[3]) {
    const size = parseInt(match2[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
function joinParams(format, params) {
  return "(" + params.map((p) => p.format(format)).join(format === "full" ? ", " : ",") + ")";
}
var _kwVisibDeploy, KwVisibDeploy, _kwVisib, KwVisib, _kwTypes, KwTypes, _kwModifiers, KwModifiers, _kwOther, _keywords, Keywords, SimpleTokens, regexWhitespacePrefix, regexNumberPrefix, regexIdPrefix, regexId, regexType, _offset2, _tokens, _subTokenString, subTokenString_fn, _TokenString, TokenString, regexArrayType, _guard4, internal, ParamTypeInternal, ErrorFragmentInternal, EventFragmentInternal, ConstructorFragmentInternal, FallbackFragmentInternal, FunctionFragmentInternal, StructFragmentInternal, _walkAsync, walkAsync_fn, _ParamType, ParamType2, Fragment2, NamedFragment, ErrorFragment2, EventFragment2, ConstructorFragment2, FallbackFragment, FunctionFragment2, StructFragment;
var init_fragments2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/fragments.js"() {
    init_utils3();
    init_hash();
    _kwVisibDeploy = "external public payable";
    KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
    _kwVisib = "constant external internal payable private public pure view";
    KwVisib = setify(_kwVisib.split(" "));
    _kwTypes = "constructor error event fallback function receive struct";
    KwTypes = setify(_kwTypes.split(" "));
    _kwModifiers = "calldata memory storage payable indexed";
    KwModifiers = setify(_kwModifiers.split(" "));
    _kwOther = "tuple returns";
    _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
    Keywords = setify(_keywords.split(" "));
    SimpleTokens = {
      "(": "OPEN_PAREN",
      ")": "CLOSE_PAREN",
      "[": "OPEN_BRACKET",
      "]": "CLOSE_BRACKET",
      ",": "COMMA",
      "@": "AT"
    };
    regexWhitespacePrefix = new RegExp("^(\\s*)");
    regexNumberPrefix = new RegExp("^([0-9]+)");
    regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
    regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
    regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
    _TokenString = class {
      constructor(tokens) {
        __privateAdd(this, _subTokenString);
        __privateAdd(this, _offset2, void 0);
        __privateAdd(this, _tokens, void 0);
        __privateSet(this, _offset2, 0);
        __privateSet(this, _tokens, tokens.slice());
      }
      get offset() {
        return __privateGet(this, _offset2);
      }
      get length() {
        return __privateGet(this, _tokens).length - __privateGet(this, _offset2);
      }
      clone() {
        return new _TokenString(__privateGet(this, _tokens));
      }
      reset() {
        __privateSet(this, _offset2, 0);
      }
      popKeyword(allowed) {
        const top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
          throw new Error(`expected keyword ${top.text}`);
        }
        return this.pop().text;
      }
      popType(type) {
        if (this.peek().type !== type) {
          throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);
        }
        return this.pop().text;
      }
      popParen() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
          throw new Error("bad start");
        }
        const result = __privateMethod(this, _subTokenString, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, top.match + 1);
        __privateSet(this, _offset2, top.match + 1);
        return result;
      }
      popParams() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
          throw new Error("bad start");
        }
        const result = [];
        while (__privateGet(this, _offset2) < top.match - 1) {
          const link = this.peek().linkNext;
          result.push(__privateMethod(this, _subTokenString, subTokenString_fn).call(this, __privateGet(this, _offset2) + 1, link));
          __privateSet(this, _offset2, link);
        }
        __privateSet(this, _offset2, top.match + 1);
        return result;
      }
      peek() {
        if (__privateGet(this, _offset2) >= __privateGet(this, _tokens).length) {
          throw new Error("out-of-bounds");
        }
        return __privateGet(this, _tokens)[__privateGet(this, _offset2)];
      }
      peekKeyword(allowed) {
        const top = this.peekType("KEYWORD");
        return top != null && allowed.has(top) ? top : null;
      }
      peekType(type) {
        if (this.length === 0) {
          return null;
        }
        const top = this.peek();
        return top.type === type ? top.text : null;
      }
      pop() {
        const result = this.peek();
        __privateWrapper(this, _offset2)._++;
        return result;
      }
      toString() {
        const tokens = [];
        for (let i = __privateGet(this, _offset2); i < __privateGet(this, _tokens).length; i++) {
          const token = __privateGet(this, _tokens)[i];
          tokens.push(`${token.type}:${token.text}`);
        }
        return `<TokenString ${tokens.join(" ")}>`;
      }
    };
    TokenString = _TokenString;
    _offset2 = new WeakMap();
    _tokens = new WeakMap();
    _subTokenString = new WeakSet();
    subTokenString_fn = function(from = 0, to = 0) {
      return new _TokenString(__privateGet(this, _tokens).slice(from, to).map((t) => {
        return Object.freeze(Object.assign({}, t, {
          match: t.match - from,
          linkBack: t.linkBack - from,
          linkNext: t.linkNext - from
        }));
      }));
    };
    regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
    _guard4 = {};
    internal = Symbol.for("_ethers_internal");
    ParamTypeInternal = "_ParamTypeInternal";
    ErrorFragmentInternal = "_ErrorInternal";
    EventFragmentInternal = "_EventInternal";
    ConstructorFragmentInternal = "_ConstructorInternal";
    FallbackFragmentInternal = "_FallbackInternal";
    FunctionFragmentInternal = "_FunctionInternal";
    StructFragmentInternal = "_StructInternal";
    _ParamType = class {
      constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
        __privateAdd(this, _walkAsync);
        __publicField(this, "name");
        __publicField(this, "type");
        __publicField(this, "baseType");
        __publicField(this, "indexed");
        __publicField(this, "components");
        __publicField(this, "arrayLength");
        __publicField(this, "arrayChildren");
        assertPrivate(guard, _guard4, "ParamType");
        Object.defineProperty(this, internal, { value: ParamTypeInternal });
        if (components) {
          components = Object.freeze(components.slice());
        }
        if (baseType === "array") {
          if (arrayLength == null || arrayChildren == null) {
            throw new Error("");
          }
        } else if (arrayLength != null || arrayChildren != null) {
          throw new Error("");
        }
        if (baseType === "tuple") {
          if (components == null) {
            throw new Error("");
          }
        } else if (components != null) {
          throw new Error("");
        }
        defineProperties(this, {
          name,
          type,
          baseType,
          indexed,
          components,
          arrayLength,
          arrayChildren
        });
      }
      format(format) {
        if (format == null) {
          format = "sighash";
        }
        if (format === "json") {
          const name = this.name || "";
          if (this.isArray()) {
            const result3 = JSON.parse(this.arrayChildren.format("json"));
            result3.name = name;
            result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
            return JSON.stringify(result3);
          }
          const result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.isTuple()) {
            result2.components = this.components.map((c) => JSON.parse(c.format(format)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.isArray()) {
          result += this.arrayChildren.format(format);
          result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        } else {
          if (this.isTuple()) {
            if (format !== "sighash") {
              result += this.type;
            }
            result += "(" + this.components.map((comp) => comp.format(format)).join(format === "full" ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format !== "sighash") {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format === "full" && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      isArray() {
        return this.baseType === "array";
      }
      isTuple() {
        return this.baseType === "tuple";
      }
      isIndexable() {
        return this.indexed != null;
      }
      walk(value, process2) {
        if (this.isArray()) {
          if (!Array.isArray(value)) {
            throw new Error("invalid array value");
          }
          if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
            throw new Error("array is wrong length");
          }
          const _this = this;
          return value.map((v) => _this.arrayChildren.walk(v, process2));
        }
        if (this.isTuple()) {
          if (!Array.isArray(value)) {
            throw new Error("invalid tuple value");
          }
          if (value.length !== this.components.length) {
            throw new Error("array is wrong length");
          }
          const _this = this;
          return value.map((v, i) => _this.components[i].walk(v, process2));
        }
        return process2(this.type, value);
      }
      async walkAsync(value, process2) {
        const promises = [];
        const result = [value];
        __privateMethod(this, _walkAsync, walkAsync_fn).call(this, promises, value, process2, (value2) => {
          result[0] = value2;
        });
        if (promises.length) {
          await Promise.all(promises);
        }
        return result[0];
      }
      static from(obj, allowIndexed) {
        if (_ParamType.isParamType(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return _ParamType.from(lex(obj), allowIndexed);
          } catch (error) {
            assertArgument(false, "invalid param type", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          let type2 = "", baseType = "";
          let comps = null;
          if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
            baseType = "tuple";
            comps = obj.popParams().map((t) => _ParamType.from(t));
            type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
          } else {
            type2 = verifyBasicType(obj.popType("TYPE"));
            baseType = type2;
          }
          let arrayChildren = null;
          let arrayLength = null;
          while (obj.length && obj.peekType("BRACKET")) {
            const bracket = obj.pop();
            arrayChildren = new _ParamType(_guard4, "", type2, baseType, null, comps, arrayLength, arrayChildren);
            arrayLength = bracket.value;
            type2 += bracket.text;
            baseType = "array";
            comps = null;
          }
          let indexed2 = null;
          const keywords = consumeKeywords(obj, KwModifiers);
          if (keywords.has("indexed")) {
            if (!allowIndexed) {
              throw new Error("");
            }
            indexed2 = true;
          }
          const name2 = obj.peekType("ID") ? obj.pop().text : "";
          if (obj.length) {
            throw new Error("leftover tokens");
          }
          return new _ParamType(_guard4, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
        }
        const name = obj.name;
        assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
        let indexed = obj.indexed;
        if (indexed != null) {
          assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
          indexed = !!indexed;
        }
        let type = obj.type;
        let arrayMatch = type.match(regexArrayType);
        if (arrayMatch) {
          const arrayLength = parseInt(arrayMatch[2] || "-1");
          const arrayChildren = _ParamType.from({
            type: arrayMatch[1],
            components: obj.components
          });
          return new _ParamType(_guard4, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
        }
        if (type === "tuple" || type.startsWith("tuple(") || type.startsWith("(")) {
          const comps = obj.components != null ? obj.components.map((c) => _ParamType.from(c)) : null;
          const tuple = new _ParamType(_guard4, name || "", type, "tuple", indexed, comps, null, null);
          return tuple;
        }
        type = verifyBasicType(obj.type);
        return new _ParamType(_guard4, name || "", type, type, indexed, null, null, null);
      }
      static isParamType(value) {
        return value && value[internal] === ParamTypeInternal;
      }
    };
    ParamType2 = _ParamType;
    _walkAsync = new WeakSet();
    walkAsync_fn = function(promises, value, process2, setValue) {
      if (this.isArray()) {
        if (!Array.isArray(value)) {
          throw new Error("invalid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
          throw new Error("array is wrong length");
        }
        const childType = this.arrayChildren;
        const result2 = value.slice();
        result2.forEach((value2, index) => {
          var _a2;
          __privateMethod(_a2 = childType, _walkAsync, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
            result2[index] = value3;
          });
        });
        setValue(result2);
        return;
      }
      if (this.isTuple()) {
        const components = this.components;
        let result2;
        if (Array.isArray(value)) {
          result2 = value.slice();
        } else {
          if (value == null || typeof value !== "object") {
            throw new Error("invalid tuple value");
          }
          result2 = components.map((param) => {
            if (!param.name) {
              throw new Error("cannot use object value with unnamed components");
            }
            if (!(param.name in value)) {
              throw new Error(`missing value for component ${param.name}`);
            }
            return value[param.name];
          });
        }
        if (result2.length !== this.components.length) {
          throw new Error("array is wrong length");
        }
        result2.forEach((value2, index) => {
          var _a2;
          __privateMethod(_a2 = components[index], _walkAsync, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
            result2[index] = value3;
          });
        });
        setValue(result2);
        return;
      }
      const result = process2(this.type, value);
      if (result.then) {
        promises.push(async function() {
          setValue(await result);
        }());
      } else {
        setValue(result);
      }
    };
    Fragment2 = class {
      constructor(guard, type, inputs) {
        __publicField(this, "type");
        __publicField(this, "inputs");
        assertPrivate(guard, _guard4, "Fragment");
        inputs = Object.freeze(inputs.slice());
        defineProperties(this, { type, inputs });
      }
      static from(obj) {
        if (typeof obj === "string") {
          try {
            Fragment2.from(JSON.parse(obj));
          } catch (e) {
          }
          return Fragment2.from(lex(obj));
        }
        if (obj instanceof TokenString) {
          const type = obj.peekKeyword(KwTypes);
          switch (type) {
            case "constructor":
              return ConstructorFragment2.from(obj);
            case "error":
              return ErrorFragment2.from(obj);
            case "event":
              return EventFragment2.from(obj);
            case "fallback":
            case "receive":
              return FallbackFragment.from(obj);
            case "function":
              return FunctionFragment2.from(obj);
            case "struct":
              return StructFragment.from(obj);
          }
        } else if (typeof obj === "object") {
          switch (obj.type) {
            case "constructor":
              return ConstructorFragment2.from(obj);
            case "error":
              return ErrorFragment2.from(obj);
            case "event":
              return EventFragment2.from(obj);
            case "fallback":
            case "receive":
              return FallbackFragment.from(obj);
            case "function":
              return FunctionFragment2.from(obj);
            case "struct":
              return StructFragment.from(obj);
          }
          assert2(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
            operation: "Fragment.from"
          });
        }
        assertArgument(false, "unsupported frgament object", "obj", obj);
      }
      static isConstructor(value) {
        return ConstructorFragment2.isFragment(value);
      }
      static isError(value) {
        return ErrorFragment2.isFragment(value);
      }
      static isEvent(value) {
        return EventFragment2.isFragment(value);
      }
      static isFunction(value) {
        return FunctionFragment2.isFragment(value);
      }
      static isStruct(value) {
        return StructFragment.isFragment(value);
      }
    };
    NamedFragment = class extends Fragment2 {
      constructor(guard, type, name, inputs) {
        super(guard, type, inputs);
        __publicField(this, "name");
        assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
        inputs = Object.freeze(inputs.slice());
        defineProperties(this, { name });
      }
    };
    ErrorFragment2 = class extends NamedFragment {
      constructor(guard, name, inputs) {
        super(guard, "error", name, inputs);
        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
      }
      get selector() {
        return id2(this.format("sighash")).substring(0, 10);
      }
      format(format) {
        if (format == null) {
          format = "sighash";
        }
        if (format === "json") {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
          });
        }
        const result = [];
        if (format !== "sighash") {
          result.push("error");
        }
        result.push(this.name + joinParams(format, this.inputs));
        return result.join(" ");
      }
      static from(obj) {
        if (ErrorFragment2.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          return ErrorFragment2.from(lex(obj));
        } else if (obj instanceof TokenString) {
          const name = consumeName("error", obj);
          const inputs = consumeParams(obj);
          consumeEoi(obj);
          return new ErrorFragment2(_guard4, name, inputs);
        }
        return new ErrorFragment2(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
      }
      static isFragment(value) {
        return value && value[internal] === ErrorFragmentInternal;
      }
    };
    EventFragment2 = class extends NamedFragment {
      constructor(guard, name, inputs, anonymous) {
        super(guard, "event", name, inputs);
        __publicField(this, "anonymous");
        Object.defineProperty(this, internal, { value: EventFragmentInternal });
        defineProperties(this, { anonymous });
      }
      get topicHash() {
        return id2(this.format("sighash"));
      }
      format(format) {
        if (format == null) {
          format = "sighash";
        }
        if (format === "json") {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
          });
        }
        const result = [];
        if (format !== "sighash") {
          result.push("event");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash" && this.anonymous) {
          result.push("anonymous");
        }
        return result.join(" ");
      }
      static getTopicHash(name, params) {
        params = (params || []).map((p) => ParamType2.from(p));
        const fragment = new EventFragment2(_guard4, name, params, false);
        return fragment.topicHash;
      }
      static from(obj) {
        if (EventFragment2.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return EventFragment2.from(lex(obj));
          } catch (error) {
            assertArgument(false, "invalid event fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const name = consumeName("event", obj);
          const inputs = consumeParams(obj, true);
          const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
          consumeEoi(obj);
          return new EventFragment2(_guard4, name, inputs, anonymous);
        }
        return new EventFragment2(_guard4, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType2.from(p, true)) : [], !!obj.anonymous);
      }
      static isFragment(value) {
        return value && value[internal] === EventFragmentInternal;
      }
    };
    ConstructorFragment2 = class extends Fragment2 {
      constructor(guard, type, inputs, payable, gas) {
        super(guard, type, inputs);
        __publicField(this, "payable");
        __publicField(this, "gas");
        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
        defineProperties(this, { payable, gas });
      }
      format(format) {
        assert2(format != null && format !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
        if (format === "json") {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.payable ? "payable" : "undefined",
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
          });
        }
        const result = [`constructor${joinParams(format, this.inputs)}`];
        if (this.payable) {
          result.push("payable");
        }
        if (this.gas != null) {
          result.push(`@${this.gas.toString()}`);
        }
        return result.join(" ");
      }
      static from(obj) {
        if (ConstructorFragment2.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return ConstructorFragment2.from(lex(obj));
          } catch (error) {
            assertArgument(false, "invalid constuctor fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          consumeKeywords(obj, setify(["constructor"]));
          const inputs = consumeParams(obj);
          const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
          const gas = consumeGas(obj);
          consumeEoi(obj);
          return new ConstructorFragment2(_guard4, "constructor", inputs, payable, gas);
        }
        return new ConstructorFragment2(_guard4, "constructor", obj.inputs ? obj.inputs.map(ParamType2.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
      }
      static isFragment(value) {
        return value && value[internal] === ConstructorFragmentInternal;
      }
    };
    FallbackFragment = class extends Fragment2 {
      constructor(guard, inputs, payable) {
        super(guard, "fallback", inputs);
        __publicField(this, "payable");
        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
        defineProperties(this, { payable });
      }
      format(format) {
        const type = this.inputs.length === 0 ? "receive" : "fallback";
        if (format === "json") {
          const stateMutability = this.payable ? "payable" : "nonpayable";
          return JSON.stringify({ type, stateMutability });
        }
        return `${type}()${this.payable ? " payable" : ""}`;
      }
      static from(obj) {
        if (FallbackFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return FallbackFragment.from(lex(obj));
          } catch (error) {
            assertArgument(false, "invalid fallback fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const errorObj = obj.toString();
          const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
          assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
          const type = obj.popKeyword(setify(["fallback", "receive"]));
          if (type === "receive") {
            const inputs2 = consumeParams(obj);
            assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
            consumeKeywords(obj, setify(["payable"]));
            consumeEoi(obj);
            return new FallbackFragment(_guard4, [], true);
          }
          let inputs = consumeParams(obj);
          if (inputs.length) {
            assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
          } else {
            inputs = [ParamType2.from("bytes")];
          }
          const mutability = consumeMutability(obj);
          assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
          if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
            const outputs = consumeParams(obj);
            assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
          }
          consumeEoi(obj);
          return new FallbackFragment(_guard4, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
          return new FallbackFragment(_guard4, [], true);
        }
        if (obj.type === "fallback") {
          const inputs = [ParamType2.from("bytes")];
          const payable = obj.stateMutability === "payable";
          return new FallbackFragment(_guard4, inputs, payable);
        }
        assertArgument(false, "invalid fallback description", "obj", obj);
      }
      static isFragment(value) {
        return value && value[internal] === FallbackFragmentInternal;
      }
    };
    FunctionFragment2 = class extends NamedFragment {
      constructor(guard, name, stateMutability, inputs, outputs, gas) {
        super(guard, "function", name, inputs);
        __publicField(this, "constant");
        __publicField(this, "outputs");
        __publicField(this, "stateMutability");
        __publicField(this, "payable");
        __publicField(this, "gas");
        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
        outputs = Object.freeze(outputs.slice());
        const constant = stateMutability === "view" || stateMutability === "pure";
        const payable = stateMutability === "payable";
        defineProperties(this, { constant, gas, outputs, payable, stateMutability });
      }
      get selector() {
        return id2(this.format("sighash")).substring(0, 10);
      }
      format(format) {
        if (format == null) {
          format = "sighash";
        }
        if (format === "json") {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
            outputs: this.outputs.map((o) => JSON.parse(o.format(format)))
          });
        }
        const result = [];
        if (format !== "sighash") {
          result.push("function");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash") {
          if (this.stateMutability !== "nonpayable") {
            result.push(this.stateMutability);
          }
          if (this.outputs && this.outputs.length) {
            result.push("returns");
            result.push(joinParams(format, this.outputs));
          }
          if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
          }
        }
        return result.join(" ");
      }
      static getSelector(name, params) {
        params = (params || []).map((p) => ParamType2.from(p));
        const fragment = new FunctionFragment2(_guard4, name, "view", params, [], null);
        return fragment.selector;
      }
      static from(obj) {
        if (FunctionFragment2.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return FunctionFragment2.from(lex(obj));
          } catch (error) {
            assertArgument(false, "invalid function fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const name = consumeName("function", obj);
          const inputs = consumeParams(obj);
          const mutability = consumeMutability(obj);
          let outputs = [];
          if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
            outputs = consumeParams(obj);
          }
          const gas = consumeGas(obj);
          consumeEoi(obj);
          return new FunctionFragment2(_guard4, name, mutability, inputs, outputs, gas);
        }
        let stateMutability = obj.stateMutability;
        if (stateMutability == null) {
          stateMutability = "payable";
          if (typeof obj.constant === "boolean") {
            stateMutability = "view";
            if (!obj.constant) {
              stateMutability = "payable";
              if (typeof obj.payable === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
              }
            }
          } else if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
        return new FunctionFragment2(_guard4, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType2.from) : [], obj.outputs ? obj.outputs.map(ParamType2.from) : [], obj.gas != null ? obj.gas : null);
      }
      static isFragment(value) {
        return value && value[internal] === FunctionFragmentInternal;
      }
    };
    StructFragment = class extends NamedFragment {
      constructor(guard, name, inputs) {
        super(guard, "struct", name, inputs);
        Object.defineProperty(this, internal, { value: StructFragmentInternal });
      }
      format() {
        throw new Error("@TODO");
      }
      static from(obj) {
        if (typeof obj === "string") {
          try {
            return StructFragment.from(lex(obj));
          } catch (error) {
            assertArgument(false, "invalid struct fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const name = consumeName("struct", obj);
          const inputs = consumeParams(obj);
          consumeEoi(obj);
          return new StructFragment(_guard4, name, inputs);
        }
        return new StructFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType2.from) : []);
      }
      static isFragment(value) {
        return value && value[internal] === StructFragmentInternal;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/abi-coder.js
function getBuiltinCallException(action, tx, data2, abiCoder3) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data2) {
    message = "execution reverted";
    const bytes3 = getBytes(data2);
    data2 = hexlify2(data2);
    if (bytes3.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes3.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify2(bytes3.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder3.decode(["string"], bytes3.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify2(bytes3.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder3.decode(["uint256"], bytes3.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction = {
    to: tx.to ? getAddress2(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = getAddress2(tx.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data: data2,
    reason,
    transaction,
    invocation,
    revert
  });
}
var PanicReasons, paramTypeBytes2, paramTypeNumber2, defaultCoder, _getCoder, getCoder_fn, _AbiCoder, AbiCoder2;
var init_abi_coder2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/abi-coder.js"() {
    init_utils3();
    init_abstract_coder2();
    init_address4();
    init_array2();
    init_boolean2();
    init_bytes2();
    init_fixed_bytes2();
    init_null2();
    init_number2();
    init_string2();
    init_tuple2();
    init_fragments2();
    init_address3();
    init_utils3();
    PanicReasons = /* @__PURE__ */ new Map();
    PanicReasons.set(0, "GENERIC_PANIC");
    PanicReasons.set(1, "ASSERT_FALSE");
    PanicReasons.set(17, "OVERFLOW");
    PanicReasons.set(18, "DIVIDE_BY_ZERO");
    PanicReasons.set(33, "ENUM_RANGE_ERROR");
    PanicReasons.set(34, "BAD_STORAGE_DATA");
    PanicReasons.set(49, "STACK_UNDERFLOW");
    PanicReasons.set(50, "ARRAY_RANGE_ERROR");
    PanicReasons.set(65, "OUT_OF_MEMORY");
    PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
    paramTypeBytes2 = new RegExp(/^bytes([0-9]*)$/);
    paramTypeNumber2 = new RegExp(/^(u?int)([0-9]*)$/);
    defaultCoder = null;
    _AbiCoder = class {
      constructor() {
        __privateAdd(this, _getCoder);
      }
      getDefaultValue(types) {
        const coders = types.map((type) => __privateMethod(this, _getCoder, getCoder_fn).call(this, ParamType2.from(type)));
        const coder = new TupleCoder2(coders, "_");
        return coder.defaultValue();
      }
      encode(types, values2) {
        assertArgumentCount(values2.length, types.length, "types/values length mismatch");
        const coders = types.map((type) => __privateMethod(this, _getCoder, getCoder_fn).call(this, ParamType2.from(type)));
        const coder = new TupleCoder2(coders, "_");
        const writer = new Writer2();
        coder.encode(writer, values2);
        return writer.data;
      }
      decode(types, data2, loose) {
        const coders = types.map((type) => __privateMethod(this, _getCoder, getCoder_fn).call(this, ParamType2.from(type)));
        const coder = new TupleCoder2(coders, "_");
        return coder.decode(new Reader2(data2, loose));
      }
      static defaultAbiCoder() {
        if (defaultCoder == null) {
          defaultCoder = new _AbiCoder();
        }
        return defaultCoder;
      }
      static getBuiltinCallException(action, tx, data2) {
        return getBuiltinCallException(action, tx, data2, _AbiCoder.defaultAbiCoder());
      }
    };
    AbiCoder2 = _AbiCoder;
    _getCoder = new WeakSet();
    getCoder_fn = function(param) {
      if (param.isArray()) {
        return new ArrayCoder2(__privateMethod(this, _getCoder, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
      }
      if (param.isTuple()) {
        return new TupleCoder2(param.components.map((c) => __privateMethod(this, _getCoder, getCoder_fn).call(this, c)), param.name);
      }
      switch (param.baseType) {
        case "address":
          return new AddressCoder2(param.name);
        case "bool":
          return new BooleanCoder2(param.name);
        case "string":
          return new StringCoder2(param.name);
        case "bytes":
          return new BytesCoder2(param.name);
        case "":
          return new NullCoder2(param.name);
      }
      let match2 = param.type.match(paramTypeNumber2);
      if (match2) {
        let size = parseInt(match2[2] || "256");
        assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match2[1] + " bit length", "param", param);
        return new NumberCoder2(size / 8, match2[1] === "int", param.name);
      }
      match2 = param.type.match(paramTypeBytes2);
      if (match2) {
        let size = parseInt(match2[1]);
        assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
        return new FixedBytesCoder2(size, param.name);
      }
      assertArgument(false, "invalid type", "type", param.type);
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/bytes32.js
var init_bytes322 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/bytes32.js"() {
    init_utils3();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/interface.js
var LogDescription2, TransactionDescription2, ErrorDescription2, Indexed2, PanicReasons2, BuiltinErrors2, _errors, _events, _functions, _abiCoder, _getFunction, getFunction_fn, _getEvent, getEvent_fn, _Interface, Interface2;
var init_interface2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/interface.js"() {
    init_crypto2();
    init_hash();
    init_utils3();
    init_abi_coder2();
    init_abstract_coder2();
    init_fragments2();
    init_typed();
    LogDescription2 = class {
      constructor(fragment, topic, args) {
        __publicField(this, "fragment");
        __publicField(this, "name");
        __publicField(this, "signature");
        __publicField(this, "topic");
        __publicField(this, "args");
        const name = fragment.name, signature2 = fragment.format();
        defineProperties(this, {
          fragment,
          name,
          signature: signature2,
          topic,
          args
        });
      }
    };
    TransactionDescription2 = class {
      constructor(fragment, selector, args, value) {
        __publicField(this, "fragment");
        __publicField(this, "name");
        __publicField(this, "args");
        __publicField(this, "signature");
        __publicField(this, "selector");
        __publicField(this, "value");
        const name = fragment.name, signature2 = fragment.format();
        defineProperties(this, {
          fragment,
          name,
          args,
          signature: signature2,
          selector,
          value
        });
      }
    };
    ErrorDescription2 = class {
      constructor(fragment, selector, args) {
        __publicField(this, "fragment");
        __publicField(this, "name");
        __publicField(this, "args");
        __publicField(this, "signature");
        __publicField(this, "selector");
        const name = fragment.name, signature2 = fragment.format();
        defineProperties(this, {
          fragment,
          name,
          args,
          signature: signature2,
          selector
        });
      }
    };
    Indexed2 = class {
      constructor(hash4) {
        __publicField(this, "hash");
        __publicField(this, "_isIndexed");
        defineProperties(this, { hash: hash4, _isIndexed: true });
      }
      static isIndexed(value) {
        return !!(value && value._isIndexed);
      }
    };
    PanicReasons2 = {
      "0": "generic panic",
      "1": "assert(false)",
      "17": "arithmetic overflow",
      "18": "division or modulo by zero",
      "33": "enum overflow",
      "34": "invalid encoded storage byte array accessed",
      "49": "out-of-bounds array access; popping on an empty array",
      "50": "out-of-bounds access of an array or bytesN",
      "65": "out of memory",
      "81": "uninitialized function"
    };
    BuiltinErrors2 = {
      "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: (message) => {
          return `reverted with reason string ${JSON.stringify(message)}`;
        }
      },
      "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: (code) => {
          let reason = "unknown panic code";
          if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
            reason = PanicReasons2[code.toString()];
          }
          return `reverted with panic code 0x${code.toString(16)} (${reason})`;
        }
      }
    };
    _Interface = class {
      constructor(fragments) {
        __privateAdd(this, _getFunction);
        __privateAdd(this, _getEvent);
        __publicField(this, "fragments");
        __publicField(this, "deploy");
        __publicField(this, "fallback");
        __publicField(this, "receive");
        __privateAdd(this, _errors, void 0);
        __privateAdd(this, _events, void 0);
        __privateAdd(this, _functions, void 0);
        __privateAdd(this, _abiCoder, void 0);
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        __privateSet(this, _functions, /* @__PURE__ */ new Map());
        __privateSet(this, _errors, /* @__PURE__ */ new Map());
        __privateSet(this, _events, /* @__PURE__ */ new Map());
        const frags = [];
        for (const a of abi) {
          try {
            frags.push(Fragment2.from(a));
          } catch (error) {
            console.log("EE", error);
          }
        }
        defineProperties(this, {
          fragments: Object.freeze(frags)
        });
        let fallback = null;
        let receive = false;
        __privateSet(this, _abiCoder, this.getAbiCoder());
        this.fragments.forEach((fragment, index) => {
          let bucket;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                console.log("duplicate definition - constructor");
                return;
              }
              defineProperties(this, { deploy: fragment });
              return;
            case "fallback":
              if (fragment.inputs.length === 0) {
                receive = true;
              } else {
                assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
                fallback = fragment;
                receive = fallback.payable;
              }
              return;
            case "function":
              bucket = __privateGet(this, _functions);
              break;
            case "event":
              bucket = __privateGet(this, _events);
              break;
            case "error":
              bucket = __privateGet(this, _errors);
              break;
            default:
              return;
          }
          const signature2 = fragment.format();
          if (bucket.has(signature2)) {
            return;
          }
          bucket.set(signature2, fragment);
        });
        if (!this.deploy) {
          defineProperties(this, {
            deploy: ConstructorFragment2.from("constructor()")
          });
        }
        defineProperties(this, { fallback, receive });
      }
      format(minimal) {
        const format = minimal ? "minimal" : "full";
        const abi = this.fragments.map((f2) => f2.format(format));
        return abi;
      }
      formatJson() {
        const abi = this.fragments.map((f2) => f2.format("json"));
        return JSON.stringify(abi.map((j) => JSON.parse(j)));
      }
      getAbiCoder() {
        return AbiCoder2.defaultAbiCoder();
      }
      getFunctionName(key2) {
        const fragment = __privateMethod(this, _getFunction, getFunction_fn).call(this, key2, null, false);
        assertArgument(fragment, "no matching function", "key", key2);
        return fragment.name;
      }
      hasFunction(key2) {
        return !!__privateMethod(this, _getFunction, getFunction_fn).call(this, key2, null, false);
      }
      getFunction(key2, values2) {
        return __privateMethod(this, _getFunction, getFunction_fn).call(this, key2, values2 || null, true);
      }
      forEachFunction(callback) {
        const names2 = Array.from(__privateGet(this, _functions).keys());
        names2.sort((a, b2) => a.localeCompare(b2));
        for (let i = 0; i < names2.length; i++) {
          const name = names2[i];
          callback(__privateGet(this, _functions).get(name), i);
        }
      }
      getEventName(key2) {
        const fragment = __privateMethod(this, _getEvent, getEvent_fn).call(this, key2, null, false);
        assertArgument(fragment, "no matching event", "key", key2);
        return fragment.name;
      }
      hasEvent(key2) {
        return !!__privateMethod(this, _getEvent, getEvent_fn).call(this, key2, null, false);
      }
      getEvent(key2, values2) {
        return __privateMethod(this, _getEvent, getEvent_fn).call(this, key2, values2 || null, true);
      }
      forEachEvent(callback) {
        const names2 = Array.from(__privateGet(this, _events).keys());
        names2.sort((a, b2) => a.localeCompare(b2));
        for (let i = 0; i < names2.length; i++) {
          const name = names2[i];
          callback(__privateGet(this, _events).get(name), i);
        }
      }
      getError(key2, values2) {
        if (isHexString2(key2)) {
          const selector = key2.toLowerCase();
          if (BuiltinErrors2[selector]) {
            return ErrorFragment2.from(BuiltinErrors2[selector].signature);
          }
          for (const fragment of __privateGet(this, _errors).values()) {
            if (selector === fragment.selector) {
              return fragment;
            }
          }
          return null;
        }
        if (key2.indexOf("(") === -1) {
          const matching = [];
          for (const [name, fragment] of __privateGet(this, _errors)) {
            if (name.split("(")[0] === key2) {
              matching.push(fragment);
            }
          }
          if (matching.length === 0) {
            if (key2 === "Error") {
              return ErrorFragment2.from("error Error(string)");
            }
            if (key2 === "Panic") {
              return ErrorFragment2.from("error Panic(uint256)");
            }
            return null;
          } else if (matching.length > 1) {
            const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
            assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key2);
          }
          return matching[0];
        }
        key2 = ErrorFragment2.from(key2).format();
        if (key2 === "Error(string)") {
          return ErrorFragment2.from("error Error(string)");
        }
        if (key2 === "Panic(uint256)") {
          return ErrorFragment2.from("error Panic(uint256)");
        }
        const result = __privateGet(this, _errors).get(key2);
        if (result) {
          return result;
        }
        return null;
      }
      forEachError(callback) {
        const names2 = Array.from(__privateGet(this, _errors).keys());
        names2.sort((a, b2) => a.localeCompare(b2));
        for (let i = 0; i < names2.length; i++) {
          const name = names2[i];
          callback(__privateGet(this, _errors).get(name), i);
        }
      }
      _decodeParams(params, data2) {
        return __privateGet(this, _abiCoder).decode(params, data2);
      }
      _encodeParams(params, values2) {
        return __privateGet(this, _abiCoder).encode(params, values2);
      }
      encodeDeploy(values2) {
        return this._encodeParams(this.deploy.inputs, values2 || []);
      }
      decodeErrorResult(fragment, data2) {
        if (typeof fragment === "string") {
          const f2 = this.getError(fragment);
          assertArgument(f2, "unknown error", "fragment", fragment);
          fragment = f2;
        }
        assertArgument(dataSlice(data2, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data2);
        return this._decodeParams(fragment.inputs, dataSlice(data2, 4));
      }
      encodeErrorResult(fragment, values2) {
        if (typeof fragment === "string") {
          const f2 = this.getError(fragment);
          assertArgument(f2, "unknown error", "fragment", fragment);
          fragment = f2;
        }
        return concat2([
          fragment.selector,
          this._encodeParams(fragment.inputs, values2 || [])
        ]);
      }
      decodeFunctionData(fragment, data2) {
        if (typeof fragment === "string") {
          const f2 = this.getFunction(fragment);
          assertArgument(f2, "unknown function", "fragment", fragment);
          fragment = f2;
        }
        assertArgument(dataSlice(data2, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data2);
        return this._decodeParams(fragment.inputs, dataSlice(data2, 4));
      }
      encodeFunctionData(fragment, values2) {
        if (typeof fragment === "string") {
          const f2 = this.getFunction(fragment);
          assertArgument(f2, "unknown function", "fragment", fragment);
          fragment = f2;
        }
        return concat2([
          fragment.selector,
          this._encodeParams(fragment.inputs, values2 || [])
        ]);
      }
      decodeFunctionResult(fragment, data2) {
        if (typeof fragment === "string") {
          const f2 = this.getFunction(fragment);
          assertArgument(f2, "unknown function", "fragment", fragment);
          fragment = f2;
        }
        let message = "invalid length for result data";
        const bytes3 = getBytesCopy(data2);
        if (bytes3.length % 32 === 0) {
          try {
            return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes3);
          } catch (error) {
            message = "could not decode result data";
          }
        }
        assert2(false, message, "BAD_DATA", {
          value: hexlify2(bytes3),
          info: { method: fragment.name, signature: fragment.format() }
        });
      }
      makeError(_data5, tx) {
        const data2 = getBytes(_data5, "data");
        const error = AbiCoder2.getBuiltinCallException("call", tx, data2);
        const customPrefix = "execution reverted (unknown custom error)";
        if (error.message.startsWith(customPrefix)) {
          const selector = hexlify2(data2.slice(0, 4));
          const ef = this.getError(selector);
          if (ef) {
            try {
              const args = __privateGet(this, _abiCoder).decode(ef.inputs, data2.slice(4));
              error.revert = {
                name: ef.name,
                signature: ef.format(),
                args
              };
              error.reason = error.revert.signature;
              error.message = `execution reverted: ${error.reason}`;
            } catch (e) {
              error.message = `execution reverted (coult not decode custom error)`;
            }
          }
        }
        const parsed = this.parseTransaction(tx);
        if (parsed) {
          error.invocation = {
            method: parsed.name,
            signature: parsed.signature,
            args: parsed.args
          };
        }
        return error;
      }
      encodeFunctionResult(fragment, values2) {
        if (typeof fragment === "string") {
          const f2 = this.getFunction(fragment);
          assertArgument(f2, "unknown function", "fragment", fragment);
          fragment = f2;
        }
        return hexlify2(__privateGet(this, _abiCoder).encode(fragment.outputs, values2 || []));
      }
      encodeFilterTopics(fragment, values2) {
        if (typeof fragment === "string") {
          const f2 = this.getEvent(fragment);
          assertArgument(f2, "unknown event", "eventFragment", fragment);
          fragment = f2;
        }
        assert2(values2.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values2.length, expectedCount: fragment.inputs.length });
        const topics = [];
        if (!fragment.anonymous) {
          topics.push(fragment.topicHash);
        }
        const encodeTopic = (param, value) => {
          if (param.type === "string") {
            return id2(value);
          } else if (param.type === "bytes") {
            return keccak2563(hexlify2(value));
          }
          if (param.type === "bool" && typeof value === "boolean") {
            value = value ? "0x01" : "0x00";
          } else if (param.type.match(/^u?int/)) {
            value = toBeHex(value);
          } else if (param.type.match(/^bytes/)) {
            value = zeroPadBytes(value, 32);
          } else if (param.type === "address") {
            __privateGet(this, _abiCoder).encode(["address"], [value]);
          }
          return zeroPadValue(hexlify2(value), 32);
        };
        values2.forEach((value, index) => {
          const param = fragment.inputs[index];
          if (!param.indexed) {
            assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map((value2) => encodeTopic(param, value2)));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(fragment, values2) {
        if (typeof fragment === "string") {
          const f2 = this.getEvent(fragment);
          assertArgument(f2, "unknown event", "eventFragment", fragment);
          fragment = f2;
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!fragment.anonymous) {
          topics.push(fragment.topicHash);
        }
        assertArgument(values2.length === fragment.inputs.length, "event arguments/values mismatch", "values", values2);
        fragment.inputs.forEach((param, index) => {
          const value = values2[index];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push(id2(value));
            } else if (param.type === "bytes") {
              topics.push(keccak2563(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
          topics
        };
      }
      decodeEventLog(fragment, data2, topics) {
        if (typeof fragment === "string") {
          const f2 = this.getEvent(fragment);
          assertArgument(f2, "unknown event", "eventFragment", fragment);
          fragment = f2;
        }
        if (topics != null && !fragment.anonymous) {
          const eventTopic = fragment.topicHash;
          assertArgument(isHexString2(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
          topics = topics.slice(1);
        }
        const indexed = [];
        const nonIndexed = [];
        const dynamic = [];
        fragment.inputs.forEach((param, index) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(ParamType2.from({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, concat2(topics)) : null;
        const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data2, true);
        const values2 = [];
        const keys3 = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        fragment.inputs.forEach((param, index) => {
          let value = null;
          if (param.indexed) {
            if (resultIndexed == null) {
              value = new Indexed2(null);
            } else if (dynamic[index]) {
              value = new Indexed2(resultIndexed[indexedIndex++]);
            } else {
              try {
                value = resultIndexed[indexedIndex++];
              } catch (error) {
                value = error;
              }
            }
          } else {
            try {
              value = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              value = error;
            }
          }
          values2.push(value);
          keys3.push(param.name || null);
        });
        return Result.fromItems(values2, keys3);
      }
      parseTransaction(tx) {
        const data2 = getBytes(tx.data, "tx.data");
        const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
        const fragment = this.getFunction(hexlify2(data2.slice(0, 4)));
        if (!fragment) {
          return null;
        }
        const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data2.slice(4));
        return new TransactionDescription2(fragment, fragment.selector, args, value);
      }
      parseCallResult(data2) {
        throw new Error("@TODO");
      }
      parseLog(log) {
        const fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription2(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
      }
      parseError(data2) {
        const hexData = hexlify2(data2);
        const fragment = this.getError(dataSlice(hexData, 0, 4));
        if (!fragment) {
          return null;
        }
        const args = __privateGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));
        return new ErrorDescription2(fragment, fragment.selector, args);
      }
      static from(value) {
        if (value instanceof _Interface) {
          return value;
        }
        if (typeof value === "string") {
          return new _Interface(JSON.parse(value));
        }
        if (typeof value.format === "function") {
          return new _Interface(value.format("json"));
        }
        return new _Interface(value);
      }
    };
    Interface2 = _Interface;
    _errors = new WeakMap();
    _events = new WeakMap();
    _functions = new WeakMap();
    _abiCoder = new WeakMap();
    _getFunction = new WeakSet();
    getFunction_fn = function(key2, values2, forceUnique) {
      if (isHexString2(key2)) {
        const selector = key2.toLowerCase();
        for (const fragment of __privateGet(this, _functions).values()) {
          if (selector === fragment.selector) {
            return fragment;
          }
        }
        return null;
      }
      if (key2.indexOf("(") === -1) {
        const matching = [];
        for (const [name, fragment] of __privateGet(this, _functions)) {
          if (name.split("(")[0] === key2) {
            matching.push(fragment);
          }
        }
        if (values2) {
          const lastValue = values2.length > 0 ? values2[values2.length - 1] : null;
          let valueLength = values2.length;
          let allowOptions = true;
          if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
            allowOptions = false;
            valueLength--;
          }
          for (let i = matching.length - 1; i >= 0; i--) {
            const inputs = matching[i].inputs.length;
            if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
              matching.splice(i, 1);
            }
          }
          for (let i = matching.length - 1; i >= 0; i--) {
            const inputs = matching[i].inputs;
            for (let j = 0; j < values2.length; j++) {
              if (!Typed.isTyped(values2[j])) {
                continue;
              }
              if (j >= inputs.length) {
                if (values2[j].type === "overrides") {
                  continue;
                }
                matching.splice(i, 1);
                break;
              }
              if (values2[j].type !== inputs[j].baseType) {
                matching.splice(i, 1);
                break;
              }
            }
          }
        }
        if (matching.length === 1 && values2 && values2.length !== matching[0].inputs.length) {
          const lastArg = values2[values2.length - 1];
          if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
            matching.splice(0, 1);
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
          assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key2);
        }
        return matching[0];
      }
      const result = __privateGet(this, _functions).get(FunctionFragment2.from(key2).format());
      if (result) {
        return result;
      }
      return null;
    };
    _getEvent = new WeakSet();
    getEvent_fn = function(key2, values2, forceUnique) {
      if (isHexString2(key2)) {
        const eventTopic = key2.toLowerCase();
        for (const fragment of __privateGet(this, _events).values()) {
          if (eventTopic === fragment.topicHash) {
            return fragment;
          }
        }
        return null;
      }
      if (key2.indexOf("(") === -1) {
        const matching = [];
        for (const [name, fragment] of __privateGet(this, _events)) {
          if (name.split("(")[0] === key2) {
            matching.push(fragment);
          }
        }
        if (values2) {
          for (let i = matching.length - 1; i >= 0; i--) {
            if (matching[i].inputs.length < values2.length) {
              matching.splice(i, 1);
            }
          }
          for (let i = matching.length - 1; i >= 0; i--) {
            const inputs = matching[i].inputs;
            for (let j = 0; j < values2.length; j++) {
              if (!Typed.isTyped(values2[j])) {
                continue;
              }
              if (values2[j].type !== inputs[j].baseType) {
                matching.splice(i, 1);
                break;
              }
            }
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
          assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key2);
        }
        return matching[0];
      }
      const result = __privateGet(this, _events).get(EventFragment2.from(key2).format());
      if (result) {
        return result;
      }
      return null;
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/index.js
var init_abi = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/abi/index.js"() {
    init_abi_coder2();
    init_bytes322();
    init_fragments2();
    init_interface2();
    init_typed();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider.js
function getValue2(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify2(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key2 of bigIntKeys) {
    if (!(key2 in req) || req[key2] == null) {
      continue;
    }
    result[key2] = getBigInt(req[key2], `request.${key2}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key2 of numberKeys) {
    if (!(key2 in req) || req[key2] == null) {
      continue;
    }
    result[key2] = getNumber(req[key2], `request.${key2}`);
  }
  if (req.accessList) {
    result.accessList = accessListify2(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  return result;
}
function createOrphanedBlockFilter(block) {
  return { orphan: "drop-block", hash: block.hash, number: block.number };
}
function createReorderedTransactionFilter(tx, other) {
  return { orphan: "reorder-transaction", tx, other };
}
function createRemovedTransactionFilter(tx) {
  return { orphan: "drop-transaction", tx };
}
function createRemovedLogFilter(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
}
var BN_09, FeeData, _transactions, Block, Log, _logs, TransactionReceipt, _startBlock, _TransactionResponse, TransactionResponse;
var init_provider = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider.js"() {
    init_utils3();
    init_transaction2();
    BN_09 = BigInt(0);
    FeeData = class {
      constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
        __publicField(this, "gasPrice");
        __publicField(this, "maxFeePerGas");
        __publicField(this, "maxPriorityFeePerGas");
        defineProperties(this, {
          gasPrice: getValue2(gasPrice),
          maxFeePerGas: getValue2(maxFeePerGas),
          maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
        });
      }
      toJSON() {
        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
        return {
          _type: "FeeData",
          gasPrice: toJson(gasPrice),
          maxFeePerGas: toJson(maxFeePerGas),
          maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
        };
      }
    };
    Block = class {
      constructor(block, provider) {
        __publicField(this, "provider");
        __publicField(this, "number");
        __publicField(this, "hash");
        __publicField(this, "timestamp");
        __publicField(this, "parentHash");
        __publicField(this, "nonce");
        __publicField(this, "difficulty");
        __publicField(this, "gasLimit");
        __publicField(this, "gasUsed");
        __publicField(this, "miner");
        __publicField(this, "extraData");
        __publicField(this, "baseFeePerGas");
        __privateAdd(this, _transactions, void 0);
        __privateSet(this, _transactions, block.transactions.map((tx) => {
          if (typeof tx !== "string") {
            return new TransactionResponse(tx, provider);
          }
          return tx;
        }));
        defineProperties(this, {
          provider,
          hash: getValue2(block.hash),
          number: block.number,
          timestamp: block.timestamp,
          parentHash: block.parentHash,
          nonce: block.nonce,
          difficulty: block.difficulty,
          gasLimit: block.gasLimit,
          gasUsed: block.gasUsed,
          miner: block.miner,
          extraData: block.extraData,
          baseFeePerGas: getValue2(block.baseFeePerGas)
        });
      }
      get transactions() {
        return __privateGet(this, _transactions).map((tx) => {
          if (typeof tx === "string") {
            return tx;
          }
          return tx.hash;
        });
      }
      get prefetchedTransactions() {
        const txs = __privateGet(this, _transactions).slice();
        if (txs.length === 0) {
          return [];
        }
        assert2(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
          operation: "transactionResponses()"
        });
        return txs;
      }
      toJSON() {
        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash4, miner, nonce, number: number2, parentHash, timestamp, transactions } = this;
        return {
          _type: "Block",
          baseFeePerGas: toJson(baseFeePerGas),
          difficulty: toJson(difficulty),
          extraData,
          gasLimit: toJson(gasLimit),
          gasUsed: toJson(gasUsed),
          hash: hash4,
          miner,
          nonce,
          number: number2,
          parentHash,
          timestamp,
          transactions
        };
      }
      [Symbol.iterator]() {
        let index = 0;
        const txs = this.transactions;
        return {
          next: () => {
            if (index < this.length) {
              return {
                value: txs[index++],
                done: false
              };
            }
            return { value: void 0, done: true };
          }
        };
      }
      get length() {
        return __privateGet(this, _transactions).length;
      }
      get date() {
        if (this.timestamp == null) {
          return null;
        }
        return new Date(this.timestamp * 1e3);
      }
      async getTransaction(indexOrHash) {
        let tx = void 0;
        if (typeof indexOrHash === "number") {
          tx = __privateGet(this, _transactions)[indexOrHash];
        } else {
          const hash4 = indexOrHash.toLowerCase();
          for (const v of __privateGet(this, _transactions)) {
            if (typeof v === "string") {
              if (v !== hash4) {
                continue;
              }
              tx = v;
              break;
            } else {
              if (v.hash === hash4) {
                continue;
              }
              tx = v;
              break;
            }
          }
        }
        if (tx == null) {
          throw new Error("no such tx");
        }
        if (typeof tx === "string") {
          return await this.provider.getTransaction(tx);
        } else {
          return tx;
        }
      }
      getPrefetchedTransaction(indexOrHash) {
        const txs = this.prefetchedTransactions;
        if (typeof indexOrHash === "number") {
          return txs[indexOrHash];
        }
        indexOrHash = indexOrHash.toLowerCase();
        for (const tx of txs) {
          if (tx.hash === indexOrHash) {
            return tx;
          }
        }
        assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
      }
      isMined() {
        return !!this.hash;
      }
      isLondon() {
        return !!this.baseFeePerGas;
      }
      orphanedEvent() {
        if (!this.isMined()) {
          throw new Error("");
        }
        return createOrphanedBlockFilter(this);
      }
    };
    _transactions = new WeakMap();
    Log = class {
      constructor(log, provider) {
        __publicField(this, "provider");
        __publicField(this, "transactionHash");
        __publicField(this, "blockHash");
        __publicField(this, "blockNumber");
        __publicField(this, "removed");
        __publicField(this, "address");
        __publicField(this, "data");
        __publicField(this, "topics");
        __publicField(this, "index");
        __publicField(this, "transactionIndex");
        this.provider = provider;
        const topics = Object.freeze(log.topics.slice());
        defineProperties(this, {
          transactionHash: log.transactionHash,
          blockHash: log.blockHash,
          blockNumber: log.blockNumber,
          removed: log.removed,
          address: log.address,
          data: log.data,
          topics,
          index: log.index,
          transactionIndex: log.transactionIndex
        });
      }
      toJSON() {
        const { address, blockHash, blockNumber, data: data2, index, removed, topics, transactionHash, transactionIndex } = this;
        return {
          _type: "log",
          address,
          blockHash,
          blockNumber,
          data: data2,
          index,
          removed,
          topics,
          transactionHash,
          transactionIndex
        };
      }
      async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        assert2(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
        return block;
      }
      async getTransaction() {
        const tx = await this.provider.getTransaction(this.transactionHash);
        assert2(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
        return tx;
      }
      async getTransactionReceipt() {
        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
        assert2(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
        return receipt;
      }
      removedEvent() {
        return createRemovedLogFilter(this);
      }
    };
    TransactionReceipt = class {
      constructor(tx, provider) {
        __publicField(this, "provider");
        __publicField(this, "to");
        __publicField(this, "from");
        __publicField(this, "contractAddress");
        __publicField(this, "hash");
        __publicField(this, "index");
        __publicField(this, "blockHash");
        __publicField(this, "blockNumber");
        __publicField(this, "logsBloom");
        __publicField(this, "gasUsed");
        __publicField(this, "cumulativeGasUsed");
        __publicField(this, "gasPrice");
        __publicField(this, "type");
        __publicField(this, "status");
        __publicField(this, "root");
        __privateAdd(this, _logs, void 0);
        __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
          return new Log(log, provider);
        })));
        let gasPrice = BN_09;
        if (tx.effectiveGasPrice != null) {
          gasPrice = tx.effectiveGasPrice;
        } else if (tx.gasPrice != null) {
          gasPrice = tx.gasPrice;
        }
        defineProperties(this, {
          provider,
          to: tx.to,
          from: tx.from,
          contractAddress: tx.contractAddress,
          hash: tx.hash,
          index: tx.index,
          blockHash: tx.blockHash,
          blockNumber: tx.blockNumber,
          logsBloom: tx.logsBloom,
          gasUsed: tx.gasUsed,
          cumulativeGasUsed: tx.cumulativeGasUsed,
          gasPrice,
          type: tx.type,
          status: tx.status,
          root: tx.root
        });
      }
      get logs() {
        return __privateGet(this, _logs);
      }
      toJSON() {
        const {
          to,
          from,
          contractAddress,
          hash: hash4,
          index,
          blockHash,
          blockNumber,
          logsBloom,
          logs,
          status,
          root
        } = this;
        return {
          _type: "TransactionReceipt",
          blockHash,
          blockNumber,
          contractAddress,
          cumulativeGasUsed: toJson(this.cumulativeGasUsed),
          from,
          gasPrice: toJson(this.gasPrice),
          gasUsed: toJson(this.gasUsed),
          hash: hash4,
          index,
          logs,
          logsBloom,
          root,
          status,
          to
        };
      }
      get length() {
        return this.logs.length;
      }
      [Symbol.iterator]() {
        let index = 0;
        return {
          next: () => {
            if (index < this.length) {
              return { value: this.logs[index++], done: false };
            }
            return { value: void 0, done: true };
          }
        };
      }
      get fee() {
        return this.gasUsed * this.gasPrice;
      }
      async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        if (block == null) {
          throw new Error("TODO");
        }
        return block;
      }
      async getTransaction() {
        const tx = await this.provider.getTransaction(this.hash);
        if (tx == null) {
          throw new Error("TODO");
        }
        return tx;
      }
      async getResult() {
        return await this.provider.getTransactionResult(this.hash);
      }
      async confirmations() {
        return await this.provider.getBlockNumber() - this.blockNumber + 1;
      }
      removedEvent() {
        return createRemovedTransactionFilter(this);
      }
      reorderedEvent(other) {
        assert2(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
        return createReorderedTransactionFilter(this, other);
      }
    };
    _logs = new WeakMap();
    _TransactionResponse = class {
      constructor(tx, provider) {
        __publicField(this, "provider");
        __publicField(this, "blockNumber");
        __publicField(this, "blockHash");
        __publicField(this, "index");
        __publicField(this, "hash");
        __publicField(this, "type");
        __publicField(this, "to");
        __publicField(this, "from");
        __publicField(this, "nonce");
        __publicField(this, "gasLimit");
        __publicField(this, "gasPrice");
        __publicField(this, "maxPriorityFeePerGas");
        __publicField(this, "maxFeePerGas");
        __publicField(this, "data");
        __publicField(this, "value");
        __publicField(this, "chainId");
        __publicField(this, "signature");
        __publicField(this, "accessList");
        __privateAdd(this, _startBlock, void 0);
        this.provider = provider;
        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
        this.blockHash = tx.blockHash != null ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.from = tx.from;
        this.to = tx.to || null;
        this.gasLimit = tx.gasLimit;
        this.nonce = tx.nonce;
        this.data = tx.data;
        this.value = tx.value;
        this.gasPrice = tx.gasPrice;
        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.accessList = tx.accessList != null ? tx.accessList : null;
        __privateSet(this, _startBlock, -1);
      }
      toJSON() {
        const { blockNumber, blockHash, index, hash: hash4, type, to, from, nonce, data: data2, signature: signature2, accessList } = this;
        return {
          _type: "TransactionReceipt",
          accessList,
          blockNumber,
          blockHash,
          chainId: toJson(this.chainId),
          data: data2,
          from,
          gasLimit: toJson(this.gasLimit),
          gasPrice: toJson(this.gasPrice),
          hash: hash4,
          maxFeePerGas: toJson(this.maxFeePerGas),
          maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
          nonce,
          signature: signature2,
          to,
          index,
          type,
          value: toJson(this.value)
        };
      }
      async getBlock() {
        let blockNumber = this.blockNumber;
        if (blockNumber == null) {
          const tx = await this.getTransaction();
          if (tx) {
            blockNumber = tx.blockNumber;
          }
        }
        if (blockNumber == null) {
          return null;
        }
        const block = this.provider.getBlock(blockNumber);
        if (block == null) {
          throw new Error("TODO");
        }
        return block;
      }
      async getTransaction() {
        return this.provider.getTransaction(this.hash);
      }
      async confirmations() {
        if (this.blockNumber == null) {
          const { tx, blockNumber: blockNumber2 } = await resolveProperties2({
            tx: this.getTransaction(),
            blockNumber: this.provider.getBlockNumber()
          });
          if (tx == null || tx.blockNumber == null) {
            return 0;
          }
          return blockNumber2 - tx.blockNumber + 1;
        }
        const blockNumber = await this.provider.getBlockNumber();
        return blockNumber - this.blockNumber + 1;
      }
      async wait(_confirms, _timeout2) {
        const confirms = _confirms == null ? 1 : _confirms;
        const timeout = _timeout2 == null ? 0 : _timeout2;
        let startBlock = __privateGet(this, _startBlock);
        let nextScan = -1;
        let stopScanning = startBlock === -1 ? true : false;
        const checkReplacement = async () => {
          if (stopScanning) {
            return null;
          }
          const { blockNumber, nonce } = await resolveProperties2({
            blockNumber: this.provider.getBlockNumber(),
            nonce: this.provider.getTransactionCount(this.from)
          });
          if (nonce < this.nonce) {
            startBlock = blockNumber;
            return;
          }
          if (stopScanning) {
            return null;
          }
          const mined = await this.getTransaction();
          if (mined && mined.blockNumber != null) {
            return;
          }
          if (nextScan === -1) {
            nextScan = startBlock - 3;
            if (nextScan < __privateGet(this, _startBlock)) {
              nextScan = __privateGet(this, _startBlock);
            }
          }
          while (nextScan <= blockNumber) {
            if (stopScanning) {
              return null;
            }
            const block = await this.provider.getBlock(nextScan, true);
            if (block == null) {
              return;
            }
            for (const hash4 of block) {
              if (hash4 === this.hash) {
                return;
              }
            }
            for (let i = 0; i < block.length; i++) {
              const tx = await block.getTransaction(i);
              if (tx.from === this.from && tx.nonce === this.nonce) {
                if (stopScanning) {
                  return null;
                }
                const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
                if (receipt2 == null) {
                  return;
                }
                if (blockNumber - receipt2.blockNumber + 1 < confirms) {
                  return;
                }
                let reason = "replaced";
                if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                  reason = "repriced";
                } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_09) {
                  reason = "cancelled";
                }
                assert2(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                  cancelled: reason === "replaced" || reason === "cancelled",
                  reason,
                  replacement: tx.replaceableTransaction(startBlock),
                  hash: tx.hash,
                  receipt: receipt2
                });
              }
            }
            nextScan++;
          }
          return;
        };
        const checkReceipt = (receipt2) => {
          if (receipt2 == null || receipt2.status !== 0) {
            return receipt2;
          }
          assert2(false, "transaction execution reverted", "CALL_EXCEPTION", {
            action: "sendTransaction",
            data: null,
            reason: null,
            invocation: null,
            revert: null,
            transaction: {
              to: receipt2.to,
              from: receipt2.from,
              data: ""
            },
            receipt: receipt2
          });
        };
        const receipt = await this.provider.getTransactionReceipt(this.hash);
        if (confirms === 0) {
          return checkReceipt(receipt);
        }
        if (receipt) {
          if (await receipt.confirmations() >= confirms) {
            return checkReceipt(receipt);
          }
        } else {
          await checkReplacement();
          if (confirms === 0) {
            return null;
          }
        }
        const waiter = new Promise((resolve2, reject2) => {
          const cancellers = [];
          const cancel = () => {
            cancellers.forEach((c) => c());
          };
          cancellers.push(() => {
            stopScanning = true;
          });
          if (timeout > 0) {
            const timer2 = setTimeout(() => {
              cancel();
              reject2(makeError("wait for transaction timeout", "TIMEOUT"));
            }, timeout);
            cancellers.push(() => {
              clearTimeout(timer2);
            });
          }
          const txListener = async (receipt2) => {
            if (await receipt2.confirmations() >= confirms) {
              cancel();
              try {
                resolve2(checkReceipt(receipt2));
              } catch (error) {
                reject2(error);
              }
            }
          };
          cancellers.push(() => {
            this.provider.off(this.hash, txListener);
          });
          this.provider.on(this.hash, txListener);
          if (startBlock >= 0) {
            const replaceListener = async () => {
              try {
                await checkReplacement();
              } catch (error) {
                if (isError(error, "TRANSACTION_REPLACED")) {
                  cancel();
                  reject2(error);
                  return;
                }
              }
              if (!stopScanning) {
                this.provider.once("block", replaceListener);
              }
            };
            cancellers.push(() => {
              this.provider.off("block", replaceListener);
            });
            this.provider.once("block", replaceListener);
          }
        });
        return await waiter;
      }
      isMined() {
        return this.blockHash != null;
      }
      isLegacy() {
        return this.type === 0;
      }
      isBerlin() {
        return this.type === 1;
      }
      isLondon() {
        return this.type === 2;
      }
      removedEvent() {
        assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createRemovedTransactionFilter(this);
      }
      reorderedEvent(other) {
        assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        assert2(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createReorderedTransactionFilter(this, other);
      }
      replaceableTransaction(startBlock) {
        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
        const tx = new _TransactionResponse(this, this.provider);
        __privateSet(tx, _startBlock, startBlock);
        return tx;
      }
    };
    TransactionResponse = _TransactionResponse;
    _startBlock = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/wrappers.js
var EventLog, UndecodedEventLog, _iface, ContractTransactionReceipt, _iface2, ContractTransactionResponse, ContractUnknownEventPayload, ContractEventPayload;
var init_wrappers = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/wrappers.js"() {
    init_provider();
    init_utils3();
    EventLog = class extends Log {
      constructor(log, iface, fragment) {
        super(log, log.provider);
        __publicField(this, "interface");
        __publicField(this, "fragment");
        __publicField(this, "args");
        const args = iface.decodeEventLog(fragment, log.data, log.topics);
        defineProperties(this, { args, fragment, interface: iface });
      }
      get eventName() {
        return this.fragment.name;
      }
      get eventSignature() {
        return this.fragment.format();
      }
    };
    UndecodedEventLog = class extends Log {
      constructor(log, error) {
        super(log, log.provider);
        __publicField(this, "error");
        defineProperties(this, { error });
      }
    };
    ContractTransactionReceipt = class extends TransactionReceipt {
      constructor(iface, provider, tx) {
        super(tx, provider);
        __privateAdd(this, _iface, void 0);
        __privateSet(this, _iface, iface);
      }
      get logs() {
        return super.logs.map((log) => {
          const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
          if (fragment) {
            try {
              return new EventLog(log, __privateGet(this, _iface), fragment);
            } catch (error) {
              return new UndecodedEventLog(log, error);
            }
          }
          return log;
        });
      }
    };
    _iface = new WeakMap();
    ContractTransactionResponse = class extends TransactionResponse {
      constructor(iface, provider, tx) {
        super(tx, provider);
        __privateAdd(this, _iface2, void 0);
        __privateSet(this, _iface2, iface);
      }
      async wait(confirms) {
        const receipt = await super.wait(confirms);
        if (receipt == null) {
          return null;
        }
        return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
      }
    };
    _iface2 = new WeakMap();
    ContractUnknownEventPayload = class extends EventPayload {
      constructor(contract, listener, filter, log) {
        super(contract, listener, filter);
        __publicField(this, "log");
        defineProperties(this, { log });
      }
      async getBlock() {
        return await this.log.getBlock();
      }
      async getTransaction() {
        return await this.log.getTransaction();
      }
      async getTransactionReceipt() {
        return await this.log.getTransactionReceipt();
      }
    };
    ContractEventPayload = class extends ContractUnknownEventPayload {
      constructor(contract, listener, filter, fragment, _log) {
        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
        defineProperties(this, { args, fragment });
      }
      get eventName() {
        return this.fragment.name;
      }
      get eventSignature() {
        return this.fragment.format();
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/contract.js
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return void 0;
}
function getRunner2(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = overrides.from;
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner2 = getRunner2(_runner, "resolveName");
  const resolver = canResolve(runner2) ? runner2 : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver);
      }
      return value;
    });
  }));
}
function buildWrappedFallback(contract) {
  const populateTransaction2 = async function(overrides) {
    const tx = await copyOverrides(overrides, ["data"]);
    tx.to = await contract.getAddress();
    if (tx.from) {
      tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
    }
    const iface = contract.interface;
    const noValue = getBigInt(tx.value || BN_010, "overrides.value") === BN_010;
    const noData = (tx.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
    return tx;
  };
  const staticCall = async function(overrides) {
    const runner2 = getRunner2(contract.runner, "call");
    assert2(canCall(runner2), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction2(overrides);
    try {
      return await runner2.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner2 = contract.runner;
    assert2(canSend(runner2), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner2.sendTransaction(await populateTransaction2(overrides));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(overrides) {
    const runner2 = getRunner2(contract.runner, "estimateGas");
    assert2(canEstimate(runner2), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner2.estimateGas(await populateTransaction2(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract,
    estimateGas,
    populateTransaction: populateTransaction2,
    send,
    staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key2) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getFunction(key2, args);
    assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: key2, args }
    });
    return fragment;
  };
  const populateTransaction2 = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
      if (overrides.from) {
        overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
      }
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties2({
      to: contract.getAddress(),
      data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner2 = contract.runner;
    assert2(canSend(runner2), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx = await runner2.sendTransaction(await populateTransaction2(...args));
    const provider = getProvider(contract.runner);
    return new ContractTransactionResponse(contract.interface, provider, tx);
  };
  const estimateGas = async function(...args) {
    const runner2 = getRunner2(contract.runner, "estimateGas");
    assert2(canEstimate(runner2), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner2.estimateGas(await populateTransaction2(...args));
  };
  const staticCallResult = async function(...args) {
    const runner2 = getRunner2(contract.runner, "call");
    assert2(canCall(runner2), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx = await populateTransaction2(...args);
    let result = "0x";
    try {
      result = await runner2.call(tx);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract.interface.makeError(error.data, tx);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract.interface.getFunctionName(key2),
    _contract: contract,
    _key: key2,
    getFragment,
    estimateGas,
    populateTransaction: populateTransaction2,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getFunction(key2);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: key2 }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key2) {
  const getFragment = function(...args) {
    const fragment = contract.interface.getEvent(key2, args);
    assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key: key2, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract.interface.getEventName(key2),
    _contract: contract,
    _key: key2,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract.interface.getEvent(key2);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key: key2 }
      });
      return fragment;
    }
  });
  return method;
}
function setInternal(contract, values2) {
  internalValues.set(contract[internal2], values2);
}
function getInternal(contract) {
  return internalValues.get(contract[internal2]);
}
function isDeferred(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
async function getSubInfo(contract, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString2(name, 32)) {
        return name;
      }
      const fragment2 = contract.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString2(event, 32)) {
      topics = [event];
    } else {
      fragment = contract.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract, event) {
  const { subs } = getInternal(contract);
  return subs.get((await getSubInfo(contract, event)).tag) || null;
}
async function getSub(contract, operation, event) {
  const provider = getProvider(contract.runner);
  assert2(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract, event);
  const { addr, subs } = getInternal(contract);
  let sub = subs.get(tag);
  if (!sub) {
    const address = addr ? addr : contract;
    const filter = { address, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract, event, args, (listener2) => {
          return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider.on(filter, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider.off(filter, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
async function _emit(contract, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
function _ContractBase() {
  return BaseContract2;
}
var BN_010, _filter, PreparedTopicFilter, internal2, internalValues, lastEmit, passProperties2, _a, _BaseContract, BaseContract2, Contract2;
var init_contract = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/contract.js"() {
    init_abi();
    init_address3();
    init_provider();
    init_utils3();
    init_wrappers();
    BN_010 = BigInt(0);
    PreparedTopicFilter = class {
      constructor(contract, fragment, args) {
        __privateAdd(this, _filter, void 0);
        __publicField(this, "fragment");
        defineProperties(this, { fragment });
        if (fragment.inputs.length < args.length) {
          throw new Error("too many arguments");
        }
        const runner2 = getRunner2(contract.runner, "resolveName");
        const resolver = canResolve(runner2) ? runner2 : null;
        __privateSet(this, _filter, async function() {
          const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
            const arg = args[index];
            if (arg == null) {
              return null;
            }
            return param.walkAsync(args[index], (type, value) => {
              if (type === "address") {
                if (Array.isArray(value)) {
                  return Promise.all(value.map((v) => resolveAddress(v, resolver)));
                }
                return resolveAddress(value, resolver);
              }
              return value;
            });
          }));
          return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
        }());
      }
      getTopicFilter() {
        return __privateGet(this, _filter);
      }
    };
    _filter = new WeakMap();
    internal2 = Symbol.for("_ethersInternal_contract");
    internalValues = /* @__PURE__ */ new WeakMap();
    lastEmit = Promise.resolve();
    passProperties2 = ["then"];
    _BaseContract = class {
      constructor(target, abi, runner2, _deployTx) {
        __publicField(this, "target");
        __publicField(this, "interface");
        __publicField(this, "runner");
        __publicField(this, "filters");
        __publicField(this, _a);
        __publicField(this, "fallback");
        assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
        if (runner2 == null) {
          runner2 = null;
        }
        const iface = Interface2.from(abi);
        defineProperties(this, { target, runner: runner2, interface: iface });
        Object.defineProperty(this, internal2, { value: {} });
        let addrPromise;
        let addr = null;
        let deployTx = null;
        if (_deployTx) {
          const provider = getProvider(runner2);
          deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
        }
        let subs = /* @__PURE__ */ new Map();
        if (typeof target === "string") {
          if (isHexString2(target)) {
            addr = target;
            addrPromise = Promise.resolve(target);
          } else {
            const resolver = getRunner2(runner2, "resolveName");
            if (!canResolve(resolver)) {
              throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                operation: "resolveName"
              });
            }
            addrPromise = resolver.resolveName(target).then((addr2) => {
              if (addr2 == null) {
                throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                  value: target
                });
              }
              getInternal(this).addr = addr2;
              return addr2;
            });
          }
        } else {
          addrPromise = target.getAddress().then((addr2) => {
            if (addr2 == null) {
              throw new Error("TODO");
            }
            getInternal(this).addr = addr2;
            return addr2;
          });
        }
        setInternal(this, { addrPromise, addr, deployTx, subs });
        const filters = new Proxy({}, {
          get: (target2, prop, receiver) => {
            if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
              return Reflect.get(target2, prop, receiver);
            }
            try {
              return this.getEvent(prop);
            } catch (error) {
              if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                throw error;
              }
            }
            return void 0;
          },
          has: (target2, prop) => {
            if (passProperties2.indexOf(prop) >= 0) {
              return Reflect.has(target2, prop);
            }
            return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
          }
        });
        defineProperties(this, { filters });
        defineProperties(this, {
          fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
        });
        return new Proxy(this, {
          get: (target2, prop, receiver) => {
            if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
              return Reflect.get(target2, prop, receiver);
            }
            try {
              return target2.getFunction(prop);
            } catch (error) {
              if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                throw error;
              }
            }
            return void 0;
          },
          has: (target2, prop) => {
            if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
              return Reflect.has(target2, prop);
            }
            return target2.interface.hasFunction(prop);
          }
        });
      }
      connect(runner2) {
        return new _BaseContract(this.target, this.interface, runner2);
      }
      attach(target) {
        return new _BaseContract(target, this.interface, this.runner);
      }
      async getAddress() {
        return await getInternal(this).addrPromise;
      }
      async getDeployedCode() {
        const provider = getProvider(this.runner);
        assert2(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
        const code = await provider.getCode(await this.getAddress());
        if (code === "0x") {
          return null;
        }
        return code;
      }
      async waitForDeployment() {
        const deployTx = this.deploymentTransaction();
        if (deployTx) {
          await deployTx.wait();
          return this;
        }
        const code = await this.getDeployedCode();
        if (code != null) {
          return this;
        }
        const provider = getProvider(this.runner);
        assert2(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
        return new Promise((resolve2, reject2) => {
          const checkCode = async () => {
            try {
              const code2 = await this.getDeployedCode();
              if (code2 != null) {
                return resolve2(this);
              }
              provider.once("block", checkCode);
            } catch (error) {
              reject2(error);
            }
          };
          checkCode();
        });
      }
      deploymentTransaction() {
        return getInternal(this).deployTx;
      }
      getFunction(key2) {
        if (typeof key2 !== "string") {
          key2 = key2.format();
        }
        const func = buildWrappedMethod(this, key2);
        return func;
      }
      getEvent(key2) {
        if (typeof key2 !== "string") {
          key2 = key2.format();
        }
        return buildWrappedEvent(this, key2);
      }
      async queryTransaction(hash4) {
        throw new Error("@TODO");
      }
      async queryFilter(event, fromBlock, toBlock) {
        if (fromBlock == null) {
          fromBlock = 0;
        }
        if (toBlock == null) {
          toBlock = "latest";
        }
        const { addr, addrPromise } = getInternal(this);
        const address = addr ? addr : await addrPromise;
        const { fragment, topics } = await getSubInfo(this, event);
        const filter = { address, topics, fromBlock, toBlock };
        const provider = getProvider(this.runner);
        assert2(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
        return (await provider.getLogs(filter)).map((log) => {
          let foundFragment = fragment;
          if (foundFragment == null) {
            try {
              foundFragment = this.interface.getEvent(log.topics[0]);
            } catch (error) {
            }
          }
          if (foundFragment) {
            try {
              return new EventLog(log, this.interface, foundFragment);
            } catch (error) {
              return new UndecodedEventLog(log, error);
            }
          }
          return new Log(log, provider);
        });
      }
      async on(event, listener) {
        const sub = await getSub(this, "on", event);
        sub.listeners.push({ listener, once: false });
        sub.start();
        return this;
      }
      async once(event, listener) {
        const sub = await getSub(this, "once", event);
        sub.listeners.push({ listener, once: true });
        sub.start();
        return this;
      }
      async emit(event, ...args) {
        return await emit(this, event, args, null);
      }
      async listenerCount(event) {
        if (event) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return 0;
          }
          return sub.listeners.length;
        }
        const { subs } = getInternal(this);
        let total = 0;
        for (const { listeners } of subs.values()) {
          total += listeners.length;
        }
        return total;
      }
      async listeners(event) {
        if (event) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return [];
          }
          return sub.listeners.map(({ listener }) => listener);
        }
        const { subs } = getInternal(this);
        let result = [];
        for (const { listeners } of subs.values()) {
          result = result.concat(listeners.map(({ listener }) => listener));
        }
        return result;
      }
      async off(event, listener) {
        const sub = await hasSub(this, event);
        if (!sub) {
          return this;
        }
        if (listener) {
          const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
          if (index >= 0) {
            sub.listeners.splice(index, 1);
          }
        }
        if (listener == null || sub.listeners.length === 0) {
          sub.stop();
          getInternal(this).subs.delete(sub.tag);
        }
        return this;
      }
      async removeAllListeners(event) {
        if (event) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return this;
          }
          sub.stop();
          getInternal(this).subs.delete(sub.tag);
        } else {
          const { subs } = getInternal(this);
          for (const { tag, stop } of subs.values()) {
            stop();
            subs.delete(tag);
          }
        }
        return this;
      }
      async addListener(event, listener) {
        return await this.on(event, listener);
      }
      async removeListener(event, listener) {
        return await this.off(event, listener);
      }
      static buildClass(abi) {
        class CustomContract extends _BaseContract {
          constructor(address, runner2 = null) {
            super(address, abi, runner2);
          }
        }
        return CustomContract;
      }
      static from(target, abi, runner2) {
        if (runner2 == null) {
          runner2 = null;
        }
        const contract = new this(target, abi, runner2);
        return contract;
      }
    };
    BaseContract2 = _BaseContract;
    _a = internal2;
    Contract2 = class extends _ContractBase() {
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/factory.js
var init_factory = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/factory.js"() {
    init_abi();
    init_address3();
    init_utils3();
    init_contract();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/index.js
var init_contract2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/contract/index.js"() {
    init_contract();
    init_factory();
    init_wrappers();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/ens-resolver.js
function getIpfsLink2(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
var MulticoinProviderPlugin, matcherIpfs2, matchers2, _supports2544, _resolver, _fetch, fetch_fn, _getResolver, getResolver_fn, _EnsResolver, EnsResolver;
var init_ens_resolver = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/ens-resolver.js"() {
    init_address3();
    init_constants();
    init_contract2();
    init_hash();
    init_utils3();
    MulticoinProviderPlugin = class {
      constructor(name) {
        __publicField(this, "name");
        defineProperties(this, { name });
      }
      connect(proivder) {
        return this;
      }
      supportsCoinType(coinType) {
        return false;
      }
      async encodeAddress(coinType, address) {
        throw new Error("unsupported coin");
      }
      async decodeAddress(coinType, data2) {
        throw new Error("unsupported coin");
      }
    };
    matcherIpfs2 = new RegExp("^(ipfs)://(.*)$", "i");
    matchers2 = [
      new RegExp("^(https)://(.*)$", "i"),
      new RegExp("^(data):(.*)$", "i"),
      matcherIpfs2,
      new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
    ];
    _EnsResolver = class {
      constructor(provider, address, name) {
        __privateAdd(this, _fetch);
        __publicField(this, "provider");
        __publicField(this, "address");
        __publicField(this, "name");
        __privateAdd(this, _supports2544, void 0);
        __privateAdd(this, _resolver, void 0);
        defineProperties(this, { provider, address, name });
        __privateSet(this, _supports2544, null);
        __privateSet(this, _resolver, new Contract2(address, [
          "function supportsInterface(bytes4) view returns (bool)",
          "function resolve(bytes, bytes) view returns (bytes)",
          "function addr(bytes32) view returns (address)",
          "function addr(bytes32, uint) view returns (bytes)",
          "function text(bytes32, string) view returns (string)",
          "function contenthash(bytes32) view returns (bytes)"
        ], provider));
      }
      async supportsWildcard() {
        if (__privateGet(this, _supports2544) == null) {
          __privateSet(this, _supports2544, (async () => {
            try {
              return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
            } catch (error) {
              if (isError(error, "CALL_EXCEPTION")) {
                return false;
              }
              __privateSet(this, _supports2544, null);
              throw error;
            }
          })());
        }
        return await __privateGet(this, _supports2544);
      }
      async getAddress(coinType) {
        if (coinType == null) {
          coinType = 60;
        }
        if (coinType === 60) {
          try {
            const result = await __privateMethod(this, _fetch, fetch_fn).call(this, "addr(bytes32)");
            if (result == null || result === ZeroAddress) {
              return null;
            }
            return result;
          } catch (error) {
            if (isError(error, "CALL_EXCEPTION")) {
              return null;
            }
            throw error;
          }
        }
        if (coinType >= 0 && coinType < 2147483648) {
          let ethCoinType = coinType + 2147483648;
          const data3 = await __privateMethod(this, _fetch, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
          if (isHexString2(data3, 20)) {
            return getAddress2(data3);
          }
        }
        let coinPlugin = null;
        for (const plugin of this.provider.plugins) {
          if (!(plugin instanceof MulticoinProviderPlugin)) {
            continue;
          }
          if (plugin.supportsCoinType(coinType)) {
            coinPlugin = plugin;
            break;
          }
        }
        if (coinPlugin == null) {
          return null;
        }
        const data2 = await __privateMethod(this, _fetch, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
        if (data2 == null || data2 === "0x") {
          return null;
        }
        const address = await coinPlugin.decodeAddress(coinType, data2);
        if (address != null) {
          return address;
        }
        assert2(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
          operation: `getAddress(${coinType})`,
          info: { coinType, data: data2 }
        });
      }
      async getText(key2) {
        const data2 = await __privateMethod(this, _fetch, fetch_fn).call(this, "text(bytes32,string)", [key2]);
        if (data2 == null || data2 === "0x") {
          return null;
        }
        return data2;
      }
      async getContentHash() {
        const data2 = await __privateMethod(this, _fetch, fetch_fn).call(this, "contenthash(bytes32)");
        if (data2 == null || data2 === "0x") {
          return null;
        }
        const ipfs = data2.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipfs) {
          const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
          const length = parseInt(ipfs[4], 16);
          if (ipfs[5].length === length * 2) {
            return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
          }
        }
        const swarm = data2.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (swarm && swarm[1].length === 64) {
          return `bzz://${swarm[1]}`;
        }
        assert2(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
          operation: "getContentHash()",
          info: { data: data2 }
        });
      }
      async getAvatar() {
        const avatar = await this._getAvatar();
        return avatar.url;
      }
      async _getAvatar() {
        const linkage = [{ type: "name", value: this.name }];
        try {
          const avatar = await this.getText("avatar");
          if (avatar == null) {
            linkage.push({ type: "!avatar", value: "" });
            return { url: null, linkage };
          }
          linkage.push({ type: "avatar", value: avatar });
          for (let i = 0; i < matchers2.length; i++) {
            const match2 = avatar.match(matchers2[i]);
            if (match2 == null) {
              continue;
            }
            const scheme = match2[1].toLowerCase();
            switch (scheme) {
              case "https":
              case "data":
                linkage.push({ type: "url", value: avatar });
                return { linkage, url: avatar };
              case "ipfs": {
                const url = getIpfsLink2(avatar);
                linkage.push({ type: "ipfs", value: avatar });
                linkage.push({ type: "url", value: url });
                return { linkage, url };
              }
              case "erc721":
              case "erc1155": {
                const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                linkage.push({ type: scheme, value: avatar });
                const owner = await this.getAddress();
                if (owner == null) {
                  linkage.push({ type: "!owner", value: "" });
                  return { url: null, linkage };
                }
                const comps = (match2[2] || "").split("/");
                if (comps.length !== 2) {
                  linkage.push({ type: `!${scheme}caip`, value: match2[2] || "" });
                  return { url: null, linkage };
                }
                const tokenId = comps[1];
                const contract = new Contract2(comps[0], [
                  "function tokenURI(uint) view returns (string)",
                  "function ownerOf(uint) view returns (address)",
                  "function uri(uint) view returns (string)",
                  "function balanceOf(address, uint256) view returns (uint)"
                ], this.provider);
                if (scheme === "erc721") {
                  const tokenOwner = await contract.ownerOf(tokenId);
                  if (owner !== tokenOwner) {
                    linkage.push({ type: "!owner", value: tokenOwner });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "owner", value: tokenOwner });
                } else if (scheme === "erc1155") {
                  const balance = await contract.balanceOf(owner, tokenId);
                  if (!balance) {
                    linkage.push({ type: "!balance", value: "0" });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "balance", value: balance.toString() });
                }
                let metadataUrl = await contract[selector](tokenId);
                if (metadataUrl == null || metadataUrl === "0x") {
                  linkage.push({ type: "!metadata-url", value: "" });
                  return { url: null, linkage };
                }
                linkage.push({ type: "metadata-url-base", value: metadataUrl });
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
                  linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
                }
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink2(metadataUrl);
                }
                linkage.push({ type: "metadata-url", value: metadataUrl });
                let metadata = {};
                const response = await new FetchRequest(metadataUrl).send();
                response.assertOk();
                try {
                  metadata = response.bodyJson;
                } catch (error) {
                  try {
                    linkage.push({ type: "!metadata", value: response.bodyText });
                  } catch (error2) {
                    const bytes3 = response.body;
                    if (bytes3) {
                      linkage.push({ type: "!metadata", value: hexlify2(bytes3) });
                    }
                    return { url: null, linkage };
                  }
                  return { url: null, linkage };
                }
                if (!metadata) {
                  linkage.push({ type: "!metadata", value: "" });
                  return { url: null, linkage };
                }
                linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
                let imageUrl = metadata.image;
                if (typeof imageUrl !== "string") {
                  linkage.push({ type: "!imageUrl", value: "" });
                  return { url: null, linkage };
                }
                if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                } else {
                  const ipfs = imageUrl.match(matcherIpfs2);
                  if (ipfs == null) {
                    linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                  imageUrl = getIpfsLink2(imageUrl);
                }
                linkage.push({ type: "url", value: imageUrl });
                return { linkage, url: imageUrl };
              }
            }
          }
        } catch (error) {
        }
        return { linkage, url: null };
      }
      static async getEnsAddress(provider) {
        const network = await provider.getNetwork();
        const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
        assert2(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
          operation: "getEnsAddress",
          info: { network }
        });
        return ensPlugin.address;
      }
      static async fromName(provider, name) {
        var _a2;
        let currentName = name;
        while (true) {
          if (currentName === "" || currentName === ".") {
            return null;
          }
          if (name !== "eth" && currentName === "eth") {
            return null;
          }
          const addr = await __privateMethod(_a2 = _EnsResolver, _getResolver, getResolver_fn).call(_a2, provider, currentName);
          if (addr != null) {
            const resolver = new _EnsResolver(provider, addr, name);
            if (currentName !== name && !await resolver.supportsWildcard()) {
              return null;
            }
            return resolver;
          }
          currentName = currentName.split(".").slice(1).join(".");
        }
      }
    };
    EnsResolver = _EnsResolver;
    _supports2544 = new WeakMap();
    _resolver = new WeakMap();
    _fetch = new WeakSet();
    fetch_fn = async function(funcName, params) {
      params = (params || []).slice();
      const iface = __privateGet(this, _resolver).interface;
      params.unshift(namehash2(this.name));
      let fragment = null;
      if (await this.supportsWildcard()) {
        fragment = iface.getFunction(funcName);
        assert2(fragment, "missing fragment", "UNKNOWN_ERROR", {
          info: { funcName }
        });
        params = [
          dnsEncode2(this.name),
          iface.encodeFunctionData(fragment, params)
        ];
        funcName = "resolve(bytes,bytes)";
      }
      params.push({
        enableCcipRead: true
      });
      try {
        const result = await __privateGet(this, _resolver)[funcName](...params);
        if (fragment) {
          return iface.decodeFunctionResult(fragment, result)[0];
        }
        return result;
      } catch (error) {
        if (!isError(error, "CALL_EXCEPTION")) {
          throw error;
        }
      }
      return null;
    };
    _getResolver = new WeakSet();
    getResolver_fn = async function(provider, name) {
      const ensAddr = await _EnsResolver.getEnsAddress(provider);
      try {
        const contract = new Contract2(ensAddr, [
          "function resolver(bytes32) view returns (address)"
        ], provider);
        const addr = await contract.resolver(namehash2(name), {
          enableCcipRead: true
        });
        if (addr === ZeroAddress) {
          return null;
        }
        return addr;
      } catch (error) {
        throw error;
      }
      return null;
    };
    __privateAdd(EnsResolver, _getResolver);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/format.js
function allowNull(format, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
function arrayOf(format) {
  return (array) => {
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map((i) => format(i));
  };
}
function object(format, altNames) {
  return (value) => {
    const result = {};
    for (const key2 in format) {
      let srcKey = key2;
      if (altNames && key2 in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key2]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format[key2](value[srcKey]);
        if (nv !== void 0) {
          result[key2] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert2(false, `invalid value for value.${key2} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString2(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString2(value, 32), "invalid hash", "value", value);
  return value;
}
function formatLog(value) {
  return _formatLog(value);
}
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx) => {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_011) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object({
    hash: formatHash,
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify2, null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress2,
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    gasLimit: getBigInt,
    to: allowNull(getAddress2, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress2, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature2.from(value.signature);
  } else {
    result.signature = Signature2.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_011) {
    result.blockHash = null;
  }
  return result;
}
var BN_011, _formatLog, _formatBlock, _formatReceiptLog, _formatTransactionReceipt;
var init_format = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/format.js"() {
    init_address3();
    init_crypto2();
    init_transaction2();
    init_utils3();
    BN_011 = BigInt(0);
    _formatLog = object({
      address: getAddress2,
      blockHash: formatHash,
      blockNumber: getNumber,
      data: formatData,
      index: getNumber,
      removed: allowNull(formatBoolean, false),
      topics: arrayOf(formatHash),
      transactionHash: formatHash,
      transactionIndex: getNumber
    }, {
      index: ["logIndex"]
    });
    _formatBlock = object({
      hash: allowNull(formatHash),
      parentHash: formatHash,
      number: getNumber,
      timestamp: getNumber,
      nonce: allowNull(formatData),
      difficulty: getBigInt,
      gasLimit: getBigInt,
      gasUsed: getBigInt,
      miner: allowNull(getAddress2),
      extraData: formatData,
      baseFeePerGas: allowNull(getBigInt)
    });
    _formatReceiptLog = object({
      transactionIndex: getNumber,
      blockNumber: getNumber,
      transactionHash: formatHash,
      address: getAddress2,
      topics: arrayOf(formatHash),
      data: formatData,
      index: getNumber,
      blockHash: formatHash
    }, {
      index: ["logIndex"]
    });
    _formatTransactionReceipt = object({
      to: allowNull(getAddress2, null),
      from: allowNull(getAddress2, null),
      contractAddress: allowNull(getAddress2, null),
      index: getNumber,
      root: allowNull(hexlify2),
      gasUsed: getBigInt,
      logsBloom: allowNull(formatData),
      blockHash: formatHash,
      hash: formatHash,
      logs: arrayOf(formatReceiptLog),
      blockNumber: getNumber,
      cumulativeGasUsed: getBigInt,
      effectiveGasPrice: allowNull(getBigInt),
      status: allowNull(getNumber),
      type: allowNull(getNumber, 0)
    }, {
      effectiveGasPrice: ["gasPrice"],
      hash: ["transactionHash"],
      index: ["transactionIndex"]
    });
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress, NetworkPlugin, GasCostPlugin, EnsPlugin, _feeDataFunc, _FeeDataNetworkPlugin, FeeDataNetworkPlugin, _url2, _processFunc, FetchUrlFeeDataNetworkPlugin;
var init_plugins_network = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/plugins-network.js"() {
    init_properties();
    init_utils3();
    EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
    NetworkPlugin = class {
      constructor(name) {
        __publicField(this, "name");
        defineProperties(this, { name });
      }
      clone() {
        return new NetworkPlugin(this.name);
      }
    };
    GasCostPlugin = class extends NetworkPlugin {
      constructor(effectiveBlock, costs) {
        if (effectiveBlock == null) {
          effectiveBlock = 0;
        }
        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
        __publicField(this, "effectiveBlock");
        __publicField(this, "txBase");
        __publicField(this, "txCreate");
        __publicField(this, "txDataZero");
        __publicField(this, "txDataNonzero");
        __publicField(this, "txAccessListStorageKey");
        __publicField(this, "txAccessListAddress");
        const props = { effectiveBlock };
        function set2(name, nullish) {
          let value = (costs || {})[name];
          if (value == null) {
            value = nullish;
          }
          assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
          props[name] = value;
        }
        set2("txBase", 21e3);
        set2("txCreate", 32e3);
        set2("txDataZero", 4);
        set2("txDataNonzero", 16);
        set2("txAccessListStorageKey", 1900);
        set2("txAccessListAddress", 2400);
        defineProperties(this, props);
      }
      clone() {
        return new GasCostPlugin(this.effectiveBlock, this);
      }
    };
    EnsPlugin = class extends NetworkPlugin {
      constructor(address, targetNetwork) {
        super("org.ethers.plugins.network.Ens");
        __publicField(this, "address");
        __publicField(this, "targetNetwork");
        defineProperties(this, {
          address: address || EnsAddress,
          targetNetwork: targetNetwork == null ? 1 : targetNetwork
        });
      }
      clone() {
        return new EnsPlugin(this.address, this.targetNetwork);
      }
    };
    _FeeDataNetworkPlugin = class extends NetworkPlugin {
      constructor(feeDataFunc) {
        super("org.ethers.plugins.network.FeeData");
        __privateAdd(this, _feeDataFunc, void 0);
        __privateSet(this, _feeDataFunc, feeDataFunc);
      }
      get feeDataFunc() {
        return __privateGet(this, _feeDataFunc);
      }
      async getFeeData(provider) {
        return await __privateGet(this, _feeDataFunc).call(this, provider);
      }
      clone() {
        return new _FeeDataNetworkPlugin(__privateGet(this, _feeDataFunc));
      }
    };
    FeeDataNetworkPlugin = _FeeDataNetworkPlugin;
    _feeDataFunc = new WeakMap();
    FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
      constructor(url, processFunc) {
        super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        __privateAdd(this, _url2, void 0);
        __privateAdd(this, _processFunc, void 0);
        __privateSet(this, _url2, url);
        __privateSet(this, _processFunc, processFunc);
      }
      get url() {
        return __privateGet(this, _url2);
      }
      get processFunc() {
        return __privateGet(this, _processFunc);
      }
      clone() {
        return this;
      }
    };
    _url2 = new WeakMap();
    _processFunc = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/network.js
function parseUnits3(_value2, decimals) {
  const value = String(_value2);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value2}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
function getGasStationPlugin(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      const [_response, _feeData] = await Promise.all([
        request.send(),
        fetchFeeData()
      ]);
      response = _response;
      const payload = response.bodyJson.standard;
      const feeData = {
        gasPrice: _feeData.gasPrice,
        maxFeePerGas: parseUnits3(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits3(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert2(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
}
function getPriorityFeePlugin(maxPriorityFeePerGas) {
  return new FetchUrlFeeDataNetworkPlugin("data:", async (fetchFeeData, provider, request) => {
    const feeData = await fetchFeeData();
    if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {
      return feeData;
    }
    const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;
    return {
      gasPrice: feeData.gasPrice,
      maxFeePerGas: baseFee + maxPriorityFeePerGas,
      maxPriorityFeePerGas
    };
  });
}
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin());
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: [
      getPriorityFeePlugin(BigInt("1000000"))
    ]
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
}
var Networks, _name, _chainId2, _plugins, _Network, Network, injected;
var init_network = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/network.js"() {
    init_transaction2();
    init_utils3();
    init_plugins_network();
    Networks = /* @__PURE__ */ new Map();
    _Network = class {
      constructor(name, chainId) {
        __privateAdd(this, _name, void 0);
        __privateAdd(this, _chainId2, void 0);
        __privateAdd(this, _plugins, void 0);
        __privateSet(this, _name, name);
        __privateSet(this, _chainId2, getBigInt(chainId));
        __privateSet(this, _plugins, /* @__PURE__ */ new Map());
      }
      toJSON() {
        return { name: this.name, chainId: String(this.chainId) };
      }
      get name() {
        return __privateGet(this, _name);
      }
      set name(value) {
        __privateSet(this, _name, value);
      }
      get chainId() {
        return __privateGet(this, _chainId2);
      }
      set chainId(value) {
        __privateSet(this, _chainId2, getBigInt(value, "chainId"));
      }
      matches(other) {
        if (other == null) {
          return false;
        }
        if (typeof other === "string") {
          try {
            return this.chainId === getBigInt(other);
          } catch (error) {
          }
          return this.name === other;
        }
        if (typeof other === "number" || typeof other === "bigint") {
          try {
            return this.chainId === getBigInt(other);
          } catch (error) {
          }
          return false;
        }
        if (typeof other === "object") {
          if (other.chainId != null) {
            try {
              return this.chainId === getBigInt(other.chainId);
            } catch (error) {
            }
            return false;
          }
          if (other.name != null) {
            return this.name === other.name;
          }
          return false;
        }
        return false;
      }
      get plugins() {
        return Array.from(__privateGet(this, _plugins).values());
      }
      attachPlugin(plugin) {
        if (__privateGet(this, _plugins).get(plugin.name)) {
          throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        __privateGet(this, _plugins).set(plugin.name, plugin.clone());
        return this;
      }
      getPlugin(name) {
        return __privateGet(this, _plugins).get(name) || null;
      }
      getPlugins(basename) {
        return this.plugins.filter((p) => p.name.split("#")[0] === basename);
      }
      clone() {
        const clone = new _Network(this.name, this.chainId);
        this.plugins.forEach((plugin) => {
          clone.attachPlugin(plugin.clone());
        });
        return clone;
      }
      computeIntrinsicGas(tx) {
        const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
        let gas = costs.txBase;
        if (tx.to == null) {
          gas += costs.txCreate;
        }
        if (tx.data) {
          for (let i = 2; i < tx.data.length; i += 2) {
            if (tx.data.substring(i, i + 2) === "00") {
              gas += costs.txDataZero;
            } else {
              gas += costs.txDataNonzero;
            }
          }
        }
        if (tx.accessList) {
          const accessList = accessListify2(tx.accessList);
          for (const addr in accessList) {
            gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
          }
        }
        return gas;
      }
      static from(network) {
        injectCommonNetworks();
        if (network == null) {
          return _Network.from("mainnet");
        }
        if (typeof network === "number") {
          network = BigInt(network);
        }
        if (typeof network === "string" || typeof network === "bigint") {
          const networkFunc = Networks.get(network);
          if (networkFunc) {
            return networkFunc();
          }
          if (typeof network === "bigint") {
            return new _Network("unknown", network);
          }
          assertArgument(false, "unknown network", "network", network);
        }
        if (typeof network.clone === "function") {
          const clone = network.clone();
          return clone;
        }
        if (typeof network === "object") {
          assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
          const custom = new _Network(network.name, network.chainId);
          if (network.ensAddress || network.ensNetwork != null) {
            custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
          }
          return custom;
        }
        assertArgument(false, "invalid network", "network", network);
      }
      static register(nameOrChainId, networkFunc) {
        if (typeof nameOrChainId === "number") {
          nameOrChainId = BigInt(nameOrChainId);
        }
        const existing = Networks.get(nameOrChainId);
        if (existing) {
          assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
        }
        Networks.set(nameOrChainId, networkFunc);
      }
    };
    Network = _Network;
    _name = new WeakMap();
    _chainId2 = new WeakMap();
    _plugins = new WeakMap();
    injected = false;
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/subscriber-polling.js
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var _provider, _poller, _interval, _blockNumber, _poll, poll_fn, PollingBlockSubscriber, _provider2, _poll2, _running, OnBlockSubscriber, _filter2, PollingOrphanSubscriber, _hash, PollingTransactionSubscriber, _provider3, _filter3, _poller2, _running2, _blockNumber2, _poll3, poll_fn2, PollingEventSubscriber;
var init_subscriber_polling = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/subscriber-polling.js"() {
    init_utils3();
    PollingBlockSubscriber = class {
      constructor(provider) {
        __privateAdd(this, _poll);
        __privateAdd(this, _provider, void 0);
        __privateAdd(this, _poller, void 0);
        __privateAdd(this, _interval, void 0);
        __privateAdd(this, _blockNumber, void 0);
        __privateSet(this, _provider, provider);
        __privateSet(this, _poller, null);
        __privateSet(this, _interval, 4e3);
        __privateSet(this, _blockNumber, -2);
      }
      get pollingInterval() {
        return __privateGet(this, _interval);
      }
      set pollingInterval(value) {
        __privateSet(this, _interval, value);
      }
      start() {
        if (__privateGet(this, _poller)) {
          return;
        }
        __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _poll, poll_fn).bind(this), __privateGet(this, _interval)));
        __privateMethod(this, _poll, poll_fn).call(this);
      }
      stop() {
        if (!__privateGet(this, _poller)) {
          return;
        }
        __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
        __privateSet(this, _poller, null);
      }
      pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
          __privateSet(this, _blockNumber, -2);
        }
      }
      resume() {
        this.start();
      }
    };
    _provider = new WeakMap();
    _poller = new WeakMap();
    _interval = new WeakMap();
    _blockNumber = new WeakMap();
    _poll = new WeakSet();
    poll_fn = async function() {
      try {
        const blockNumber = await __privateGet(this, _provider).getBlockNumber();
        if (__privateGet(this, _blockNumber) === -2) {
          __privateSet(this, _blockNumber, blockNumber);
          return;
        }
        if (blockNumber !== __privateGet(this, _blockNumber)) {
          for (let b2 = __privateGet(this, _blockNumber) + 1; b2 <= blockNumber; b2++) {
            if (__privateGet(this, _poller) == null) {
              return;
            }
            await __privateGet(this, _provider).emit("block", b2);
          }
          __privateSet(this, _blockNumber, blockNumber);
        }
      } catch (error) {
      }
      if (__privateGet(this, _poller) == null) {
        return;
      }
      __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _poll, poll_fn).bind(this), __privateGet(this, _interval)));
    };
    OnBlockSubscriber = class {
      constructor(provider) {
        __privateAdd(this, _provider2, void 0);
        __privateAdd(this, _poll2, void 0);
        __privateAdd(this, _running, void 0);
        __privateSet(this, _provider2, provider);
        __privateSet(this, _running, false);
        __privateSet(this, _poll2, (blockNumber) => {
          this._poll(blockNumber, __privateGet(this, _provider2));
        });
      }
      async _poll(blockNumber, provider) {
        throw new Error("sub-classes must override this");
      }
      start() {
        if (__privateGet(this, _running)) {
          return;
        }
        __privateSet(this, _running, true);
        __privateGet(this, _poll2).call(this, -2);
        __privateGet(this, _provider2).on("block", __privateGet(this, _poll2));
      }
      stop() {
        if (!__privateGet(this, _running)) {
          return;
        }
        __privateSet(this, _running, false);
        __privateGet(this, _provider2).off("block", __privateGet(this, _poll2));
      }
      pause(dropWhilePaused) {
        this.stop();
      }
      resume() {
        this.start();
      }
    };
    _provider2 = new WeakMap();
    _poll2 = new WeakMap();
    _running = new WeakMap();
    PollingOrphanSubscriber = class extends OnBlockSubscriber {
      constructor(provider, filter) {
        super(provider);
        __privateAdd(this, _filter2, void 0);
        __privateSet(this, _filter2, copy(filter));
      }
      async _poll(blockNumber, provider) {
        throw new Error("@TODO");
        console.log(__privateGet(this, _filter2));
      }
    };
    _filter2 = new WeakMap();
    PollingTransactionSubscriber = class extends OnBlockSubscriber {
      constructor(provider, hash4) {
        super(provider);
        __privateAdd(this, _hash, void 0);
        __privateSet(this, _hash, hash4);
      }
      async _poll(blockNumber, provider) {
        const tx = await provider.getTransactionReceipt(__privateGet(this, _hash));
        if (tx) {
          provider.emit(__privateGet(this, _hash), tx);
        }
      }
    };
    _hash = new WeakMap();
    PollingEventSubscriber = class {
      constructor(provider, filter) {
        __privateAdd(this, _poll3);
        __privateAdd(this, _provider3, void 0);
        __privateAdd(this, _filter3, void 0);
        __privateAdd(this, _poller2, void 0);
        __privateAdd(this, _running2, void 0);
        __privateAdd(this, _blockNumber2, void 0);
        __privateSet(this, _provider3, provider);
        __privateSet(this, _filter3, copy(filter));
        __privateSet(this, _poller2, __privateMethod(this, _poll3, poll_fn2).bind(this));
        __privateSet(this, _running2, false);
        __privateSet(this, _blockNumber2, -2);
      }
      start() {
        if (__privateGet(this, _running2)) {
          return;
        }
        __privateSet(this, _running2, true);
        if (__privateGet(this, _blockNumber2) === -2) {
          __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
            __privateSet(this, _blockNumber2, blockNumber);
          });
        }
        __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
      }
      stop() {
        if (!__privateGet(this, _running2)) {
          return;
        }
        __privateSet(this, _running2, false);
        __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
      }
      pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
          __privateSet(this, _blockNumber2, -2);
        }
      }
      resume() {
        this.start();
      }
    };
    _provider3 = new WeakMap();
    _filter3 = new WeakMap();
    _poller2 = new WeakMap();
    _running2 = new WeakMap();
    _blockNumber2 = new WeakMap();
    _poll3 = new WeakSet();
    poll_fn2 = async function(blockNumber) {
      if (__privateGet(this, _blockNumber2) === -2) {
        return;
      }
      const filter = copy(__privateGet(this, _filter3));
      filter.fromBlock = __privateGet(this, _blockNumber2) + 1;
      filter.toBlock = blockNumber;
      const logs = await __privateGet(this, _provider3).getLogs(filter);
      if (logs.length === 0) {
        if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
          __privateSet(this, _blockNumber2, blockNumber - 60);
        }
        return;
      }
      for (const log of logs) {
        __privateGet(this, _provider3).emit(__privateGet(this, _filter3), log);
        __privateSet(this, _blockNumber2, log.blockNumber);
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/abstract-provider.js
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys3 = Object.keys(v);
      keys3.sort();
      return keys3.reduce((accum, key2) => {
        accum[key2] = v[key2];
        return accum;
      }, {});
    }
    return v;
  });
}
function copy2(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
async function getSubscription(_event2, provider) {
  if (_event2 == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event2)) {
    _event2 = { topics: _event2 };
  }
  if (typeof _event2 === "string") {
    switch (_event2) {
      case "block":
      case "pending":
      case "debug":
      case "error":
      case "network": {
        return { type: _event2, tag: _event2 };
      }
    }
  }
  if (isHexString2(_event2, 32)) {
    const hash4 = _event2.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash4 }), hash: hash4 };
  }
  if (_event2.orphan) {
    const event = _event2;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy2(event) };
  }
  if (_event2.address || _event2.topics) {
    const event = _event2;
    const filter = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString2(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter.address = concisify(addresses.map((a) => a.toLowerCase()));
    }
    return { filter, tag: getTag("event", filter), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event2);
}
function getTime3() {
  return new Date().getTime();
}
function _parseString2(result, start) {
  try {
    const bytes3 = _parseBytes2(result, start);
    if (bytes3) {
      return toUtf8String2(bytes3);
    }
  } catch (error) {
  }
  return null;
}
function _parseBytes2(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
}
function numPad2(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad2(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes2(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0; i < datas.length; i++) {
    const data2 = getBytes(datas[i]);
    result[i] = numPad2(byteCount);
    result.push(numPad2(data2.length));
    result.push(bytesPad2(data2));
    byteCount += 32 + Math.ceil(data2.length / 32) * 32;
  }
  return concat2(result);
}
function parseOffchainLookup(data2) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert2(dataLength(data2) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data2, 0, 32);
  assert2(dataSlice(sender, 0, 12) === dataSlice(zeros2, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data2, 32, 64));
    const urlsLength = getNumber(dataSlice(data2, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data2, urlsOffset + 32);
    for (let u = 0; u < urlsLength; u++) {
      const url = _parseString2(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes2(data2, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert2(dataSlice(data2, 100, 128) === dataSlice(zeros2, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data2, 96, 100);
  try {
    const extraData = _parseBytes2(data2, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
}
var BN_23, MAX_CCIP_REDIRECTS2, UnmanagedSubscriber, defaultOptions, _subs, _plugins2, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options2, _perform, perform_fn, _call, call_fn, _checkNetwork, checkNetwork_fn, _getAccountValue, getAccountValue_fn, _getBlock, getBlock_fn, _hasSub, hasSub_fn, _getSub, getSub_fn, AbstractProvider, empty, zeros2;
var init_abstract_provider = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/abstract-provider.js"() {
    init_address3();
    init_constants();
    init_contract2();
    init_hash();
    init_transaction2();
    init_utils3();
    init_ens_resolver();
    init_format();
    init_network();
    init_provider();
    init_subscriber_polling();
    BN_23 = BigInt(2);
    MAX_CCIP_REDIRECTS2 = 10;
    UnmanagedSubscriber = class {
      constructor(name) {
        __publicField(this, "name");
        defineProperties(this, { name });
      }
      start() {
      }
      stop() {
      }
      pause(dropWhilePaused) {
      }
      resume() {
      }
    };
    defaultOptions = {
      cacheTimeout: 250,
      pollingInterval: 4e3
    };
    AbstractProvider = class {
      constructor(_network3, options) {
        __privateAdd(this, _perform);
        __privateAdd(this, _call);
        __privateAdd(this, _checkNetwork);
        __privateAdd(this, _getAccountValue);
        __privateAdd(this, _getBlock);
        __privateAdd(this, _hasSub);
        __privateAdd(this, _getSub);
        __privateAdd(this, _subs, void 0);
        __privateAdd(this, _plugins2, void 0);
        __privateAdd(this, _pausedState, void 0);
        __privateAdd(this, _destroyed, void 0);
        __privateAdd(this, _networkPromise, void 0);
        __privateAdd(this, _anyNetwork, void 0);
        __privateAdd(this, _performCache, void 0);
        __privateAdd(this, _lastBlockNumber, void 0);
        __privateAdd(this, _nextTimer, void 0);
        __privateAdd(this, _timers, void 0);
        __privateAdd(this, _disableCcipRead, void 0);
        __privateAdd(this, _options2, void 0);
        __privateSet(this, _options2, Object.assign({}, defaultOptions, options || {}));
        if (_network3 === "any") {
          __privateSet(this, _anyNetwork, true);
          __privateSet(this, _networkPromise, null);
        } else if (_network3) {
          const network = Network.from(_network3);
          __privateSet(this, _anyNetwork, false);
          __privateSet(this, _networkPromise, Promise.resolve(network));
          setTimeout(() => {
            this.emit("network", network, null);
          }, 0);
        } else {
          __privateSet(this, _anyNetwork, false);
          __privateSet(this, _networkPromise, null);
        }
        __privateSet(this, _lastBlockNumber, -1);
        __privateSet(this, _performCache, /* @__PURE__ */ new Map());
        __privateSet(this, _subs, /* @__PURE__ */ new Map());
        __privateSet(this, _plugins2, /* @__PURE__ */ new Map());
        __privateSet(this, _pausedState, null);
        __privateSet(this, _destroyed, false);
        __privateSet(this, _nextTimer, 1);
        __privateSet(this, _timers, /* @__PURE__ */ new Map());
        __privateSet(this, _disableCcipRead, false);
      }
      get pollingInterval() {
        return __privateGet(this, _options2).pollingInterval;
      }
      get provider() {
        return this;
      }
      get plugins() {
        return Array.from(__privateGet(this, _plugins2).values());
      }
      attachPlugin(plugin) {
        if (__privateGet(this, _plugins2).get(plugin.name)) {
          throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        __privateGet(this, _plugins2).set(plugin.name, plugin.connect(this));
        return this;
      }
      getPlugin(name) {
        return __privateGet(this, _plugins2).get(name) || null;
      }
      get disableCcipRead() {
        return __privateGet(this, _disableCcipRead);
      }
      set disableCcipRead(value) {
        __privateSet(this, _disableCcipRead, !!value);
      }
      async ccipReadFetch(tx, calldata, urls) {
        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
          return null;
        }
        const sender = tx.to.toLowerCase();
        const data2 = calldata.toLowerCase();
        const errorMessages = [];
        for (let i = 0; i < urls.length; i++) {
          const url = urls[i];
          const href = url.replace("{sender}", sender).replace("{data}", data2);
          const request = new FetchRequest(href);
          if (url.indexOf("{data}") === -1) {
            request.body = { data: data2, sender };
          }
          this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
          let errorMessage = "unknown error";
          const resp = await request.send();
          try {
            const result = resp.bodyJson;
            if (result.data) {
              this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
              return result.data;
            }
            if (result.message) {
              errorMessage = result.message;
            }
            this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
          } catch (error) {
          }
          assert2(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
          errorMessages.push(errorMessage);
        }
        assert2(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
          reason: "500_SERVER_ERROR",
          transaction: tx,
          info: { urls, errorMessages }
        });
      }
      _wrapBlock(value, network) {
        return new Block(formatBlock(value), this);
      }
      _wrapLog(value, network) {
        return new Log(formatLog(value), this);
      }
      _wrapTransactionReceipt(value, network) {
        return new TransactionReceipt(formatTransactionReceipt(value), this);
      }
      _wrapTransactionResponse(tx, network) {
        return new TransactionResponse(formatTransactionResponse(tx), this);
      }
      _detectNetwork() {
        assert2(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
          operation: "_detectNetwork"
        });
      }
      async _perform(req) {
        assert2(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
          operation: req.method,
          info: req
        });
      }
      async getBlockNumber() {
        const blockNumber = getNumber(await __privateMethod(this, _perform, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
        if (__privateGet(this, _lastBlockNumber) >= 0) {
          __privateSet(this, _lastBlockNumber, blockNumber);
        }
        return blockNumber;
      }
      _getAddress(address) {
        return resolveAddress(address, this);
      }
      _getBlockTag(blockTag) {
        if (blockTag == null) {
          return "latest";
        }
        switch (blockTag) {
          case "earliest":
            return "0x0";
          case "latest":
          case "pending":
          case "safe":
          case "finalized":
            return blockTag;
        }
        if (isHexString2(blockTag)) {
          if (isHexString2(blockTag, 32)) {
            return blockTag;
          }
          return toQuantity(blockTag);
        }
        if (typeof blockTag === "bigint") {
          blockTag = getNumber(blockTag, "blockTag");
        }
        if (typeof blockTag === "number") {
          if (blockTag >= 0) {
            return toQuantity(blockTag);
          }
          if (__privateGet(this, _lastBlockNumber) >= 0) {
            return toQuantity(__privateGet(this, _lastBlockNumber) + blockTag);
          }
          return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
        }
        assertArgument(false, "invalid blockTag", "blockTag", blockTag);
      }
      _getFilter(filter) {
        const topics = (filter.topics || []).map((t) => {
          if (t == null) {
            return null;
          }
          if (Array.isArray(t)) {
            return concisify(t.map((t2) => t2.toLowerCase()));
          }
          return t.toLowerCase();
        });
        const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
        const resolve2 = (_address, fromBlock2, toBlock2) => {
          let address2 = void 0;
          switch (_address.length) {
            case 0:
              break;
            case 1:
              address2 = _address[0];
              break;
            default:
              _address.sort();
              address2 = _address;
          }
          if (blockHash) {
            if (fromBlock2 != null || toBlock2 != null) {
              throw new Error("invalid filter");
            }
          }
          const filter2 = {};
          if (address2) {
            filter2.address = address2;
          }
          if (topics.length) {
            filter2.topics = topics;
          }
          if (fromBlock2) {
            filter2.fromBlock = fromBlock2;
          }
          if (toBlock2) {
            filter2.toBlock = toBlock2;
          }
          if (blockHash) {
            filter2.blockHash = blockHash;
          }
          return filter2;
        };
        let address = [];
        if (filter.address) {
          if (Array.isArray(filter.address)) {
            for (const addr of filter.address) {
              address.push(this._getAddress(addr));
            }
          } else {
            address.push(this._getAddress(filter.address));
          }
        }
        let fromBlock = void 0;
        if ("fromBlock" in filter) {
          fromBlock = this._getBlockTag(filter.fromBlock);
        }
        let toBlock = void 0;
        if ("toBlock" in filter) {
          toBlock = this._getBlockTag(filter.toBlock);
        }
        if (address.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
          return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
            return resolve2(result[0], result[1], result[2]);
          });
        }
        return resolve2(address, fromBlock, toBlock);
      }
      _getTransactionRequest(_request3) {
        const request = copyRequest(_request3);
        const promises = [];
        ["to", "from"].forEach((key2) => {
          if (request[key2] == null) {
            return;
          }
          const addr = resolveAddress(request[key2], this);
          if (isPromise(addr)) {
            promises.push(async function() {
              request[key2] = await addr;
            }());
          } else {
            request[key2] = addr;
          }
        });
        if (request.blockTag != null) {
          const blockTag = this._getBlockTag(request.blockTag);
          if (isPromise(blockTag)) {
            promises.push(async function() {
              request.blockTag = await blockTag;
            }());
          } else {
            request.blockTag = blockTag;
          }
        }
        if (promises.length) {
          return async function() {
            await Promise.all(promises);
            return request;
          }();
        }
        return request;
      }
      async getNetwork() {
        if (__privateGet(this, _networkPromise) == null) {
          const detectNetwork = this._detectNetwork().then((network) => {
            this.emit("network", network, null);
            return network;
          }, (error) => {
            if (__privateGet(this, _networkPromise) === detectNetwork) {
              __privateSet(this, _networkPromise, null);
            }
            throw error;
          });
          __privateSet(this, _networkPromise, detectNetwork);
          return (await detectNetwork).clone();
        }
        const networkPromise = __privateGet(this, _networkPromise);
        const [expected, actual] = await Promise.all([
          networkPromise,
          this._detectNetwork()
        ]);
        if (expected.chainId !== actual.chainId) {
          if (__privateGet(this, _anyNetwork)) {
            this.emit("network", actual, expected);
            if (__privateGet(this, _networkPromise) === networkPromise) {
              __privateSet(this, _networkPromise, Promise.resolve(actual));
            }
          } else {
            assert2(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
              event: "changed"
            });
          }
        }
        return expected.clone();
      }
      async getFeeData() {
        const network = await this.getNetwork();
        const getFeeDataFunc = async () => {
          const { _block, gasPrice } = await resolveProperties2({
            _block: __privateMethod(this, _getBlock, getBlock_fn).call(this, "latest", false),
            gasPrice: (async () => {
              try {
                const gasPrice2 = await __privateMethod(this, _perform, perform_fn).call(this, { method: "getGasPrice" });
                return getBigInt(gasPrice2, "%response");
              } catch (error) {
              }
              return null;
            })()
          });
          let maxFeePerGas = null;
          let maxPriorityFeePerGas = null;
          const block = this._wrapBlock(_block, network);
          if (block && block.baseFeePerGas) {
            maxPriorityFeePerGas = BigInt("1000000000");
            maxFeePerGas = block.baseFeePerGas * BN_23 + maxPriorityFeePerGas;
          }
          return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
        };
        const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (plugin) {
          const req = new FetchRequest(plugin.url);
          const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
          return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
        }
        return await getFeeDataFunc();
      }
      async estimateGas(_tx) {
        let tx = this._getTransactionRequest(_tx);
        if (isPromise(tx)) {
          tx = await tx;
        }
        return getBigInt(await __privateMethod(this, _perform, perform_fn).call(this, {
          method: "estimateGas",
          transaction: tx
        }), "%response");
      }
      async call(_tx) {
        const { tx, blockTag } = await resolveProperties2({
          tx: this._getTransactionRequest(_tx),
          blockTag: this._getBlockTag(_tx.blockTag)
        });
        return await __privateMethod(this, _checkNetwork, checkNetwork_fn).call(this, __privateMethod(this, _call, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
      }
      async getBalance(address, blockTag) {
        return getBigInt(await __privateMethod(this, _getAccountValue, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
      }
      async getTransactionCount(address, blockTag) {
        return getNumber(await __privateMethod(this, _getAccountValue, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
      }
      async getCode(address, blockTag) {
        return hexlify2(await __privateMethod(this, _getAccountValue, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
      }
      async getStorage(address, _position, blockTag) {
        const position = getBigInt(_position, "position");
        return hexlify2(await __privateMethod(this, _getAccountValue, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
      }
      async broadcastTransaction(signedTx) {
        const { blockNumber, hash: hash4, network } = await resolveProperties2({
          blockNumber: this.getBlockNumber(),
          hash: this._perform({
            method: "broadcastTransaction",
            signedTransaction: signedTx
          }),
          network: this.getNetwork()
        });
        const tx = Transaction.from(signedTx);
        if (tx.hash !== hash4) {
          throw new Error("@TODO: the returned hash did not match");
        }
        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
      }
      async getBlock(block, prefetchTxs) {
        const { network, params } = await resolveProperties2({
          network: this.getNetwork(),
          params: __privateMethod(this, _getBlock, getBlock_fn).call(this, block, !!prefetchTxs)
        });
        if (params == null) {
          return null;
        }
        return this._wrapBlock(params, network);
      }
      async getTransaction(hash4) {
        const { network, params } = await resolveProperties2({
          network: this.getNetwork(),
          params: __privateMethod(this, _perform, perform_fn).call(this, { method: "getTransaction", hash: hash4 })
        });
        if (params == null) {
          return null;
        }
        return this._wrapTransactionResponse(params, network);
      }
      async getTransactionReceipt(hash4) {
        const { network, params } = await resolveProperties2({
          network: this.getNetwork(),
          params: __privateMethod(this, _perform, perform_fn).call(this, { method: "getTransactionReceipt", hash: hash4 })
        });
        if (params == null) {
          return null;
        }
        if (params.gasPrice == null && params.effectiveGasPrice == null) {
          const tx = await __privateMethod(this, _perform, perform_fn).call(this, { method: "getTransaction", hash: hash4 });
          if (tx == null) {
            throw new Error("report this; could not find tx or effectiveGasPrice");
          }
          params.effectiveGasPrice = tx.gasPrice;
        }
        return this._wrapTransactionReceipt(params, network);
      }
      async getTransactionResult(hash4) {
        const { result } = await resolveProperties2({
          network: this.getNetwork(),
          result: __privateMethod(this, _perform, perform_fn).call(this, { method: "getTransactionResult", hash: hash4 })
        });
        if (result == null) {
          return null;
        }
        return hexlify2(result);
      }
      async getLogs(_filter5) {
        let filter = this._getFilter(_filter5);
        if (isPromise(filter)) {
          filter = await filter;
        }
        const { network, params } = await resolveProperties2({
          network: this.getNetwork(),
          params: __privateMethod(this, _perform, perform_fn).call(this, { method: "getLogs", filter })
        });
        return params.map((p) => this._wrapLog(p, network));
      }
      _getProvider(chainId) {
        assert2(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
          operation: "_getProvider()"
        });
      }
      async getResolver(name) {
        return await EnsResolver.fromName(this, name);
      }
      async getAvatar(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
          return await resolver.getAvatar();
        }
        return null;
      }
      async resolveName(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
          return await resolver.getAddress();
        }
        return null;
      }
      async lookupAddress(address) {
        address = getAddress2(address);
        const node2 = namehash2(address.substring(2).toLowerCase() + ".addr.reverse");
        try {
          const ensAddr = await EnsResolver.getEnsAddress(this);
          const ensContract = new Contract2(ensAddr, [
            "function resolver(bytes32) view returns (address)"
          ], this);
          const resolver = await ensContract.resolver(node2);
          if (resolver == null || resolver === ZeroAddress) {
            return null;
          }
          const resolverContract = new Contract2(resolver, [
            "function name(bytes32) view returns (string)"
          ], this);
          const name = await resolverContract.name(node2);
          const check2 = await this.resolveName(name);
          if (check2 !== address) {
            return null;
          }
          return name;
        } catch (error) {
          if (isError(error, "BAD_DATA") && error.value === "0x") {
            return null;
          }
          if (isError(error, "CALL_EXCEPTION")) {
            return null;
          }
          throw error;
        }
        return null;
      }
      async waitForTransaction(hash4, _confirms, timeout) {
        const confirms = _confirms != null ? _confirms : 1;
        if (confirms === 0) {
          return this.getTransactionReceipt(hash4);
        }
        return new Promise(async (resolve2, reject2) => {
          let timer2 = null;
          const listener = async (blockNumber) => {
            try {
              const receipt = await this.getTransactionReceipt(hash4);
              if (receipt != null) {
                if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                  resolve2(receipt);
                  if (timer2) {
                    clearTimeout(timer2);
                    timer2 = null;
                  }
                  return;
                }
              }
            } catch (error) {
              console.log("EEE", error);
            }
            this.once("block", listener);
          };
          if (timeout != null) {
            timer2 = setTimeout(() => {
              if (timer2 == null) {
                return;
              }
              timer2 = null;
              this.off("block", listener);
              reject2(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
            }, timeout);
          }
          listener(await this.getBlockNumber());
        });
      }
      async waitForBlock(blockTag) {
        assert2(false, "not implemented yet", "NOT_IMPLEMENTED", {
          operation: "waitForBlock"
        });
      }
      _clearTimeout(timerId) {
        const timer2 = __privateGet(this, _timers).get(timerId);
        if (!timer2) {
          return;
        }
        if (timer2.timer) {
          clearTimeout(timer2.timer);
        }
        __privateGet(this, _timers).delete(timerId);
      }
      _setTimeout(_func, timeout) {
        if (timeout == null) {
          timeout = 0;
        }
        const timerId = __privateWrapper(this, _nextTimer)._++;
        const func = () => {
          __privateGet(this, _timers).delete(timerId);
          _func();
        };
        if (this.paused) {
          __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
        } else {
          const timer2 = setTimeout(func, timeout);
          __privateGet(this, _timers).set(timerId, { timer: timer2, func, time: getTime3() });
        }
        return timerId;
      }
      _forEachSubscriber(func) {
        for (const sub of __privateGet(this, _subs).values()) {
          func(sub.subscriber);
        }
      }
      _getSubscriber(sub) {
        switch (sub.type) {
          case "debug":
          case "error":
          case "network":
            return new UnmanagedSubscriber(sub.type);
          case "block": {
            const subscriber = new PollingBlockSubscriber(this);
            subscriber.pollingInterval = this.pollingInterval;
            return subscriber;
          }
          case "event":
            return new PollingEventSubscriber(this, sub.filter);
          case "transaction":
            return new PollingTransactionSubscriber(this, sub.hash);
          case "orphan":
            return new PollingOrphanSubscriber(this, sub.filter);
        }
        throw new Error(`unsupported event: ${sub.type}`);
      }
      _recoverSubscriber(oldSub, newSub) {
        for (const sub of __privateGet(this, _subs).values()) {
          if (sub.subscriber === oldSub) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            sub.subscriber = newSub;
            if (sub.started) {
              newSub.start();
            }
            if (__privateGet(this, _pausedState) != null) {
              newSub.pause(__privateGet(this, _pausedState));
            }
            break;
          }
        }
      }
      async on(event, listener) {
        const sub = await __privateMethod(this, _getSub, getSub_fn).call(this, event);
        sub.listeners.push({ listener, once: false });
        if (!sub.started) {
          sub.subscriber.start();
          sub.started = true;
          if (__privateGet(this, _pausedState) != null) {
            sub.subscriber.pause(__privateGet(this, _pausedState));
          }
        }
        return this;
      }
      async once(event, listener) {
        const sub = await __privateMethod(this, _getSub, getSub_fn).call(this, event);
        sub.listeners.push({ listener, once: true });
        if (!sub.started) {
          sub.subscriber.start();
          sub.started = true;
          if (__privateGet(this, _pausedState) != null) {
            sub.subscriber.pause(__privateGet(this, _pausedState));
          }
        }
        return this;
      }
      async emit(event, ...args) {
        const sub = await __privateMethod(this, _hasSub, hasSub_fn).call(this, event, args);
        if (!sub || sub.listeners.length === 0) {
          return false;
        }
        ;
        const count = sub.listeners.length;
        sub.listeners = sub.listeners.filter(({ listener, once }) => {
          const payload = new EventPayload(this, once ? null : listener, event);
          try {
            listener.call(this, ...args, payload);
          } catch (error) {
          }
          return !once;
        });
        if (sub.listeners.length === 0) {
          if (sub.started) {
            sub.subscriber.stop();
          }
          __privateGet(this, _subs).delete(sub.tag);
        }
        return count > 0;
      }
      async listenerCount(event) {
        if (event) {
          const sub = await __privateMethod(this, _hasSub, hasSub_fn).call(this, event);
          if (!sub) {
            return 0;
          }
          return sub.listeners.length;
        }
        let total = 0;
        for (const { listeners } of __privateGet(this, _subs).values()) {
          total += listeners.length;
        }
        return total;
      }
      async listeners(event) {
        if (event) {
          const sub = await __privateMethod(this, _hasSub, hasSub_fn).call(this, event);
          if (!sub) {
            return [];
          }
          return sub.listeners.map(({ listener }) => listener);
        }
        let result = [];
        for (const { listeners } of __privateGet(this, _subs).values()) {
          result = result.concat(listeners.map(({ listener }) => listener));
        }
        return result;
      }
      async off(event, listener) {
        const sub = await __privateMethod(this, _hasSub, hasSub_fn).call(this, event);
        if (!sub) {
          return this;
        }
        if (listener) {
          const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
          if (index >= 0) {
            sub.listeners.splice(index, 1);
          }
        }
        if (!listener || sub.listeners.length === 0) {
          if (sub.started) {
            sub.subscriber.stop();
          }
          __privateGet(this, _subs).delete(sub.tag);
        }
        return this;
      }
      async removeAllListeners(event) {
        if (event) {
          const { tag, started, subscriber } = await __privateMethod(this, _getSub, getSub_fn).call(this, event);
          if (started) {
            subscriber.stop();
          }
          __privateGet(this, _subs).delete(tag);
        } else {
          for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
            if (started) {
              subscriber.stop();
            }
            __privateGet(this, _subs).delete(tag);
          }
        }
        return this;
      }
      async addListener(event, listener) {
        return await this.on(event, listener);
      }
      async removeListener(event, listener) {
        return this.off(event, listener);
      }
      get destroyed() {
        return __privateGet(this, _destroyed);
      }
      destroy() {
        this.removeAllListeners();
        for (const timerId of __privateGet(this, _timers).keys()) {
          this._clearTimeout(timerId);
        }
        __privateSet(this, _destroyed, true);
      }
      get paused() {
        return __privateGet(this, _pausedState) != null;
      }
      set paused(pause) {
        if (!!pause === this.paused) {
          return;
        }
        if (this.paused) {
          this.resume();
        } else {
          this.pause(false);
        }
      }
      pause(dropWhilePaused) {
        __privateSet(this, _lastBlockNumber, -1);
        if (__privateGet(this, _pausedState) != null) {
          if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
            return;
          }
          assert2(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
            operation: "pause"
          });
        }
        this._forEachSubscriber((s) => s.pause(dropWhilePaused));
        __privateSet(this, _pausedState, !!dropWhilePaused);
        for (const timer2 of __privateGet(this, _timers).values()) {
          if (timer2.timer) {
            clearTimeout(timer2.timer);
          }
          timer2.time = getTime3() - timer2.time;
        }
      }
      resume() {
        if (__privateGet(this, _pausedState) == null) {
          return;
        }
        this._forEachSubscriber((s) => s.resume());
        __privateSet(this, _pausedState, null);
        for (const timer2 of __privateGet(this, _timers).values()) {
          let timeout = timer2.time;
          if (timeout < 0) {
            timeout = 0;
          }
          timer2.time = getTime3();
          setTimeout(timer2.func, timeout);
        }
      }
    };
    _subs = new WeakMap();
    _plugins2 = new WeakMap();
    _pausedState = new WeakMap();
    _destroyed = new WeakMap();
    _networkPromise = new WeakMap();
    _anyNetwork = new WeakMap();
    _performCache = new WeakMap();
    _lastBlockNumber = new WeakMap();
    _nextTimer = new WeakMap();
    _timers = new WeakMap();
    _disableCcipRead = new WeakMap();
    _options2 = new WeakMap();
    _perform = new WeakSet();
    perform_fn = async function(req) {
      const timeout = __privateGet(this, _options2).cacheTimeout;
      if (timeout < 0) {
        return await this._perform(req);
      }
      const tag = getTag(req.method, req);
      let perform2 = __privateGet(this, _performCache).get(tag);
      if (!perform2) {
        perform2 = this._perform(req);
        __privateGet(this, _performCache).set(tag, perform2);
        setTimeout(() => {
          if (__privateGet(this, _performCache).get(tag) === perform2) {
            __privateGet(this, _performCache).delete(tag);
          }
        }, timeout);
      }
      return await perform2;
    };
    _call = new WeakSet();
    call_fn = async function(tx, blockTag, attempt) {
      assert2(attempt < MAX_CCIP_REDIRECTS2, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
        reason: "TOO_MANY_REDIRECTS",
        transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
      });
      const transaction = copyRequest(tx);
      try {
        return hexlify2(await this._perform({ method: "call", transaction, blockTag }));
      } catch (error) {
        if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
          const data2 = error.data;
          const txSender = await resolveAddress(transaction.to, this);
          let ccipArgs;
          try {
            ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
          } catch (error2) {
            assert2(false, error2.message, "OFFCHAIN_FAULT", {
              reason: "BAD_DATA",
              transaction,
              info: { data: data2 }
            });
          }
          assert2(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
            action: "call",
            data: data2,
            reason: "OffchainLookup",
            transaction,
            invocation: null,
            revert: {
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              name: "OffchainLookup",
              args: ccipArgs.errorArgs
            }
          });
          const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
          assert2(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
            reason: "FETCH_FAILED",
            transaction,
            info: { data: error.data, errorArgs: ccipArgs.errorArgs }
          });
          const tx2 = {
            to: txSender,
            data: concat2([ccipArgs.selector, encodeBytes2([ccipResult, ccipArgs.extraData])])
          };
          this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
          try {
            const result = await __privateMethod(this, _call, call_fn).call(this, tx2, blockTag, attempt + 1);
            this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
            return result;
          } catch (error2) {
            this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
            throw error2;
          }
        }
        throw error;
      }
    };
    _checkNetwork = new WeakSet();
    checkNetwork_fn = async function(promise2) {
      const { value } = await resolveProperties2({
        network: this.getNetwork(),
        value: promise2
      });
      return value;
    };
    _getAccountValue = new WeakSet();
    getAccountValue_fn = async function(request, _address, _blockTag) {
      let address = this._getAddress(_address);
      let blockTag = this._getBlockTag(_blockTag);
      if (typeof address !== "string" || typeof blockTag !== "string") {
        [address, blockTag] = await Promise.all([address, blockTag]);
      }
      return await __privateMethod(this, _checkNetwork, checkNetwork_fn).call(this, __privateMethod(this, _perform, perform_fn).call(this, Object.assign(request, { address, blockTag })));
    };
    _getBlock = new WeakSet();
    getBlock_fn = async function(block, includeTransactions) {
      if (isHexString2(block, 32)) {
        return await __privateMethod(this, _perform, perform_fn).call(this, {
          method: "getBlock",
          blockHash: block,
          includeTransactions
        });
      }
      let blockTag = this._getBlockTag(block);
      if (typeof blockTag !== "string") {
        blockTag = await blockTag;
      }
      return await __privateMethod(this, _perform, perform_fn).call(this, {
        method: "getBlock",
        blockTag,
        includeTransactions
      });
    };
    _hasSub = new WeakSet();
    hasSub_fn = async function(event, emitArgs) {
      let sub = await getSubscription(event, this);
      if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
        sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
      }
      return __privateGet(this, _subs).get(sub.tag) || null;
    };
    _getSub = new WeakSet();
    getSub_fn = async function(event) {
      const subscription = await getSubscription(event, this);
      const tag = subscription.tag;
      let sub = __privateGet(this, _subs).get(tag);
      if (!sub) {
        const subscriber = this._getSubscriber(subscription);
        const addressableMap = /* @__PURE__ */ new WeakMap();
        const nameMap = /* @__PURE__ */ new Map();
        sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
        __privateGet(this, _subs).set(tag, sub);
      }
      return sub;
    };
    empty = new Uint8Array([]);
    zeros2 = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/abstract-signer.js
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert2(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
}
async function populate2(signer, tx) {
  let pop = copyRequest(tx);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address, from2]) => {
      assertArgument(address.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties2(pop);
}
var AbstractSigner, _throwUnsupported, throwUnsupported_fn, _VoidSigner, VoidSigner2;
var init_abstract_signer = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/abstract-signer.js"() {
    init_address3();
    init_transaction2();
    init_utils3();
    init_provider();
    AbstractSigner = class {
      constructor(provider) {
        __publicField(this, "provider");
        defineProperties(this, { provider: provider || null });
      }
      async getNonce(blockTag) {
        return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
      }
      async populateCall(tx) {
        const pop = await populate2(this, tx);
        return pop;
      }
      async populateTransaction(tx) {
        const provider = checkProvider(this, "populateTransaction");
        const pop = await populate2(this, tx);
        if (pop.nonce == null) {
          pop.nonce = await this.getNonce("pending");
        }
        if (pop.gasLimit == null) {
          pop.gasLimit = await this.estimateGas(pop);
        }
        const network = await this.provider.getNetwork();
        if (pop.chainId != null) {
          const chainId = getBigInt(pop.chainId);
          assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
        } else {
          pop.chainId = network.chainId;
        }
        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
          assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
          assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
        }
        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
          pop.type = 2;
        } else if (pop.type === 0 || pop.type === 1) {
          const feeData = await provider.getFeeData();
          assert2(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
            operation: "getGasPrice"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
        } else {
          const feeData = await provider.getFeeData();
          if (pop.type == null) {
            if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
              pop.type = 2;
              if (pop.gasPrice != null) {
                const gasPrice = pop.gasPrice;
                delete pop.gasPrice;
                pop.maxFeePerGas = gasPrice;
                pop.maxPriorityFeePerGas = gasPrice;
              } else {
                if (pop.maxFeePerGas == null) {
                  pop.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                  pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
              }
            } else if (feeData.gasPrice != null) {
              assert2(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                operation: "populateTransaction"
              });
              if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
              }
              pop.type = 0;
            } else {
              assert2(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                operation: "signer.getFeeData"
              });
            }
          } else if (pop.type === 2) {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        }
        return await resolveProperties2(pop);
      }
      async estimateGas(tx) {
        return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
      }
      async call(tx) {
        return checkProvider(this, "call").call(await this.populateCall(tx));
      }
      async resolveName(name) {
        const provider = checkProvider(this, "resolveName");
        return await provider.resolveName(name);
      }
      async sendTransaction(tx) {
        const provider = checkProvider(this, "sendTransaction");
        const pop = await this.populateTransaction(tx);
        delete pop.from;
        const txObj = Transaction.from(pop);
        return await provider.broadcastTransaction(await this.signTransaction(txObj));
      }
    };
    _VoidSigner = class extends AbstractSigner {
      constructor(address, provider) {
        super(provider);
        __privateAdd(this, _throwUnsupported);
        __publicField(this, "address");
        defineProperties(this, { address });
      }
      async getAddress() {
        return this.address;
      }
      connect(provider) {
        return new _VoidSigner(this.address, provider);
      }
      async signTransaction(tx) {
        __privateMethod(this, _throwUnsupported, throwUnsupported_fn).call(this, "transactions", "signTransaction");
      }
      async signMessage(message) {
        __privateMethod(this, _throwUnsupported, throwUnsupported_fn).call(this, "messages", "signMessage");
      }
      async signTypedData(domain, types, value) {
        __privateMethod(this, _throwUnsupported, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
      }
    };
    VoidSigner2 = _VoidSigner;
    _throwUnsupported = new WeakSet();
    throwUnsupported_fn = function(suffix, operation) {
      assert2(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/community.js
function showThrottleMessage2(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}
var shown;
var init_community = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/community.js"() {
    shown = /* @__PURE__ */ new Set();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/subscriber-filterid.js
function copy3(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var _provider4, _filterIdPromise, _poller3, _running3, _network, _hault, _poll4, poll_fn3, _teardown, teardown_fn, FilterIdSubscriber, _event, FilterIdEventSubscriber, FilterIdPendingSubscriber;
var init_subscriber_filterid = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/subscriber-filterid.js"() {
    init_utils3();
    init_subscriber_polling();
    FilterIdSubscriber = class {
      constructor(provider) {
        __privateAdd(this, _poll4);
        __privateAdd(this, _teardown);
        __privateAdd(this, _provider4, void 0);
        __privateAdd(this, _filterIdPromise, void 0);
        __privateAdd(this, _poller3, void 0);
        __privateAdd(this, _running3, void 0);
        __privateAdd(this, _network, void 0);
        __privateAdd(this, _hault, void 0);
        __privateSet(this, _provider4, provider);
        __privateSet(this, _filterIdPromise, null);
        __privateSet(this, _poller3, __privateMethod(this, _poll4, poll_fn3).bind(this));
        __privateSet(this, _running3, false);
        __privateSet(this, _network, null);
        __privateSet(this, _hault, false);
      }
      _subscribe(provider) {
        throw new Error("subclasses must override this");
      }
      _emitResults(provider, result) {
        throw new Error("subclasses must override this");
      }
      _recover(provider) {
        throw new Error("subclasses must override this");
      }
      start() {
        if (__privateGet(this, _running3)) {
          return;
        }
        __privateSet(this, _running3, true);
        __privateMethod(this, _poll4, poll_fn3).call(this, -2);
      }
      stop() {
        if (!__privateGet(this, _running3)) {
          return;
        }
        __privateSet(this, _running3, false);
        __privateSet(this, _hault, true);
        __privateMethod(this, _teardown, teardown_fn).call(this);
        __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
      }
      pause(dropWhilePaused) {
        if (dropWhilePaused) {
          __privateMethod(this, _teardown, teardown_fn).call(this);
        }
        __privateGet(this, _provider4).off("block", __privateGet(this, _poller3));
      }
      resume() {
        this.start();
      }
    };
    _provider4 = new WeakMap();
    _filterIdPromise = new WeakMap();
    _poller3 = new WeakMap();
    _running3 = new WeakMap();
    _network = new WeakMap();
    _hault = new WeakMap();
    _poll4 = new WeakSet();
    poll_fn3 = async function(blockNumber) {
      try {
        if (__privateGet(this, _filterIdPromise) == null) {
          __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider4)));
        }
        let filterId = null;
        try {
          filterId = await __privateGet(this, _filterIdPromise);
        } catch (error) {
          if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
            throw error;
          }
        }
        if (filterId == null) {
          __privateSet(this, _filterIdPromise, null);
          __privateGet(this, _provider4)._recoverSubscriber(this, this._recover(__privateGet(this, _provider4)));
          return;
        }
        const network = await __privateGet(this, _provider4).getNetwork();
        if (!__privateGet(this, _network)) {
          __privateSet(this, _network, network);
        }
        if (__privateGet(this, _network).chainId !== network.chainId) {
          throw new Error("chaid changed");
        }
        if (__privateGet(this, _hault)) {
          return;
        }
        const result = await __privateGet(this, _provider4).send("eth_getFilterChanges", [filterId]);
        await this._emitResults(__privateGet(this, _provider4), result);
      } catch (error) {
        console.log("@TODO", error);
      }
      __privateGet(this, _provider4).once("block", __privateGet(this, _poller3));
    };
    _teardown = new WeakSet();
    teardown_fn = function() {
      const filterIdPromise = __privateGet(this, _filterIdPromise);
      if (filterIdPromise) {
        __privateSet(this, _filterIdPromise, null);
        filterIdPromise.then((filterId) => {
          __privateGet(this, _provider4).send("eth_uninstallFilter", [filterId]);
        });
      }
    };
    FilterIdEventSubscriber = class extends FilterIdSubscriber {
      constructor(provider, filter) {
        super(provider);
        __privateAdd(this, _event, void 0);
        __privateSet(this, _event, copy3(filter));
      }
      _recover(provider) {
        return new PollingEventSubscriber(provider, __privateGet(this, _event));
      }
      async _subscribe(provider) {
        const filterId = await provider.send("eth_newFilter", [__privateGet(this, _event)]);
        return filterId;
      }
      async _emitResults(provider, results) {
        for (const result of results) {
          provider.emit(__privateGet(this, _event), provider._wrapLog(result, provider._network));
        }
      }
    };
    _event = new WeakMap();
    FilterIdPendingSubscriber = class extends FilterIdSubscriber {
      async _subscribe(provider) {
        return await provider.send("eth_newPendingTransactionFilter", []);
      }
      async _emitResults(provider, results) {
        for (const result of results) {
          provider.emit("pending", result);
        }
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
function deepCopy2(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy2);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key2) => {
      accum[key2] = value[key2];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
}
function stall3(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
function getLowerCase2(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString2(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunkData(value[key2]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      _spelunkMessage(value[key2], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
}
function spelunkMessage(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
}
var Primitive, defaultOptions2, JsonRpcSigner2, _options3, _nextId2, _payloads, _drainTimer, _notReady, _network2, _scheduleDrain, scheduleDrain_fn, JsonRpcApiProvider, _pollingInterval, JsonRpcApiPollingProvider, _connect, JsonRpcProvider2;
var init_provider_jsonrpc = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-jsonrpc.js"() {
    init_abi();
    init_address3();
    init_hash();
    init_transaction2();
    init_utils3();
    init_abstract_provider();
    init_abstract_signer();
    init_network();
    init_subscriber_filterid();
    init_subscriber_polling();
    Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
    defaultOptions2 = {
      polling: false,
      staticNetwork: null,
      batchStallTime: 10,
      batchMaxSize: 1 << 20,
      batchMaxCount: 100,
      cacheTimeout: 250,
      pollingInterval: 4e3
    };
    JsonRpcSigner2 = class extends AbstractSigner {
      constructor(provider, address) {
        super(provider);
        __publicField(this, "address");
        address = getAddress2(address);
        defineProperties(this, { address });
      }
      connect(provider) {
        assert2(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
          operation: "signer.connect"
        });
      }
      async getAddress() {
        return this.address;
      }
      async populateTransaction(tx) {
        return await this.populateCall(tx);
      }
      async sendUncheckedTransaction(_tx) {
        const tx = deepCopy2(_tx);
        const promises = [];
        if (tx.from) {
          const _from = tx.from;
          promises.push((async () => {
            const from = await resolveAddress(_from, this.provider);
            assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
            tx.from = from;
          })());
        } else {
          tx.from = this.address;
        }
        if (tx.gasLimit == null) {
          promises.push((async () => {
            tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
          })());
        }
        if (tx.to != null) {
          const _to2 = tx.to;
          promises.push((async () => {
            tx.to = await resolveAddress(_to2, this.provider);
          })());
        }
        if (promises.length) {
          await Promise.all(promises);
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return this.provider.send("eth_sendTransaction", [hexTx]);
      }
      async sendTransaction(tx) {
        const blockNumber = await this.provider.getBlockNumber();
        const hash4 = await this.sendUncheckedTransaction(tx);
        return await new Promise((resolve2, reject2) => {
          const timeouts = [1e3, 100];
          const checkTx = async () => {
            const tx2 = await this.provider.getTransaction(hash4);
            if (tx2 != null) {
              resolve2(tx2.replaceableTransaction(blockNumber));
              return;
            }
            this.provider._setTimeout(() => {
              checkTx();
            }, timeouts.pop() || 4e3);
          };
          checkTx();
        });
      }
      async signTransaction(_tx) {
        const tx = deepCopy2(_tx);
        if (tx.from) {
          const from = await resolveAddress(tx.from, this.provider);
          assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
          tx.from = from;
        } else {
          tx.from = this.address;
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return await this.provider.send("eth_signTransaction", [hexTx]);
      }
      async signMessage(_message) {
        const message = typeof _message === "string" ? toUtf8Bytes2(_message) : _message;
        return await this.provider.send("personal_sign", [
          hexlify2(message),
          this.address.toLowerCase()
        ]);
      }
      async signTypedData(domain, types, _value2) {
        const value = deepCopy2(_value2);
        const populated = await TypedDataEncoder2.resolveNames(domain, types, value, async (value2) => {
          const address = await resolveAddress(value2);
          assertArgument(address != null, "TypedData does not support null address", "value", value2);
          return address;
        });
        return await this.provider.send("eth_signTypedData_v4", [
          this.address.toLowerCase(),
          JSON.stringify(TypedDataEncoder2.getPayload(populated.domain, types, populated.value))
        ]);
      }
      async unlock(password) {
        return this.provider.send("personal_unlockAccount", [
          this.address.toLowerCase(),
          password,
          null
        ]);
      }
      async _legacySignMessage(_message) {
        const message = typeof _message === "string" ? toUtf8Bytes2(_message) : _message;
        return await this.provider.send("eth_sign", [
          this.address.toLowerCase(),
          hexlify2(message)
        ]);
      }
    };
    JsonRpcApiProvider = class extends AbstractProvider {
      constructor(network, options) {
        super(network, options);
        __privateAdd(this, _scheduleDrain);
        __privateAdd(this, _options3, void 0);
        __privateAdd(this, _nextId2, void 0);
        __privateAdd(this, _payloads, void 0);
        __privateAdd(this, _drainTimer, void 0);
        __privateAdd(this, _notReady, void 0);
        __privateAdd(this, _network2, void 0);
        __privateSet(this, _nextId2, 1);
        __privateSet(this, _options3, Object.assign({}, defaultOptions2, options || {}));
        __privateSet(this, _payloads, []);
        __privateSet(this, _drainTimer, null);
        __privateSet(this, _network2, null);
        {
          let resolve2 = null;
          const promise2 = new Promise((_resolve) => {
            resolve2 = _resolve;
          });
          __privateSet(this, _notReady, { promise: promise2, resolve: resolve2 });
        }
        const staticNetwork = this._getOption("staticNetwork");
        if (staticNetwork) {
          assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
          __privateSet(this, _network2, staticNetwork);
        }
      }
      _getOption(key2) {
        return __privateGet(this, _options3)[key2];
      }
      get _network() {
        assert2(__privateGet(this, _network2), "network is not available yet", "NETWORK_ERROR");
        return __privateGet(this, _network2);
      }
      async _perform(req) {
        if (req.method === "call" || req.method === "estimateGas") {
          let tx = req.transaction;
          if (tx && tx.type != null && getBigInt(tx.type)) {
            if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
              const feeData = await this.getFeeData();
              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                req = Object.assign({}, req, {
                  transaction: Object.assign({}, tx, { type: void 0 })
                });
              }
            }
          }
        }
        const request = this.getRpcRequest(req);
        if (request != null) {
          return await this.send(request.method, request.args);
        }
        return super._perform(req);
      }
      async _detectNetwork() {
        const network = this._getOption("staticNetwork");
        if (network) {
          return network;
        }
        if (this.ready) {
          return Network.from(getBigInt(await this.send("eth_chainId", [])));
        }
        const payload = {
          id: __privateWrapper(this, _nextId2)._++,
          method: "eth_chainId",
          params: [],
          jsonrpc: "2.0"
        };
        this.emit("debug", { action: "sendRpcPayload", payload });
        let result;
        try {
          result = (await this._send(payload))[0];
        } catch (error) {
          this.emit("debug", { action: "receiveRpcError", error });
          throw error;
        }
        this.emit("debug", { action: "receiveRpcResult", result });
        if ("result" in result) {
          return Network.from(getBigInt(result.result));
        }
        throw this.getRpcError(payload, result);
      }
      _start() {
        if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
          return;
        }
        __privateGet(this, _notReady).resolve();
        __privateSet(this, _notReady, null);
        (async () => {
          while (__privateGet(this, _network2) == null && !this.destroyed) {
            try {
              __privateSet(this, _network2, await this._detectNetwork());
            } catch (error) {
              if (this.destroyed) {
                break;
              }
              console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
              this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
              await stall3(1e3);
            }
          }
          __privateMethod(this, _scheduleDrain, scheduleDrain_fn).call(this);
        })();
      }
      async _waitUntilReady() {
        if (__privateGet(this, _notReady) == null) {
          return;
        }
        return await __privateGet(this, _notReady).promise;
      }
      _getSubscriber(sub) {
        if (sub.type === "pending") {
          return new FilterIdPendingSubscriber(this);
        }
        if (sub.type === "event") {
          if (this._getOption("polling")) {
            return new PollingEventSubscriber(this, sub.filter);
          }
          return new FilterIdEventSubscriber(this, sub.filter);
        }
        if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("orphan");
        }
        return super._getSubscriber(sub);
      }
      get ready() {
        return __privateGet(this, _notReady) == null;
      }
      getRpcTransaction(tx) {
        const result = {};
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key2) => {
          if (tx[key2] == null) {
            return;
          }
          let dstKey = key2;
          if (key2 === "gasLimit") {
            dstKey = "gas";
          }
          result[dstKey] = toQuantity(getBigInt(tx[key2], `tx.${key2}`));
        });
        ["from", "to", "data"].forEach((key2) => {
          if (tx[key2] == null) {
            return;
          }
          result[key2] = hexlify2(tx[key2]);
        });
        if (tx.accessList) {
          result["accessList"] = accessListify2(tx.accessList);
        }
        return result;
      }
      getRpcRequest(req) {
        switch (req.method) {
          case "chainId":
            return { method: "eth_chainId", args: [] };
          case "getBlockNumber":
            return { method: "eth_blockNumber", args: [] };
          case "getGasPrice":
            return { method: "eth_gasPrice", args: [] };
          case "getBalance":
            return {
              method: "eth_getBalance",
              args: [getLowerCase2(req.address), req.blockTag]
            };
          case "getTransactionCount":
            return {
              method: "eth_getTransactionCount",
              args: [getLowerCase2(req.address), req.blockTag]
            };
          case "getCode":
            return {
              method: "eth_getCode",
              args: [getLowerCase2(req.address), req.blockTag]
            };
          case "getStorage":
            return {
              method: "eth_getStorageAt",
              args: [
                getLowerCase2(req.address),
                "0x" + req.position.toString(16),
                req.blockTag
              ]
            };
          case "broadcastTransaction":
            return {
              method: "eth_sendRawTransaction",
              args: [req.signedTransaction]
            };
          case "getBlock":
            if ("blockTag" in req) {
              return {
                method: "eth_getBlockByNumber",
                args: [req.blockTag, !!req.includeTransactions]
              };
            } else if ("blockHash" in req) {
              return {
                method: "eth_getBlockByHash",
                args: [req.blockHash, !!req.includeTransactions]
              };
            }
            break;
          case "getTransaction":
            return {
              method: "eth_getTransactionByHash",
              args: [req.hash]
            };
          case "getTransactionReceipt":
            return {
              method: "eth_getTransactionReceipt",
              args: [req.hash]
            };
          case "call":
            return {
              method: "eth_call",
              args: [this.getRpcTransaction(req.transaction), req.blockTag]
            };
          case "estimateGas": {
            return {
              method: "eth_estimateGas",
              args: [this.getRpcTransaction(req.transaction)]
            };
          }
          case "getLogs":
            if (req.filter && req.filter.address != null) {
              if (Array.isArray(req.filter.address)) {
                req.filter.address = req.filter.address.map(getLowerCase2);
              } else {
                req.filter.address = getLowerCase2(req.filter.address);
              }
            }
            return { method: "eth_getLogs", args: [req.filter] };
        }
        return null;
      }
      getRpcError(payload, _error2) {
        const { method } = payload;
        const { error } = _error2;
        if (method === "eth_estimateGas" && error.message) {
          const msg = error.message;
          if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
            return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
              transaction: payload.params[0],
              info: { payload, error }
            });
          }
        }
        if (method === "eth_call" || method === "eth_estimateGas") {
          const result = spelunkData(error);
          const e = AbiCoder2.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
          e.info = { error, payload };
          return e;
        }
        const message = JSON.stringify(spelunkMessage(error));
        if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
          const actionMap = {
            eth_sign: "signMessage",
            personal_sign: "signMessage",
            eth_signTypedData_v4: "signTypedData",
            eth_signTransaction: "signTransaction",
            eth_sendTransaction: "sendTransaction",
            eth_requestAccounts: "requestAccess",
            wallet_requestAccounts: "requestAccess"
          };
          return makeError(`user rejected action`, "ACTION_REJECTED", {
            action: actionMap[method] || "unknown",
            reason: "rejected",
            info: { payload, error }
          });
        }
        if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
          const transaction = payload.params[0];
          if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
            return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
              transaction,
              info: { error }
            });
          }
          if (message.match(/nonce/i) && message.match(/too low/i)) {
            return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
          }
          if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
            return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
          }
          if (message.match(/only replay-protected/i)) {
            return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
              operation: method,
              info: { transaction, info: { error } }
            });
          }
        }
        let unsupported = !!message.match(/the method .* does not exist/i);
        if (!unsupported) {
          if (error && error.details && error.details.startsWith("Unauthorized method:")) {
            unsupported = true;
          }
        }
        if (unsupported) {
          return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: payload.method,
            info: { error, payload }
          });
        }
        return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
      }
      send(method, params) {
        if (this.destroyed) {
          return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
        }
        const id4 = __privateWrapper(this, _nextId2)._++;
        const promise2 = new Promise((resolve2, reject2) => {
          __privateGet(this, _payloads).push({
            resolve: resolve2,
            reject: reject2,
            payload: { method, params, id: id4, jsonrpc: "2.0" }
          });
        });
        __privateMethod(this, _scheduleDrain, scheduleDrain_fn).call(this);
        return promise2;
      }
      async getSigner(address) {
        if (address == null) {
          address = 0;
        }
        const accountsPromise = this.send("eth_accounts", []);
        if (typeof address === "number") {
          const accounts2 = await accountsPromise;
          if (address >= accounts2.length) {
            throw new Error("no such account");
          }
          return new JsonRpcSigner2(this, accounts2[address]);
        }
        const { accounts } = await resolveProperties2({
          network: this.getNetwork(),
          accounts: accountsPromise
        });
        address = getAddress2(address);
        for (const account of accounts) {
          if (getAddress2(account) === address) {
            return new JsonRpcSigner2(this, address);
          }
        }
        throw new Error("invalid account");
      }
      async listAccounts() {
        const accounts = await this.send("eth_accounts", []);
        return accounts.map((a) => new JsonRpcSigner2(this, a));
      }
      destroy() {
        if (__privateGet(this, _drainTimer)) {
          clearTimeout(__privateGet(this, _drainTimer));
          __privateSet(this, _drainTimer, null);
        }
        for (const { payload, reject: reject2 } of __privateGet(this, _payloads)) {
          reject2(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
        }
        __privateSet(this, _payloads, []);
        super.destroy();
      }
    };
    _options3 = new WeakMap();
    _nextId2 = new WeakMap();
    _payloads = new WeakMap();
    _drainTimer = new WeakMap();
    _notReady = new WeakMap();
    _network2 = new WeakMap();
    _scheduleDrain = new WeakSet();
    scheduleDrain_fn = function() {
      if (__privateGet(this, _drainTimer)) {
        return;
      }
      const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
      __privateSet(this, _drainTimer, setTimeout(() => {
        __privateSet(this, _drainTimer, null);
        const payloads = __privateGet(this, _payloads);
        __privateSet(this, _payloads, []);
        while (payloads.length) {
          const batch = [payloads.shift()];
          while (payloads.length) {
            if (batch.length === __privateGet(this, _options3).batchMaxCount) {
              break;
            }
            batch.push(payloads.shift());
            const bytes3 = JSON.stringify(batch.map((p) => p.payload));
            if (bytes3.length > __privateGet(this, _options3).batchMaxSize) {
              payloads.unshift(batch.pop());
              break;
            }
          }
          (async () => {
            const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
            this.emit("debug", { action: "sendRpcPayload", payload });
            try {
              const result = await this._send(payload);
              this.emit("debug", { action: "receiveRpcResult", result });
              for (const { resolve: resolve2, reject: reject2, payload: payload2 } of batch) {
                if (this.destroyed) {
                  reject2(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                  continue;
                }
                const resp = result.filter((r2) => r2.id === payload2.id)[0];
                if (resp == null) {
                  const error = makeError("missing response for request", "BAD_DATA", {
                    value: result,
                    info: { payload: payload2 }
                  });
                  this.emit("error", error);
                  reject2(error);
                  continue;
                }
                if ("error" in resp) {
                  reject2(this.getRpcError(payload2, resp));
                  continue;
                }
                resolve2(resp.result);
              }
            } catch (error) {
              this.emit("debug", { action: "receiveRpcError", error });
              for (const { reject: reject2 } of batch) {
                reject2(error);
              }
            }
          })();
        }
      }, stallTime));
    };
    JsonRpcApiPollingProvider = class extends JsonRpcApiProvider {
      constructor(network, options) {
        super(network, options);
        __privateAdd(this, _pollingInterval, void 0);
        __privateSet(this, _pollingInterval, 4e3);
      }
      _getSubscriber(sub) {
        const subscriber = super._getSubscriber(sub);
        if (isPollable(subscriber)) {
          subscriber.pollingInterval = __privateGet(this, _pollingInterval);
        }
        return subscriber;
      }
      get pollingInterval() {
        return __privateGet(this, _pollingInterval);
      }
      set pollingInterval(value) {
        if (!Number.isInteger(value) || value < 0) {
          throw new Error("invalid interval");
        }
        __privateSet(this, _pollingInterval, value);
        this._forEachSubscriber((sub) => {
          if (isPollable(sub)) {
            sub.pollingInterval = __privateGet(this, _pollingInterval);
          }
        });
      }
    };
    _pollingInterval = new WeakMap();
    JsonRpcProvider2 = class extends JsonRpcApiPollingProvider {
      constructor(url, network, options) {
        if (url == null) {
          url = "http://localhost:8545";
        }
        super(network, options);
        __privateAdd(this, _connect, void 0);
        if (typeof url === "string") {
          __privateSet(this, _connect, new FetchRequest(url));
        } else {
          __privateSet(this, _connect, url.clone());
        }
      }
      _getConnection() {
        return __privateGet(this, _connect).clone();
      }
      async send(method, params) {
        await this._start();
        return await super.send(method, params);
      }
      async _send(payload) {
        const request = this._getConnection();
        request.body = JSON.stringify(payload);
        request.setHeader("content-type", "application/json");
        const response = await request.send();
        response.assertOk();
        let resp = response.bodyJson;
        if (!Array.isArray(resp)) {
          resp = [resp];
        }
        return resp;
      }
    };
    _connect = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-ankr.js
var init_provider_ankr = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-ankr.js"() {
    init_utils3();
    init_community();
    init_network();
    init_provider_jsonrpc();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-alchemy.js
var init_provider_alchemy = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-alchemy.js"() {
    init_utils3();
    init_community();
    init_network();
    init_provider_jsonrpc();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-cloudflare.js
var init_provider_cloudflare = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-cloudflare.js"() {
    init_utils3();
    init_network();
    init_provider_jsonrpc();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-etherscan.js
function isPromise2(value) {
  return value && typeof value.then === "function";
}
var THROTTLE, EtherscanPluginId, skipKeys, nextId, _plugin, EtherscanProvider2;
var init_provider_etherscan = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-etherscan.js"() {
    init_abi();
    init_contract2();
    init_transaction2();
    init_utils3();
    init_abstract_provider();
    init_network();
    init_plugins_network();
    init_community();
    THROTTLE = 2e3;
    EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
    skipKeys = ["enableCcipRead"];
    nextId = 1;
    EtherscanProvider2 = class extends AbstractProvider {
      constructor(_network3, _apiKey) {
        const apiKey = _apiKey != null ? _apiKey : null;
        super();
        __publicField(this, "network");
        __publicField(this, "apiKey");
        __privateAdd(this, _plugin, void 0);
        const network = Network.from(_network3);
        __privateSet(this, _plugin, network.getPlugin(EtherscanPluginId));
        defineProperties(this, { apiKey, network });
        this.getBaseUrl();
      }
      getBaseUrl() {
        if (__privateGet(this, _plugin)) {
          return __privateGet(this, _plugin).baseUrl;
        }
        switch (this.network.name) {
          case "mainnet":
            return "https://api.etherscan.io";
          case "goerli":
            return "https://api-goerli.etherscan.io";
          case "sepolia":
            return "https://api-sepolia.etherscan.io";
          case "arbitrum":
            return "https://api.arbiscan.io";
          case "arbitrum-goerli":
            return "https://api-goerli.arbiscan.io";
          case "matic":
            return "https://api.polygonscan.com";
          case "matic-mumbai":
            return "https://api-testnet.polygonscan.com";
          case "optimism":
            return "https://api-optimistic.etherscan.io";
          case "optimism-goerli":
            return "https://api-goerli-optimistic.etherscan.io";
          case "bnb":
            return "http://api.bscscan.com";
          case "bnbt":
            return "http://api-testnet.bscscan.com";
          default:
        }
        assertArgument(false, "unsupported network", "network", this.network);
      }
      getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key2) => {
          const value = params[key2];
          if (value != null) {
            accum += `&${key2}=${value}`;
          }
          return accum;
        }, "");
        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
        return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;
      }
      getPostUrl() {
        return `${this.getBaseUrl()}/api`;
      }
      getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
      }
      async detectNetwork() {
        return this.network;
      }
      async fetch(module, params, post) {
        const id4 = nextId++;
        const url = post ? this.getPostUrl() : this.getUrl(module, params);
        const payload = post ? this.getPostData(module, params) : null;
        this.emit("debug", { action: "sendRequest", id: id4, url, payload });
        const request = new FetchRequest(url);
        request.setThrottleParams({ slotInterval: 1e3 });
        request.retryFunc = (req, resp, attempt) => {
          if (this.isCommunityResource()) {
            showThrottleMessage2("Etherscan");
          }
          return Promise.resolve(true);
        };
        request.processFunc = async (request2, response2) => {
          const result2 = response2.hasBody() ? JSON.parse(toUtf8String2(response2.body)) : {};
          const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
          if (module === "proxy") {
            if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
              this.emit("debug", { action: "receiveError", id: id4, reason: "proxy-NOTOK", error: result2 });
              response2.throwThrottleError(result2.result, THROTTLE);
            }
          } else {
            if (throttle) {
              this.emit("debug", { action: "receiveError", id: id4, reason: "null result", error: result2.result });
              response2.throwThrottleError(result2.result, THROTTLE);
            }
          }
          return response2;
        };
        if (payload) {
          request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
          request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
        }
        const response = await request.send();
        try {
          response.assertOk();
        } catch (error) {
          this.emit("debug", { action: "receiveError", id: id4, error, reason: "assertOk" });
          assert2(false, "response error", "SERVER_ERROR", { request, response });
        }
        if (!response.hasBody()) {
          this.emit("debug", { action: "receiveError", id: id4, error: "missing body", reason: "null body" });
          assert2(false, "missing response", "SERVER_ERROR", { request, response });
        }
        const result = JSON.parse(toUtf8String2(response.body));
        if (module === "proxy") {
          if (result.jsonrpc != "2.0") {
            this.emit("debug", { action: "receiveError", id: id4, result, reason: "invalid JSON-RPC" });
            assert2(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
          }
          if (result.error) {
            this.emit("debug", { action: "receiveError", id: id4, result, reason: "JSON-RPC error" });
            assert2(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
          }
          this.emit("debug", { action: "receiveRequest", id: id4, result });
          return result.result;
        } else {
          if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
            this.emit("debug", { action: "receiveRequest", id: id4, result });
            return result.result;
          }
          if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
            this.emit("debug", { action: "receiveError", id: id4, result });
            assert2(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
          }
          this.emit("debug", { action: "receiveRequest", id: id4, result });
          return result.result;
        }
      }
      _getTransactionPostData(transaction) {
        const result = {};
        for (let key2 in transaction) {
          if (skipKeys.indexOf(key2) >= 0) {
            continue;
          }
          if (transaction[key2] == null) {
            continue;
          }
          let value = transaction[key2];
          if (key2 === "type" && value === 0) {
            continue;
          }
          if (key2 === "blockTag" && value === "latest") {
            continue;
          }
          if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
            value = toQuantity(value);
          } else if (key2 === "accessList") {
            value = "[" + accessListify2(value).map((set2) => {
              return `{address:"${set2.address}",storageKeys:["${set2.storageKeys.join('","')}"]}`;
            }).join(",") + "]";
          } else {
            value = hexlify2(value);
          }
          result[key2] = value;
        }
        return result;
      }
      _checkError(req, error, transaction) {
        let message = "";
        if (isError(error, "SERVER_ERROR")) {
          try {
            message = error.info.result.error.message;
          } catch (e) {
          }
          if (!message) {
            try {
              message = error.info.message;
            } catch (e) {
            }
          }
        }
        if (req.method === "estimateGas") {
          if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
            assert2(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
              transaction: req.transaction
            });
          }
        }
        if (req.method === "call" || req.method === "estimateGas") {
          if (message.match(/execution reverted/i)) {
            let data2 = "";
            try {
              data2 = error.info.result.error.data;
            } catch (error2) {
            }
            const e = AbiCoder2.getBuiltinCallException(req.method, req.transaction, data2);
            e.info = { request: req, error };
            throw e;
          }
        }
        if (message) {
          if (req.method === "broadcastTransaction") {
            const transaction2 = Transaction.from(req.signedTransaction);
            if (message.match(/replacement/i) && message.match(/underpriced/i)) {
              assert2(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                transaction: transaction2
              });
            }
            if (message.match(/insufficient funds/)) {
              assert2(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                transaction: transaction2
              });
            }
            if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
              assert2(false, "nonce has already been used", "NONCE_EXPIRED", {
                transaction: transaction2
              });
            }
          }
        }
        throw error;
      }
      async _detectNetwork() {
        return this.network;
      }
      async _perform(req) {
        switch (req.method) {
          case "chainId":
            return this.network.chainId;
          case "getBlockNumber":
            return this.fetch("proxy", { action: "eth_blockNumber" });
          case "getGasPrice":
            return this.fetch("proxy", { action: "eth_gasPrice" });
          case "getBalance":
            return this.fetch("account", {
              action: "balance",
              address: req.address,
              tag: req.blockTag
            });
          case "getTransactionCount":
            return this.fetch("proxy", {
              action: "eth_getTransactionCount",
              address: req.address,
              tag: req.blockTag
            });
          case "getCode":
            return this.fetch("proxy", {
              action: "eth_getCode",
              address: req.address,
              tag: req.blockTag
            });
          case "getStorage":
            return this.fetch("proxy", {
              action: "eth_getStorageAt",
              address: req.address,
              position: req.position,
              tag: req.blockTag
            });
          case "broadcastTransaction":
            return this.fetch("proxy", {
              action: "eth_sendRawTransaction",
              hex: req.signedTransaction
            }, true).catch((error) => {
              return this._checkError(req, error, req.signedTransaction);
            });
          case "getBlock":
            if ("blockTag" in req) {
              return this.fetch("proxy", {
                action: "eth_getBlockByNumber",
                tag: req.blockTag,
                boolean: req.includeTransactions ? "true" : "false"
              });
            }
            assert2(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
              operation: "getBlock(blockHash)"
            });
          case "getTransaction":
            return this.fetch("proxy", {
              action: "eth_getTransactionByHash",
              txhash: req.hash
            });
          case "getTransactionReceipt":
            return this.fetch("proxy", {
              action: "eth_getTransactionReceipt",
              txhash: req.hash
            });
          case "call": {
            if (req.blockTag !== "latest") {
              throw new Error("EtherscanProvider does not support blockTag for call");
            }
            const postData = this._getTransactionPostData(req.transaction);
            postData.module = "proxy";
            postData.action = "eth_call";
            try {
              return await this.fetch("proxy", postData, true);
            } catch (error) {
              return this._checkError(req, error, req.transaction);
            }
          }
          case "estimateGas": {
            const postData = this._getTransactionPostData(req.transaction);
            postData.module = "proxy";
            postData.action = "eth_estimateGas";
            try {
              return await this.fetch("proxy", postData, true);
            } catch (error) {
              return this._checkError(req, error, req.transaction);
            }
          }
          default:
            break;
        }
        return super._perform(req);
      }
      async getNetwork() {
        return this.network;
      }
      async getEtherPrice() {
        if (this.network.name !== "mainnet") {
          return 0;
        }
        return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
      }
      async getContract(_address) {
        let address = this._getAddress(_address);
        if (isPromise2(address)) {
          address = await address;
        }
        try {
          const resp = await this.fetch("contract", {
            action: "getabi",
            address
          });
          const abi = JSON.parse(resp);
          return new Contract2(address, abi, this);
        } catch (error) {
          return null;
        }
      }
      isCommunityResource() {
        return this.apiKey == null;
      }
    };
    _plugin = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/ws-browser.js
function getGlobal3() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  throw new Error("unable to locate global object");
}
var _WebSocket;
var init_ws_browser = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/ws-browser.js"() {
    _WebSocket = getGlobal3().WebSocket;
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-socket.js
var _provider5, _filter4, _filterId, _paused, _emitPromise, SocketSubscriber, SocketBlockSubscriber, SocketPendingSubscriber, _logFilter, SocketEventSubscriber, _callbacks, _subs2, _pending, SocketProvider;
var init_provider_socket = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-socket.js"() {
    init_abstract_provider();
    init_utils3();
    init_provider_jsonrpc();
    SocketSubscriber = class {
      constructor(provider, filter) {
        __privateAdd(this, _provider5, void 0);
        __privateAdd(this, _filter4, void 0);
        __privateAdd(this, _filterId, void 0);
        __privateAdd(this, _paused, void 0);
        __privateAdd(this, _emitPromise, void 0);
        __privateSet(this, _provider5, provider);
        __privateSet(this, _filter4, JSON.stringify(filter));
        __privateSet(this, _filterId, null);
        __privateSet(this, _paused, null);
        __privateSet(this, _emitPromise, null);
      }
      get filter() {
        return JSON.parse(__privateGet(this, _filter4));
      }
      start() {
        __privateSet(this, _filterId, __privateGet(this, _provider5).send("eth_subscribe", this.filter).then((filterId) => {
          ;
          __privateGet(this, _provider5)._register(filterId, this);
          return filterId;
        }));
      }
      stop() {
        __privateGet(this, _filterId).then((filterId) => {
          __privateGet(this, _provider5).send("eth_unsubscribe", [filterId]);
        });
        __privateSet(this, _filterId, null);
      }
      pause(dropWhilePaused) {
        assert2(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
        __privateSet(this, _paused, !!dropWhilePaused);
      }
      resume() {
        __privateSet(this, _paused, null);
      }
      _handleMessage(message) {
        if (__privateGet(this, _filterId) == null) {
          return;
        }
        if (__privateGet(this, _paused) === null) {
          let emitPromise = __privateGet(this, _emitPromise);
          if (emitPromise == null) {
            emitPromise = this._emit(__privateGet(this, _provider5), message);
          } else {
            emitPromise = emitPromise.then(async () => {
              await this._emit(__privateGet(this, _provider5), message);
            });
          }
          __privateSet(this, _emitPromise, emitPromise.then(() => {
            if (__privateGet(this, _emitPromise) === emitPromise) {
              __privateSet(this, _emitPromise, null);
            }
          }));
        }
      }
      async _emit(provider, message) {
        throw new Error("sub-classes must implemente this; _emit");
      }
    };
    _provider5 = new WeakMap();
    _filter4 = new WeakMap();
    _filterId = new WeakMap();
    _paused = new WeakMap();
    _emitPromise = new WeakMap();
    SocketBlockSubscriber = class extends SocketSubscriber {
      constructor(provider) {
        super(provider, ["newHeads"]);
      }
      async _emit(provider, message) {
        provider.emit("block", parseInt(message.number));
      }
    };
    SocketPendingSubscriber = class extends SocketSubscriber {
      constructor(provider) {
        super(provider, ["newPendingTransactions"]);
      }
      async _emit(provider, message) {
        provider.emit("pending", message);
      }
    };
    SocketEventSubscriber = class extends SocketSubscriber {
      constructor(provider, filter) {
        super(provider, ["logs", filter]);
        __privateAdd(this, _logFilter, void 0);
        __privateSet(this, _logFilter, JSON.stringify(filter));
      }
      get logFilter() {
        return JSON.parse(__privateGet(this, _logFilter));
      }
      async _emit(provider, message) {
        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
      }
    };
    _logFilter = new WeakMap();
    SocketProvider = class extends JsonRpcApiProvider {
      constructor(network) {
        super(network, { batchMaxCount: 1 });
        __privateAdd(this, _callbacks, void 0);
        __privateAdd(this, _subs2, void 0);
        __privateAdd(this, _pending, void 0);
        __privateSet(this, _callbacks, /* @__PURE__ */ new Map());
        __privateSet(this, _subs2, /* @__PURE__ */ new Map());
        __privateSet(this, _pending, /* @__PURE__ */ new Map());
      }
      _getSubscriber(sub) {
        switch (sub.type) {
          case "close":
            return new UnmanagedSubscriber("close");
          case "block":
            return new SocketBlockSubscriber(this);
          case "pending":
            return new SocketPendingSubscriber(this);
          case "event":
            return new SocketEventSubscriber(this, sub.filter);
          case "orphan":
            if (sub.filter.orphan === "drop-log") {
              return new UnmanagedSubscriber("drop-log");
            }
        }
        return super._getSubscriber(sub);
      }
      _register(filterId, subscriber) {
        __privateGet(this, _subs2).set(filterId, subscriber);
        const pending = __privateGet(this, _pending).get(filterId);
        if (pending) {
          for (const message of pending) {
            subscriber._handleMessage(message);
          }
          __privateGet(this, _pending).delete(filterId);
        }
      }
      async _send(payload) {
        assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
        const promise2 = new Promise((resolve2, reject2) => {
          __privateGet(this, _callbacks).set(payload.id, { payload, resolve: resolve2, reject: reject2 });
        });
        await this._waitUntilReady();
        await this._write(JSON.stringify(payload));
        return [await promise2];
      }
      async _processMessage(message) {
        const result = JSON.parse(message);
        if (result && typeof result === "object" && "id" in result) {
          const callback = __privateGet(this, _callbacks).get(result.id);
          if (callback == null) {
            this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
              reasonCode: "UNKNOWN_ID",
              result
            }));
            return;
          }
          __privateGet(this, _callbacks).delete(result.id);
          callback.resolve(result);
        } else if (result && result.method === "eth_subscription") {
          const filterId = result.params.subscription;
          const subscriber = __privateGet(this, _subs2).get(filterId);
          if (subscriber) {
            subscriber._handleMessage(result.params.result);
          } else {
            let pending = __privateGet(this, _pending).get(filterId);
            if (pending == null) {
              pending = [];
              __privateGet(this, _pending).set(filterId, pending);
            }
            pending.push(result.params.result);
          }
        } else {
          this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
            reasonCode: "UNEXPECTED_MESSAGE",
            result
          }));
          return;
        }
      }
      async _write(message) {
        throw new Error("sub-classes must override this");
      }
    };
    _callbacks = new WeakMap();
    _subs2 = new WeakMap();
    _pending = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-websocket.js
var _connect2, _websocket, WebSocketProvider2;
var init_provider_websocket = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-websocket.js"() {
    init_ws_browser();
    init_provider_socket();
    WebSocketProvider2 = class extends SocketProvider {
      constructor(url, network) {
        super(network);
        __privateAdd(this, _connect2, void 0);
        __privateAdd(this, _websocket, void 0);
        if (typeof url === "string") {
          __privateSet(this, _connect2, () => {
            return new _WebSocket(url);
          });
          __privateSet(this, _websocket, __privateGet(this, _connect2).call(this));
        } else if (typeof url === "function") {
          __privateSet(this, _connect2, url);
          __privateSet(this, _websocket, url());
        } else {
          __privateSet(this, _connect2, null);
          __privateSet(this, _websocket, url);
        }
        this.websocket.onopen = async () => {
          try {
            await this._start();
            this.resume();
          } catch (error) {
            console.log("failed to start WebsocketProvider", error);
          }
        };
        this.websocket.onmessage = (message) => {
          this._processMessage(message.data);
        };
      }
      get websocket() {
        if (__privateGet(this, _websocket) == null) {
          throw new Error("websocket closed");
        }
        return __privateGet(this, _websocket);
      }
      async _write(message) {
        this.websocket.send(message);
      }
      async destroy() {
        if (__privateGet(this, _websocket) != null) {
          __privateGet(this, _websocket).close();
          __privateSet(this, _websocket, null);
        }
        super.destroy();
      }
    };
    _connect2 = new WeakMap();
    _websocket = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-infura.js
var init_provider_infura = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-infura.js"() {
    init_utils3();
    init_community();
    init_network();
    init_provider_jsonrpc();
    init_provider_websocket();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-quicknode.js
var init_provider_quicknode = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-quicknode.js"() {
    init_utils3();
    init_community();
    init_network();
    init_provider_jsonrpc();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-fallback.js
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
}
function stall4(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
function getTime4() {
  return new Date().getTime();
}
function stringify2(value) {
  return JSON.stringify(value, (key2, value2) => {
    if (typeof value2 === "bigint") {
      return { type: "bigint", value: value2.toString() };
    }
    return value2;
  });
}
async function waitForSync2(config, blockNumber) {
  while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
    if (!config._updateNumber) {
      config._updateNumber = (async () => {
        try {
          const blockNumber2 = await config.provider.getBlockNumber();
          if (blockNumber2 > config.blockNumber) {
            config.blockNumber = blockNumber2;
          }
        } catch (error) {
          config.blockNumber = -2;
          config._lastFatalError = error;
          config._lastFatalErrorTimestamp = getTime4();
        }
        config._updateNumber = null;
      })();
    }
    await config._updateNumber;
    config.outOfSync++;
    if (config._lastFatalError) {
      break;
    }
  }
}
function _normalize(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys3 = Object.keys(value);
      keys3.sort();
      return "{" + keys3.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult(value) {
  if ("error" in value) {
    const error = value.error;
    return { tag: _normalize(error), value: error };
  }
  const result = value.result;
  return { tag: _normalize(result), value: result };
}
function checkQuorum(quorum, results) {
  const tally = /* @__PURE__ */ new Map();
  for (const { value, tag, weight } of results) {
    const t = tally.get(tag) || { value, weight: 0 };
    t.weight += weight;
    tally.set(tag, t);
  }
  let best = null;
  for (const r2 of tally.values()) {
    if (r2.weight >= quorum && (!best || r2.weight > best.weight)) {
      best = r2;
    }
  }
  if (best) {
    return best.value;
  }
  return void 0;
}
function getMedian(quorum, results) {
  let resultWeight = 0;
  const errorMap = /* @__PURE__ */ new Map();
  let bestError = null;
  const values2 = [];
  for (const { value, tag, weight } of results) {
    if (value instanceof Error) {
      const e = errorMap.get(tag) || { value, weight: 0 };
      e.weight += weight;
      errorMap.set(tag, e);
      if (bestError == null || e.weight > bestError.weight) {
        bestError = e;
      }
    } else {
      values2.push(BigInt(value));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return void 0;
  }
  values2.sort((a, b2) => a < b2 ? -1 : b2 > a ? 1 : 0);
  const mid = Math.floor(values2.length / 2);
  if (values2.length % 2) {
    return values2[mid];
  }
  return (values2[mid - 1] + values2[mid] + BN_16) / BN_24;
}
function getAnyResult(quorum, results) {
  const result = checkQuorum(quorum, results);
  if (result !== void 0) {
    return result;
  }
  for (const r2 of results) {
    if (r2.value) {
      return r2.value;
    }
  }
  return void 0;
}
function getFuzzyMode(quorum, results) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results), "%internal");
  }
  const tally = /* @__PURE__ */ new Map();
  const add4 = (result, weight) => {
    const t = tally.get(result) || { result, weight: 0 };
    t.weight += weight;
    tally.set(result, t);
  };
  for (const { weight, value } of results) {
    const r2 = getNumber(value);
    add4(r2 - 1, weight);
    add4(r2, weight);
    add4(r2 + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = void 0;
  for (const { weight, result } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
      bestWeight = weight;
      bestResult = result;
    }
  }
  return bestResult;
}
var BN_16, BN_24, defaultConfig, defaultState, _configs, _height, _initialSyncPromise, _getNextConfig, getNextConfig_fn, _addRunner, addRunner_fn, _initialSync, initialSync_fn, _checkQuorum, checkQuorum_fn, _waitForQuorum, waitForQuorum_fn, FallbackProvider2;
var init_provider_fallback = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-fallback.js"() {
    init_utils3();
    init_abstract_provider();
    init_network();
    BN_16 = BigInt("1");
    BN_24 = BigInt("2");
    defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
    defaultState = {
      blockNumber: -2,
      requests: 0,
      lateResponses: 0,
      errorResponses: 0,
      outOfSync: -1,
      unsupportedEvents: 0,
      rollingDuration: 0,
      score: 0,
      _network: null,
      _updateNumber: null,
      _totalTime: 0,
      _lastFatalError: null,
      _lastFatalErrorTimestamp: 0
    };
    FallbackProvider2 = class extends AbstractProvider {
      constructor(providers, network, options) {
        super(network, options);
        __privateAdd(this, _getNextConfig);
        __privateAdd(this, _addRunner);
        __privateAdd(this, _initialSync);
        __privateAdd(this, _checkQuorum);
        __privateAdd(this, _waitForQuorum);
        __publicField(this, "quorum");
        __publicField(this, "eventQuorum");
        __publicField(this, "eventWorkers");
        __privateAdd(this, _configs, void 0);
        __privateAdd(this, _height, void 0);
        __privateAdd(this, _initialSyncPromise, void 0);
        __privateSet(this, _configs, providers.map((p) => {
          if (p instanceof AbstractProvider) {
            return Object.assign({ provider: p }, defaultConfig, defaultState);
          } else {
            return Object.assign({}, defaultConfig, p, defaultState);
          }
        }));
        __privateSet(this, _height, -2);
        __privateSet(this, _initialSyncPromise, null);
        if (options && options.quorum != null) {
          this.quorum = options.quorum;
        } else {
          this.quorum = Math.ceil(__privateGet(this, _configs).reduce((accum, config) => {
            accum += config.weight;
            return accum;
          }, 0) / 2);
        }
        this.eventQuorum = 1;
        this.eventWorkers = 1;
        assertArgument(this.quorum <= __privateGet(this, _configs).reduce((a, c) => a + c.weight, 0), "quorum exceed provider wieght", "quorum", this.quorum);
      }
      get providerConfigs() {
        return __privateGet(this, _configs).map((c) => {
          const result = Object.assign({}, c);
          for (const key2 in result) {
            if (key2[0] === "_") {
              delete result[key2];
            }
          }
          return result;
        });
      }
      async _detectNetwork() {
        return Network.from(getBigInt(await this._perform({ method: "chainId" })));
      }
      async _translatePerform(provider, req) {
        switch (req.method) {
          case "broadcastTransaction":
            return await provider.broadcastTransaction(req.signedTransaction);
          case "call":
            return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
          case "chainId":
            return (await provider.getNetwork()).chainId;
          case "estimateGas":
            return await provider.estimateGas(req.transaction);
          case "getBalance":
            return await provider.getBalance(req.address, req.blockTag);
          case "getBlock": {
            const block = "blockHash" in req ? req.blockHash : req.blockTag;
            return await provider.getBlock(block, req.includeTransactions);
          }
          case "getBlockNumber":
            return await provider.getBlockNumber();
          case "getCode":
            return await provider.getCode(req.address, req.blockTag);
          case "getGasPrice":
            return (await provider.getFeeData()).gasPrice;
          case "getLogs":
            return await provider.getLogs(req.filter);
          case "getStorage":
            return await provider.getStorage(req.address, req.position, req.blockTag);
          case "getTransaction":
            return await provider.getTransaction(req.hash);
          case "getTransactionCount":
            return await provider.getTransactionCount(req.address, req.blockTag);
          case "getTransactionReceipt":
            return await provider.getTransactionReceipt(req.hash);
          case "getTransactionResult":
            return await provider.getTransactionResult(req.hash);
        }
      }
      async _perform(req) {
        if (req.method === "broadcastTransaction") {
          const results = await Promise.all(__privateGet(this, _configs).map(async ({ provider, weight }) => {
            try {
              const result3 = await provider._perform(req);
              return Object.assign(normalizeResult({ result: result3 }), { weight });
            } catch (error) {
              return Object.assign(normalizeResult({ error }), { weight });
            }
          }));
          const result2 = getAnyResult(this.quorum, results);
          assert2(result2 !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
            request: "%sub-requests",
            info: { request: req, results: results.map(stringify2) }
          });
          if (result2 instanceof Error) {
            throw result2;
          }
          return result2;
        }
        await __privateMethod(this, _initialSync, initialSync_fn).call(this);
        const running = /* @__PURE__ */ new Set();
        for (let i = 0; i < this.quorum; i++) {
          __privateMethod(this, _addRunner, addRunner_fn).call(this, running, req);
        }
        const result = await __privateMethod(this, _waitForQuorum, waitForQuorum_fn).call(this, running, req);
        for (const runner2 of running) {
          if (runner2.perform && runner2.result == null) {
            runner2.config.lateResponses++;
          }
        }
        return result;
      }
      async destroy() {
        for (const { provider } of __privateGet(this, _configs)) {
          provider.destroy();
        }
        super.destroy();
      }
    };
    _configs = new WeakMap();
    _height = new WeakMap();
    _initialSyncPromise = new WeakMap();
    _getNextConfig = new WeakSet();
    getNextConfig_fn = function(running) {
      const configs = Array.from(running).map((r2) => r2.config);
      const allConfigs = __privateGet(this, _configs).slice();
      shuffle(allConfigs);
      allConfigs.sort((a, b2) => a.priority - b2.priority);
      for (const config of allConfigs) {
        if (config._lastFatalError) {
          continue;
        }
        if (configs.indexOf(config) === -1) {
          return config;
        }
      }
      return null;
    };
    _addRunner = new WeakSet();
    addRunner_fn = function(running, req) {
      const config = __privateMethod(this, _getNextConfig, getNextConfig_fn).call(this, running);
      if (config == null) {
        return null;
      }
      const runner2 = {
        config,
        result: null,
        didBump: false,
        perform: null,
        staller: null
      };
      const now2 = getTime4();
      runner2.perform = (async () => {
        try {
          config.requests++;
          const result = await this._translatePerform(config.provider, req);
          runner2.result = { result };
        } catch (error) {
          config.errorResponses++;
          runner2.result = { error };
        }
        const dt = getTime4() - now2;
        config._totalTime += dt;
        config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
        runner2.perform = null;
      })();
      runner2.staller = (async () => {
        await stall4(config.stallTimeout);
        runner2.staller = null;
      })();
      running.add(runner2);
      return runner2;
    };
    _initialSync = new WeakSet();
    initialSync_fn = async function() {
      let initialSync = __privateGet(this, _initialSyncPromise);
      if (!initialSync) {
        const promises = [];
        __privateGet(this, _configs).forEach((config) => {
          promises.push((async () => {
            await waitForSync2(config, 0);
            if (!config._lastFatalError) {
              config._network = await config.provider.getNetwork();
            }
          })());
        });
        __privateSet(this, _initialSyncPromise, initialSync = (async () => {
          await Promise.all(promises);
          let chainId = null;
          for (const config of __privateGet(this, _configs)) {
            if (config._lastFatalError) {
              continue;
            }
            const network = config._network;
            if (chainId == null) {
              chainId = network.chainId;
            } else if (network.chainId !== chainId) {
              assert2(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                operation: "new FallbackProvider"
              });
            }
          }
        })());
      }
      await initialSync;
    };
    _checkQuorum = new WeakSet();
    checkQuorum_fn = async function(running, req) {
      const results = [];
      for (const runner2 of running) {
        if (runner2.result != null) {
          const { tag, value } = normalizeResult(runner2.result);
          results.push({ tag, value, weight: runner2.config.weight });
        }
      }
      if (results.reduce((a, r2) => a + r2.weight, 0) < this.quorum) {
        return void 0;
      }
      switch (req.method) {
        case "getBlockNumber": {
          if (__privateGet(this, _height) === -2) {
            __privateSet(this, _height, Math.ceil(getNumber(getMedian(this.quorum, __privateGet(this, _configs).filter((c) => !c._lastFatalError).map((c) => ({
              value: c.blockNumber,
              tag: getNumber(c.blockNumber).toString(),
              weight: c.weight
            }))))));
          }
          const mode = getFuzzyMode(this.quorum, results);
          if (mode === void 0) {
            return void 0;
          }
          if (mode > __privateGet(this, _height)) {
            __privateSet(this, _height, mode);
          }
          return __privateGet(this, _height);
        }
        case "getGasPrice":
        case "estimateGas":
          return getMedian(this.quorum, results);
        case "getBlock":
          if ("blockTag" in req && req.blockTag === "pending") {
            return getAnyResult(this.quorum, results);
          }
          return checkQuorum(this.quorum, results);
        case "call":
        case "chainId":
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorage":
        case "getTransaction":
        case "getTransactionReceipt":
        case "getLogs":
          return checkQuorum(this.quorum, results);
        case "broadcastTransaction":
          return getAnyResult(this.quorum, results);
      }
      assert2(false, "unsupported method", "UNSUPPORTED_OPERATION", {
        operation: `_perform(${stringify2(req.method)})`
      });
    };
    _waitForQuorum = new WeakSet();
    waitForQuorum_fn = async function(running, req) {
      if (running.size === 0) {
        throw new Error("no runners?!");
      }
      const interesting = [];
      let newRunners = 0;
      for (const runner2 of running) {
        if (runner2.perform) {
          interesting.push(runner2.perform);
        }
        if (runner2.staller) {
          interesting.push(runner2.staller);
          continue;
        }
        if (runner2.didBump) {
          continue;
        }
        runner2.didBump = true;
        newRunners++;
      }
      const value = await __privateMethod(this, _checkQuorum, checkQuorum_fn).call(this, running, req);
      if (value !== void 0) {
        if (value instanceof Error) {
          throw value;
        }
        return value;
      }
      for (let i = 0; i < newRunners; i++) {
        __privateMethod(this, _addRunner, addRunner_fn).call(this, running, req);
      }
      assert2(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: Array.from(running).map((r2) => stringify2(r2.result)) }
      });
      await Promise.race(interesting);
      return await __privateMethod(this, _waitForQuorum, waitForQuorum_fn).call(this, running, req);
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/default-provider.js
var Testnets;
var init_default_provider = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/default-provider.js"() {
    init_utils3();
    init_provider_ankr();
    init_provider_alchemy();
    init_provider_cloudflare();
    init_provider_etherscan();
    init_provider_infura();
    init_provider_quicknode();
    init_provider_fallback();
    init_provider_jsonrpc();
    init_network();
    init_provider_websocket();
    Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/signer-noncemanager.js
var _noncePromise, _delta, _NonceManager, NonceManager;
var init_signer_noncemanager = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/signer-noncemanager.js"() {
    init_utils3();
    init_abstract_signer();
    _NonceManager = class extends AbstractSigner {
      constructor(signer) {
        super(signer.provider);
        __publicField(this, "signer");
        __privateAdd(this, _noncePromise, void 0);
        __privateAdd(this, _delta, void 0);
        defineProperties(this, { signer });
        __privateSet(this, _noncePromise, null);
        __privateSet(this, _delta, 0);
      }
      async getAddress() {
        return this.signer.getAddress();
      }
      connect(provider) {
        return new _NonceManager(this.signer.connect(provider));
      }
      async getNonce(blockTag) {
        if (blockTag === "pending") {
          if (__privateGet(this, _noncePromise) == null) {
            __privateSet(this, _noncePromise, super.getNonce("pending"));
          }
          const delta = __privateGet(this, _delta);
          return await __privateGet(this, _noncePromise) + delta;
        }
        return super.getNonce(blockTag);
      }
      increment() {
        __privateWrapper(this, _delta)._++;
      }
      reset() {
        __privateSet(this, _delta, 0);
        __privateSet(this, _noncePromise, null);
      }
      async sendTransaction(tx) {
        const noncePromise = this.getNonce("pending");
        this.increment();
        tx = await this.signer.populateTransaction(tx);
        tx.nonce = await noncePromise;
        return await this.signer.sendTransaction(tx);
      }
      signTransaction(tx) {
        return this.signer.signTransaction(tx);
      }
      signMessage(message) {
        return this.signer.signMessage(message);
      }
      signTypedData(domain, types, value) {
        return this.signer.signTypedData(domain, types, value);
      }
    };
    NonceManager = _NonceManager;
    _noncePromise = new WeakMap();
    _delta = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-browser.js
var _request2, BrowserProvider;
var init_provider_browser = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-browser.js"() {
    init_utils3();
    init_provider_jsonrpc();
    BrowserProvider = class extends JsonRpcApiPollingProvider {
      constructor(ethereum, network) {
        super(network, { batchMaxCount: 1 });
        __privateAdd(this, _request2, void 0);
        __privateSet(this, _request2, async (method, params) => {
          const payload = { method, params };
          this.emit("debug", { action: "sendEip1193Request", payload });
          try {
            const result = await ethereum.request(payload);
            this.emit("debug", { action: "receiveEip1193Result", result });
            return result;
          } catch (e) {
            const error = new Error(e.message);
            error.code = e.code;
            error.data = e.data;
            error.payload = payload;
            this.emit("debug", { action: "receiveEip1193Error", error });
            throw error;
          }
        });
      }
      async send(method, params) {
        await this._start();
        return await super.send(method, params);
      }
      async _send(payload) {
        assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
        try {
          const result = await __privateGet(this, _request2).call(this, payload.method, payload.params || []);
          return [{ id: payload.id, result }];
        } catch (e) {
          return [{
            id: payload.id,
            error: { code: e.code, data: e.data, message: e.message }
          }];
        }
      }
      getRpcError(payload, error) {
        error = JSON.parse(JSON.stringify(error));
        switch (error.error.code || -1) {
          case 4001:
            error.error.message = `ethers-user-denied: ${error.error.message}`;
            break;
          case 4200:
            error.error.message = `ethers-unsupported: ${error.error.message}`;
            break;
        }
        return super.getRpcError(payload, error);
      }
      async hasSigner(address) {
        if (address == null) {
          address = 0;
        }
        const accounts = await this.send("eth_accounts", []);
        if (typeof address === "number") {
          return accounts.length > address;
        }
        address = address.toLowerCase();
        return accounts.filter((a) => a.toLowerCase() === address).length !== 0;
      }
      async getSigner(address) {
        if (address == null) {
          address = 0;
        }
        if (!await this.hasSigner(address)) {
          try {
            await __privateGet(this, _request2).call(this, "eth_requestAccounts", []);
          } catch (error) {
            const payload = error.payload;
            throw this.getRpcError(payload, { id: payload.id, error });
          }
        }
        return await super.getSigner(address);
      }
    };
    _request2 = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-pocket.js
var init_provider_pocket = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-pocket.js"() {
    init_utils3();
    init_community();
    init_network();
    init_provider_jsonrpc();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js
var init_provider_ipcsocket_browser = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/provider-ipcsocket-browser.js"() {
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/index.js
var init_providers = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/providers/index.js"() {
    init_abstract_provider();
    init_abstract_signer();
    init_community();
    init_default_provider();
    init_ens_resolver();
    init_network();
    init_signer_noncemanager();
    init_plugins_network();
    init_provider();
    init_provider_fallback();
    init_provider_jsonrpc();
    init_provider_browser();
    init_provider_alchemy();
    init_provider_ankr();
    init_provider_cloudflare();
    init_provider_etherscan();
    init_provider_infura();
    init_provider_pocket();
    init_provider_quicknode();
    init_provider_ipcsocket_browser();
    init_provider_socket();
    init_provider_websocket();
    init_provider_socket();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/base-wallet.js
var _signingKey, _BaseWallet, BaseWallet;
var init_base_wallet = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/base-wallet.js"() {
    init_address3();
    init_hash();
    init_providers();
    init_transaction2();
    init_utils3();
    _BaseWallet = class extends AbstractSigner {
      constructor(privateKey, provider) {
        super(provider);
        __publicField(this, "address");
        __privateAdd(this, _signingKey, void 0);
        assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
        __privateSet(this, _signingKey, privateKey);
        const address = computeAddress2(this.signingKey.publicKey);
        defineProperties(this, { address });
      }
      get signingKey() {
        return __privateGet(this, _signingKey);
      }
      get privateKey() {
        return this.signingKey.privateKey;
      }
      async getAddress() {
        return this.address;
      }
      connect(provider) {
        return new _BaseWallet(__privateGet(this, _signingKey), provider);
      }
      async signTransaction(tx) {
        const { to, from } = await resolveProperties2({
          to: tx.to ? resolveAddress(tx.to, this.provider) : void 0,
          from: tx.from ? resolveAddress(tx.from, this.provider) : void 0
        });
        if (to != null) {
          tx.to = to;
        }
        if (from != null) {
          tx.from = from;
        }
        if (tx.from != null) {
          assertArgument(getAddress2(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
          delete tx.from;
        }
        const btx = Transaction.from(tx);
        btx.signature = this.signingKey.sign(btx.unsignedHash);
        return btx.serialized;
      }
      async signMessage(message) {
        return this.signMessageSync(message);
      }
      signMessageSync(message) {
        return this.signingKey.sign(hashMessage2(message)).serialized;
      }
      async signTypedData(domain, types, value) {
        const populated = await TypedDataEncoder2.resolveNames(domain, types, value, async (name) => {
          assert2(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
            operation: "resolveName",
            info: { name }
          });
          const address = await this.provider.resolveName(name);
          assert2(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
            value: name
          });
          return address;
        });
        return this.signingKey.sign(TypedDataEncoder2.hash(populated.domain, types, populated.value)).serialized;
      }
    };
    BaseWallet = _BaseWallet;
    _signingKey = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/decode-owl.js
function unfold(words3, sep) {
  let initial = 97;
  return words3.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
function decode3(data2, subs) {
  for (let i = subsChrs.length - 1; i >= 0; i--) {
    data2 = data2.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data2.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all2, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi); i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data2) {
  assertArgument(data2[0] === "0", "unsupported auwl data", "data", data2);
  return decode3(data2.substring(1 + 2 * subsChrs.length), data2.substring(1, 1 + 2 * subsChrs.length));
}
var subsChrs, Word;
var init_decode_owl = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/decode-owl.js"() {
    init_utils3();
    subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
    Word = /^[a-z]*$/i;
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlist.js
var Wordlist2;
var init_wordlist2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlist.js"() {
    init_utils3();
    Wordlist2 = class {
      constructor(locale) {
        __publicField(this, "locale");
        defineProperties(this, { locale });
      }
      split(phrase) {
        return phrase.toLowerCase().split(/\s+/g);
      }
      join(words3) {
        return words3.join(" ");
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
var _data4, _checksum, _words, _loadWords, loadWords_fn, WordlistOwl;
var init_wordlist_owl = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlist-owl.js"() {
    init_hash();
    init_utils3();
    init_decode_owl();
    init_wordlist2();
    WordlistOwl = class extends Wordlist2 {
      constructor(locale, data2, checksum2) {
        super(locale);
        __privateAdd(this, _loadWords);
        __privateAdd(this, _data4, void 0);
        __privateAdd(this, _checksum, void 0);
        __privateAdd(this, _words, void 0);
        __privateSet(this, _data4, data2);
        __privateSet(this, _checksum, checksum2);
        __privateSet(this, _words, null);
      }
      get _data() {
        return __privateGet(this, _data4);
      }
      _decodeWords() {
        return decodeOwl(__privateGet(this, _data4));
      }
      getWord(index) {
        const words3 = __privateMethod(this, _loadWords, loadWords_fn).call(this);
        assertArgument(index >= 0 && index < words3.length, `invalid word index: ${index}`, "index", index);
        return words3[index];
      }
      getWordIndex(word) {
        return __privateMethod(this, _loadWords, loadWords_fn).call(this).indexOf(word);
      }
    };
    _data4 = new WeakMap();
    _checksum = new WeakMap();
    _words = new WeakMap();
    _loadWords = new WeakSet();
    loadWords_fn = function() {
      if (__privateGet(this, _words) == null) {
        const words3 = this._decodeWords();
        const checksum2 = id2(words3.join("\n") + "\n");
        if (checksum2 !== __privateGet(this, _checksum)) {
          throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
        }
        __privateSet(this, _words, words3);
      }
      return __privateGet(this, _words);
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/lang-en.js
var words2, checksum, wordlist2, LangEn2;
var init_lang_en2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/lang-en.js"() {
    init_wordlist_owl();
    words2 = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
    checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
    wordlist2 = null;
    LangEn2 = class extends WordlistOwl {
      constructor() {
        super("en", words2, checksum);
      }
      static wordlist() {
        if (wordlist2 == null) {
          wordlist2 = new LangEn2();
        }
        return wordlist2;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/mnemonic.js
function getUpperMask2(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
}
function getLowerMask2(bits) {
  return (1 << bits) - 1 & 255;
}
function mnemonicToEntropy2(mnemonic, wordlist3) {
  assertNormalize("NFKD");
  if (wordlist3 == null) {
    wordlist3 = LangEn2.wordlist();
  }
  const words3 = wordlist3.split(mnemonic);
  assertArgument(words3.length % 3 === 0 && words3.length >= 12 && words3.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words3.length / 8));
  let offset = 0;
  for (let i = 0; i < words3.length; i++) {
    let index = wordlist3.getWordIndex(words3[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words3.length / 3;
  const checksumBits = words3.length / 3;
  const checksumMask = getUpperMask2(checksumBits);
  const checksum2 = getBytes(sha2564(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify2(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic2(entropy, wordlist3) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist3 == null) {
    wordlist3 = LangEn2.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0; i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask2(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha2564(entropy).substring(2, 4), 16) & getUpperMask2(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist3.join(indices.map((index) => wordlist3.getWord(index)));
}
var _guard5, Mnemonic;
var init_mnemonic = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/mnemonic.js"() {
    init_crypto2();
    init_utils3();
    init_lang_en2();
    _guard5 = {};
    Mnemonic = class {
      constructor(guard, entropy, phrase, password, wordlist3) {
        __publicField(this, "phrase");
        __publicField(this, "password");
        __publicField(this, "wordlist");
        __publicField(this, "entropy");
        if (password == null) {
          password = "";
        }
        if (wordlist3 == null) {
          wordlist3 = LangEn2.wordlist();
        }
        assertPrivate(guard, _guard5, "Mnemonic");
        defineProperties(this, { phrase, password, wordlist: wordlist3, entropy });
      }
      computeSeed() {
        const salt = toUtf8Bytes2("mnemonic" + this.password, "NFKD");
        return pbkdf24(toUtf8Bytes2(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
      }
      static fromPhrase(phrase, password, wordlist3) {
        const entropy = mnemonicToEntropy2(phrase, wordlist3);
        phrase = entropyToMnemonic2(getBytes(entropy), wordlist3);
        return new Mnemonic(_guard5, entropy, phrase, password, wordlist3);
      }
      static fromEntropy(_entropy, password, wordlist3) {
        const entropy = getBytes(_entropy, "entropy");
        const phrase = entropyToMnemonic2(entropy, wordlist3);
        return new Mnemonic(_guard5, hexlify2(entropy), phrase, password, wordlist3);
      }
      static entropyToPhrase(_entropy, wordlist3) {
        const entropy = getBytes(_entropy, "entropy");
        return entropyToMnemonic2(entropy, wordlist3);
      }
      static phraseToEntropy(phrase, wordlist3) {
        return mnemonicToEntropy2(phrase, wordlist3);
      }
      static isValidMnemonic(phrase, wordlist3) {
        try {
          mnemonicToEntropy2(phrase, wordlist3);
          return true;
        } catch (error) {
        }
        return false;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/aes.js
function convertToInt32(bytes3) {
  const result = [];
  for (let i = 0; i < bytes3.length; i += 4) {
    result.push(bytes3[i] << 24 | bytes3[i + 1] << 16 | bytes3[i + 2] << 8 | bytes3[i + 3]);
  }
  return result;
}
var __classPrivateFieldGet, __classPrivateFieldSet, _AES_key, _AES_Kd, _AES_Ke, numberOfRounds, rcon, S, Si, T12, T2, T3, T4, T5, T6, T7, T8, U1, U2, U3, U4, AES;
var init_aes = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/aes.js"() {
    __classPrivateFieldGet = function(receiver, state, kind, f2) {
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    AES = class {
      get key() {
        return __classPrivateFieldGet(this, _AES_key, "f").slice();
      }
      constructor(key2) {
        _AES_key.set(this, void 0);
        _AES_Kd.set(this, void 0);
        _AES_Ke.set(this, void 0);
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        __classPrivateFieldSet(this, _AES_key, new Uint8Array(key2), "f");
        const rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
        }
        __classPrivateFieldSet(this, _AES_Ke, [], "f");
        __classPrivateFieldSet(this, _AES_Kd, [], "f");
        for (let i = 0; i <= rounds; i++) {
          __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
          __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
        }
        const roundKeyCount = (rounds + 1) * 4;
        const KC = this.key.length / 4;
        const tk = convertToInt32(this.key);
        let index;
        for (let i = 0; i < KC; i++) {
          index = i >> 2;
          __classPrivateFieldGet(this, _AES_Ke, "f")[index][i % 4] = tk[i];
          __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
        }
        let rconpointer = 0;
        let t = KC, tt;
        while (t < roundKeyCount) {
          tt = tk[KC - 1];
          tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (let i2 = 1; i2 < KC; i2++) {
              tk[i2] ^= tk[i2 - 1];
            }
          } else {
            for (let i2 = 1; i2 < KC / 2; i2++) {
              tk[i2] ^= tk[i2 - 1];
            }
            tt = tk[KC / 2 - 1];
            tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
            for (let i2 = KC / 2 + 1; i2 < KC; i2++) {
              tk[i2] ^= tk[i2 - 1];
            }
          }
          let i = 0, r2, c;
          while (i < KC && t < roundKeyCount) {
            r2 = t >> 2;
            c = t % 4;
            __classPrivateFieldGet(this, _AES_Ke, "f")[r2][c] = tk[i];
            __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r2][c] = tk[i++];
            t++;
          }
        }
        for (let r2 = 1; r2 < rounds; r2++) {
          for (let c = 0; c < 4; c++) {
            tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r2][c];
            __classPrivateFieldGet(this, _AES_Kd, "f")[r2][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
          }
        }
      }
      encrypt(plaintext) {
        if (plaintext.length != 16) {
          throw new TypeError("invalid plaintext size (must be 16 bytes)");
        }
        const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
        const a = [0, 0, 0, 0];
        let t = convertToInt32(plaintext);
        for (let i = 0; i < 4; i++) {
          t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
        }
        for (let r2 = 1; r2 < rounds; r2++) {
          for (let i = 0; i < 4; i++) {
            a[i] = T12[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r2][i];
          }
          t = a.slice();
        }
        const result = new Uint8Array(16);
        let tt = 0;
        for (let i = 0; i < 4; i++) {
          tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i];
          result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
        }
        return result;
      }
      decrypt(ciphertext) {
        if (ciphertext.length != 16) {
          throw new TypeError("invalid ciphertext size (must be 16 bytes)");
        }
        const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
        const a = [0, 0, 0, 0];
        let t = convertToInt32(ciphertext);
        for (let i = 0; i < 4; i++) {
          t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
        }
        for (let r2 = 1; r2 < rounds; r2++) {
          for (let i = 0; i < 4; i++) {
            a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r2][i];
          }
          t = a.slice();
        }
        const result = new Uint8Array(16);
        let tt = 0;
        for (let i = 0; i < 4; i++) {
          tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i];
          result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
          result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
          result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
          result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
        }
        return result;
      }
    };
    _AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode.js
var ModeOfOperation;
var init_mode = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode.js"() {
    init_aes();
    ModeOfOperation = class {
      constructor(name, key2, cls) {
        if (cls && !(this instanceof cls)) {
          throw new Error(`${name} must be instantiated with "new"`);
        }
        Object.defineProperties(this, {
          aes: { enumerable: true, value: new AES(key2) },
          name: { enumerable: true, value: name }
        });
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-cbc.js
var __classPrivateFieldSet2, __classPrivateFieldGet2, _CBC_iv, _CBC_lastBlock, CBC;
var init_mode_cbc = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-cbc.js"() {
    init_mode();
    __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    CBC = class extends ModeOfOperation {
      constructor(key2, iv) {
        super("ECC", key2, CBC);
        _CBC_iv.set(this, void 0);
        _CBC_lastBlock.set(this, void 0);
        if (iv) {
          if (iv.length % 16) {
            throw new TypeError("invalid iv size (must be 16 bytes)");
          }
          __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(iv), "f");
        } else {
          __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(16), "f");
        }
        __classPrivateFieldSet2(this, _CBC_lastBlock, this.iv, "f");
      }
      get iv() {
        return new Uint8Array(__classPrivateFieldGet2(this, _CBC_iv, "f"));
      }
      encrypt(plaintext) {
        if (plaintext.length % 16) {
          throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        const ciphertext = new Uint8Array(plaintext.length);
        for (let i = 0; i < plaintext.length; i += 16) {
          for (let j = 0; j < 16; j++) {
            __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
          }
          __classPrivateFieldSet2(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet2(this, _CBC_lastBlock, "f")), "f");
          ciphertext.set(__classPrivateFieldGet2(this, _CBC_lastBlock, "f"), i);
        }
        return ciphertext;
      }
      decrypt(ciphertext) {
        if (ciphertext.length % 16) {
          throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        const plaintext = new Uint8Array(ciphertext.length);
        for (let i = 0; i < ciphertext.length; i += 16) {
          const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
          for (let j = 0; j < 16; j++) {
            plaintext[i + j] = block[j] ^ __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j];
            __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
          }
        }
        return plaintext;
      }
    };
    _CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-cfb.js
var __classPrivateFieldGet3, _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;
var init_mode_cfb = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-cfb.js"() {
    init_mode();
    __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    _CFB_iv = /* @__PURE__ */ new WeakMap(), _CFB_shiftRegister = /* @__PURE__ */ new WeakMap(), _CFB_instances = /* @__PURE__ */ new WeakSet(), _CFB_shift = function _CFB_shift2(data2) {
      const segmentSize = this.segmentSize / 8;
      __classPrivateFieldGet3(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet3(this, _CFB_shiftRegister, "f").subarray(segmentSize));
      __classPrivateFieldGet3(this, _CFB_shiftRegister, "f").set(data2.subarray(0, segmentSize), 16 - segmentSize);
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet3, __classPrivateFieldGet4, _CTR_remaining, _CTR_remainingIndex, _CTR_counter, CTR;
var init_mode_ctr = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-ctr.js"() {
    init_mode();
    __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet4 = function(receiver, state, kind, f2) {
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    CTR = class extends ModeOfOperation {
      constructor(key2, initialValue) {
        super("CTR", key2, CTR);
        _CTR_remaining.set(this, void 0);
        _CTR_remainingIndex.set(this, void 0);
        _CTR_counter.set(this, void 0);
        __classPrivateFieldSet3(this, _CTR_counter, new Uint8Array(16), "f");
        __classPrivateFieldGet4(this, _CTR_counter, "f").fill(0);
        __classPrivateFieldSet3(this, _CTR_remaining, __classPrivateFieldGet4(this, _CTR_counter, "f"), "f");
        __classPrivateFieldSet3(this, _CTR_remainingIndex, 16, "f");
        if (initialValue == null) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this.setCounterValue(initialValue);
        } else {
          this.setCounterBytes(initialValue);
        }
      }
      get counter() {
        return new Uint8Array(__classPrivateFieldGet4(this, _CTR_counter, "f"));
      }
      setCounterValue(value) {
        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
          throw new TypeError("invalid counter initial integer value");
        }
        for (let index = 15; index >= 0; --index) {
          __classPrivateFieldGet4(this, _CTR_counter, "f")[index] = value % 256;
          value = Math.floor(value / 256);
        }
      }
      setCounterBytes(value) {
        if (value.length !== 16) {
          throw new TypeError("invalid counter initial Uint8Array value length");
        }
        __classPrivateFieldGet4(this, _CTR_counter, "f").set(value);
      }
      increment() {
        for (let i = 15; i >= 0; i--) {
          if (__classPrivateFieldGet4(this, _CTR_counter, "f")[i] === 255) {
            __classPrivateFieldGet4(this, _CTR_counter, "f")[i] = 0;
          } else {
            __classPrivateFieldGet4(this, _CTR_counter, "f")[i]++;
            break;
          }
        }
      }
      encrypt(plaintext) {
        var _a2, _b;
        const crypttext = new Uint8Array(plaintext);
        for (let i = 0; i < crypttext.length; i++) {
          if (__classPrivateFieldGet4(this, _CTR_remainingIndex, "f") === 16) {
            __classPrivateFieldSet3(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet4(this, _CTR_counter, "f")), "f");
            __classPrivateFieldSet3(this, _CTR_remainingIndex, 0, "f");
            this.increment();
          }
          crypttext[i] ^= __classPrivateFieldGet4(this, _CTR_remaining, "f")[__classPrivateFieldSet3(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet4(this, _CTR_remainingIndex, "f"), _a2 = _b++, _b), "f"), _a2];
        }
        return crypttext;
      }
      decrypt(ciphertext) {
        return this.encrypt(ciphertext);
      }
    };
    _CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-ecb.js
var init_mode_ecb = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-ecb.js"() {
    init_mode();
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-ofb.js
var _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;
var init_mode_ofb = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/mode-ofb.js"() {
    init_mode();
    _OFB_iv = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipher = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipherIndex = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/padding.js
function pkcs7Strip(data2) {
  if (data2.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data2[data2.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data2.length - padder;
  for (let i = 0; i < padder; i++) {
    if (data2[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data2.subarray(0, length));
}
var init_padding = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/padding.js"() {
  }
});

// node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/index.js
var init_lib33 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/aes-js/lib.esm/index.js"() {
    init_aes();
    init_mode();
    init_mode_cbc();
    init_mode_cfb();
    init_mode_ctr();
    init_mode_ecb();
    init_mode_ofb();
    init_padding();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/utils.js
function looseArrayify2(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad2(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword2(password) {
  if (typeof password === "string") {
    return toUtf8Bytes2(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk2(object2, _path) {
  const match2 = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match2 != null, "invalid path", "path", _path);
  const path = match2[1];
  const type = match2[3];
  const reqd = match2[4] === "!";
  let cur = object2;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key2 in cur) {
        if (key2.toLowerCase() === comp) {
          found = cur[key2];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify2(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}
var init_utils6 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/utils.js"() {
    init_utils3();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/json-keystore.js
function isKeystoreJson(json) {
  try {
    const data2 = JSON.parse(json);
    const version29 = data2.version != null ? parseInt(data2.version) : 0;
    if (version29 === 3) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decrypt3(data2, key2, ciphertext) {
  const cipher = spelunk2(data2, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk2(data2, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key2, iv);
    return hexlify2(aesCtr.decrypt(ciphertext));
  }
  assert2(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount2(data2, _key) {
  const key2 = getBytes(_key);
  const ciphertext = spelunk2(data2, "crypto.ciphertext:data!");
  const computedMAC = hexlify2(keccak2563(concat2([key2.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk2(data2, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt3(data2, key2.slice(0, 16), ciphertext);
  const address = computeAddress2(privateKey);
  if (data2.address) {
    let check2 = data2.address.toLowerCase();
    if (!check2.startsWith("0x")) {
      check2 = "0x" + check2;
    }
    assertArgument(getAddress2(check2) === address, "keystore address/privateKey mismatch", "address", data2.address);
  }
  const account = { address, privateKey };
  const version29 = spelunk2(data2, "x-ethers.version:string");
  if (version29 === "0.1") {
    const mnemonicKey = key2.slice(32, 64);
    const mnemonicCiphertext = spelunk2(data2, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk2(data2, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: spelunk2(data2, "x-ethers.path:string") || defaultPath2,
      locale: spelunk2(data2, "x-ethers.locale:string") || "en",
      entropy: hexlify2(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data2) {
  const kdf = spelunk2(data2, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk2(data2, "crypto.kdfparams.salt:data!");
      const N4 = spelunk2(data2, "crypto.kdfparams.n:int!");
      const r2 = spelunk2(data2, "crypto.kdfparams.r:int!");
      const p = spelunk2(data2, "crypto.kdfparams.p:int!");
      assertArgument(N4 > 0 && (N4 & N4 - 1) === 0, "invalid kdf.N", "kdf.N", N4);
      assertArgument(r2 > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk2(data2, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N4, r: r2, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk2(data2, "crypto.kdfparams.salt:data!");
      const prf = spelunk2(data2, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk2(data2, "crypto.kdfparams.c:int!");
      const dkLen = spelunk2(data2, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
}
function decryptKeystoreJsonSync(json, _password) {
  const data2 = JSON.parse(json);
  const password = getPassword2(_password);
  const params = getDecryptKdfParams(data2);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key3 = pbkdf24(password, salt2, count, dkLen2, algorithm);
    return getAccount2(data2, key3);
  }
  assert2(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N4, r: r2, p, dkLen } = params;
  const key2 = scryptSync(password, salt, N4, r2, p, dkLen);
  return getAccount2(data2, key2);
}
function stall5(duration) {
  return new Promise((resolve2) => {
    setTimeout(() => {
      resolve2();
    }, duration);
  });
}
async function decryptKeystoreJson(json, _password, progress) {
  const data2 = JSON.parse(json);
  const password = getPassword2(_password);
  const params = getDecryptKdfParams(data2);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall5(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key3 = pbkdf24(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall5(0);
    }
    return getAccount2(data2, key3);
  }
  assert2(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N4, r: r2, p, dkLen } = params;
  const key2 = await scrypt3(password, salt, N4, r2, p, dkLen, progress);
  return getAccount2(data2, key2);
}
function getEncryptKdfParams(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes4(32);
  let N4 = 1 << 17, r2 = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N4 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N4 === "number" && N4 > 0 && Number.isSafeInteger(N4) && (BigInt(N4) & BigInt(N4 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N4);
  assertArgument(typeof r2 === "number" && r2 > 0 && Number.isSafeInteger(r2), "invalid scrypt r parameter", "options.r", r2);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N4, r: r2, p };
}
function _encryptKeystore(key2, kdf, account, options) {
  const privateKey = getBytes(account.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes4(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes4(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key2.slice(0, 16);
  const macPrefix = key2.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak2563(concat2([macPrefix, ciphertext]));
  const data2 = {
    address: account.address.substring(2).toLowerCase(),
    id: uuidV42(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify2(iv).substring(2)
      },
      ciphertext: hexlify2(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify2(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version27}`;
    const path = account.mnemonic.path || defaultPath2;
    const locale = account.mnemonic.locale || "en";
    const mnemonicKey = key2.slice(32, 64);
    const entropy = getBytes(account.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes4(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now2 = new Date();
    const timestamp = now2.getUTCFullYear() + "-" + zpad2(now2.getUTCMonth() + 1, 2) + "-" + zpad2(now2.getUTCDate(), 2) + "T" + zpad2(now2.getUTCHours(), 2) + "-" + zpad2(now2.getUTCMinutes(), 2) + "-" + zpad2(now2.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data2.address;
    data2["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify2(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify2(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data2);
}
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword2(password);
  const kdf = getEncryptKdfParams(options);
  const key2 = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key2), kdf, account, options);
}
async function encryptKeystoreJson(account, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword2(password);
  const kdf = getEncryptKdfParams(options);
  const key2 = await scrypt3(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key2), kdf, account, options);
}
var defaultPath2;
var init_json_keystore = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/json-keystore.js"() {
    init_lib33();
    init_address3();
    init_crypto2();
    init_transaction2();
    init_utils3();
    init_utils6();
    init_version27();
    defaultPath2 = "m/44'/60'/0'/0/0";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/hdwallet.js
function zpad3(value, length) {
  let result = "";
  while (value) {
    result = Nibbles2[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value2) {
  const value = getBytes(_value2);
  const check2 = dataSlice(sha2564(sha2564(value)), 0, 4);
  const bytes3 = concat2([value, check2]);
  return encodeBase58(bytes3);
}
function ser_I(index, chainCode, publicKey, privateKey) {
  const data2 = new Uint8Array(37);
  if (index & HardenedBit2) {
    assert2(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data2.set(getBytes(privateKey), 1);
  } else {
    data2.set(getBytes(publicKey));
  }
  for (let i = 24; i >= 0; i -= 8) {
    data2[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac2("sha512", chainCode, data2));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
}
function derivePath(node2, path) {
  const components = path.split("/");
  assertArgument(components.length > 0 && (components[0] === "m" || node2.depth > 0), "invalid path", "path", path);
  if (components[0] === "m") {
    components.shift();
  }
  let result = node2;
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit2, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit2 + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit2, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
}
var defaultPath3, MasterSecret2, HardenedBit2, N3, Nibbles2, _guard6, _account, account_fn, _fromSeed, fromSeed_fn, _HDNodeWallet, HDNodeWallet, HDNodeVoidWallet;
var init_hdwallet = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/hdwallet.js"() {
    init_crypto2();
    init_providers();
    init_transaction2();
    init_utils3();
    init_lang_en2();
    init_base_wallet();
    init_mnemonic();
    init_json_keystore();
    defaultPath3 = "m/44'/60'/0'/0/0";
    MasterSecret2 = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
    HardenedBit2 = 2147483648;
    N3 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    Nibbles2 = "0123456789abcdef";
    _guard6 = {};
    _HDNodeWallet = class extends BaseWallet {
      constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
        super(signingKey, provider);
        __privateAdd(this, _account);
        __publicField(this, "publicKey");
        __publicField(this, "fingerprint");
        __publicField(this, "parentFingerprint");
        __publicField(this, "mnemonic");
        __publicField(this, "chainCode");
        __publicField(this, "path");
        __publicField(this, "index");
        __publicField(this, "depth");
        assertPrivate(guard, _guard6, "HDNodeWallet");
        defineProperties(this, { publicKey: signingKey.compressedPublicKey });
        const fingerprint = dataSlice(ripemd1603(sha2564(this.publicKey)), 0, 4);
        defineProperties(this, {
          parentFingerprint,
          fingerprint,
          chainCode,
          path,
          index,
          depth
        });
        defineProperties(this, { mnemonic });
      }
      connect(provider) {
        return new _HDNodeWallet(_guard6, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
      }
      async encrypt(password, progressCallback) {
        return await encryptKeystoreJson(__privateMethod(this, _account, account_fn).call(this), password, { progressCallback });
      }
      encryptSync(password) {
        return encryptKeystoreJsonSync(__privateMethod(this, _account, account_fn).call(this), password);
      }
      get extendedKey() {
        assert2(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
        return encodeBase58Check(concat2([
          "0x0488ADE4",
          zpad3(this.depth, 1),
          this.parentFingerprint,
          zpad3(this.index, 4),
          this.chainCode,
          concat2(["0x00", this.privateKey])
        ]));
      }
      hasPath() {
        return this.path != null;
      }
      neuter() {
        return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
      }
      deriveChild(_index) {
        const index = getNumber(_index, "index");
        assertArgument(index <= 4294967295, "invalid index", "index", index);
        let path = this.path;
        if (path) {
          path += "/" + (index & ~HardenedBit2);
          if (index & HardenedBit2) {
            path += "'";
          }
        }
        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
        const ki = new SigningKey2(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N3, 32));
        return new _HDNodeWallet(_guard6, ki, this.fingerprint, hexlify2(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
      }
      derivePath(path) {
        return derivePath(this, path);
      }
      static fromExtendedKey(extendedKey) {
        const bytes3 = toBeArray(decodeBase58(extendedKey));
        assertArgument(bytes3.length === 82 || encodeBase58Check(bytes3.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
        const depth = bytes3[4];
        const parentFingerprint = hexlify2(bytes3.slice(5, 9));
        const index = parseInt(hexlify2(bytes3.slice(9, 13)).substring(2), 16);
        const chainCode = hexlify2(bytes3.slice(13, 45));
        const key2 = bytes3.slice(45, 78);
        switch (hexlify2(bytes3.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf": {
            const publicKey = hexlify2(key2);
            return new HDNodeVoidWallet(_guard6, computeAddress2(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
          }
          case "0x0488ade4":
          case "0x04358394 ":
            if (key2[0] !== 0) {
              break;
            }
            return new _HDNodeWallet(_guard6, new SigningKey2(key2.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
        }
        assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
      }
      static createRandom(password, path, wordlist3) {
        var _a2;
        if (password == null) {
          password = "";
        }
        if (path == null) {
          path = defaultPath3;
        }
        if (wordlist3 == null) {
          wordlist3 = LangEn2.wordlist();
        }
        const mnemonic = Mnemonic.fromEntropy(randomBytes4(16), password, wordlist3);
        return __privateMethod(_a2 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
      }
      static fromMnemonic(mnemonic, path) {
        var _a2;
        if (!path) {
          path = defaultPath3;
        }
        return __privateMethod(_a2 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
      }
      static fromPhrase(phrase, password, path, wordlist3) {
        var _a2;
        if (password == null) {
          password = "";
        }
        if (path == null) {
          path = defaultPath3;
        }
        if (wordlist3 == null) {
          wordlist3 = LangEn2.wordlist();
        }
        const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist3);
        return __privateMethod(_a2 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path);
      }
      static fromSeed(seed) {
        var _a2;
        return __privateMethod(_a2 = _HDNodeWallet, _fromSeed, fromSeed_fn).call(_a2, seed, null);
      }
    };
    HDNodeWallet = _HDNodeWallet;
    _account = new WeakSet();
    account_fn = function() {
      const account = { address: this.address, privateKey: this.privateKey };
      const m = this.mnemonic;
      if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
        account.mnemonic = {
          path: this.path,
          locale: "en",
          entropy: m.entropy
        };
      }
      return account;
    };
    _fromSeed = new WeakSet();
    fromSeed_fn = function(_seed, mnemonic) {
      assertArgument(isBytesLike2(_seed), "invalid seed", "seed", "[REDACTED]");
      const seed = getBytes(_seed, "seed");
      assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
      const I = getBytes(computeHmac2("sha512", MasterSecret2, seed));
      const signingKey = new SigningKey2(hexlify2(I.slice(0, 32)));
      return new _HDNodeWallet(_guard6, signingKey, "0x00000000", hexlify2(I.slice(32)), "m", 0, 0, mnemonic, null);
    };
    __privateAdd(HDNodeWallet, _fromSeed);
    HDNodeVoidWallet = class extends VoidSigner2 {
      constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
        super(address, provider);
        __publicField(this, "publicKey");
        __publicField(this, "fingerprint");
        __publicField(this, "parentFingerprint");
        __publicField(this, "chainCode");
        __publicField(this, "path");
        __publicField(this, "index");
        __publicField(this, "depth");
        assertPrivate(guard, _guard6, "HDNodeVoidWallet");
        defineProperties(this, { publicKey });
        const fingerprint = dataSlice(ripemd1603(sha2564(publicKey)), 0, 4);
        defineProperties(this, {
          publicKey,
          fingerprint,
          parentFingerprint,
          chainCode,
          path,
          index,
          depth
        });
      }
      connect(provider) {
        return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
      }
      get extendedKey() {
        assert2(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
        return encodeBase58Check(concat2([
          "0x0488B21E",
          zpad3(this.depth, 1),
          this.parentFingerprint,
          zpad3(this.index, 4),
          this.chainCode,
          this.publicKey
        ]));
      }
      hasPath() {
        return this.path != null;
      }
      deriveChild(_index) {
        const index = getNumber(_index, "index");
        assertArgument(index <= 4294967295, "invalid index", "index", index);
        let path = this.path;
        if (path) {
          path += "/" + (index & ~HardenedBit2);
          if (index & HardenedBit2) {
            path += "'";
          }
        }
        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
        const Ki = SigningKey2.addPoints(IL, this.publicKey, true);
        const address = computeAddress2(Ki);
        return new HDNodeVoidWallet(_guard6, address, Ki, this.fingerprint, hexlify2(IR), path, index, this.depth + 1, this.provider);
      }
      derivePath(path) {
        return derivePath(this, path);
      }
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/json-crowdsale.js
function isCrowdsaleJson(json) {
  try {
    const data2 = JSON.parse(json);
    if (data2.encseed) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data2 = JSON.parse(json);
  const password = getPassword2(_password);
  const address = getAddress2(spelunk2(data2, "ethaddr:string!"));
  const encseed = looseArrayify2(spelunk2(data2, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key2 = getBytes(pbkdf24(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key2, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address, privateKey: id2(seedHex) };
}
var init_json_crowdsale = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/json-crowdsale.js"() {
    init_lib33();
    init_address3();
    init_crypto2();
    init_hash();
    init_utils3();
    init_utils6();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/wallet.js
function stall6(duration) {
  return new Promise((resolve2) => {
    setTimeout(() => {
      resolve2();
    }, duration);
  });
}
var _fromAccount, fromAccount_fn, _Wallet, Wallet2;
var init_wallet = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/wallet.js"() {
    init_crypto2();
    init_utils3();
    init_base_wallet();
    init_hdwallet();
    init_json_crowdsale();
    init_json_keystore();
    init_mnemonic();
    _Wallet = class extends BaseWallet {
      constructor(key2, provider) {
        if (typeof key2 === "string" && !key2.startsWith("0x")) {
          key2 = "0x" + key2;
        }
        let signingKey = typeof key2 === "string" ? new SigningKey2(key2) : key2;
        super(signingKey, provider);
      }
      connect(provider) {
        return new _Wallet(this.signingKey, provider);
      }
      async encrypt(password, progressCallback) {
        const account = { address: this.address, privateKey: this.privateKey };
        return await encryptKeystoreJson(account, password, { progressCallback });
      }
      encryptSync(password) {
        const account = { address: this.address, privateKey: this.privateKey };
        return encryptKeystoreJsonSync(account, password);
      }
      static async fromEncryptedJson(json, password, progress) {
        var _a2;
        let account = null;
        if (isKeystoreJson(json)) {
          account = await decryptKeystoreJson(json, password, progress);
        } else if (isCrowdsaleJson(json)) {
          if (progress) {
            progress(0);
            await stall6(0);
          }
          account = decryptCrowdsaleJson(json, password);
          if (progress) {
            progress(1);
            await stall6(0);
          }
        }
        return __privateMethod(_a2 = _Wallet, _fromAccount, fromAccount_fn).call(_a2, account);
      }
      static fromEncryptedJsonSync(json, password) {
        var _a2;
        let account = null;
        if (isKeystoreJson(json)) {
          account = decryptKeystoreJsonSync(json, password);
        } else if (isCrowdsaleJson(json)) {
          account = decryptCrowdsaleJson(json, password);
        } else {
          assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
        }
        return __privateMethod(_a2 = _Wallet, _fromAccount, fromAccount_fn).call(_a2, account);
      }
      static createRandom(provider) {
        const wallet = HDNodeWallet.createRandom();
        if (provider) {
          return wallet.connect(provider);
        }
        return wallet;
      }
      static fromPhrase(phrase, provider) {
        const wallet = HDNodeWallet.fromPhrase(phrase);
        if (provider) {
          return wallet.connect(provider);
        }
        return wallet;
      }
    };
    Wallet2 = _Wallet;
    _fromAccount = new WeakSet();
    fromAccount_fn = function(account) {
      assertArgument(account, "invalid JSON wallet", "json", "[ REDACTED ]");
      if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
        const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
        const wallet2 = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
        if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
          return wallet2;
        }
        console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
      }
      const wallet = new _Wallet(account.privateKey);
      assertArgument(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
      return wallet;
    };
    __privateAdd(Wallet2, _fromAccount);
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/index.js
var init_wallet2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wallet/index.js"() {
    init_base_wallet();
    init_hdwallet();
    init_json_crowdsale();
    init_json_keystore();
    init_mnemonic();
    init_wallet();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/bit-reader.js
function decodeBits(width, data2) {
  const maxValue2 = (1 << width) - 1;
  const result = [];
  let accum = 0, bits = 0, flood = 0;
  for (let i = 0; i < data2.length; i++) {
    accum = accum << 6 | Base64.indexOf(data2[i]);
    bits += 6;
    while (bits >= width) {
      const value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      if (value === 0) {
        flood += maxValue2;
      } else {
        result.push(value + flood);
        flood = 0;
      }
    }
  }
  return result;
}
var Base64;
var init_bit_reader = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/bit-reader.js"() {
    Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/decode-owla.js
function decodeOwlA(data2, accents) {
  let words3 = decodeOwl(data2).join(",");
  accents.split(/,/g).forEach((accent) => {
    const match2 = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match2 !== null, "internal error parsing accents", "accents", accents);
    let posOffset = 0;
    const positions = decodeBits(parseInt(match2[3]), match2[4]);
    const charCode = parseInt(match2[2]);
    const regex = new RegExp(`([${match2[1]}])`, "g");
    words3 = words3.replace(regex, (all2, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words3.split(",");
}
var init_decode_owla = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/decode-owla.js"() {
    init_utils3();
    init_bit_reader();
    init_decode_owl();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
var _accent, WordlistOwlA;
var init_wordlist_owla = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlist-owla.js"() {
    init_wordlist_owl();
    init_decode_owla();
    WordlistOwlA = class extends WordlistOwl {
      constructor(locale, data2, accent, checksum2) {
        super(locale, data2, checksum2);
        __privateAdd(this, _accent, void 0);
        __privateSet(this, _accent, accent);
      }
      get _accent() {
        return __privateGet(this, _accent);
      }
      _decodeWords() {
        return decodeOwlA(this._data, this._accent);
      }
    };
    _accent = new WeakMap();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js
var wordlists2;
var init_wordlists_browser = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/wordlists-browser.js"() {
    init_lang_en2();
    wordlists2 = {
      en: LangEn2.wordlist()
    };
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/index.js
var init_wordlists2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/wordlists/index.js"() {
    init_wordlist2();
    init_lang_en2();
    init_wordlist_owl();
    init_wordlist_owla();
    init_wordlists_browser();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/ethers.js
var init_ethers2 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/ethers.js"() {
    init_version27();
    init_abi();
    init_address3();
    init_constants();
    init_contract2();
    init_crypto2();
    init_hash();
    init_providers();
    init_transaction2();
    init_utils3();
    init_wallet2();
    init_wordlists2();
  }
});

// node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/index.js
var init_lib34 = __esm({
  "node_modules/@shazow/whatsabi/node_modules/ethers/lib.esm/index.js"() {
    init_ethers2();
    init_ethers2();
  }
});

// node_modules/@shazow/whatsabi/lib.esm/utils.js
function hexToBytes2(hex) {
  if (hex.startsWith("0x")) {
    hex = hex.slice(2);
  }
  const length = hex.length;
  if (length % 2 !== 0) {
    throw new Error("hexToBytes: odd input length, must be even: " + hex);
  }
  const r2 = new Uint8Array(length / 2);
  for (let i = 0; i < length; i += 2) {
    const highNibble = parseInt(hex[i], 16);
    const lowNibble = parseInt(hex[i + 1], 16);
    r2[i / 2] = highNibble << 4 | lowNibble;
  }
  return r2;
}
function bytesToHex2(bytes3, padToBytes) {
  const hex = typeof bytes3 === "number" ? bytes3.toString(16) : Array.prototype.map.call(bytes3, function(n2) {
    return n2.toString(16).padStart(2, "0");
  }).join("");
  if (padToBytes) {
    return "0x" + hex.padStart(padToBytes * 2, "0");
  }
  return "0x" + hex;
}
function keccak2564(data2) {
  if (typeof data2 !== "string") {
    return bytesToHex2(keccak_256(data2));
  }
  if (data2.startsWith("0x")) {
    data2 = hexToBytes2(data2.slice(2));
  }
  return bytesToHex2(keccak_256(data2));
}
async function fetchJSON(url) {
  const response = await fetch(url, {
    headers: {
      "Content-Type": "application/json"
    }
  });
  if (!response.ok) {
    throw new FetchError(response.statusText, response.status);
  }
  return response.json();
}
function addressWithChecksum(address) {
  const chars = address.toLowerCase().substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = keccak_256(expanded);
  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var FetchError;
var init_utils7 = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/utils.js"() {
    init_sha3();
    FetchError = class extends Error {
      constructor(message, status) {
        super(message);
        this.status = status;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/lib.esm/opcodes.js
function pushWidth(op) {
  if (op < opcodes.PUSH1 || op > opcodes.PUSH32)
    return 0;
  return op - opcodes.PUSH1 + 1;
}
function isPush(op) {
  return !(op < opcodes.PUSH1 || op > opcodes.PUSH32);
}
function isLog(op) {
  return op >= opcodes.LOG1 && op <= opcodes.LOG4;
}
function isHalt(op) {
  return op === opcodes.STOP || op === opcodes.RETURN || op >= opcodes.REVERT;
}
function isCompare(op) {
  return !(op < 16 || op > 20);
}
var opcodes, mnemonics, noStackPush, hasStackArgs;
var init_opcodes = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/opcodes.js"() {
    opcodes = Object.freeze({
      STOP: 0,
      ADD: 1,
      MUL: 2,
      SUB: 3,
      DIV: 4,
      SDIV: 5,
      MOD: 6,
      SMOD: 7,
      ADDMOD: 8,
      MULMOD: 9,
      EXP: 10,
      SIGNEXTEND: 11,
      LT: 16,
      GT: 17,
      SLT: 18,
      SGT: 19,
      EQ: 20,
      ISZERO: 21,
      AND: 22,
      OR: 23,
      XOR: 24,
      NOT: 25,
      BYTE: 26,
      SHL: 27,
      SHR: 28,
      SAR: 29,
      SHA3: 32,
      ADDRESS: 48,
      BALANCE: 49,
      ORIGIN: 50,
      CALLER: 51,
      CALLVALUE: 52,
      CALLDATALOAD: 53,
      CALLDATASIZE: 54,
      CALLDATACOPY: 55,
      CODESIZE: 56,
      CODECOPY: 57,
      GASPRICE: 58,
      EXTCODESIZE: 59,
      EXTCODECOPY: 60,
      RETURNDATASIZE: 61,
      RETURNDATACOPY: 62,
      EXTCODEHASH: 63,
      BLOCKHASH: 64,
      COINBASE: 65,
      TIMESTAMP: 66,
      NUMBER: 67,
      DIFFICULTY: 68,
      GASLIMIT: 69,
      CHAINID: 70,
      SELFBALANCE: 71,
      POP: 80,
      MLOAD: 81,
      MSTORE: 82,
      MSTORE8: 83,
      SLOAD: 84,
      SSTORE: 85,
      JUMP: 86,
      JUMPI: 87,
      PC: 88,
      MSIZE: 89,
      GAS: 90,
      JUMPDEST: 91,
      PUSH0: 95,
      PUSH1: 96,
      PUSH2: 97,
      PUSH3: 98,
      PUSH4: 99,
      PUSH5: 100,
      PUSH6: 101,
      PUSH7: 102,
      PUSH8: 103,
      PUSH9: 104,
      PUSH10: 105,
      PUSH11: 106,
      PUSH12: 107,
      PUSH13: 108,
      PUSH14: 109,
      PUSH15: 110,
      PUSH16: 111,
      PUSH17: 112,
      PUSH18: 113,
      PUSH19: 114,
      PUSH20: 115,
      PUSH21: 116,
      PUSH22: 117,
      PUSH23: 118,
      PUSH24: 119,
      PUSH25: 120,
      PUSH26: 121,
      PUSH27: 122,
      PUSH28: 123,
      PUSH29: 124,
      PUSH30: 125,
      PUSH31: 126,
      PUSH32: 127,
      DUP1: 128,
      DUP2: 129,
      DUP3: 130,
      DUP4: 131,
      DUP5: 132,
      DUP6: 133,
      DUP7: 134,
      DUP8: 135,
      DUP9: 136,
      DUP10: 137,
      DUP11: 138,
      DUP12: 139,
      DUP13: 140,
      DUP14: 141,
      DUP15: 142,
      DUP16: 143,
      SWAP1: 144,
      SWAP2: 145,
      SWAP3: 146,
      SWAP4: 147,
      SWAP5: 148,
      SWAP6: 149,
      SWAP7: 150,
      SWAP8: 151,
      SWAP9: 152,
      SWAP10: 153,
      SWAP11: 154,
      SWAP12: 155,
      SWAP13: 156,
      SWAP14: 157,
      SWAP15: 158,
      SWAP16: 159,
      LOG0: 160,
      LOG1: 161,
      LOG2: 162,
      LOG3: 163,
      LOG4: 164,
      CREATE: 240,
      CALL: 241,
      CALLCODE: 242,
      RETURN: 243,
      DELEGATECALL: 244,
      CREATE2: 245,
      STATICCALL: 250,
      REVERT: 253,
      INVALID: 254,
      SUICIDE: 255
    });
    mnemonics = Object.freeze(Object.fromEntries(Object.entries(opcodes).map(([k, v]) => [v, k])));
    noStackPush = /* @__PURE__ */ new Set([
      opcodes.STOP,
      opcodes.CALLDATACOPY,
      opcodes.CODECOPY,
      opcodes.EXTCODECOPY,
      opcodes.RETURNDATACOPY,
      opcodes.POP,
      opcodes.MSTORE,
      opcodes.MSTORE8,
      opcodes.SSTORE,
      opcodes.JUMP,
      opcodes.JUMPI,
      opcodes.JUMPDEST,
      opcodes.RETURN,
      opcodes.REVERT,
      opcodes.INVALID,
      opcodes.SUICIDE
    ]);
    hasStackArgs = Object.freeze({
      [opcodes.ADD]: 2,
      [opcodes.MUL]: 2,
      [opcodes.SUB]: 2,
      [opcodes.DIV]: 2,
      [opcodes.SDIV]: 2,
      [opcodes.MOD]: 2,
      [opcodes.SMOD]: 2,
      [opcodes.ADDMOD]: 3,
      [opcodes.MULMOD]: 3,
      [opcodes.EXP]: 2,
      [opcodes.SIGNEXTEND]: 2,
      [opcodes.LT]: 2,
      [opcodes.GT]: 2,
      [opcodes.SLT]: 2,
      [opcodes.SGT]: 2,
      [opcodes.EQ]: 2,
      [opcodes.ISZERO]: 1,
      [opcodes.AND]: 2,
      [opcodes.OR]: 2,
      [opcodes.XOR]: 2,
      [opcodes.NOT]: 1,
      [opcodes.BYTE]: 2,
      [opcodes.SHL]: 2,
      [opcodes.SHR]: 2,
      [opcodes.SAR]: 2,
      [opcodes.SHA3]: 2,
      [opcodes.BALANCE]: 1,
      [opcodes.CALLDATALOAD]: 1,
      [opcodes.CALLDATACOPY]: 3,
      [opcodes.CODECOPY]: 3,
      [opcodes.EXTCODESIZE]: 1,
      [opcodes.EXTCODECOPY]: 4,
      [opcodes.RETURNDATACOPY]: 3,
      [opcodes.EXTCODEHASH]: 1,
      [opcodes.BLOCKHASH]: 1,
      [opcodes.POP]: 1,
      [opcodes.MLOAD]: 1,
      [opcodes.MSTORE]: 2,
      [opcodes.MSTORE8]: 2,
      [opcodes.SLOAD]: 1,
      [opcodes.SSTORE]: 2,
      [opcodes.JUMP]: 1,
      [opcodes.JUMPI]: 2,
      [opcodes.LOG0]: 2,
      [opcodes.LOG1]: 3,
      [opcodes.LOG2]: 4,
      [opcodes.LOG3]: 5,
      [opcodes.LOG4]: 6,
      [opcodes.CREATE]: 3,
      [opcodes.CALL]: 7,
      [opcodes.CALLCODE]: 7,
      [opcodes.RETURN]: 2,
      [opcodes.DELEGATECALL]: 6,
      [opcodes.CREATE2]: 4,
      [opcodes.STATICCALL]: 6,
      [opcodes.REVERT]: 2,
      [opcodes.SUICIDE]: 1
    });
  }
});

// node_modules/@shazow/whatsabi/lib.esm/proxies.js
var proxies_exports = {};
__export(proxies_exports, {
  BaseProxyResolver: () => BaseProxyResolver,
  DiamondProxyResolver: () => DiamondProxyResolver,
  EIP1967ProxyResolver: () => EIP1967ProxyResolver,
  FixedProxyResolver: () => FixedProxyResolver,
  GnosisSafeProxyResolver: () => GnosisSafeProxyResolver,
  LegacyUpgradeableProxyResolver: () => LegacyUpgradeableProxyResolver,
  PROXIABLEProxyResolver: () => PROXIABLEProxyResolver,
  SequenceWalletProxyResolver: () => SequenceWalletProxyResolver,
  ZeppelinOSProxyResolver: () => ZeppelinOSProxyResolver,
  slotResolvers: () => slotResolvers,
  slots: () => slots
});
function callToAddress(data2) {
  return "0x" + data2.slice(data2.length - 40);
}
var _zeroAddress, BaseProxyResolver, GnosisSafeProxyResolver, LegacyUpgradeableProxyResolver, EIP1967FallbackSelectors, EIP1967ProxyResolver, diamondSelectors, DiamondProxyResolver, ZeppelinOSProxyResolver, PROXIABLEProxyResolver, SequenceWalletProxyResolver, FixedProxyResolver, slots, slotResolvers;
var init_proxies = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/proxies.js"() {
    init_utils7();
    _zeroAddress = "0x0000000000000000000000000000000000000000";
    BaseProxyResolver = class {
      constructor(name) {
        this.name = name || this.constructor.name;
      }
      toString() {
        return this.name;
      }
    };
    GnosisSafeProxyResolver = class extends BaseProxyResolver {
      async resolve(provider, address) {
        const slotPosition = 0;
        return callToAddress(await provider.getStorageAt(address, slotPosition));
      }
    };
    LegacyUpgradeableProxyResolver = class extends BaseProxyResolver {
      async resolve(provider, address) {
        const slotPosition = 1;
        return callToAddress(await provider.getStorageAt(address, slotPosition));
      }
    };
    EIP1967FallbackSelectors = [
      "0x5c60da1b",
      "0xda525716",
      "0xa619486e",
      "0xbb82aa5e"
    ];
    EIP1967ProxyResolver = class extends BaseProxyResolver {
      async resolve(provider, address) {
        const implAddr = callToAddress(await provider.getStorageAt(address, slots.EIP1967_IMPL));
        if (implAddr !== _zeroAddress) {
          return implAddr;
        }
        const fallbackAddr = callToAddress(await provider.getStorageAt(address, slots.EIP1967_BEACON));
        if (fallbackAddr === _zeroAddress) {
          return _zeroAddress;
        }
        for (const selector of EIP1967FallbackSelectors) {
          try {
            const addr = callToAddress(await provider.call({
              to: fallbackAddr,
              data: selector
            }));
            if (addr !== _zeroAddress)
              return addr;
          } catch (e) {
            if (e.toString().includes("revert"))
              continue;
            throw e;
          }
        }
        return _zeroAddress;
      }
    };
    diamondSelectors = [
      "0xcdffacc6",
      "0x0d741577"
    ];
    DiamondProxyResolver = class extends BaseProxyResolver {
      async resolve(provider, address, selector) {
        if (!selector) {
          throw "DiamondProxy requires a selector to resolve to a specific facet";
        } else if (selector.startsWith("0x")) {
          selector = selector.slice(2);
        }
        const facetMappingSlot = keccak2564(
          "0x" + selector.padEnd(64, "0") + slots.DIAMOND_STORAGE.slice(2)
        );
        const facet = await provider.getStorageAt(address, facetMappingSlot);
        const storageAddr = "0x" + facet.slice(facet.length - 40);
        if (storageAddr !== _zeroAddress) {
          return storageAddr;
        }
        for (const facetSelector of diamondSelectors) {
          try {
            const addr = callToAddress(await provider.call({
              to: address,
              data: facetSelector + selector
            }));
            if (addr !== _zeroAddress)
              return addr;
          } catch (e) {
            if (e.toString().includes("revert"))
              continue;
            throw e;
          }
        }
        return _zeroAddress;
      }
    };
    ZeppelinOSProxyResolver = class extends BaseProxyResolver {
      async resolve(provider, address) {
        return callToAddress(await provider.getStorageAt(address, slots.ZEPPELINOS_IMPL));
      }
    };
    PROXIABLEProxyResolver = class extends BaseProxyResolver {
      async resolve(provider, address) {
        return callToAddress(await provider.getStorageAt(address, slots.PROXIABLE));
      }
    };
    SequenceWalletProxyResolver = class extends BaseProxyResolver {
      async resolve(provider, address) {
        return callToAddress(await provider.getStorageAt(address, address.toLowerCase().slice(2)));
      }
      toString() {
        return "SequenceWalletProxy";
      }
    };
    FixedProxyResolver = class extends BaseProxyResolver {
      constructor(name, resolvedAddress) {
        super(name);
        this.resolvedAddress = resolvedAddress;
      }
      async resolve(provider, address) {
        return this.resolvedAddress;
      }
    };
    slots = {
      EIP1967_IMPL: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
      EIP1967_BEACON: "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50",
      ZEPPELINOS_IMPL: "0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3",
      PROXIABLE: "0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7",
      GNOSIS_SAFE_SELECTOR: "0xa619486e00000000000000000000000000000000000000000000000000000000",
      DIAMOND_STORAGE: "0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b"
    };
    slotResolvers = {
      [slots.EIP1967_IMPL]: new EIP1967ProxyResolver("EIP1967Proxy"),
      [slots.EIP1967_BEACON]: new EIP1967ProxyResolver("EIP1967Proxy"),
      [slots.ZEPPELINOS_IMPL]: new ZeppelinOSProxyResolver("ZeppelinOSProxy"),
      [slots.PROXIABLE]: new PROXIABLEProxyResolver("PROXIABLE"),
      [slots.GNOSIS_SAFE_SELECTOR]: new GnosisSafeProxyResolver("GnosisSafeProxy"),
      [slots.DIAMOND_STORAGE]: new DiamondProxyResolver("DiamondProxy"),
      ["0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d"]: new DiamondProxyResolver("DiamondProxy")
    };
  }
});

// node_modules/@shazow/whatsabi/lib.esm/disasm.js
function valueToOffset(value) {
  return parseInt(bytesToHex2(value), 16);
}
function abiFromBytecode(bytecodeOrProgram) {
  const p = typeof bytecodeOrProgram === "string" ? disasm(bytecodeOrProgram) : bytecodeOrProgram;
  const abi = [];
  for (const [selector, offset] of Object.entries(p.selectors)) {
    if (!(offset in p.dests)) {
      continue;
    }
    const fn = p.dests[offset];
    const tags = subtreeTags(fn, p.dests);
    const funcABI = {
      type: "function",
      selector,
      payable: !p.notPayable[offset]
    };
    let mutability = "nonpayable";
    if (funcABI.payable) {
      mutability = "payable";
    } else if (!tags.has(opcodes.SSTORE)) {
      mutability = "view";
    }
    funcABI.stateMutability = mutability;
    if (tags.has(opcodes.RETURN) || mutability === "view") {
      funcABI.outputs = [{ type: "bytes" }];
    }
    if (tags.has(opcodes.CALLDATALOAD) || tags.has(opcodes.CALLDATASIZE) || tags.has(opcodes.CALLDATACOPY)) {
      funcABI.inputs = [{ type: "bytes" }];
    }
    abi.push(funcABI);
  }
  for (const h of p.eventCandidates) {
    abi.push({
      type: "event",
      hash: h
    });
  }
  return abi;
}
function disasm(bytecode) {
  let p = new Program();
  const selectorDests = /* @__PURE__ */ new Set();
  let lastPush32 = _EmptyArray;
  let checkJumpTable = true;
  let resumeJumpTable = /* @__PURE__ */ new Set();
  let runtimeOffset = 0;
  let currentFunction = new Function2();
  p.dests[0] = currentFunction;
  const code = new BytecodeIter(bytecode, { bufferSize: 5 });
  while (code.hasMore()) {
    const inst = code.next();
    const pos = code.pos();
    const step = code.step();
    if (inst === opcodes.PUSH32) {
      const v = code.value();
      const resolver = slotResolvers[bytesToHex2(v)];
      if (resolver !== void 0) {
        p.proxies.push(resolver);
      } else {
        lastPush32 = v;
      }
      continue;
    } else if (isLog(inst) && lastPush32.length > 0) {
      p.eventCandidates.push(bytesToHex2(lastPush32));
      continue;
    }
    if (inst === opcodes.DELEGATECALL && code.at(-2) === opcodes.GAS) {
      if (isPush(code.at(-3))) {
        const addr = bytesToHex2(code.valueAt(-3), 20);
        p.proxies.push(new FixedProxyResolver("HardcodedDelegateProxy", addr));
      } else if (code.at(-3) === opcodes.SLOAD && code.at(-4) === opcodes.ADDRESS) {
        p.proxies.push(new SequenceWalletProxyResolver());
      }
    }
    if (inst === opcodes.JUMPDEST) {
      if (isHalt(code.at(-2)) || code.at(-2) === opcodes.JUMP) {
        if (currentFunction)
          currentFunction.end = pos - 1 - runtimeOffset;
        currentFunction = new Function2(step, pos);
        if (checkJumpTable && Object.keys(p.selectors).length > 0) {
          checkJumpTable = false;
        }
        if (resumeJumpTable.delete(pos)) {
          checkJumpTable = code.at(pos + 1) === opcodes.DUP1 || code.at(pos + 1) === opcodes.CALLDATALOAD;
        }
      }
      p.dests[pos - runtimeOffset] = currentFunction;
      if (code.at(pos + 1) === opcodes.CALLVALUE && code.at(pos + 2) === opcodes.DUP1 && code.at(pos + 3) === opcodes.ISZERO) {
        p.notPayable[pos] = step;
      }
      continue;
    }
    if (currentFunction.opTags !== void 0) {
      if ((inst === opcodes.JUMP || inst === opcodes.JUMPI) && isPush(code.at(-2))) {
        const jumpOffset = valueToOffset(code.valueAt(-2));
        currentFunction.jumps.push(jumpOffset - runtimeOffset);
      }
      if (interestingOpCodes.has(inst)) {
        currentFunction.opTags.add(inst);
      }
    }
    if (code.at(-1) === opcodes.CODECOPY && code.at(-2) === opcodes.PUSH1 && code.at(-3) === opcodes.PUSH2) {
      const offsetDest2 = valueToOffset(code.valueAt(-3));
      resumeJumpTable.add(offsetDest2);
      runtimeOffset = offsetDest2;
      continue;
    }
    if (pos === runtimeOffset && currentFunction.opTags.has(opcodes.RETURN) && !currentFunction.opTags.has(opcodes.CALLDATALOAD)) {
      p = new Program(p);
      currentFunction = new Function2();
      p.dests[0] = currentFunction;
      checkJumpTable = true;
    }
    if (!checkJumpTable)
      continue;
    if (inst === opcodes.JUMP && isPush(code.at(-2))) {
      const offsetDest2 = valueToOffset(code.valueAt(-2));
      resumeJumpTable.add(offsetDest2);
    }
    if (!(code.at(-1) === opcodes.JUMPI && isPush(code.at(-2))))
      continue;
    const offsetDest = valueToOffset(code.valueAt(-2));
    currentFunction.jumps.push(offsetDest);
    if (code.at(-3) === opcodes.EQ && isPush(code.at(-4))) {
      let value = code.valueAt(-4);
      const selector = bytesToHex2(value, 4);
      p.selectors[selector] = offsetDest;
      selectorDests.add(offsetDest);
      continue;
    }
    if (code.at(-3) === opcodes.EQ && code.at(-4) === opcodes.DUP2 && isPush(code.at(-5))) {
      let value = code.valueAt(-5);
      const selector = bytesToHex2(value, 4);
      p.selectors[selector] = offsetDest;
      selectorDests.add(offsetDest);
      continue;
    }
    if (code.at(-3) === opcodes.ISZERO && code.at(-4) === opcodes.DUP1 && code.at(-5) !== opcodes.CALLVALUE) {
      const selector = "0x00000000";
      p.selectors[selector] = offsetDest;
      selectorDests.add(offsetDest);
      continue;
    }
    if (code.at(-3) !== opcodes.EQ && isCompare(code.at(-3)) && code.at(-5) === opcodes.DUP1) {
      resumeJumpTable.add(offsetDest);
      continue;
    }
  }
  return p;
}
function subtreeTags(entryFunc, dests) {
  let tags = /* @__PURE__ */ new Set([]);
  const stack = new Array(entryFunc);
  const seen = /* @__PURE__ */ new Set();
  while (stack.length > 0) {
    const fn = stack.pop();
    if (!fn)
      continue;
    if (seen.has(fn.start))
      continue;
    seen.add(fn.start);
    tags = /* @__PURE__ */ new Set([...tags, ...fn.opTags]);
    stack.push(...fn.jumps.map((offset) => dests[offset]));
  }
  return tags;
}
var BytecodeIter, interestingOpCodes, Function2, Program, _EmptyArray;
var init_disasm = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/disasm.js"() {
    init_utils7();
    init_opcodes();
    init_proxies();
    BytecodeIter = class {
      constructor(bytecode, config) {
        this.nextStep = 0;
        this.nextPos = 0;
        if (config === void 0)
          config = {};
        this.posBufferSize = Math.max(config.bufferSize || 1, 1);
        this.posBuffer = [];
        this.bytecode = hexToBytes2(bytecode);
      }
      hasMore() {
        return this.bytecode.length > this.nextPos;
      }
      next() {
        if (this.bytecode.length <= this.nextPos)
          return opcodes.STOP;
        const instruction = this.bytecode[this.nextPos];
        const width = pushWidth(instruction);
        if (this.posBuffer.length >= this.posBufferSize)
          this.posBuffer.shift();
        this.posBuffer.push(this.nextPos);
        this.nextStep += 1;
        this.nextPos += 1 + width;
        return instruction;
      }
      step() {
        return this.nextStep - 1;
      }
      pos() {
        if (this.posBuffer.length === 0)
          return -1;
        return this.posBuffer[this.posBuffer.length - 1];
      }
      asPos(posOrRelativeStep) {
        let pos = posOrRelativeStep;
        if (pos < 0) {
          pos = this.posBuffer[this.posBuffer.length + pos];
          if (pos === void 0) {
            return -1;
          }
        }
        return pos;
      }
      at(posOrRelativeStep) {
        const pos = this.asPos(posOrRelativeStep);
        return this.bytecode[pos];
      }
      value() {
        return this.valueAt(-1);
      }
      valueAt(posOrRelativeStep) {
        const pos = this.asPos(posOrRelativeStep);
        const instruction = this.bytecode[pos];
        const width = pushWidth(instruction);
        return this.bytecode.slice(pos + 1, pos + 1 + width);
      }
    };
    interestingOpCodes = /* @__PURE__ */ new Set([
      opcodes.STOP,
      opcodes.RETURN,
      opcodes.CALLDATALOAD,
      opcodes.CALLDATASIZE,
      opcodes.CALLDATACOPY,
      opcodes.DELEGATECALL,
      opcodes.SLOAD,
      opcodes.SSTORE,
      opcodes.REVERT
    ]);
    Function2 = class {
      constructor(byteOffset = 0, start = 0) {
        this.byteOffset = byteOffset;
        this.start = start;
        this.opTags = /* @__PURE__ */ new Set();
        this.jumps = [];
      }
    };
    Program = class {
      constructor(init3) {
        this.dests = {};
        this.selectors = {};
        this.notPayable = {};
        this.eventCandidates = [];
        this.proxySlots = [];
        this.proxies = [];
        this.init = init3;
      }
    };
    _EmptyArray = new Uint8Array();
  }
});

// node_modules/@shazow/whatsabi/lib.esm/selectors.js
function selectorsFromABI(abi) {
  const r2 = {};
  for (const el of abi) {
    if (typeof el !== "string" && el.type !== "function")
      continue;
    const f2 = FunctionFragment2.from(el).format();
    r2[keccak2564(f2).substring(0, 10)] = f2;
  }
  return r2;
}
function selectorsFromBytecode(code) {
  const abi = abiFromBytecode(code);
  if (abi.length === 0)
    return [];
  let selectors = [];
  for (const a of abi) {
    if (a.type !== "function")
      continue;
    selectors.push(a.selector);
  }
  return selectors;
}
var init_selectors = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/selectors.js"() {
    init_lib34();
    init_utils7();
    init_disasm();
  }
});

// node_modules/@shazow/whatsabi/lib.esm/types.js
function CompatibleProvider(provider) {
  if (typeof provider.getAddress === "function") {
    return new Web3Provider2(provider);
  }
  if (typeof provider.getStorage === "function") {
    return new Ethers6Provider(provider);
  }
  if (typeof provider.getCode === "function") {
    return new Ethers5Provider(provider);
  }
  if (typeof provider.getBytecode === "function") {
    return new ViemProvider(provider);
  }
  throw new Error("Unsupported provider, please open an issue: https://github.com/shazow/whatsabi/issues");
}
var Web3Provider2, Ethers5Provider, Ethers6Provider, ViemProvider;
var init_types3 = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/types.js"() {
    init_utils7();
    Web3Provider2 = class {
      constructor(provider) {
        this.provider = provider;
      }
      getStorageAt(address, slot) {
        return this.provider.getStorageAt(address, slot);
      }
      call(transaction) {
        return this.provider.call(transaction);
      }
      getCode(address) {
        return this.provider.getCode(address);
      }
      getAddress(name) {
        return this.provider.getAddress(name);
      }
    };
    Ethers5Provider = class extends Web3Provider2 {
      getAddress(name) {
        return this.provider.resolveName(name);
      }
    };
    Ethers6Provider = class extends Ethers5Provider {
      getStorageAt(address, slot) {
        return this.provider.getStorage(address, slot);
      }
    };
    ViemProvider = class extends Web3Provider2 {
      getStorageAt(address, slot) {
        if (typeof slot === "number") {
          slot = bytesToHex2(slot);
        }
        return this.provider.getStorageAt({ address, slot });
      }
      call(transaction) {
        return this.provider.transport.request({ method: "eth_call", params: [{
          from: "0x0000000000000000000000000000000000000001",
          to: transaction.to,
          data: transaction.data
        }, "latest"] });
      }
      getCode(address) {
        return this.provider.getBytecode({ address });
      }
      getAddress(name) {
        return this.provider.getEnsAddress({ name });
      }
    };
  }
});

// node_modules/@shazow/whatsabi/lib.esm/loaders.js
var loaders_exports = {};
__export(loaders_exports, {
  EtherscanABILoader: () => EtherscanABILoader,
  FourByteSignatureLookup: () => FourByteSignatureLookup,
  MultiABILoader: () => MultiABILoader,
  MultiSignatureLookup: () => MultiSignatureLookup,
  OpenChainSignatureLookup: () => OpenChainSignatureLookup,
  SamczunSignatureLookup: () => SamczunSignatureLookup,
  SourcifyABILoader: () => SourcifyABILoader,
  defaultABILoader: () => defaultABILoader,
  defaultSignatureLookup: () => defaultSignatureLookup
});
var MultiABILoader, EtherscanABILoader, SourcifyABILoader, MultiSignatureLookup, FourByteSignatureLookup, OpenChainSignatureLookup, SamczunSignatureLookup, defaultABILoader, defaultSignatureLookup;
var init_loaders = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/loaders.js"() {
    init_utils7();
    MultiABILoader = class {
      constructor(loaders) {
        this.loaders = loaders;
      }
      async loadABI(address) {
        for (const loader of this.loaders) {
          const r2 = await loader.loadABI(address);
          if (r2.length > 0)
            return Promise.resolve(r2);
        }
        return Promise.resolve([]);
      }
    };
    EtherscanABILoader = class {
      constructor(config) {
        if (config === void 0)
          config = {};
        this.apiKey = config.apiKey;
        this.baseURL = config.baseURL || "https://api.etherscan.io/api";
      }
      async loadABI(address) {
        let url = this.baseURL + "?module=contract&action=getabi&address=" + address;
        if (this.apiKey)
          url += "&apikey=" + this.apiKey;
        const r2 = await fetchJSON(url);
        if (r2.status === "0") {
          if (r2.result === "Contract source code not verified")
            return [];
          throw new Error("Etherscan error: " + r2.result);
        }
        return JSON.parse(r2.result);
      }
    };
    SourcifyABILoader = class {
      async loadABI(address) {
        address = addressWithChecksum(address);
        try {
          return (await fetchJSON("https://repo.sourcify.dev/contracts/full_match/1/" + address + "/metadata.json")).output.abi;
        } catch (error) {
          if (error.status !== 404)
            throw error;
        }
        try {
          return (await fetchJSON("https://repo.sourcify.dev/contracts/partial_match/1/" + address + "/metadata.json")).output.abi;
        } catch (error) {
          if (error.status !== 404)
            throw error;
        }
        return [];
      }
    };
    MultiSignatureLookup = class {
      constructor(lookups) {
        this.lookups = lookups;
      }
      async loadFunctions(selector) {
        for (const lookup of this.lookups) {
          const r2 = await lookup.loadFunctions(selector);
          if (r2.length > 0)
            return Promise.resolve(r2);
        }
        return Promise.resolve([]);
      }
      async loadEvents(hash4) {
        for (const lookup of this.lookups) {
          const r2 = await lookup.loadEvents(hash4);
          if (r2.length > 0)
            return Promise.resolve(r2);
        }
        return Promise.resolve([]);
      }
    };
    FourByteSignatureLookup = class {
      async load(url) {
        try {
          const r2 = await fetchJSON(url);
          if (r2.results === void 0)
            return [];
          return r2.results.map((r3) => {
            return r3.text_signature;
          });
        } catch (error) {
          if (error.status === 404)
            return [];
          throw error;
        }
      }
      async loadFunctions(selector) {
        return this.load("https://www.4byte.directory/api/v1/signatures/?hex_signature=" + selector);
      }
      async loadEvents(hash4) {
        return this.load("https://www.4byte.directory/api/v1/event-signatures/?hex_signature=" + hash4);
      }
    };
    OpenChainSignatureLookup = class {
      async load(url) {
        try {
          const r2 = await fetchJSON(url);
          if (!r2.ok)
            throw new Error("OpenChain API bad response: " + JSON.stringify(r2));
          return r2;
        } catch (error) {
          if (error.status === 404)
            return [];
          throw error;
        }
      }
      async loadFunctions(selector) {
        const r2 = await this.load("https://api.openchain.xyz/signature-database/v1/lookup?function=" + selector);
        return (r2.result.function[selector] || []).map((item) => item.name);
      }
      async loadEvents(hash4) {
        const r2 = await this.load("https://api.openchain.xyz/signature-database/v1/lookup?event=" + hash4);
        return (r2.result.event[hash4] || []).map((item) => item.name);
      }
    };
    SamczunSignatureLookup = class extends OpenChainSignatureLookup {
    };
    defaultABILoader = new MultiABILoader([new SourcifyABILoader(), new EtherscanABILoader()]);
    defaultSignatureLookup = new MultiSignatureLookup([new OpenChainSignatureLookup(), new FourByteSignatureLookup()]);
  }
});

// node_modules/@shazow/whatsabi/lib.esm/auto.js
function isAddress3(address) {
  return address.length === 42 && address.startsWith("0x");
}
async function autoload(address, config) {
  const onProgress = config.onProgress || defaultConfig2.onProgress;
  const onError = config.onError || defaultConfig2.onError;
  const provider = CompatibleProvider(config.provider);
  const result = {
    address,
    abi: [],
    proxies: []
  };
  if (config === void 0) {
    throw new Error("autoload: config is undefined, must include 'provider'");
  }
  let abiLoader = config.abiLoader;
  if (abiLoader === void 0)
    abiLoader = defaultABILoader;
  if (!isAddress3(address)) {
    onProgress("resolveName", { address });
    address = await provider.getAddress(address);
  }
  onProgress("getCode", { address });
  const program = disasm(await provider.getCode(address));
  result.proxies = program.proxies;
  if (result.proxies.length > 0) {
    result.followProxies = async function(selector) {
      for (const resolver of result.proxies) {
        onProgress("followProxies", { resolver, address });
        const resolved = await resolver.resolve(provider, address, selector);
        if (resolved !== void 0)
          return await autoload(resolved, config);
      }
      onError("followProxies", new Error("failed to resolve proxy"));
      return result;
    };
    if (config.followProxies) {
      return await result.followProxies();
    }
  }
  if (abiLoader) {
    onProgress("abiLoader", { address });
    try {
      result.abi = await abiLoader.loadABI(address);
      if (result.abi.length > 0)
        return result;
    } catch (error) {
      if (onError("abiLoad", error) === true)
        return result;
    }
  }
  onProgress("getCode", { address });
  result.abi = abiFromBytecode(program);
  if (!config.enableExperimentalMetadata) {
    result.abi = stripUnreliableABI(result.abi);
  }
  let signatureLookup = config.signatureLookup;
  if (signatureLookup === void 0)
    signatureLookup = defaultSignatureLookup;
  if (!signatureLookup)
    return result;
  onProgress("signatureLookup", { abiItems: result.abi.length });
  let promises = [];
  for (const a of result.abi) {
    if (a.type === "function") {
      promises.push(signatureLookup.loadFunctions(a.selector).then((r2) => {
        if (r2.length >= 1) {
          a.sig = r2[0];
          const extracted = JSON.parse(Fragment2.from("function " + a.sig).format("json"));
          if (extracted.outputs.length === 0) {
            delete extracted.outputs;
          }
          Object.assign(a, extracted);
        }
        if (r2.length > 1)
          a.sigAlts = r2.slice(1);
      }));
    } else if (a.type === "event") {
      promises.push(signatureLookup.loadEvents(a.hash).then((r2) => {
        if (r2.length >= 1) {
          a.sig = r2[0];
          Object.assign(a, JSON.parse(Fragment2.from("event " + a.sig).format("json")));
        }
        if (r2.length > 1)
          a.sigAlts = r2.slice(1);
      }));
    }
  }
  await Promise.all(promises);
  return result;
}
function stripUnreliableABI(abi) {
  const r2 = [];
  for (const a of abi) {
    if (a.type !== "function")
      continue;
    r2.push({
      type: "function",
      selector: a.selector
    });
  }
  return r2;
}
var defaultConfig2;
var init_auto = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/auto.js"() {
    init_lib34();
    init_types3();
    init_loaders();
    init_disasm();
    defaultConfig2 = {
      onProgress: (_) => {
      },
      onError: (phase, err) => {
        console.error(phase + ":", err);
        return false;
      }
    };
  }
});

// node_modules/@shazow/whatsabi/lib.esm/whatsabi.js
var whatsabi_exports = {};
__export(whatsabi_exports, {
  BytecodeIter: () => BytecodeIter,
  abiFromBytecode: () => abiFromBytecode,
  autoload: () => autoload,
  loaders: () => loaders_exports,
  proxies: () => proxies_exports,
  selectorsFromABI: () => selectorsFromABI,
  selectorsFromBytecode: () => selectorsFromBytecode
});
var init_whatsabi = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/whatsabi.js"() {
    init_selectors();
    init_disasm();
    init_auto();
    init_loaders();
    init_proxies();
  }
});

// node_modules/@shazow/whatsabi/lib.esm/index.js
var init_lib35 = __esm({
  "node_modules/@shazow/whatsabi/lib.esm/index.js"() {
    init_whatsabi();
    init_whatsabi();
  }
});

// node_modules/@daohaus/tx-builder/index.js
var tx_builder_exports = {};
__export(tx_builder_exports, {
  TXBuilder: () => TXBuilder,
  TxBuilderContext: () => TxBuilderContext,
  buildMultiCallTX: () => buildMultiCallTX,
  cacheABI: () => cacheABI,
  checkArgType: () => checkArgType,
  checkHasCondition: () => checkHasCondition,
  createEthersContract: () => createEthersContract,
  deepDecodeProposalActions: () => deepDecodeProposalActions,
  deepSearch: () => deepSearch,
  encodeExecFromModule: () => encodeExecFromModule,
  encodeMultiAction: () => encodeMultiAction,
  estimateFunctionalGas: () => estimateFunctionalGas,
  executeTx: () => executeTx,
  fetchABI: () => fetchABI,
  gasEstimateFromActions: () => gasEstimateFromActions,
  getABIstore: () => getABIstore,
  getCachedABI: () => getCachedABI,
  getCode: () => getCode,
  getImplementation: () => getImplementation,
  handleArgEncode: () => handleArgEncode,
  handleConditionalPath: () => handleConditionalPath,
  handleDetailsJSON: () => handleDetailsJSON,
  handleEncodeCallArg: () => handleEncodeCallArg,
  handleEncodeMulticallArg: () => handleEncodeMulticallArg,
  handleGasEstimate: () => handleGasEstimate,
  handleMulticallArg: () => handleMulticallArg,
  isActionError: () => isActionError,
  isProxyABI: () => isProxyABI,
  prepareTX: () => prepareTX,
  processABI: () => processABI,
  searchApp: () => searchApp,
  searchArg: () => searchArg,
  txActionToMetaTx: () => txActionToMetaTx,
  useTxBuilder: () => useTxBuilder
});
function __awaiter17(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function prepareTX(args) {
  var _a2, _b, _c;
  return __awaiter17(this, void 0, void 0, function* () {
    const {
      argCallbackRecord,
      tx,
      chainId,
      safeId,
      localABIs,
      lifeCycleFns,
      appState,
      rpcs,
      explorerKeys,
      pinataApiKeys,
      graphApiKeys,
      publicClient
    } = args;
    console.log("**APPLICATION STATE**", appState);
    try {
      const processedContract = yield processContractLego({
        localABIs,
        contract: tx.contract,
        chainId,
        appState,
        rpcs,
        explorerKeys
      });
      console.log("**PROCESSED CONTRACT**", processedContract);
      const {
        abi,
        address
      } = processedContract;
      const {
        method
      } = tx;
      const processedArgs = yield processArgs({
        tx: Object.assign(Object.assign({}, tx), {
          contract: processedContract
        }),
        localABIs,
        chainId,
        safeId,
        appState,
        argCallbackRecord,
        rpcs,
        pinataApiKeys,
        explorerKeys
      });
      console.log("**PROCESSED ARGS**", processedArgs);
      const overrides = yield processOverrides({
        tx,
        localABIs,
        chainId,
        safeId,
        appState,
        rpcs,
        pinataApiKeys,
        explorerKeys
      });
      console.log("**PROCESSED overrides**", overrides);
      if (!publicClient) {
        return;
      }
      const {
        address: account,
        connector
      } = getAccount();
      const walletClient = yield connector === null || connector === void 0 ? void 0 : connector.getWalletClient({
        chainId: (_a2 = import_keychain_utils.VIEM_CHAINS[chainId]) === null || _a2 === void 0 ? void 0 : _a2.id
      });
      if (!walletClient) {
        throw new Error("Wallet Client not found!");
      }
      const {
        request
      } = yield publicClient.simulateContract({
        account,
        address,
        abi,
        args: processedArgs,
        functionName: method,
        value: overrides.value,
        gas: overrides.gasLimit,
        maxFeePerGas: overrides.gasPrice,
        blockTag: overrides.blockTag
      });
      (_b = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onRequestSign) === null || _b === void 0 ? void 0 : _b.call(lifeCycleFns);
      const txHash = yield walletClient.writeContract(request);
      console.log("txHash", txHash);
      executeTx(Object.assign(Object.assign({}, args), {
        publicClient,
        txHash,
        graphApiKeys
      }));
    } catch (error) {
      console.error(error);
      (_c = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onTxError) === null || _c === void 0 ? void 0 : _c.call(lifeCycleFns, error);
    }
  });
}
var import_jsx_runtime, import_react, import_keychain_utils, import_moloch_v3_data, import_utils92, import_data_fetch_utils, import_abis, import_safe_contracts, commonjsGlobal, fails$n, fails$m, functionBindNative, NATIVE_BIND$3, FunctionPrototype$2, call$k, uncurryThisWithBind, functionUncurryThis, uncurryThis$n, toString$a, stringSlice$7, classofRaw$2, uncurryThis$m, fails$l, classof$7, $Object$4, split3, indexedObject, isNullOrUndefined$7, isNullOrUndefined$6, $TypeError$f, requireObjectCoercible$9, IndexedObject$2, requireObjectCoercible$8, toIndexedObject$5, check, global$k, shared$4, global$j, defineProperty$6, defineGlobalProperty$3, global$i, defineGlobalProperty$2, SHARED, store$3, sharedStore, store$2, requireObjectCoercible$7, $Object$3, toObject$5, uncurryThis$l, toObject$4, hasOwnProperty, hasOwnProperty_1, uncurryThis$k, id3, postfix, toString$9, uid$2, engineUserAgent, global$h, userAgent$3, process$4, Deno$1, versions, v8, match, version28, engineV8Version, V8_VERSION$1, fails$k, global$g, $String$5, symbolConstructorDetection, NATIVE_SYMBOL$1, useSymbolAsUid, global$f, shared$3, hasOwn$a, uid$1, NATIVE_SYMBOL, USE_SYMBOL_AS_UID$1, Symbol$1, WellKnownSymbolsStore, createWellKnownSymbol, wellKnownSymbol$i, documentAll$2, IS_HTMLDDA, documentAll_1, $documentAll$1, documentAll$1, isCallable$m, isCallable$l, $documentAll, documentAll, isObject$9, isObject$8, $String$4, $TypeError$e, anObject$g, objectDefineProperties, fails$j, descriptors, DESCRIPTORS$a, fails$i, v8PrototypeDefineBug, objectDefineProperty, global$e, isObject$7, document$3, EXISTS$1, documentCreateElement$2, DESCRIPTORS$9, fails$h, createElement$1, ie8DomDefine, NATIVE_BIND$2, call$j, functionCall, global$d, isCallable$k, aFunction, getBuiltIn$7, uncurryThis$j, objectIsPrototypeOf, getBuiltIn$6, isCallable$j, isPrototypeOf$3, USE_SYMBOL_AS_UID, $Object$2, isSymbol$2, $String$3, tryToString$4, isCallable$i, tryToString$3, $TypeError$d, aCallable$9, aCallable$8, isNullOrUndefined$5, getMethod$6, call$i, isCallable$h, isObject$6, $TypeError$c, ordinaryToPrimitive$1, call$h, isObject$5, isSymbol$1, getMethod$5, ordinaryToPrimitive, wellKnownSymbol$h, $TypeError$b, TO_PRIMITIVE, toPrimitive$1, toPrimitive, isSymbol, toPropertyKey$3, DESCRIPTORS$8, IE8_DOM_DEFINE$1, V8_PROTOTYPE_DEFINE_BUG$1, anObject$f, toPropertyKey$2, $TypeError$a, $defineProperty, $getOwnPropertyDescriptor$1, ENUMERABLE, CONFIGURABLE$1, WRITABLE, ceil, floor$1, mathTrunc, trunc2, toIntegerOrInfinity$4, toIntegerOrInfinity$3, max$2, min$4, toAbsoluteIndex$2, toIntegerOrInfinity$2, min$3, toLength$4, toLength$3, lengthOfArrayLike$4, toIndexedObject$4, toAbsoluteIndex$1, lengthOfArrayLike$3, createMethod$3, arrayIncludes, hiddenKeys$4, uncurryThis$i, hasOwn$9, toIndexedObject$3, indexOf$1, hiddenKeys$3, push$2, objectKeysInternal, enumBugKeys$3, internalObjectKeys$1, enumBugKeys$2, objectKeys$2, DESCRIPTORS$7, V8_PROTOTYPE_DEFINE_BUG, definePropertyModule$4, anObject$e, toIndexedObject$2, objectKeys$1, getBuiltIn$5, html$2, shared$2, uid, keys2, sharedKey$3, anObject$d, definePropertiesModule, enumBugKeys$1, hiddenKeys$2, html$1, documentCreateElement$1, sharedKey$2, GT, LT, PROTOTYPE, SCRIPT, IE_PROTO$1, EmptyConstructor, scriptTag, NullProtoObjectViaActiveX, NullProtoObjectViaIFrame, activeXDocument, NullProtoObject, objectCreate, wellKnownSymbol$g, create$2, defineProperty$5, UNSCOPABLES, ArrayPrototype$1, addToUnscopables$2, iterators, global$c, isCallable$g, WeakMap$1, weakMapBasicDetection, createPropertyDescriptor$4, DESCRIPTORS$6, definePropertyModule$3, createPropertyDescriptor$3, createNonEnumerableProperty$5, NATIVE_WEAK_MAP, global$b, isObject$4, createNonEnumerableProperty$4, hasOwn$8, shared$1, sharedKey$1, hiddenKeys$1, OBJECT_ALREADY_INITIALIZED, TypeError$2, WeakMap2, set$1, get, has, enforce, getterFor, store$1, STATE, internalState, objectGetOwnPropertyDescriptor, objectPropertyIsEnumerable, $propertyIsEnumerable, getOwnPropertyDescriptor$3, NASHORN_BUG, DESCRIPTORS$5, call$g, propertyIsEnumerableModule$1, createPropertyDescriptor$2, toIndexedObject$1, toPropertyKey$1, hasOwn$7, IE8_DOM_DEFINE, $getOwnPropertyDescriptor, makeBuiltIn$3, DESCRIPTORS$4, hasOwn$6, FunctionPrototype$1, getDescriptor, EXISTS, PROPER, CONFIGURABLE, functionName, uncurryThis$h, isCallable$f, store, functionToString, inspectSource$3, uncurryThis$g, fails$g, isCallable$e, hasOwn$5, DESCRIPTORS$3, CONFIGURABLE_FUNCTION_NAME$1, inspectSource$2, InternalStateModule$2, enforceInternalState, getInternalState$2, $String$2, defineProperty$4, stringSlice$6, replace$3, join, CONFIGURABLE_LENGTH, TEMPLATE, makeBuiltIn$2, isCallable$d, definePropertyModule$2, makeBuiltIn$1, defineGlobalProperty$1, defineBuiltIn$7, objectGetOwnPropertyNames, internalObjectKeys, enumBugKeys, hiddenKeys, objectGetOwnPropertySymbols, getBuiltIn$4, uncurryThis$f, getOwnPropertyNamesModule, getOwnPropertySymbolsModule$1, anObject$c, concat$2, ownKeys$1, hasOwn$4, ownKeys2, getOwnPropertyDescriptorModule, definePropertyModule$1, copyConstructorProperties$1, fails$f, isCallable$c, replacement, isForced$2, normalize2, data, NATIVE, POLYFILL, isForced_1, global$a, getOwnPropertyDescriptor$2, createNonEnumerableProperty$3, defineBuiltIn$6, defineGlobalProperty, copyConstructorProperties, isForced$1, _export, fails$e, correctPrototypeGetter, hasOwn$3, isCallable$b, toObject$3, sharedKey, CORRECT_PROTOTYPE_GETTER, IE_PROTO, $Object$1, ObjectPrototype, objectGetPrototypeOf, fails$d, isCallable$a, isObject$3, getPrototypeOf$1, defineBuiltIn$5, wellKnownSymbol$f, ITERATOR$5, BUGGY_SAFARI_ITERATORS$1, IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator, NEW_ITERATOR_PROTOTYPE, iteratorsCore, defineProperty$3, hasOwn$2, wellKnownSymbol$e, TO_STRING_TAG$3, setToStringTag$3, IteratorPrototype$1, create$1, createPropertyDescriptor$1, setToStringTag$2, Iterators$4, returnThis$1, iteratorCreateConstructor, uncurryThis$e, aCallable$7, functionUncurryThisAccessor, isCallable$9, $String$1, $TypeError$9, aPossiblePrototype$1, uncurryThisAccessor, anObject$b, aPossiblePrototype, objectSetPrototypeOf, $$d, call$f, FunctionName, isCallable$8, createIteratorConstructor, getPrototypeOf, setPrototypeOf$1, setToStringTag$1, createNonEnumerableProperty$2, defineBuiltIn$4, wellKnownSymbol$d, Iterators$3, IteratorsCore, PROPER_FUNCTION_NAME$2, CONFIGURABLE_FUNCTION_NAME, IteratorPrototype, BUGGY_SAFARI_ITERATORS, ITERATOR$4, KEYS, VALUES, ENTRIES, returnThis, iteratorDefine, createIterResultObject$1, toIndexedObject, addToUnscopables$1, Iterators$2, InternalStateModule$1, defineProperty$2, defineIterator, createIterResultObject, DESCRIPTORS$2, ARRAY_ITERATOR, setInternalState$1, getInternalState$1, es_array_iterator, values, domIterables, documentCreateElement, classList, DOMTokenListPrototype$1, domTokenListPrototype, global$9, DOMIterables, DOMTokenListPrototype, ArrayIteratorMethods, createNonEnumerableProperty$1, wellKnownSymbol$c, ITERATOR$3, TO_STRING_TAG$2, ArrayValues, handlePrototype, COLLECTION_NAME, DESCRIPTORS$1, uncurryThis$d, call$e, fails$c, objectKeys, getOwnPropertySymbolsModule, propertyIsEnumerableModule, toObject$2, IndexedObject$1, $assign, defineProperty$1, concat$1, objectAssign, $$c, assign2, classof$6, engineIsNode, makeBuiltIn, defineProperty3, defineBuiltInAccessor$1, getBuiltIn$3, defineBuiltInAccessor, wellKnownSymbol$b, DESCRIPTORS, SPECIES$3, setSpecies$1, isPrototypeOf$2, $TypeError$8, anInstance$1, wellKnownSymbol$a, TO_STRING_TAG$1, test, toStringTagSupport, TO_STRING_TAG_SUPPORT, isCallable$7, classofRaw$1, wellKnownSymbol$9, TO_STRING_TAG, $Object, CORRECT_ARGUMENTS, tryGet, classof$5, uncurryThis$c, fails$b, isCallable$6, classof$4, getBuiltIn$2, inspectSource$1, noop, empty2, construct, constructorRegExp, exec$2, INCORRECT_TO_STRING, isConstructorModern, isConstructorLegacy, isConstructor$1, isConstructor3, tryToString$2, $TypeError$7, aConstructor$1, anObject$a, aConstructor, isNullOrUndefined$4, wellKnownSymbol$8, SPECIES$2, speciesConstructor$2, NATIVE_BIND$1, FunctionPrototype, apply$3, call$d, functionApply, classofRaw, uncurryThis$b, functionUncurryThisClause, uncurryThis$a, aCallable$6, NATIVE_BIND, bind$4, functionBindContext, uncurryThis$9, arraySlice$2, $TypeError$6, validateArgumentsLength$1, userAgent$2, engineIsIos, global$8, apply$2, bind$3, isCallable$5, hasOwn$1, fails$a, html, arraySlice$1, createElement, validateArgumentsLength, IS_IOS$1, IS_NODE$4, set, clear, process$3, Dispatch, Function$1, MessageChannel, String$1, counter, queue$2, ONREADYSTATECHANGE, $location, defer, channel, port, run, runner, eventListener, globalPostMessageDefer, task$1, Queue$2, queue$1, userAgent$1, engineIsIosPebble, userAgent, engineIsWebosWebkit, global$7, bind$2, getOwnPropertyDescriptor$1, macrotask, Queue$1, IS_IOS, IS_IOS_PEBBLE, IS_WEBOS_WEBKIT, IS_NODE$3, MutationObserver, document$2, process$2, Promise$1, queueMicrotaskDescriptor, microtask$1, notify$1, toggle, node, promise, then, queue, flush, microtask_1, hostReportErrors$1, perform$3, global$6, promiseNativeConstructor, engineIsDeno, IS_DENO$1, IS_NODE$2, engineIsBrowser, global$5, NativePromiseConstructor$3, isCallable$4, isForced, inspectSource, wellKnownSymbol$7, IS_BROWSER, IS_DENO, V8_VERSION, SPECIES$1, SUBCLASSING, NATIVE_PROMISE_REJECTION_EVENT$1, FORCED_PROMISE_CONSTRUCTOR$5, promiseConstructorDetection, newPromiseCapability$2, aCallable$5, $TypeError$5, PromiseCapability, $$b, IS_NODE$1, global$4, call$c, defineBuiltIn$3, setPrototypeOf, setToStringTag, setSpecies, aCallable$4, isCallable$3, isObject$2, anInstance, speciesConstructor$1, task, microtask, hostReportErrors, perform$2, Queue, InternalStateModule, NativePromiseConstructor$2, PromiseConstructorDetection, newPromiseCapabilityModule$3, PROMISE, FORCED_PROMISE_CONSTRUCTOR$4, NATIVE_PROMISE_REJECTION_EVENT, NATIVE_PROMISE_SUBCLASSING, getInternalPromiseState, setInternalState, NativePromisePrototype$1, PromiseConstructor, PromisePrototype, TypeError$1, document$1, process$1, newPromiseCapability$1, newGenericPromiseCapability, DISPATCH_EVENT, UNHANDLED_REJECTION, REJECTION_HANDLED, PENDING, FULFILLED, REJECTED, HANDLED, UNHANDLED, Internal, OwnPromiseCapability, PromiseWrapper, nativeThen, isThenable, callReaction, notify, dispatchEvent, onUnhandled, isUnhandled, onHandleUnhandled, bind$1, internalReject, internalResolve, wellKnownSymbol$6, Iterators$1, ITERATOR$2, ArrayPrototype, isArrayIteratorMethod$1, classof$3, getMethod$4, isNullOrUndefined$3, Iterators, wellKnownSymbol$5, ITERATOR$1, getIteratorMethod$2, call$b, aCallable$3, anObject$9, tryToString$1, getIteratorMethod$1, $TypeError$4, getIterator$1, call$a, anObject$8, getMethod$3, iteratorClose$1, bind, call$9, anObject$7, tryToString, isArrayIteratorMethod, lengthOfArrayLike$2, isPrototypeOf$1, getIterator, getIteratorMethod, iteratorClose, $TypeError$3, Result2, ResultPrototype, iterate$2, wellKnownSymbol$4, ITERATOR, SAFE_CLOSING, called, iteratorWithReturn, checkCorrectnessOfIteration$1, NativePromiseConstructor$1, checkCorrectnessOfIteration, FORCED_PROMISE_CONSTRUCTOR$3, promiseStaticsIncorrectIteration, $$a, call$8, aCallable$2, newPromiseCapabilityModule$2, perform$1, iterate$1, PROMISE_STATICS_INCORRECT_ITERATION$1, $$9, FORCED_PROMISE_CONSTRUCTOR$2, NativePromiseConstructor, getBuiltIn$1, isCallable$2, defineBuiltIn$2, NativePromisePrototype, method, $$8, call$7, aCallable$1, newPromiseCapabilityModule$1, perform, iterate, PROMISE_STATICS_INCORRECT_ITERATION, $$7, call$6, newPromiseCapabilityModule, FORCED_PROMISE_CONSTRUCTOR$1, anObject$6, isObject$1, newPromiseCapability, promiseResolve$1, $$6, getBuiltIn, FORCED_PROMISE_CONSTRUCTOR, promiseResolve, classof$2, $String, toString$8, anObject$5, regexpFlags$1, fails$9, global$3, $RegExp$2, UNSUPPORTED_Y$2, MISSED_STICKY, BROKEN_CARET, regexpStickyHelpers, fails$8, global$2, $RegExp$1, regexpUnsupportedDotAll, fails$7, global$1, $RegExp, regexpUnsupportedNcg, call$5, uncurryThis$8, toString$7, regexpFlags, stickyHelpers$1, shared, create2, getInternalState, UNSUPPORTED_DOT_ALL, UNSUPPORTED_NCG, nativeReplace, nativeExec, patchedExec, charAt$3, indexOf, replace$2, stringSlice$5, UPDATES_LAST_INDEX_WRONG, UNSUPPORTED_Y$1, NPCG_INCLUDED, PATCH, regexpExec$3, $$5, exec$1, pollLastTX, testLastTX, standardGraphPoll, uncurryThis$7, defineBuiltIn$1, regexpExec$2, fails$6, wellKnownSymbol$3, createNonEnumerableProperty, SPECIES, RegExpPrototype$2, fixRegexpWellKnownSymbolLogic, isObject, classof$1, wellKnownSymbol$2, MATCH$1, isRegexp, uncurryThis$6, toIntegerOrInfinity$1, toString$6, requireObjectCoercible$6, charAt$2, charCodeAt, stringSlice$4, createMethod$2, stringMultibyte, charAt$1, advanceStringIndex$2, toPropertyKey, definePropertyModule, createPropertyDescriptor, createProperty$1, toAbsoluteIndex, lengthOfArrayLike$1, createProperty, $Array, max$1, arraySliceSimple, call$4, anObject$4, isCallable$1, classof, regexpExec$1, $TypeError$2, regexpExecAbstract, apply$1, call$3, uncurryThis$5, fixRegExpWellKnownSymbolLogic$2, anObject$3, isNullOrUndefined$2, isRegExp$1, requireObjectCoercible$5, speciesConstructor, advanceStringIndex$1, toLength$2, toString$5, getMethod$2, arraySlice, callRegExpExec, regexpExec, stickyHelpers, fails$5, UNSUPPORTED_Y, MAX_UINT32, min$2, $push, exec, push$1, stringSlice$3, SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, sameValue$1, call$2, fixRegExpWellKnownSymbolLogic$1, anObject$2, isNullOrUndefined$1, requireObjectCoercible$4, sameValue, toString$4, getMethod$1, regExpExec$1, handleIPFSPinata, call$1, hasOwn2, isPrototypeOf, regExpFlags, RegExpPrototype$1, regexpGetFlags, PROPER_FUNCTION_NAME$1, defineBuiltIn, anObject$1, $toString, fails$4, getRegExpFlags, TO_STRING, RegExpPrototype, nativeToString, NOT_GENERIC, INCORRECT_NAME, aCallable, toObject$1, IndexedObject, lengthOfArrayLike, $TypeError$1, createMethod$1, arrayReduce, fails$3, arrayMethodIsStrict$1, $$4, $reduce, arrayMethodIsStrict, CHROME_VERSION, IS_NODE, CHROME_BUG, FORCED, EXPIRY, FORM, CURRENT_DAO, gasBufferMultiplier, BaalContractBase, basicDetails, $$3, $includes, fails$2, addToUnscopables, BROKEN_ON_SPARSE, uncurryThis$4, toObject, floor, charAt, replace$1, stringSlice$2, SUBSTITUTION_SYMBOLS, SUBSTITUTION_SYMBOLS_NO_NAMED, getSubstitution$1, apply, call, uncurryThis$3, fixRegExpWellKnownSymbolLogic, fails$1, anObject, isCallable, isNullOrUndefined, toIntegerOrInfinity, toLength$1, toString$3, requireObjectCoercible$3, advanceStringIndex, getMethod, getSubstitution, regExpExec, wellKnownSymbol$1, REPLACE, max, min$1, concat3, push, stringIndexOf$1, stringSlice$1, maybeToString, REPLACE_KEEPS_$0, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, REPLACE_SUPPORTS_NAMED_GROUPS, localforage, defaultABIStore, getABIstore, getCachedABI, addABI, cacheABI, initABIs, isGnosisProxy, isSuperfluidProxy, isProxyABI, getABIUrl, getGnosisMasterCopy, getProxyStorageSlot, getImplementation, processABI, fetchABI, getCode, whitespaces$2, uncurryThis$2, requireObjectCoercible$2, toString$2, whitespaces$1, replace, ltrim, rtrim, createMethod, stringTrim, PROPER_FUNCTION_NAME, fails, whitespaces, non, stringTrimForced, $$2, $trim, forcedStringTrimMethod, isRegExp, $TypeError, notARegexp, wellKnownSymbol, MATCH, correctIsRegexpLogic, $$1, uncurryThis$1, notARegExp$1, requireObjectCoercible$1, toString$1, correctIsRegExpLogic$1, stringIndexOf, checkArgType, deepSearch, searchApp, checkHasCondition, handleConditionalPath, searchArg, handleDetailsJSON, findTargetAddress, handleTargetAddress, processStaticContract, processLocalContract, processRemoteContract, processContractLego, estimateFunctionalGas, txActionToMetaTx, handleEncodeCallArg, handleMulticallFormActions, handleMulticallArg, gasEstimateFromActions, handleEncodeMulticallArg, handleGasEstimate, encodeMultiAction, encodeExecFromModule, buildMultiCallTX, handleArgEncode, isSearchArg, handleKeychainArg, handleArgCallback, processArg, processArgs, handleProposalOfferingValue, processOverrides, sleep, executeTx, bundleLifeCycleFns, TxBuilderContext, TXBuilder, useTxBuilder, isActionError, $, uncurryThis, getOwnPropertyDescriptor2, toLength, toString3, notARegExp, requireObjectCoercible, correctIsRegExpLogic, nativeStartsWith, stringSlice, min, CORRECT_IS_REGEXP_LOGIC, MDN_POLYFILL_BUG, MultiABILoader2, SourcifyABILoader2, EtherscanABILoader2, deepDecodeProposalActions, createActionError, decodeMultiCall, decodeValue, decodeMethod, actionDecoders, decodeAction, createEthersContract;
var init_tx_builder = __esm({
  "node_modules/@daohaus/tx-builder/index.js"() {
    import_jsx_runtime = __toESM(require_jsx_runtime());
    import_react = __toESM(require_react());
    import_keychain_utils = __toESM(require_src2());
    init_dist();
    init_esm();
    import_moloch_v3_data = __toESM(require_src5());
    import_utils92 = __toESM(require_src3());
    import_data_fetch_utils = __toESM(require_src4());
    import_abis = __toESM(require_src());
    import_safe_contracts = __toESM(require_dist());
    init_esm2();
    init_lib35();
    init_lib32();
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
    fails$n = function(exec2) {
      try {
        return !!exec2();
      } catch (error) {
        return true;
      }
    };
    fails$m = fails$n;
    functionBindNative = !fails$m(function() {
      var test2 = function() {
      }.bind();
      return typeof test2 != "function" || test2.hasOwnProperty("prototype");
    });
    NATIVE_BIND$3 = functionBindNative;
    FunctionPrototype$2 = Function.prototype;
    call$k = FunctionPrototype$2.call;
    uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$2.bind.bind(call$k, call$k);
    functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function(fn) {
      return function() {
        return call$k.apply(fn, arguments);
      };
    };
    uncurryThis$n = functionUncurryThis;
    toString$a = uncurryThis$n({}.toString);
    stringSlice$7 = uncurryThis$n("".slice);
    classofRaw$2 = function(it) {
      return stringSlice$7(toString$a(it), 8, -1);
    };
    uncurryThis$m = functionUncurryThis;
    fails$l = fails$n;
    classof$7 = classofRaw$2;
    $Object$4 = Object;
    split3 = uncurryThis$m("".split);
    indexedObject = fails$l(function() {
      return !$Object$4("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof$7(it) == "String" ? split3(it, "") : $Object$4(it);
    } : $Object$4;
    isNullOrUndefined$7 = function(it) {
      return it === null || it === void 0;
    };
    isNullOrUndefined$6 = isNullOrUndefined$7;
    $TypeError$f = TypeError;
    requireObjectCoercible$9 = function(it) {
      if (isNullOrUndefined$6(it))
        throw $TypeError$f("Can't call method on " + it);
      return it;
    };
    IndexedObject$2 = indexedObject;
    requireObjectCoercible$8 = requireObjectCoercible$9;
    toIndexedObject$5 = function(it) {
      return IndexedObject$2(requireObjectCoercible$8(it));
    };
    check = function(it) {
      return it && it.Math == Math && it;
    };
    global$k = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
      return this;
    }() || commonjsGlobal || Function("return this")();
    shared$4 = { exports: {} };
    global$j = global$k;
    defineProperty$6 = Object.defineProperty;
    defineGlobalProperty$3 = function(key2, value) {
      try {
        defineProperty$6(global$j, key2, { value, configurable: true, writable: true });
      } catch (error) {
        global$j[key2] = value;
      }
      return value;
    };
    global$i = global$k;
    defineGlobalProperty$2 = defineGlobalProperty$3;
    SHARED = "__core-js_shared__";
    store$3 = global$i[SHARED] || defineGlobalProperty$2(SHARED, {});
    sharedStore = store$3;
    store$2 = sharedStore;
    (shared$4.exports = function(key2, value) {
      return store$2[key2] || (store$2[key2] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.32.0",
      mode: "global",
      copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
    requireObjectCoercible$7 = requireObjectCoercible$9;
    $Object$3 = Object;
    toObject$5 = function(argument) {
      return $Object$3(requireObjectCoercible$7(argument));
    };
    uncurryThis$l = functionUncurryThis;
    toObject$4 = toObject$5;
    hasOwnProperty = uncurryThis$l({}.hasOwnProperty);
    hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key2) {
      return hasOwnProperty(toObject$4(it), key2);
    };
    uncurryThis$k = functionUncurryThis;
    id3 = 0;
    postfix = Math.random();
    toString$9 = uncurryThis$k(1 .toString);
    uid$2 = function(key2) {
      return "Symbol(" + (key2 === void 0 ? "" : key2) + ")_" + toString$9(++id3 + postfix, 36);
    };
    engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
    global$h = global$k;
    userAgent$3 = engineUserAgent;
    process$4 = global$h.process;
    Deno$1 = global$h.Deno;
    versions = process$4 && process$4.versions || Deno$1 && Deno$1.version;
    v8 = versions && versions.v8;
    if (v8) {
      match = v8.split(".");
      version28 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version28 && userAgent$3) {
      match = userAgent$3.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent$3.match(/Chrome\/(\d+)/);
        if (match)
          version28 = +match[1];
      }
    }
    engineV8Version = version28;
    V8_VERSION$1 = engineV8Version;
    fails$k = fails$n;
    global$g = global$k;
    $String$5 = global$g.String;
    symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$k(function() {
      var symbol = Symbol();
      return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;
    });
    NATIVE_SYMBOL$1 = symbolConstructorDetection;
    useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
    global$f = global$k;
    shared$3 = shared$4.exports;
    hasOwn$a = hasOwnProperty_1;
    uid$1 = uid$2;
    NATIVE_SYMBOL = symbolConstructorDetection;
    USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
    Symbol$1 = global$f.Symbol;
    WellKnownSymbolsStore = shared$3("wks");
    createWellKnownSymbol = USE_SYMBOL_AS_UID$1 ? Symbol$1["for"] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
    wellKnownSymbol$i = function(name) {
      if (!hasOwn$a(WellKnownSymbolsStore, name)) {
        WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$a(Symbol$1, name) ? Symbol$1[name] : createWellKnownSymbol("Symbol." + name);
      }
      return WellKnownSymbolsStore[name];
    };
    documentAll$2 = typeof document == "object" && document.all;
    IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
    documentAll_1 = {
      all: documentAll$2,
      IS_HTMLDDA
    };
    $documentAll$1 = documentAll_1;
    documentAll$1 = $documentAll$1.all;
    isCallable$m = $documentAll$1.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll$1;
    } : function(argument) {
      return typeof argument == "function";
    };
    isCallable$l = isCallable$m;
    $documentAll = documentAll_1;
    documentAll = $documentAll.all;
    isObject$9 = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable$l(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable$l(it);
    };
    isObject$8 = isObject$9;
    $String$4 = String;
    $TypeError$e = TypeError;
    anObject$g = function(argument) {
      if (isObject$8(argument))
        return argument;
      throw $TypeError$e($String$4(argument) + " is not an object");
    };
    objectDefineProperties = {};
    fails$j = fails$n;
    descriptors = !fails$j(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
    DESCRIPTORS$a = descriptors;
    fails$i = fails$n;
    v8PrototypeDefineBug = DESCRIPTORS$a && fails$i(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype != 42;
    });
    objectDefineProperty = {};
    global$e = global$k;
    isObject$7 = isObject$9;
    document$3 = global$e.document;
    EXISTS$1 = isObject$7(document$3) && isObject$7(document$3.createElement);
    documentCreateElement$2 = function(it) {
      return EXISTS$1 ? document$3.createElement(it) : {};
    };
    DESCRIPTORS$9 = descriptors;
    fails$h = fails$n;
    createElement$1 = documentCreateElement$2;
    ie8DomDefine = !DESCRIPTORS$9 && !fails$h(function() {
      return Object.defineProperty(createElement$1("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
    NATIVE_BIND$2 = functionBindNative;
    call$j = Function.prototype.call;
    functionCall = NATIVE_BIND$2 ? call$j.bind(call$j) : function() {
      return call$j.apply(call$j, arguments);
    };
    global$d = global$k;
    isCallable$k = isCallable$m;
    aFunction = function(argument) {
      return isCallable$k(argument) ? argument : void 0;
    };
    getBuiltIn$7 = function(namespace, method) {
      return arguments.length < 2 ? aFunction(global$d[namespace]) : global$d[namespace] && global$d[namespace][method];
    };
    uncurryThis$j = functionUncurryThis;
    objectIsPrototypeOf = uncurryThis$j({}.isPrototypeOf);
    getBuiltIn$6 = getBuiltIn$7;
    isCallable$j = isCallable$m;
    isPrototypeOf$3 = objectIsPrototypeOf;
    USE_SYMBOL_AS_UID = useSymbolAsUid;
    $Object$2 = Object;
    isSymbol$2 = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn$6("Symbol");
      return isCallable$j($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$2(it));
    };
    $String$3 = String;
    tryToString$4 = function(argument) {
      try {
        return $String$3(argument);
      } catch (error) {
        return "Object";
      }
    };
    isCallable$i = isCallable$m;
    tryToString$3 = tryToString$4;
    $TypeError$d = TypeError;
    aCallable$9 = function(argument) {
      if (isCallable$i(argument))
        return argument;
      throw $TypeError$d(tryToString$3(argument) + " is not a function");
    };
    aCallable$8 = aCallable$9;
    isNullOrUndefined$5 = isNullOrUndefined$7;
    getMethod$6 = function(V, P) {
      var func = V[P];
      return isNullOrUndefined$5(func) ? void 0 : aCallable$8(func);
    };
    call$i = functionCall;
    isCallable$h = isCallable$m;
    isObject$6 = isObject$9;
    $TypeError$c = TypeError;
    ordinaryToPrimitive$1 = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable$h(fn = input.toString) && !isObject$6(val = call$i(fn, input)))
        return val;
      if (isCallable$h(fn = input.valueOf) && !isObject$6(val = call$i(fn, input)))
        return val;
      if (pref !== "string" && isCallable$h(fn = input.toString) && !isObject$6(val = call$i(fn, input)))
        return val;
      throw $TypeError$c("Can't convert object to primitive value");
    };
    call$h = functionCall;
    isObject$5 = isObject$9;
    isSymbol$1 = isSymbol$2;
    getMethod$5 = getMethod$6;
    ordinaryToPrimitive = ordinaryToPrimitive$1;
    wellKnownSymbol$h = wellKnownSymbol$i;
    $TypeError$b = TypeError;
    TO_PRIMITIVE = wellKnownSymbol$h("toPrimitive");
    toPrimitive$1 = function(input, pref) {
      if (!isObject$5(input) || isSymbol$1(input))
        return input;
      var exoticToPrim = getMethod$5(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call$h(exoticToPrim, input, pref);
        if (!isObject$5(result) || isSymbol$1(result))
          return result;
        throw $TypeError$b("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
    toPrimitive = toPrimitive$1;
    isSymbol = isSymbol$2;
    toPropertyKey$3 = function(argument) {
      var key2 = toPrimitive(argument, "string");
      return isSymbol(key2) ? key2 : key2 + "";
    };
    DESCRIPTORS$8 = descriptors;
    IE8_DOM_DEFINE$1 = ie8DomDefine;
    V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
    anObject$f = anObject$g;
    toPropertyKey$2 = toPropertyKey$3;
    $TypeError$a = TypeError;
    $defineProperty = Object.defineProperty;
    $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
    ENUMERABLE = "enumerable";
    CONFIGURABLE$1 = "configurable";
    WRITABLE = "writable";
    objectDefineProperty.f = DESCRIPTORS$8 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {
      anObject$f(O);
      P = toPropertyKey$2(P);
      anObject$f(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor$1(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    } : $defineProperty : function defineProperty2(O, P, Attributes) {
      anObject$f(O);
      P = toPropertyKey$2(P);
      anObject$f(Attributes);
      if (IE8_DOM_DEFINE$1)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError$a("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    };
    ceil = Math.ceil;
    floor$1 = Math.floor;
    mathTrunc = Math.trunc || function trunc(x) {
      var n2 = +x;
      return (n2 > 0 ? floor$1 : ceil)(n2);
    };
    trunc2 = mathTrunc;
    toIntegerOrInfinity$4 = function(argument) {
      var number2 = +argument;
      return number2 !== number2 || number2 === 0 ? 0 : trunc2(number2);
    };
    toIntegerOrInfinity$3 = toIntegerOrInfinity$4;
    max$2 = Math.max;
    min$4 = Math.min;
    toAbsoluteIndex$2 = function(index, length) {
      var integer = toIntegerOrInfinity$3(index);
      return integer < 0 ? max$2(integer + length, 0) : min$4(integer, length);
    };
    toIntegerOrInfinity$2 = toIntegerOrInfinity$4;
    min$3 = Math.min;
    toLength$4 = function(argument) {
      return argument > 0 ? min$3(toIntegerOrInfinity$2(argument), 9007199254740991) : 0;
    };
    toLength$3 = toLength$4;
    lengthOfArrayLike$4 = function(obj) {
      return toLength$3(obj.length);
    };
    toIndexedObject$4 = toIndexedObject$5;
    toAbsoluteIndex$1 = toAbsoluteIndex$2;
    lengthOfArrayLike$3 = lengthOfArrayLike$4;
    createMethod$3 = function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject$4($this);
        var length = lengthOfArrayLike$3(O);
        var index = toAbsoluteIndex$1(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el)
          while (length > index) {
            value = O[index++];
            if (value != value)
              return true;
          }
        else
          for (; length > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    };
    arrayIncludes = {
      includes: createMethod$3(true),
      indexOf: createMethod$3(false)
    };
    hiddenKeys$4 = {};
    uncurryThis$i = functionUncurryThis;
    hasOwn$9 = hasOwnProperty_1;
    toIndexedObject$3 = toIndexedObject$5;
    indexOf$1 = arrayIncludes.indexOf;
    hiddenKeys$3 = hiddenKeys$4;
    push$2 = uncurryThis$i([].push);
    objectKeysInternal = function(object2, names2) {
      var O = toIndexedObject$3(object2);
      var i = 0;
      var result = [];
      var key2;
      for (key2 in O)
        !hasOwn$9(hiddenKeys$3, key2) && hasOwn$9(O, key2) && push$2(result, key2);
      while (names2.length > i)
        if (hasOwn$9(O, key2 = names2[i++])) {
          ~indexOf$1(result, key2) || push$2(result, key2);
        }
      return result;
    };
    enumBugKeys$3 = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
    internalObjectKeys$1 = objectKeysInternal;
    enumBugKeys$2 = enumBugKeys$3;
    objectKeys$2 = Object.keys || function keys(O) {
      return internalObjectKeys$1(O, enumBugKeys$2);
    };
    DESCRIPTORS$7 = descriptors;
    V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
    definePropertyModule$4 = objectDefineProperty;
    anObject$e = anObject$g;
    toIndexedObject$2 = toIndexedObject$5;
    objectKeys$1 = objectKeys$2;
    objectDefineProperties.f = DESCRIPTORS$7 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties2(O, Properties) {
      anObject$e(O);
      var props = toIndexedObject$2(Properties);
      var keys3 = objectKeys$1(Properties);
      var length = keys3.length;
      var index = 0;
      var key2;
      while (length > index)
        definePropertyModule$4.f(O, key2 = keys3[index++], props[key2]);
      return O;
    };
    getBuiltIn$5 = getBuiltIn$7;
    html$2 = getBuiltIn$5("document", "documentElement");
    shared$2 = shared$4.exports;
    uid = uid$2;
    keys2 = shared$2("keys");
    sharedKey$3 = function(key2) {
      return keys2[key2] || (keys2[key2] = uid(key2));
    };
    anObject$d = anObject$g;
    definePropertiesModule = objectDefineProperties;
    enumBugKeys$1 = enumBugKeys$3;
    hiddenKeys$2 = hiddenKeys$4;
    html$1 = html$2;
    documentCreateElement$1 = documentCreateElement$2;
    sharedKey$2 = sharedKey$3;
    GT = ">";
    LT = "<";
    PROTOTYPE = "prototype";
    SCRIPT = "script";
    IE_PROTO$1 = sharedKey$2("IE_PROTO");
    EmptyConstructor = function() {
    };
    scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement$1("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html$1.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys$1.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys$1[length]];
      return NullProtoObject();
    };
    hiddenKeys$2[IE_PROTO$1] = true;
    objectCreate = Object.create || function create(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject$d(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO$1] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
    wellKnownSymbol$g = wellKnownSymbol$i;
    create$2 = objectCreate;
    defineProperty$5 = objectDefineProperty.f;
    UNSCOPABLES = wellKnownSymbol$g("unscopables");
    ArrayPrototype$1 = Array.prototype;
    if (ArrayPrototype$1[UNSCOPABLES] == void 0) {
      defineProperty$5(ArrayPrototype$1, UNSCOPABLES, {
        configurable: true,
        value: create$2(null)
      });
    }
    addToUnscopables$2 = function(key2) {
      ArrayPrototype$1[UNSCOPABLES][key2] = true;
    };
    iterators = {};
    global$c = global$k;
    isCallable$g = isCallable$m;
    WeakMap$1 = global$c.WeakMap;
    weakMapBasicDetection = isCallable$g(WeakMap$1) && /native code/.test(String(WeakMap$1));
    createPropertyDescriptor$4 = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
    DESCRIPTORS$6 = descriptors;
    definePropertyModule$3 = objectDefineProperty;
    createPropertyDescriptor$3 = createPropertyDescriptor$4;
    createNonEnumerableProperty$5 = DESCRIPTORS$6 ? function(object2, key2, value) {
      return definePropertyModule$3.f(object2, key2, createPropertyDescriptor$3(1, value));
    } : function(object2, key2, value) {
      object2[key2] = value;
      return object2;
    };
    NATIVE_WEAK_MAP = weakMapBasicDetection;
    global$b = global$k;
    isObject$4 = isObject$9;
    createNonEnumerableProperty$4 = createNonEnumerableProperty$5;
    hasOwn$8 = hasOwnProperty_1;
    shared$1 = sharedStore;
    sharedKey$1 = sharedKey$3;
    hiddenKeys$1 = hiddenKeys$4;
    OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    TypeError$2 = global$b.TypeError;
    WeakMap2 = global$b.WeakMap;
    enforce = function(it) {
      return has(it) ? get(it) : set$1(it, {});
    };
    getterFor = function(TYPE) {
      return function(it) {
        var state;
        if (!isObject$4(it) || (state = get(it)).type !== TYPE) {
          throw TypeError$2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    };
    if (NATIVE_WEAK_MAP || shared$1.state) {
      store$1 = shared$1.state || (shared$1.state = new WeakMap2());
      store$1.get = store$1.get;
      store$1.has = store$1.has;
      store$1.set = store$1.set;
      set$1 = function(it, metadata) {
        if (store$1.has(it))
          throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store$1.set(it, metadata);
        return metadata;
      };
      get = function(it) {
        return store$1.get(it) || {};
      };
      has = function(it) {
        return store$1.has(it);
      };
    } else {
      STATE = sharedKey$1("state");
      hiddenKeys$1[STATE] = true;
      set$1 = function(it, metadata) {
        if (hasOwn$8(it, STATE))
          throw TypeError$2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty$4(it, STATE, metadata);
        return metadata;
      };
      get = function(it) {
        return hasOwn$8(it, STATE) ? it[STATE] : {};
      };
      has = function(it) {
        return hasOwn$8(it, STATE);
      };
    }
    internalState = {
      set: set$1,
      get,
      has,
      enforce,
      getterFor
    };
    objectGetOwnPropertyDescriptor = {};
    objectPropertyIsEnumerable = {};
    $propertyIsEnumerable = {}.propertyIsEnumerable;
    getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;
    NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor$3(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
    DESCRIPTORS$5 = descriptors;
    call$g = functionCall;
    propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
    createPropertyDescriptor$2 = createPropertyDescriptor$4;
    toIndexedObject$1 = toIndexedObject$5;
    toPropertyKey$1 = toPropertyKey$3;
    hasOwn$7 = hasOwnProperty_1;
    IE8_DOM_DEFINE = ie8DomDefine;
    $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    objectGetOwnPropertyDescriptor.f = DESCRIPTORS$5 ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject$1(O);
      P = toPropertyKey$1(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
      if (hasOwn$7(O, P))
        return createPropertyDescriptor$2(!call$g(propertyIsEnumerableModule$1.f, O, P), O[P]);
    };
    makeBuiltIn$3 = { exports: {} };
    DESCRIPTORS$4 = descriptors;
    hasOwn$6 = hasOwnProperty_1;
    FunctionPrototype$1 = Function.prototype;
    getDescriptor = DESCRIPTORS$4 && Object.getOwnPropertyDescriptor;
    EXISTS = hasOwn$6(FunctionPrototype$1, "name");
    PROPER = EXISTS && function something() {
    }.name === "something";
    CONFIGURABLE = EXISTS && (!DESCRIPTORS$4 || DESCRIPTORS$4 && getDescriptor(FunctionPrototype$1, "name").configurable);
    functionName = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
    uncurryThis$h = functionUncurryThis;
    isCallable$f = isCallable$m;
    store = sharedStore;
    functionToString = uncurryThis$h(Function.toString);
    if (!isCallable$f(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    inspectSource$3 = store.inspectSource;
    uncurryThis$g = functionUncurryThis;
    fails$g = fails$n;
    isCallable$e = isCallable$m;
    hasOwn$5 = hasOwnProperty_1;
    DESCRIPTORS$3 = descriptors;
    CONFIGURABLE_FUNCTION_NAME$1 = functionName.CONFIGURABLE;
    inspectSource$2 = inspectSource$3;
    InternalStateModule$2 = internalState;
    enforceInternalState = InternalStateModule$2.enforce;
    getInternalState$2 = InternalStateModule$2.get;
    $String$2 = String;
    defineProperty$4 = Object.defineProperty;
    stringSlice$6 = uncurryThis$g("".slice);
    replace$3 = uncurryThis$g("".replace);
    join = uncurryThis$g([].join);
    CONFIGURABLE_LENGTH = DESCRIPTORS$3 && !fails$g(function() {
      return defineProperty$4(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    TEMPLATE = String(String).split("String");
    makeBuiltIn$2 = makeBuiltIn$3.exports = function(value, name, options) {
      if (stringSlice$6($String$2(name), 0, 7) === "Symbol(") {
        name = "[" + replace$3($String$2(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn$5(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
        if (DESCRIPTORS$3)
          defineProperty$4(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn$5(options, "arity") && value.length !== options.arity) {
        defineProperty$4(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn$5(options, "constructor") && options.constructor) {
          if (DESCRIPTORS$3)
            defineProperty$4(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn$5(state, "source")) {
        state.source = join(TEMPLATE, typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn$2(function toString2() {
      return isCallable$e(this) && getInternalState$2(this).source || inspectSource$2(this);
    }, "toString");
    isCallable$d = isCallable$m;
    definePropertyModule$2 = objectDefineProperty;
    makeBuiltIn$1 = makeBuiltIn$3.exports;
    defineGlobalProperty$1 = defineGlobalProperty$3;
    defineBuiltIn$7 = function(O, key2, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key2;
      if (isCallable$d(value))
        makeBuiltIn$1(value, name, options);
      if (options.global) {
        if (simple)
          O[key2] = value;
        else
          defineGlobalProperty$1(key2, value);
      } else {
        try {
          if (!options.unsafe)
            delete O[key2];
          else if (O[key2])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O[key2] = value;
        else
          definePropertyModule$2.f(O, key2, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O;
    };
    objectGetOwnPropertyNames = {};
    internalObjectKeys = objectKeysInternal;
    enumBugKeys = enumBugKeys$3;
    hiddenKeys = enumBugKeys.concat("length", "prototype");
    objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
    objectGetOwnPropertySymbols = {};
    objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
    getBuiltIn$4 = getBuiltIn$7;
    uncurryThis$f = functionUncurryThis;
    getOwnPropertyNamesModule = objectGetOwnPropertyNames;
    getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
    anObject$c = anObject$g;
    concat$2 = uncurryThis$f([].concat);
    ownKeys$1 = getBuiltIn$4("Reflect", "ownKeys") || function ownKeys(it) {
      var keys3 = getOwnPropertyNamesModule.f(anObject$c(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
      return getOwnPropertySymbols ? concat$2(keys3, getOwnPropertySymbols(it)) : keys3;
    };
    hasOwn$4 = hasOwnProperty_1;
    ownKeys2 = ownKeys$1;
    getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
    definePropertyModule$1 = objectDefineProperty;
    copyConstructorProperties$1 = function(target, source, exceptions) {
      var keys3 = ownKeys2(source);
      var defineProperty4 = definePropertyModule$1.f;
      var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys3.length; i++) {
        var key2 = keys3[i];
        if (!hasOwn$4(target, key2) && !(exceptions && hasOwn$4(exceptions, key2))) {
          defineProperty4(target, key2, getOwnPropertyDescriptor3(source, key2));
        }
      }
    };
    fails$f = fails$n;
    isCallable$c = isCallable$m;
    replacement = /#|\.prototype\./;
    isForced$2 = function(feature, detection) {
      var value = data[normalize2(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : isCallable$c(detection) ? fails$f(detection) : !!detection;
    };
    normalize2 = isForced$2.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    data = isForced$2.data = {};
    NATIVE = isForced$2.NATIVE = "N";
    POLYFILL = isForced$2.POLYFILL = "P";
    isForced_1 = isForced$2;
    global$a = global$k;
    getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
    createNonEnumerableProperty$3 = createNonEnumerableProperty$5;
    defineBuiltIn$6 = defineBuiltIn$7;
    defineGlobalProperty = defineGlobalProperty$3;
    copyConstructorProperties = copyConstructorProperties$1;
    isForced$1 = isForced_1;
    _export = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED2, target, key2, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global$a;
      } else if (STATIC) {
        target = global$a[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global$a[TARGET] || {}).prototype;
      }
      if (target)
        for (key2 in source) {
          sourceProperty = source[key2];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor$2(target, key2);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key2];
          FORCED2 = isForced$1(GLOBAL ? key2 : TARGET + (STATIC ? "." : "#") + key2, options.forced);
          if (!FORCED2 && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty$3(sourceProperty, "sham", true);
          }
          defineBuiltIn$6(target, key2, sourceProperty, options);
        }
    };
    fails$e = fails$n;
    correctPrototypeGetter = !fails$e(function() {
      function F() {
      }
      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    hasOwn$3 = hasOwnProperty_1;
    isCallable$b = isCallable$m;
    toObject$3 = toObject$5;
    sharedKey = sharedKey$3;
    CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
    IE_PROTO = sharedKey("IE_PROTO");
    $Object$1 = Object;
    ObjectPrototype = $Object$1.prototype;
    objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function(O) {
      var object2 = toObject$3(O);
      if (hasOwn$3(object2, IE_PROTO))
        return object2[IE_PROTO];
      var constructor = object2.constructor;
      if (isCallable$b(constructor) && object2 instanceof constructor) {
        return constructor.prototype;
      }
      return object2 instanceof $Object$1 ? ObjectPrototype : null;
    };
    fails$d = fails$n;
    isCallable$a = isCallable$m;
    isObject$3 = isObject$9;
    getPrototypeOf$1 = objectGetPrototypeOf;
    defineBuiltIn$5 = defineBuiltIn$7;
    wellKnownSymbol$f = wellKnownSymbol$i;
    ITERATOR$5 = wellKnownSymbol$f("iterator");
    BUGGY_SAFARI_ITERATORS$1 = false;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator))
        BUGGY_SAFARI_ITERATORS$1 = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
          IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
      }
    }
    NEW_ITERATOR_PROTOTYPE = !isObject$3(IteratorPrototype$2) || fails$d(function() {
      var test2 = {};
      return IteratorPrototype$2[ITERATOR$5].call(test2) !== test2;
    });
    if (NEW_ITERATOR_PROTOTYPE)
      IteratorPrototype$2 = {};
    if (!isCallable$a(IteratorPrototype$2[ITERATOR$5])) {
      defineBuiltIn$5(IteratorPrototype$2, ITERATOR$5, function() {
        return this;
      });
    }
    iteratorsCore = {
      IteratorPrototype: IteratorPrototype$2,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
    };
    defineProperty$3 = objectDefineProperty.f;
    hasOwn$2 = hasOwnProperty_1;
    wellKnownSymbol$e = wellKnownSymbol$i;
    TO_STRING_TAG$3 = wellKnownSymbol$e("toStringTag");
    setToStringTag$3 = function(target, TAG, STATIC) {
      if (target && !STATIC)
        target = target.prototype;
      if (target && !hasOwn$2(target, TO_STRING_TAG$3)) {
        defineProperty$3(target, TO_STRING_TAG$3, { configurable: true, value: TAG });
      }
    };
    IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
    create$1 = objectCreate;
    createPropertyDescriptor$1 = createPropertyDescriptor$4;
    setToStringTag$2 = setToStringTag$3;
    Iterators$4 = iterators;
    returnThis$1 = function() {
      return this;
    };
    iteratorCreateConstructor = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG2 = NAME + " Iterator";
      IteratorConstructor.prototype = create$1(IteratorPrototype$1, { next: createPropertyDescriptor$1(+!ENUMERABLE_NEXT, next) });
      setToStringTag$2(IteratorConstructor, TO_STRING_TAG2, false);
      Iterators$4[TO_STRING_TAG2] = returnThis$1;
      return IteratorConstructor;
    };
    uncurryThis$e = functionUncurryThis;
    aCallable$7 = aCallable$9;
    functionUncurryThisAccessor = function(object2, key2, method) {
      try {
        return uncurryThis$e(aCallable$7(Object.getOwnPropertyDescriptor(object2, key2)[method]));
      } catch (error) {
      }
    };
    isCallable$9 = isCallable$m;
    $String$1 = String;
    $TypeError$9 = TypeError;
    aPossiblePrototype$1 = function(argument) {
      if (typeof argument == "object" || isCallable$9(argument))
        return argument;
      throw $TypeError$9("Can't set " + $String$1(argument) + " as a prototype");
    };
    uncurryThisAccessor = functionUncurryThisAccessor;
    anObject$b = anObject$g;
    aPossiblePrototype = aPossiblePrototype$1;
    objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test2 = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test2, []);
        CORRECT_SETTER = test2 instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf2(O, proto) {
        anObject$b(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER)
          setter(O, proto);
        else
          O.__proto__ = proto;
        return O;
      };
    }() : void 0);
    $$d = _export;
    call$f = functionCall;
    FunctionName = functionName;
    isCallable$8 = isCallable$m;
    createIteratorConstructor = iteratorCreateConstructor;
    getPrototypeOf = objectGetPrototypeOf;
    setPrototypeOf$1 = objectSetPrototypeOf;
    setToStringTag$1 = setToStringTag$3;
    createNonEnumerableProperty$2 = createNonEnumerableProperty$5;
    defineBuiltIn$4 = defineBuiltIn$7;
    wellKnownSymbol$d = wellKnownSymbol$i;
    Iterators$3 = iterators;
    IteratorsCore = iteratorsCore;
    PROPER_FUNCTION_NAME$2 = FunctionName.PROPER;
    CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    IteratorPrototype = IteratorsCore.IteratorPrototype;
    BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    ITERATOR$4 = wellKnownSymbol$d("iterator");
    KEYS = "keys";
    VALUES = "values";
    ENTRIES = "entries";
    returnThis = function() {
      return this;
    };
    iteratorDefine = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED2) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator)
          return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
          return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys3() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values2() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG2 = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf$1) {
              setPrototypeOf$1(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable$8(CurrentIteratorPrototype[ITERATOR$4])) {
              defineBuiltIn$4(CurrentIteratorPrototype, ITERATOR$4, returnThis);
            }
          }
          setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG2, true);
        }
      }
      if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty$2(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values2() {
            return call$f(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED2)
          for (KEY in methods) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              defineBuiltIn$4(IterablePrototype, KEY, methods[KEY]);
            }
          }
        else
          $$d({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
        defineBuiltIn$4(IterablePrototype, ITERATOR$4, defaultIterator, { name: DEFAULT });
      }
      Iterators$3[NAME] = defaultIterator;
      return methods;
    };
    createIterResultObject$1 = function(value, done) {
      return { value, done };
    };
    toIndexedObject = toIndexedObject$5;
    addToUnscopables$1 = addToUnscopables$2;
    Iterators$2 = iterators;
    InternalStateModule$1 = internalState;
    defineProperty$2 = objectDefineProperty.f;
    defineIterator = iteratorDefine;
    createIterResultObject = createIterResultObject$1;
    DESCRIPTORS$2 = descriptors;
    ARRAY_ITERATOR = "Array Iterator";
    setInternalState$1 = InternalStateModule$1.set;
    getInternalState$1 = InternalStateModule$1.getterFor(ARRAY_ITERATOR);
    es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState$1(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        index: 0,
        kind
      });
    }, function() {
      var state = getInternalState$1(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;
      if (!target || index >= target.length) {
        state.target = void 0;
        return createIterResultObject(void 0, true);
      }
      if (kind == "keys")
        return createIterResultObject(index, false);
      if (kind == "values")
        return createIterResultObject(target[index], false);
      return createIterResultObject([index, target[index]], false);
    }, "values");
    values = Iterators$2.Arguments = Iterators$2.Array;
    addToUnscopables$1("keys");
    addToUnscopables$1("values");
    addToUnscopables$1("entries");
    if (DESCRIPTORS$2 && values.name !== "values")
      try {
        defineProperty$2(values, "name", { value: "values" });
      } catch (error) {
      }
    domIterables = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    documentCreateElement = documentCreateElement$2;
    classList = documentCreateElement("span").classList;
    DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
    domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
    global$9 = global$k;
    DOMIterables = domIterables;
    DOMTokenListPrototype = domTokenListPrototype;
    ArrayIteratorMethods = es_array_iterator;
    createNonEnumerableProperty$1 = createNonEnumerableProperty$5;
    wellKnownSymbol$c = wellKnownSymbol$i;
    ITERATOR$3 = wellKnownSymbol$c("iterator");
    TO_STRING_TAG$2 = wellKnownSymbol$c("toStringTag");
    ArrayValues = ArrayIteratorMethods.values;
    handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {
      if (CollectionPrototype) {
        if (CollectionPrototype[ITERATOR$3] !== ArrayValues)
          try {
            createNonEnumerableProperty$1(CollectionPrototype, ITERATOR$3, ArrayValues);
          } catch (error) {
            CollectionPrototype[ITERATOR$3] = ArrayValues;
          }
        if (!CollectionPrototype[TO_STRING_TAG$2]) {
          createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG$2, COLLECTION_NAME);
        }
        if (DOMIterables[COLLECTION_NAME])
          for (var METHOD_NAME in ArrayIteratorMethods) {
            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
              try {
                createNonEnumerableProperty$1(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
              } catch (error) {
                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
              }
          }
      }
    };
    for (COLLECTION_NAME in DOMIterables) {
      handlePrototype(global$9[COLLECTION_NAME] && global$9[COLLECTION_NAME].prototype, COLLECTION_NAME);
    }
    handlePrototype(DOMTokenListPrototype, "DOMTokenList");
    DESCRIPTORS$1 = descriptors;
    uncurryThis$d = functionUncurryThis;
    call$e = functionCall;
    fails$c = fails$n;
    objectKeys = objectKeys$2;
    getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
    propertyIsEnumerableModule = objectPropertyIsEnumerable;
    toObject$2 = toObject$5;
    IndexedObject$1 = indexedObject;
    $assign = Object.assign;
    defineProperty$1 = Object.defineProperty;
    concat$1 = uncurryThis$d([].concat);
    objectAssign = !$assign || fails$c(function() {
      if (DESCRIPTORS$1 && $assign({ b: 1 }, $assign(defineProperty$1({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty$1(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1)
        return true;
      var A = {};
      var B = {};
      var symbol = Symbol();
      var alphabet = "abcdefghijklmnopqrst";
      A[symbol] = 7;
      alphabet.split("").forEach(function(chr) {
        B[chr] = chr;
      });
      return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
    }) ? function assign(target, source) {
      var T = toObject$2(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable2 = propertyIsEnumerableModule.f;
      while (argumentsLength > index) {
        var S2 = IndexedObject$1(arguments[index++]);
        var keys3 = getOwnPropertySymbols ? concat$1(objectKeys(S2), getOwnPropertySymbols(S2)) : objectKeys(S2);
        var length = keys3.length;
        var j = 0;
        var key2;
        while (length > j) {
          key2 = keys3[j++];
          if (!DESCRIPTORS$1 || call$e(propertyIsEnumerable2, S2, key2))
            T[key2] = S2[key2];
        }
      }
      return T;
    } : $assign;
    $$c = _export;
    assign2 = objectAssign;
    $$c({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
      assign: assign2
    });
    classof$6 = classofRaw$2;
    engineIsNode = typeof process != "undefined" && classof$6(process) == "process";
    makeBuiltIn = makeBuiltIn$3.exports;
    defineProperty3 = objectDefineProperty;
    defineBuiltInAccessor$1 = function(target, name, descriptor) {
      if (descriptor.get)
        makeBuiltIn(descriptor.get, name, { getter: true });
      if (descriptor.set)
        makeBuiltIn(descriptor.set, name, { setter: true });
      return defineProperty3.f(target, name, descriptor);
    };
    getBuiltIn$3 = getBuiltIn$7;
    defineBuiltInAccessor = defineBuiltInAccessor$1;
    wellKnownSymbol$b = wellKnownSymbol$i;
    DESCRIPTORS = descriptors;
    SPECIES$3 = wellKnownSymbol$b("species");
    setSpecies$1 = function(CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
      if (DESCRIPTORS && Constructor && !Constructor[SPECIES$3]) {
        defineBuiltInAccessor(Constructor, SPECIES$3, {
          configurable: true,
          get: function() {
            return this;
          }
        });
      }
    };
    isPrototypeOf$2 = objectIsPrototypeOf;
    $TypeError$8 = TypeError;
    anInstance$1 = function(it, Prototype) {
      if (isPrototypeOf$2(Prototype, it))
        return it;
      throw $TypeError$8("Incorrect invocation");
    };
    wellKnownSymbol$a = wellKnownSymbol$i;
    TO_STRING_TAG$1 = wellKnownSymbol$a("toStringTag");
    test = {};
    test[TO_STRING_TAG$1] = "z";
    toStringTagSupport = String(test) === "[object z]";
    TO_STRING_TAG_SUPPORT = toStringTagSupport;
    isCallable$7 = isCallable$m;
    classofRaw$1 = classofRaw$2;
    wellKnownSymbol$9 = wellKnownSymbol$i;
    TO_STRING_TAG = wellKnownSymbol$9("toStringTag");
    $Object = Object;
    CORRECT_ARGUMENTS = classofRaw$1(function() {
      return arguments;
    }()) == "Arguments";
    tryGet = function(it, key2) {
      try {
        return it[key2];
      } catch (error) {
      }
    };
    classof$5 = TO_STRING_TAG_SUPPORT ? classofRaw$1 : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw$1(O) : (result = classofRaw$1(O)) == "Object" && isCallable$7(O.callee) ? "Arguments" : result;
    };
    uncurryThis$c = functionUncurryThis;
    fails$b = fails$n;
    isCallable$6 = isCallable$m;
    classof$4 = classof$5;
    getBuiltIn$2 = getBuiltIn$7;
    inspectSource$1 = inspectSource$3;
    noop = function() {
    };
    empty2 = [];
    construct = getBuiltIn$2("Reflect", "construct");
    constructorRegExp = /^\s*(?:class|function)\b/;
    exec$2 = uncurryThis$c(constructorRegExp.exec);
    INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
    isConstructorModern = function isConstructor(argument) {
      if (!isCallable$6(argument))
        return false;
      try {
        construct(noop, empty2, argument);
        return true;
      } catch (error) {
        return false;
      }
    };
    isConstructorLegacy = function isConstructor2(argument) {
      if (!isCallable$6(argument))
        return false;
      switch (classof$4(argument)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      try {
        return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));
      } catch (error) {
        return true;
      }
    };
    isConstructorLegacy.sham = true;
    isConstructor$1 = !construct || fails$b(function() {
      var called;
      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
        called = true;
      }) || called;
    }) ? isConstructorLegacy : isConstructorModern;
    isConstructor3 = isConstructor$1;
    tryToString$2 = tryToString$4;
    $TypeError$7 = TypeError;
    aConstructor$1 = function(argument) {
      if (isConstructor3(argument))
        return argument;
      throw $TypeError$7(tryToString$2(argument) + " is not a constructor");
    };
    anObject$a = anObject$g;
    aConstructor = aConstructor$1;
    isNullOrUndefined$4 = isNullOrUndefined$7;
    wellKnownSymbol$8 = wellKnownSymbol$i;
    SPECIES$2 = wellKnownSymbol$8("species");
    speciesConstructor$2 = function(O, defaultConstructor) {
      var C = anObject$a(O).constructor;
      var S2;
      return C === void 0 || isNullOrUndefined$4(S2 = anObject$a(C)[SPECIES$2]) ? defaultConstructor : aConstructor(S2);
    };
    NATIVE_BIND$1 = functionBindNative;
    FunctionPrototype = Function.prototype;
    apply$3 = FunctionPrototype.apply;
    call$d = FunctionPrototype.call;
    functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$1 ? call$d.bind(apply$3) : function() {
      return call$d.apply(apply$3, arguments);
    });
    classofRaw = classofRaw$2;
    uncurryThis$b = functionUncurryThis;
    functionUncurryThisClause = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis$b(fn);
    };
    uncurryThis$a = functionUncurryThisClause;
    aCallable$6 = aCallable$9;
    NATIVE_BIND = functionBindNative;
    bind$4 = uncurryThis$a(uncurryThis$a.bind);
    functionBindContext = function(fn, that) {
      aCallable$6(fn);
      return that === void 0 ? fn : NATIVE_BIND ? bind$4(fn, that) : function() {
        return fn.apply(that, arguments);
      };
    };
    uncurryThis$9 = functionUncurryThis;
    arraySlice$2 = uncurryThis$9([].slice);
    $TypeError$6 = TypeError;
    validateArgumentsLength$1 = function(passed, required) {
      if (passed < required)
        throw $TypeError$6("Not enough arguments");
      return passed;
    };
    userAgent$2 = engineUserAgent;
    engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$2);
    global$8 = global$k;
    apply$2 = functionApply;
    bind$3 = functionBindContext;
    isCallable$5 = isCallable$m;
    hasOwn$1 = hasOwnProperty_1;
    fails$a = fails$n;
    html = html$2;
    arraySlice$1 = arraySlice$2;
    createElement = documentCreateElement$2;
    validateArgumentsLength = validateArgumentsLength$1;
    IS_IOS$1 = engineIsIos;
    IS_NODE$4 = engineIsNode;
    set = global$8.setImmediate;
    clear = global$8.clearImmediate;
    process$3 = global$8.process;
    Dispatch = global$8.Dispatch;
    Function$1 = global$8.Function;
    MessageChannel = global$8.MessageChannel;
    String$1 = global$8.String;
    counter = 0;
    queue$2 = {};
    ONREADYSTATECHANGE = "onreadystatechange";
    fails$a(function() {
      $location = global$8.location;
    });
    run = function(id4) {
      if (hasOwn$1(queue$2, id4)) {
        var fn = queue$2[id4];
        delete queue$2[id4];
        fn();
      }
    };
    runner = function(id4) {
      return function() {
        run(id4);
      };
    };
    eventListener = function(event) {
      run(event.data);
    };
    globalPostMessageDefer = function(id4) {
      global$8.postMessage(String$1(id4), $location.protocol + "//" + $location.host);
    };
    if (!set || !clear) {
      set = function setImmediate2(handler) {
        validateArgumentsLength(arguments.length, 1);
        var fn = isCallable$5(handler) ? handler : Function$1(handler);
        var args = arraySlice$1(arguments, 1);
        queue$2[++counter] = function() {
          apply$2(fn, void 0, args);
        };
        defer(counter);
        return counter;
      };
      clear = function clearImmediate(id4) {
        delete queue$2[id4];
      };
      if (IS_NODE$4) {
        defer = function(id4) {
          process$3.nextTick(runner(id4));
        };
      } else if (Dispatch && Dispatch.now) {
        defer = function(id4) {
          Dispatch.now(runner(id4));
        };
      } else if (MessageChannel && !IS_IOS$1) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = eventListener;
        defer = bind$3(port.postMessage, port);
      } else if (global$8.addEventListener && isCallable$5(global$8.postMessage) && !global$8.importScripts && $location && $location.protocol !== "file:" && !fails$a(globalPostMessageDefer)) {
        defer = globalPostMessageDefer;
        global$8.addEventListener("message", eventListener, false);
      } else if (ONREADYSTATECHANGE in createElement("script")) {
        defer = function(id4) {
          html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run(id4);
          };
        };
      } else {
        defer = function(id4) {
          setTimeout(runner(id4), 0);
        };
      }
    }
    task$1 = {
      set,
      clear
    };
    Queue$2 = function() {
      this.head = null;
      this.tail = null;
    };
    Queue$2.prototype = {
      add: function(item) {
        var entry = { item, next: null };
        var tail = this.tail;
        if (tail)
          tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
      },
      get: function() {
        var entry = this.head;
        if (entry) {
          var next = this.head = entry.next;
          if (next === null)
            this.tail = null;
          return entry.item;
        }
      }
    };
    queue$1 = Queue$2;
    userAgent$1 = engineUserAgent;
    engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$1) && typeof Pebble != "undefined";
    userAgent = engineUserAgent;
    engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
    global$7 = global$k;
    bind$2 = functionBindContext;
    getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
    macrotask = task$1.set;
    Queue$1 = queue$1;
    IS_IOS = engineIsIos;
    IS_IOS_PEBBLE = engineIsIosPebble;
    IS_WEBOS_WEBKIT = engineIsWebosWebkit;
    IS_NODE$3 = engineIsNode;
    MutationObserver = global$7.MutationObserver || global$7.WebKitMutationObserver;
    document$2 = global$7.document;
    process$2 = global$7.process;
    Promise$1 = global$7.Promise;
    queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$7, "queueMicrotask");
    microtask$1 = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    if (!microtask$1) {
      queue = new Queue$1();
      flush = function() {
        var parent, fn;
        if (IS_NODE$3 && (parent = process$2.domain))
          parent.exit();
        while (fn = queue.get())
          try {
            fn();
          } catch (error) {
            if (queue.head)
              notify$1();
            throw error;
          }
        if (parent)
          parent.enter();
      };
      if (!IS_IOS && !IS_NODE$3 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
        toggle = true;
        node = document$2.createTextNode("");
        new MutationObserver(flush).observe(node, { characterData: true });
        notify$1 = function() {
          node.data = toggle = !toggle;
        };
      } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
        promise = Promise$1.resolve(void 0);
        promise.constructor = Promise$1;
        then = bind$2(promise.then, promise);
        notify$1 = function() {
          then(flush);
        };
      } else if (IS_NODE$3) {
        notify$1 = function() {
          process$2.nextTick(flush);
        };
      } else {
        macrotask = bind$2(macrotask, global$7);
        notify$1 = function() {
          macrotask(flush);
        };
      }
      microtask$1 = function(fn) {
        if (!queue.head)
          notify$1();
        queue.add(fn);
      };
    }
    microtask_1 = microtask$1;
    hostReportErrors$1 = function(a, b2) {
      try {
        arguments.length == 1 ? console.error(a) : console.error(a, b2);
      } catch (error) {
      }
    };
    perform$3 = function(exec2) {
      try {
        return { error: false, value: exec2() };
      } catch (error) {
        return { error: true, value: error };
      }
    };
    global$6 = global$k;
    promiseNativeConstructor = global$6.Promise;
    engineIsDeno = typeof Deno == "object" && Deno && typeof Deno.version == "object";
    IS_DENO$1 = engineIsDeno;
    IS_NODE$2 = engineIsNode;
    engineIsBrowser = !IS_DENO$1 && !IS_NODE$2 && typeof window == "object" && typeof document == "object";
    global$5 = global$k;
    NativePromiseConstructor$3 = promiseNativeConstructor;
    isCallable$4 = isCallable$m;
    isForced = isForced_1;
    inspectSource = inspectSource$3;
    wellKnownSymbol$7 = wellKnownSymbol$i;
    IS_BROWSER = engineIsBrowser;
    IS_DENO = engineIsDeno;
    V8_VERSION = engineV8Version;
    NativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;
    SPECIES$1 = wellKnownSymbol$7("species");
    SUBCLASSING = false;
    NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$4(global$5.PromiseRejectionEvent);
    FORCED_PROMISE_CONSTRUCTOR$5 = isForced("Promise", function() {
      var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);
      var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);
      if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
        return true;
      if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
        var promise2 = new NativePromiseConstructor$3(function(resolve2) {
          resolve2(1);
        });
        var FakePromise = function(exec2) {
          exec2(function() {
          }, function() {
          });
        };
        var constructor = promise2.constructor = {};
        constructor[SPECIES$1] = FakePromise;
        SUBCLASSING = promise2.then(function() {
        }) instanceof FakePromise;
        if (!SUBCLASSING)
          return true;
      }
      return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT$1;
    });
    promiseConstructorDetection = {
      CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
      REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
      SUBCLASSING
    };
    newPromiseCapability$2 = {};
    aCallable$5 = aCallable$9;
    $TypeError$5 = TypeError;
    PromiseCapability = function(C) {
      var resolve2, reject2;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve2 !== void 0 || reject2 !== void 0)
          throw $TypeError$5("Bad Promise constructor");
        resolve2 = $$resolve;
        reject2 = $$reject;
      });
      this.resolve = aCallable$5(resolve2);
      this.reject = aCallable$5(reject2);
    };
    newPromiseCapability$2.f = function(C) {
      return new PromiseCapability(C);
    };
    $$b = _export;
    IS_NODE$1 = engineIsNode;
    global$4 = global$k;
    call$c = functionCall;
    defineBuiltIn$3 = defineBuiltIn$7;
    setPrototypeOf = objectSetPrototypeOf;
    setToStringTag = setToStringTag$3;
    setSpecies = setSpecies$1;
    aCallable$4 = aCallable$9;
    isCallable$3 = isCallable$m;
    isObject$2 = isObject$9;
    anInstance = anInstance$1;
    speciesConstructor$1 = speciesConstructor$2;
    task = task$1.set;
    microtask = microtask_1;
    hostReportErrors = hostReportErrors$1;
    perform$2 = perform$3;
    Queue = queue$1;
    InternalStateModule = internalState;
    NativePromiseConstructor$2 = promiseNativeConstructor;
    PromiseConstructorDetection = promiseConstructorDetection;
    newPromiseCapabilityModule$3 = newPromiseCapability$2;
    PROMISE = "Promise";
    FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;
    NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
    NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
    getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    setInternalState = InternalStateModule.set;
    NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;
    PromiseConstructor = NativePromiseConstructor$2;
    PromisePrototype = NativePromisePrototype$1;
    TypeError$1 = global$4.TypeError;
    document$1 = global$4.document;
    process$1 = global$4.process;
    newPromiseCapability$1 = newPromiseCapabilityModule$3.f;
    newGenericPromiseCapability = newPromiseCapability$1;
    DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$4.dispatchEvent);
    UNHANDLED_REJECTION = "unhandledrejection";
    REJECTION_HANDLED = "rejectionhandled";
    PENDING = 0;
    FULFILLED = 1;
    REJECTED = 2;
    HANDLED = 1;
    UNHANDLED = 2;
    isThenable = function(it) {
      var then2;
      return isObject$2(it) && isCallable$3(then2 = it.then) ? then2 : false;
    };
    callReaction = function(reaction, state) {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve2 = reaction.resolve;
      var reject2 = reaction.reject;
      var domain = reaction.domain;
      var result, then2, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED)
              onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true)
            result = value;
          else {
            if (domain)
              domain.enter();
            result = handler(value);
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject2(TypeError$1("Promise-chain cycle"));
          } else if (then2 = isThenable(result)) {
            call$c(then2, result, resolve2, reject2);
          } else
            resolve2(result);
        } else
          reject2(value);
      } catch (error) {
        if (domain && !exited)
          domain.exit();
        reject2(error);
      }
    };
    notify = function(state, isReject) {
      if (state.notified)
        return;
      state.notified = true;
      microtask(function() {
        var reactions = state.reactions;
        var reaction;
        while (reaction = reactions.get()) {
          callReaction(reaction, state);
        }
        state.notified = false;
        if (isReject && !state.rejection)
          onUnhandled(state);
      });
    };
    dispatchEvent = function(name, promise2, reason) {
      var event, handler;
      if (DISPATCH_EVENT) {
        event = document$1.createEvent("Event");
        event.promise = promise2;
        event.reason = reason;
        event.initEvent(name, false, true);
        global$4.dispatchEvent(event);
      } else
        event = { promise: promise2, reason };
      if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$4["on" + name]))
        handler(event);
      else if (name === UNHANDLED_REJECTION)
        hostReportErrors("Unhandled promise rejection", reason);
    };
    onUnhandled = function(state) {
      call$c(task, global$4, function() {
        var promise2 = state.facade;
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
          result = perform$2(function() {
            if (IS_NODE$1) {
              process$1.emit("unhandledRejection", value, promise2);
            } else
              dispatchEvent(UNHANDLED_REJECTION, promise2, value);
          });
          state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error)
            throw result.value;
        }
      });
    };
    isUnhandled = function(state) {
      return state.rejection !== HANDLED && !state.parent;
    };
    onHandleUnhandled = function(state) {
      call$c(task, global$4, function() {
        var promise2 = state.facade;
        if (IS_NODE$1) {
          process$1.emit("rejectionHandled", promise2);
        } else
          dispatchEvent(REJECTION_HANDLED, promise2, state.value);
      });
    };
    bind$1 = function(fn, state, unwrap) {
      return function(value) {
        fn(state, value, unwrap);
      };
    };
    internalReject = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(state, true);
    };
    internalResolve = function(state, value, unwrap) {
      if (state.done)
        return;
      state.done = true;
      if (unwrap)
        state = unwrap;
      try {
        if (state.facade === value)
          throw TypeError$1("Promise can't be resolved itself");
        var then2 = isThenable(value);
        if (then2) {
          microtask(function() {
            var wrapper = { done: false };
            try {
              call$c(
                then2,
                value,
                bind$1(internalResolve, wrapper, state),
                bind$1(internalReject, wrapper, state)
              );
            } catch (error) {
              internalReject(wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(state, false);
        }
      } catch (error) {
        internalReject({ done: false }, error, state);
      }
    };
    if (FORCED_PROMISE_CONSTRUCTOR$4) {
      PromiseConstructor = function Promise2(executor) {
        anInstance(this, PromisePrototype);
        aCallable$4(executor);
        call$c(Internal, this);
        var state = getInternalPromiseState(this);
        try {
          executor(bind$1(internalResolve, state), bind$1(internalReject, state));
        } catch (error) {
          internalReject(state, error);
        }
      };
      PromisePrototype = PromiseConstructor.prototype;
      Internal = function Promise2(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: new Queue(),
          rejection: false,
          state: PENDING,
          value: void 0
        });
      };
      Internal.prototype = defineBuiltIn$3(PromisePrototype, "then", function then2(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability$1(speciesConstructor$1(this, PromiseConstructor));
        state.parent = true;
        reaction.ok = isCallable$3(onFulfilled) ? onFulfilled : true;
        reaction.fail = isCallable$3(onRejected) && onRejected;
        reaction.domain = IS_NODE$1 ? process$1.domain : void 0;
        if (state.state == PENDING)
          state.reactions.add(reaction);
        else
          microtask(function() {
            callReaction(reaction, state);
          });
        return reaction.promise;
      });
      OwnPromiseCapability = function() {
        var promise2 = new Internal();
        var state = getInternalPromiseState(promise2);
        this.promise = promise2;
        this.resolve = bind$1(internalResolve, state);
        this.reject = bind$1(internalReject, state);
      };
      newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };
      if (isCallable$3(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {
        nativeThen = NativePromisePrototype$1.then;
        if (!NATIVE_PROMISE_SUBCLASSING) {
          defineBuiltIn$3(NativePromisePrototype$1, "then", function then2(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve2, reject2) {
              call$c(nativeThen, that, resolve2, reject2);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
        }
        try {
          delete NativePromisePrototype$1.constructor;
        } catch (error) {
        }
        if (setPrototypeOf) {
          setPrototypeOf(NativePromisePrototype$1, PromisePrototype);
        }
      }
    }
    $$b({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false);
    setSpecies(PROMISE);
    wellKnownSymbol$6 = wellKnownSymbol$i;
    Iterators$1 = iterators;
    ITERATOR$2 = wellKnownSymbol$6("iterator");
    ArrayPrototype = Array.prototype;
    isArrayIteratorMethod$1 = function(it) {
      return it !== void 0 && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);
    };
    classof$3 = classof$5;
    getMethod$4 = getMethod$6;
    isNullOrUndefined$3 = isNullOrUndefined$7;
    Iterators = iterators;
    wellKnownSymbol$5 = wellKnownSymbol$i;
    ITERATOR$1 = wellKnownSymbol$5("iterator");
    getIteratorMethod$2 = function(it) {
      if (!isNullOrUndefined$3(it))
        return getMethod$4(it, ITERATOR$1) || getMethod$4(it, "@@iterator") || Iterators[classof$3(it)];
    };
    call$b = functionCall;
    aCallable$3 = aCallable$9;
    anObject$9 = anObject$g;
    tryToString$1 = tryToString$4;
    getIteratorMethod$1 = getIteratorMethod$2;
    $TypeError$4 = TypeError;
    getIterator$1 = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
      if (aCallable$3(iteratorMethod))
        return anObject$9(call$b(iteratorMethod, argument));
      throw $TypeError$4(tryToString$1(argument) + " is not iterable");
    };
    call$a = functionCall;
    anObject$8 = anObject$g;
    getMethod$3 = getMethod$6;
    iteratorClose$1 = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject$8(iterator);
      try {
        innerResult = getMethod$3(iterator, "return");
        if (!innerResult) {
          if (kind === "throw")
            throw value;
          return value;
        }
        innerResult = call$a(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw")
        throw value;
      if (innerError)
        throw innerResult;
      anObject$8(innerResult);
      return value;
    };
    bind = functionBindContext;
    call$9 = functionCall;
    anObject$7 = anObject$g;
    tryToString = tryToString$4;
    isArrayIteratorMethod = isArrayIteratorMethod$1;
    lengthOfArrayLike$2 = lengthOfArrayLike$4;
    isPrototypeOf$1 = objectIsPrototypeOf;
    getIterator = getIterator$1;
    getIteratorMethod = getIteratorMethod$2;
    iteratorClose = iteratorClose$1;
    $TypeError$3 = TypeError;
    Result2 = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    ResultPrototype = Result2.prototype;
    iterate$2 = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn = bind(unboundFunction, that);
      var iterator, iterFn, index, length, result, next, step;
      var stop = function(condition) {
        if (iterator)
          iteratorClose(iterator, "normal", condition);
        return new Result2(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject$7(value);
          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
        }
        return INTERRUPTED ? fn(value, stop) : fn(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn)
          throw $TypeError$3(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf$1(ResultPrototype, result))
              return result;
          }
          return new Result2(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call$9(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf$1(ResultPrototype, result))
          return result;
      }
      return new Result2(false);
    };
    wellKnownSymbol$4 = wellKnownSymbol$i;
    ITERATOR = wellKnownSymbol$4("iterator");
    SAFE_CLOSING = false;
    try {
      called = 0;
      iteratorWithReturn = {
        next: function() {
          return { done: !!called++ };
        },
        "return": function() {
          SAFE_CLOSING = true;
        }
      };
      iteratorWithReturn[ITERATOR] = function() {
        return this;
      };
      Array.from(iteratorWithReturn, function() {
        throw 2;
      });
    } catch (error) {
    }
    checkCorrectnessOfIteration$1 = function(exec2, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING)
        return false;
      var ITERATION_SUPPORT = false;
      try {
        var object2 = {};
        object2[ITERATOR] = function() {
          return {
            next: function() {
              return { done: ITERATION_SUPPORT = true };
            }
          };
        };
        exec2(object2);
      } catch (error) {
      }
      return ITERATION_SUPPORT;
    };
    NativePromiseConstructor$1 = promiseNativeConstructor;
    checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
    FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;
    promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration(function(iterable) {
      NativePromiseConstructor$1.all(iterable).then(void 0, function() {
      });
    });
    $$a = _export;
    call$8 = functionCall;
    aCallable$2 = aCallable$9;
    newPromiseCapabilityModule$2 = newPromiseCapability$2;
    perform$1 = perform$3;
    iterate$1 = iterate$2;
    PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;
    $$a({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule$2.f(C);
        var resolve2 = capability.resolve;
        var reject2 = capability.reject;
        var result = perform$1(function() {
          var $promiseResolve = aCallable$2(C.resolve);
          var values2 = [];
          var counter2 = 0;
          var remaining = 1;
          iterate$1(iterable, function(promise2) {
            var index = counter2++;
            var alreadyCalled = false;
            remaining++;
            call$8($promiseResolve, C, promise2).then(function(value) {
              if (alreadyCalled)
                return;
              alreadyCalled = true;
              values2[index] = value;
              --remaining || resolve2(values2);
            }, reject2);
          });
          --remaining || resolve2(values2);
        });
        if (result.error)
          reject2(result.value);
        return capability.promise;
      }
    });
    $$9 = _export;
    FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;
    NativePromiseConstructor = promiseNativeConstructor;
    getBuiltIn$1 = getBuiltIn$7;
    isCallable$2 = isCallable$m;
    defineBuiltIn$2 = defineBuiltIn$7;
    NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
    $$9({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
      "catch": function(onRejected) {
        return this.then(void 0, onRejected);
      }
    });
    if (isCallable$2(NativePromiseConstructor)) {
      method = getBuiltIn$1("Promise").prototype["catch"];
      if (NativePromisePrototype["catch"] !== method) {
        defineBuiltIn$2(NativePromisePrototype, "catch", method, { unsafe: true });
      }
    }
    $$8 = _export;
    call$7 = functionCall;
    aCallable$1 = aCallable$9;
    newPromiseCapabilityModule$1 = newPromiseCapability$2;
    perform = perform$3;
    iterate = iterate$2;
    PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;
    $$8({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapabilityModule$1.f(C);
        var reject2 = capability.reject;
        var result = perform(function() {
          var $promiseResolve = aCallable$1(C.resolve);
          iterate(iterable, function(promise2) {
            call$7($promiseResolve, C, promise2).then(capability.resolve, reject2);
          });
        });
        if (result.error)
          reject2(result.value);
        return capability.promise;
      }
    });
    $$7 = _export;
    call$6 = functionCall;
    newPromiseCapabilityModule = newPromiseCapability$2;
    FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;
    $$7({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
      reject: function reject(r2) {
        var capability = newPromiseCapabilityModule.f(this);
        call$6(capability.reject, void 0, r2);
        return capability.promise;
      }
    });
    anObject$6 = anObject$g;
    isObject$1 = isObject$9;
    newPromiseCapability = newPromiseCapability$2;
    promiseResolve$1 = function(C, x) {
      anObject$6(C);
      if (isObject$1(x) && x.constructor === C)
        return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve2 = promiseCapability.resolve;
      resolve2(x);
      return promiseCapability.promise;
    };
    $$6 = _export;
    getBuiltIn = getBuiltIn$7;
    FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;
    promiseResolve = promiseResolve$1;
    getBuiltIn("Promise");
    $$6({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
      resolve: function resolve(x) {
        return promiseResolve(this, x);
      }
    });
    classof$2 = classof$5;
    $String = String;
    toString$8 = function(argument) {
      if (classof$2(argument) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
    anObject$5 = anObject$g;
    regexpFlags$1 = function() {
      var that = anObject$5(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
    fails$9 = fails$n;
    global$3 = global$k;
    $RegExp$2 = global$3.RegExp;
    UNSUPPORTED_Y$2 = fails$9(function() {
      var re = $RegExp$2("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") != null;
    });
    MISSED_STICKY = UNSUPPORTED_Y$2 || fails$9(function() {
      return !$RegExp$2("a", "y").sticky;
    });
    BROKEN_CARET = UNSUPPORTED_Y$2 || fails$9(function() {
      var re = $RegExp$2("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") != null;
    });
    regexpStickyHelpers = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y: UNSUPPORTED_Y$2
    };
    fails$8 = fails$n;
    global$2 = global$k;
    $RegExp$1 = global$2.RegExp;
    regexpUnsupportedDotAll = fails$8(function() {
      var re = $RegExp$1(".", "s");
      return !(re.dotAll && re.exec("\n") && re.flags === "s");
    });
    fails$7 = fails$n;
    global$1 = global$k;
    $RegExp = global$1.RegExp;
    regexpUnsupportedNcg = fails$7(function() {
      var re = $RegExp("(?<a>b)", "g");
      return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
    });
    call$5 = functionCall;
    uncurryThis$8 = functionUncurryThis;
    toString$7 = toString$8;
    regexpFlags = regexpFlags$1;
    stickyHelpers$1 = regexpStickyHelpers;
    shared = shared$4.exports;
    create2 = objectCreate;
    getInternalState = internalState.get;
    UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;
    UNSUPPORTED_NCG = regexpUnsupportedNcg;
    nativeReplace = shared("native-string-replace", String.prototype.replace);
    nativeExec = RegExp.prototype.exec;
    patchedExec = nativeExec;
    charAt$3 = uncurryThis$8("".charAt);
    indexOf = uncurryThis$8("".indexOf);
    replace$2 = uncurryThis$8("".replace);
    stringSlice$5 = uncurryThis$8("".slice);
    UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call$5(nativeExec, re1, "a");
      call$5(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;
    NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = function exec2(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString$7(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match2, i, object2, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call$5(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y$1 && re.sticky;
        var flags = call$5(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace$2(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice$5(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$3(str, re.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re.lastIndex;
        match2 = call$5(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match2) {
            match2.input = stringSlice$5(match2.input, charsAdded);
            match2[0] = stringSlice$5(match2[0], charsAdded);
            match2.index = re.lastIndex;
            re.lastIndex += match2[0].length;
          } else
            re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match2) {
          re.lastIndex = re.global ? match2.index + match2[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match2 && match2.length > 1) {
          call$5(nativeReplace, match2[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0)
                match2[i] = void 0;
            }
          });
        }
        if (match2 && groups) {
          match2.groups = object2 = create2(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object2[group[0]] = match2[group[1]];
          }
        }
        return match2;
      };
    }
    regexpExec$3 = patchedExec;
    $$5 = _export;
    exec$1 = regexpExec$3;
    $$5({ target: "RegExp", proto: true, forced: /./.exec !== exec$1 }, {
      exec: exec$1
    });
    pollLastTX = ({
      chainId,
      txHash,
      graphApiKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      try {
        const result = yield (0, import_moloch_v3_data.findTransaction)({
          networkId: chainId,
          txHash,
          graphApiKeys
        });
        return result;
      } catch (error) {
        console.error(error);
        return;
      }
    });
    testLastTX = (result) => {
      var _a2;
      if ((_a2 = result === null || result === void 0 ? void 0 : result.data) === null || _a2 === void 0 ? void 0 : _a2.transaction) {
        return true;
      }
      return false;
    };
    standardGraphPoll = ({
      poll: poll2,
      test: test2,
      interval: _interval2 = 5e3,
      variables,
      onPollSuccess,
      onPollError,
      onPollTimeout,
      onPollStart,
      maxTries: _maxTries = 12
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      onPollStart === null || onPollStart === void 0 ? void 0 : onPollStart();
      let count = 0;
      const pollId = setInterval(() => __awaiter17(void 0, void 0, void 0, function* () {
        if (count < _maxTries) {
          try {
            const result = yield poll2(variables);
            console.log("**POLL RESULT**");
            console.log("result", result);
            const testPassed = test2(result);
            if (testPassed) {
              console.log("TEST PASSED");
              onPollSuccess === null || onPollSuccess === void 0 ? void 0 : onPollSuccess(result);
              clearInterval(pollId);
              return result;
            }
            count += 1;
            return;
          } catch (error) {
            onPollError === null || onPollError === void 0 ? void 0 : onPollError(error);
            clearInterval(pollId);
            return;
          }
        } else {
          const error = new Error("Transcaction Poll ran out of tries. There could be issues with the subgraph.");
          onPollTimeout === null || onPollTimeout === void 0 ? void 0 : onPollTimeout(error);
          return;
        }
      }), _interval2);
    });
    uncurryThis$7 = functionUncurryThisClause;
    defineBuiltIn$1 = defineBuiltIn$7;
    regexpExec$2 = regexpExec$3;
    fails$6 = fails$n;
    wellKnownSymbol$3 = wellKnownSymbol$i;
    createNonEnumerableProperty = createNonEnumerableProperty$5;
    SPECIES = wellKnownSymbol$3("species");
    RegExpPrototype$2 = RegExp.prototype;
    fixRegexpWellKnownSymbolLogic = function(KEY, exec2, FORCED2, SHAM) {
      var SYMBOL = wellKnownSymbol$3(KEY);
      var DELEGATES_TO_SYMBOL = !fails$6(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$6(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
          re.flags = "";
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED2) {
        var uncurriedNativeRegExpMethod = uncurryThis$7(/./[SYMBOL]);
        var methods = exec2(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var uncurriedNativeMethod = uncurryThis$7(nativeMethod);
          var $exec = regexp.exec;
          if ($exec === regexpExec$2 || $exec === RegExpPrototype$2.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
            }
            return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn$1(String.prototype, KEY, methods[0]);
        defineBuiltIn$1(RegExpPrototype$2, SYMBOL, methods[1]);
      }
      if (SHAM)
        createNonEnumerableProperty(RegExpPrototype$2[SYMBOL], "sham", true);
    };
    isObject = isObject$9;
    classof$1 = classofRaw$2;
    wellKnownSymbol$2 = wellKnownSymbol$i;
    MATCH$1 = wellKnownSymbol$2("match");
    isRegexp = function(it) {
      var isRegExp2;
      return isObject(it) && ((isRegExp2 = it[MATCH$1]) !== void 0 ? !!isRegExp2 : classof$1(it) == "RegExp");
    };
    uncurryThis$6 = functionUncurryThis;
    toIntegerOrInfinity$1 = toIntegerOrInfinity$4;
    toString$6 = toString$8;
    requireObjectCoercible$6 = requireObjectCoercible$9;
    charAt$2 = uncurryThis$6("".charAt);
    charCodeAt = uncurryThis$6("".charCodeAt);
    stringSlice$4 = uncurryThis$6("".slice);
    createMethod$2 = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S2 = toString$6(requireObjectCoercible$6($this));
        var position = toIntegerOrInfinity$1(pos);
        var size = S2.length;
        var first, second;
        if (position < 0 || position >= size)
          return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S2, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S2, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$2(S2, position) : first : CONVERT_TO_STRING ? stringSlice$4(S2, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    stringMultibyte = {
      codeAt: createMethod$2(false),
      charAt: createMethod$2(true)
    };
    charAt$1 = stringMultibyte.charAt;
    advanceStringIndex$2 = function(S2, index, unicode) {
      return index + (unicode ? charAt$1(S2, index).length : 1);
    };
    toPropertyKey = toPropertyKey$3;
    definePropertyModule = objectDefineProperty;
    createPropertyDescriptor = createPropertyDescriptor$4;
    createProperty$1 = function(object2, key2, value) {
      var propertyKey = toPropertyKey(key2);
      if (propertyKey in object2)
        definePropertyModule.f(object2, propertyKey, createPropertyDescriptor(0, value));
      else
        object2[propertyKey] = value;
    };
    toAbsoluteIndex = toAbsoluteIndex$2;
    lengthOfArrayLike$1 = lengthOfArrayLike$4;
    createProperty = createProperty$1;
    $Array = Array;
    max$1 = Math.max;
    arraySliceSimple = function(O, start, end) {
      var length = lengthOfArrayLike$1(O);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
      var result = $Array(max$1(fin - k, 0));
      for (var n2 = 0; k < fin; k++, n2++)
        createProperty(result, n2, O[k]);
      result.length = n2;
      return result;
    };
    call$4 = functionCall;
    anObject$4 = anObject$g;
    isCallable$1 = isCallable$m;
    classof = classofRaw$2;
    regexpExec$1 = regexpExec$3;
    $TypeError$2 = TypeError;
    regexpExecAbstract = function(R, S2) {
      var exec2 = R.exec;
      if (isCallable$1(exec2)) {
        var result = call$4(exec2, R, S2);
        if (result !== null)
          anObject$4(result);
        return result;
      }
      if (classof(R) === "RegExp")
        return call$4(regexpExec$1, R, S2);
      throw $TypeError$2("RegExp#exec called on incompatible receiver");
    };
    apply$1 = functionApply;
    call$3 = functionCall;
    uncurryThis$5 = functionUncurryThis;
    fixRegExpWellKnownSymbolLogic$2 = fixRegexpWellKnownSymbolLogic;
    anObject$3 = anObject$g;
    isNullOrUndefined$2 = isNullOrUndefined$7;
    isRegExp$1 = isRegexp;
    requireObjectCoercible$5 = requireObjectCoercible$9;
    speciesConstructor = speciesConstructor$2;
    advanceStringIndex$1 = advanceStringIndex$2;
    toLength$2 = toLength$4;
    toString$5 = toString$8;
    getMethod$2 = getMethod$6;
    arraySlice = arraySliceSimple;
    callRegExpExec = regexpExecAbstract;
    regexpExec = regexpExec$3;
    stickyHelpers = regexpStickyHelpers;
    fails$5 = fails$n;
    UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    MAX_UINT32 = 4294967295;
    min$2 = Math.min;
    $push = [].push;
    exec = uncurryThis$5(/./.exec);
    push$1 = uncurryThis$5($push);
    stringSlice$3 = uncurryThis$5("".slice);
    SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails$5(function() {
      var re = /(?:)/;
      var originalExec = re.exec;
      re.exec = function() {
        return originalExec.apply(this, arguments);
      };
      var result = "ab".split(re);
      return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
    });
    fixRegExpWellKnownSymbolLogic$2("split", function(SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;
      if ("abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
        internalSplit = function(separator, limit) {
          var string = toString$5(requireObjectCoercible$5(this));
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (separator === void 0)
            return [string];
          if (!isRegExp$1(separator)) {
            return call$3(nativeSplit, string, separator, lim);
          }
          var output2 = [];
          var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
          var lastLastIndex = 0;
          var separatorCopy = new RegExp(separator.source, flags + "g");
          var match2, lastIndex, lastLength;
          while (match2 = call$3(regexpExec, separatorCopy, string)) {
            lastIndex = separatorCopy.lastIndex;
            if (lastIndex > lastLastIndex) {
              push$1(output2, stringSlice$3(string, lastLastIndex, match2.index));
              if (match2.length > 1 && match2.index < string.length)
                apply$1($push, output2, arraySlice(match2, 1));
              lastLength = match2[0].length;
              lastLastIndex = lastIndex;
              if (output2.length >= lim)
                break;
            }
            if (separatorCopy.lastIndex === match2.index)
              separatorCopy.lastIndex++;
          }
          if (lastLastIndex === string.length) {
            if (lastLength || !exec(separatorCopy, ""))
              push$1(output2, "");
          } else
            push$1(output2, stringSlice$3(string, lastLastIndex));
          return output2.length > lim ? arraySlice(output2, 0, lim) : output2;
        };
      } else if ("0".split(void 0, 0).length) {
        internalSplit = function(separator, limit) {
          return separator === void 0 && limit === 0 ? [] : call$3(nativeSplit, this, separator, limit);
        };
      } else
        internalSplit = nativeSplit;
      return [
        function split4(separator, limit) {
          var O = requireObjectCoercible$5(this);
          var splitter = isNullOrUndefined$2(separator) ? void 0 : getMethod$2(separator, SPLIT);
          return splitter ? call$3(splitter, separator, O, limit) : call$3(internalSplit, toString$5(O), separator, limit);
        },
        function(string, limit) {
          var rx = anObject$3(this);
          var S2 = toString$5(string);
          var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
          if (res.done)
            return res.value;
          var C = speciesConstructor(rx, RegExp);
          var unicodeMatching = rx.unicode;
          var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
          var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
          var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
          if (lim === 0)
            return [];
          if (S2.length === 0)
            return callRegExpExec(splitter, S2) === null ? [S2] : [];
          var p = 0;
          var q = 0;
          var A = [];
          while (q < S2.length) {
            splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
            var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice$3(S2, q) : S2);
            var e;
            if (z === null || (e = min$2(toLength$2(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S2.length)) === p) {
              q = advanceStringIndex$1(S2, q, unicodeMatching);
            } else {
              push$1(A, stringSlice$3(S2, p, q));
              if (A.length === lim)
                return A;
              for (var i = 1; i <= z.length - 1; i++) {
                push$1(A, z[i]);
                if (A.length === lim)
                  return A;
              }
              q = p = e;
            }
          }
          push$1(A, stringSlice$3(S2, p));
          return A;
        }
      ];
    }, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
    sameValue$1 = Object.is || function is(x, y) {
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    };
    call$2 = functionCall;
    fixRegExpWellKnownSymbolLogic$1 = fixRegexpWellKnownSymbolLogic;
    anObject$2 = anObject$g;
    isNullOrUndefined$1 = isNullOrUndefined$7;
    requireObjectCoercible$4 = requireObjectCoercible$9;
    sameValue = sameValue$1;
    toString$4 = toString$8;
    getMethod$1 = getMethod$6;
    regExpExec$1 = regexpExecAbstract;
    fixRegExpWellKnownSymbolLogic$1("search", function(SEARCH, nativeSearch, maybeCallNative) {
      return [
        function search(regexp) {
          var O = requireObjectCoercible$4(this);
          var searcher = isNullOrUndefined$1(regexp) ? void 0 : getMethod$1(regexp, SEARCH);
          return searcher ? call$2(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString$4(O));
        },
        function(string) {
          var rx = anObject$2(this);
          var S2 = toString$4(string);
          var res = maybeCallNative(nativeSearch, rx, S2);
          if (res.done)
            return res.value;
          var previousLastIndex = rx.lastIndex;
          if (!sameValue(previousLastIndex, 0))
            rx.lastIndex = 0;
          var result = regExpExec$1(rx, S2);
          if (!sameValue(rx.lastIndex, previousLastIndex))
            rx.lastIndex = previousLastIndex;
          return result === null ? -1 : result.index;
        }
      ];
    });
    handleIPFSPinata = ({
      arg,
      chainId,
      safeId,
      localABIs,
      appState,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const processedContent = yield processArg({
        arg: arg === null || arg === void 0 ? void 0 : arg.content,
        chainId,
        safeId,
        localABIs,
        appState,
        rpcs,
        pinataApiKeys,
        explorerKeys
      });
      const pinata_api_key = pinataApiKeys.pinata_api_key;
      const pinata_api_secret = pinataApiKeys.pinata_api_secret;
      if (!pinata_api_key || !pinata_api_secret) {
        throw new Error("PINATA_API_KEY and PINATA_API_SECRET must be set in the environment");
      }
      const res = yield (0, import_data_fetch_utils.pinataPostJSON)({
        creds: {
          pinata_api_key,
          pinata_api_secret
        },
        jsonString: JSON.stringify({
          data: processedContent
        })
      });
      const IPFSpin = res.IpfsHash;
      console.log("***IPFSpin***", IPFSpin);
      if (IPFSpin) {
        return IPFSpin;
      }
      throw new Error(`IPFS Pin failed.`);
    });
    call$1 = functionCall;
    hasOwn2 = hasOwnProperty_1;
    isPrototypeOf = objectIsPrototypeOf;
    regExpFlags = regexpFlags$1;
    RegExpPrototype$1 = RegExp.prototype;
    regexpGetFlags = function(R) {
      var flags = R.flags;
      return flags === void 0 && !("flags" in RegExpPrototype$1) && !hasOwn2(R, "flags") && isPrototypeOf(RegExpPrototype$1, R) ? call$1(regExpFlags, R) : flags;
    };
    PROPER_FUNCTION_NAME$1 = functionName.PROPER;
    defineBuiltIn = defineBuiltIn$7;
    anObject$1 = anObject$g;
    $toString = toString$8;
    fails$4 = fails$n;
    getRegExpFlags = regexpGetFlags;
    TO_STRING = "toString";
    RegExpPrototype = RegExp.prototype;
    nativeToString = RegExpPrototype[TO_STRING];
    NOT_GENERIC = fails$4(function() {
      return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
    });
    INCORRECT_NAME = PROPER_FUNCTION_NAME$1 && nativeToString.name != TO_STRING;
    if (NOT_GENERIC || INCORRECT_NAME) {
      defineBuiltIn(RegExp.prototype, TO_STRING, function toString4() {
        var R = anObject$1(this);
        var pattern = $toString(R.source);
        var flags = $toString(getRegExpFlags(R));
        return "/" + pattern + "/" + flags;
      }, { unsafe: true });
    }
    aCallable = aCallable$9;
    toObject$1 = toObject$5;
    IndexedObject = indexedObject;
    lengthOfArrayLike = lengthOfArrayLike$4;
    $TypeError$1 = TypeError;
    createMethod$1 = function(IS_RIGHT) {
      return function(that, callbackfn, argumentsLength, memo) {
        aCallable(callbackfn);
        var O = toObject$1(that);
        var self2 = IndexedObject(O);
        var length = lengthOfArrayLike(O);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2)
          while (true) {
            if (index in self2) {
              memo = self2[index];
              index += i;
              break;
            }
            index += i;
            if (IS_RIGHT ? index < 0 : length <= index) {
              throw $TypeError$1("Reduce of empty array with no initial value");
            }
          }
        for (; IS_RIGHT ? index >= 0 : length > index; index += i)
          if (index in self2) {
            memo = callbackfn(memo, self2[index], index, O);
          }
        return memo;
      };
    };
    arrayReduce = {
      left: createMethod$1(false),
      right: createMethod$1(true)
    };
    fails$3 = fails$n;
    arrayMethodIsStrict$1 = function(METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails$3(function() {
        method.call(null, argument || function() {
          return 1;
        }, 1);
      });
    };
    $$4 = _export;
    $reduce = arrayReduce.left;
    arrayMethodIsStrict = arrayMethodIsStrict$1;
    CHROME_VERSION = engineV8Version;
    IS_NODE = engineIsNode;
    CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
    FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
    $$4({ target: "Array", proto: true, forced: FORCED }, {
      reduce: function reduce(callbackfn) {
        var length = arguments.length;
        return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
      }
    });
    EXPIRY = ".proposalExpiry";
    FORM = ".formValues";
    CURRENT_DAO = ".daoId";
    gasBufferMultiplier = 1.2;
    BaalContractBase = {
      type: "local",
      contractName: "Baal",
      abi: import_abis.LOCAL_ABI.BAAL
    };
    basicDetails = {
      type: "JSONDetails",
      jsonSchema: {
        title: ".formValues.title",
        description: ".formValues.description",
        proposalType: {
          type: "static",
          value: "Multicall Proposal"
        }
      }
    };
    $$3 = _export;
    $includes = arrayIncludes.includes;
    fails$2 = fails$n;
    addToUnscopables = addToUnscopables$2;
    BROKEN_ON_SPARSE = fails$2(function() {
      return !Array(1).includes();
    });
    $$3({ target: "Array", proto: true, forced: BROKEN_ON_SPARSE }, {
      includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      }
    });
    addToUnscopables("includes");
    uncurryThis$4 = functionUncurryThis;
    toObject = toObject$5;
    floor = Math.floor;
    charAt = uncurryThis$4("".charAt);
    replace$1 = uncurryThis$4("".replace);
    stringSlice$2 = uncurryThis$4("".slice);
    SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    getSubstitution$1 = function(matched, str, position, captures, namedCaptures, replacement2) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace$1(replacement2, symbols, function(match2, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice$2(str, 0, position);
          case "'":
            return stringSlice$2(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice$2(ch, 1, -1)];
            break;
          default:
            var n2 = +ch;
            if (n2 === 0)
              return match2;
            if (n2 > m) {
              var f2 = floor(n2 / 10);
              if (f2 === 0)
                return match2;
              if (f2 <= m)
                return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
              return match2;
            }
            capture = captures[n2 - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
    apply = functionApply;
    call = functionCall;
    uncurryThis$3 = functionUncurryThis;
    fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
    fails$1 = fails$n;
    anObject = anObject$g;
    isCallable = isCallable$m;
    isNullOrUndefined = isNullOrUndefined$7;
    toIntegerOrInfinity = toIntegerOrInfinity$4;
    toLength$1 = toLength$4;
    toString$3 = toString$8;
    requireObjectCoercible$3 = requireObjectCoercible$9;
    advanceStringIndex = advanceStringIndex$2;
    getMethod = getMethod$6;
    getSubstitution = getSubstitution$1;
    regExpExec = regexpExecAbstract;
    wellKnownSymbol$1 = wellKnownSymbol$i;
    REPLACE = wellKnownSymbol$1("replace");
    max = Math.max;
    min$1 = Math.min;
    concat3 = uncurryThis$3([].concat);
    push = uncurryThis$3([].push);
    stringIndexOf$1 = uncurryThis$3("".indexOf);
    stringSlice$1 = uncurryThis$3("".slice);
    maybeToString = function(it) {
      return it === void 0 ? it : String(it);
    };
    REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    REPLACE_SUPPORTS_NAMED_GROUPS = !fails$1(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace2, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        function replace2(searchValue, replaceValue) {
          var O = requireObjectCoercible$3(this);
          var replacer = isNullOrUndefined(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
          return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace2, toString$3(O), searchValue, replaceValue);
        },
        function(string, replaceValue) {
          var rx = anObject(this);
          var S2 = toString$3(string);
          if (typeof replaceValue == "string" && stringIndexOf$1(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf$1(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace2, rx, S2, replaceValue);
            if (res.done)
              return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace)
            replaceValue = toString$3(replaceValue);
          var global2 = rx.global;
          if (global2) {
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          while (true) {
            var result = regExpExec(rx, S2);
            if (result === null)
              break;
            push(results, result);
            if (!global2)
              break;
            var matchStr = toString$3(result[0]);
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S2, toLength$1(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = toString$3(result[0]);
            var position = max(min$1(toIntegerOrInfinity(result.index), S2.length), 0);
            var captures = [];
            for (var j = 1; j < result.length; j++)
              push(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat3([matched], captures, position, S2);
              if (namedCaptures !== void 0)
                push(replacerArgs, namedCaptures);
              var replacement2 = toString$3(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement2 = getSubstitution(matched, S2, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice$1(S2, nextSourcePosition, position) + replacement2;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice$1(S2, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
    localforage = import("./localforage-2P4SSVI6.js").then((localforage2) => __awaiter17(void 0, void 0, void 0, function* () {
      if (typeof window === "object")
        yield localforage2.default.ready();
      return localforage2.default;
    }));
    defaultABIStore = {
      "0x1": {},
      "0x4": {},
      "0x5": {},
      "0x2a": {},
      "0xa": {},
      "0x64": {},
      "0x89": {},
      "0xa4b1": {},
      "0xa4ec": {}
    };
    getABIstore = () => __awaiter17(void 0, void 0, void 0, function* () {
      const local = yield localforage;
      return yield local.getItem(import_utils92.CacheStoreName.ABI);
    });
    getCachedABI = ({
      address,
      chainId
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      var _a2;
      const abiStore = yield getABIstore();
      const abi = (_a2 = abiStore === null || abiStore === void 0 ? void 0 : abiStore[chainId]) === null || _a2 === void 0 ? void 0 : _a2[address];
      return abi;
    });
    addABI = ({
      abiStore,
      chainId,
      address,
      abi
    }) => {
      return Object.assign(Object.assign({}, abiStore), {
        [chainId]: Object.assign(Object.assign({}, abiStore[chainId]), {
          [address]: abi
        })
      });
    };
    cacheABI = ({
      address,
      chainId,
      abi
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const abiStore = yield getABIstore();
      const newStore = addABI({
        abiStore,
        chainId,
        address: address.toLowerCase(),
        abi
      });
      const local = yield localforage;
      try {
        yield local.setItem(import_utils92.CacheStoreName.ABI, newStore);
        return true;
      } catch (error) {
        console.error(error);
        return false;
      }
    });
    initABIs = () => __awaiter17(void 0, void 0, void 0, function* () {
      const local = yield localforage;
      local.config(import_utils92.CACHE_CONFIG);
      const store2 = yield getABIstore();
      if (!store2) {
        local.setItem(import_utils92.CacheStoreName.ABI, defaultABIStore);
      }
    });
    initABIs();
    isGnosisProxy = (abi) => {
      return abi.length === 2 && abi.every((fn) => ["constructor", "fallback"].includes(fn === null || fn === void 0 ? void 0 : fn.type));
    };
    isSuperfluidProxy = (abi) => {
      return abi.length === 3 && abi.some((fn) => fn.name === "initializeProxy");
    };
    isProxyABI = (abi) => {
      if (abi === null || abi === void 0 ? void 0 : abi.length) {
        return abi.some((fn) => fn.name === "implementation");
      }
      return false;
    };
    getABIUrl = ({
      chainId,
      contractAddress,
      explorerKeys: _explorerKeys = import_keychain_utils.ABI_EXPLORER_KEYS
    }) => {
      var _a2;
      const ABI_ADDRESS = "<<address>>";
      const TEMPORARY_ABI_EXPLORER = {
        "0x1": `https://api.etherscan.io/api?module=contract&action=getabi&address=${ABI_ADDRESS}&apikey=${_explorerKeys[chainId]}`,
        "0x5": `https://api-goerli.etherscan.io/api?module=contract&action=getabi&address=${ABI_ADDRESS}&apikey=${_explorerKeys[chainId]}`,
        "0x64": `https://api.gnosisscan.io/api?module=contract&action=getabi&address=${ABI_ADDRESS}&apikey=${_explorerKeys[chainId]}`,
        "0x89": `https://api.polygonscan.com/api?module=contract&action=getabi&address=${ABI_ADDRESS}&apikey=${_explorerKeys[chainId]}`,
        "0xa": `https://api-optimistic.etherscan.io/api?module=contract&action=getabi&address=${ABI_ADDRESS}&apikey=${_explorerKeys[chainId]}`,
        "0xa4b1": `https://api.arbiscan.io/api?module=contract&action=getabi&address=${ABI_ADDRESS}&apiKey=${_explorerKeys[chainId]}`
      };
      return (_a2 = TEMPORARY_ABI_EXPLORER[chainId]) === null || _a2 === void 0 ? void 0 : _a2.replace(ABI_ADDRESS, contractAddress);
    };
    getGnosisMasterCopy = (address, chainId, rpcs) => __awaiter17(void 0, void 0, void 0, function* () {
      const client = (0, import_utils92.createViemClient)({
        chainId,
        rpcs
      });
      return yield client.readContract({
        abi: import_abis.LOCAL_ABI.ERC20,
        address,
        functionName: "masterCopy"
      });
    });
    getProxyStorageSlot = ({
      address,
      client,
      slot: _slot = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      try {
        const proxyAddr = yield client.getStorageAt({
          address,
          slot: _slot
        });
        return trim(proxyAddr);
      } catch (error) {
        console.error(error);
        return false;
      }
    });
    getImplementation = ({
      address,
      chainId,
      abi,
      rpcs: _rpcs = import_keychain_utils.HAUS_RPC
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const client = (0, import_utils92.createViemClient)({
        chainId,
        rpcs: _rpcs
      });
      try {
        const proxyAddr = yield client.readContract({
          address,
          abi,
          functionName: "implementation"
        });
        return proxyAddr;
      } catch (_a2) {
        return yield getProxyStorageSlot({
          address,
          client
        });
      }
    });
    processABI = ({
      abi,
      fetchABI: fetchABI2,
      contractAddress,
      chainId,
      rpcs: _rpcs2 = import_keychain_utils.HAUS_RPC,
      explorerKeys: _explorerKeys2 = import_keychain_utils.ABI_EXPLORER_KEYS
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      if (isProxyABI(abi)) {
        const proxyAddress = yield getImplementation({
          address: contractAddress,
          chainId,
          abi
        });
        if (proxyAddress) {
          const newData = yield fetchABI2({
            contractAddress: proxyAddress,
            chainId,
            rpcs: _rpcs2,
            explorerKeys: _explorerKeys2
          });
          if (newData) {
            return newData;
          } else {
            throw new Error("Could not fetch ABI from proxy");
          }
        }
      } else if (isSuperfluidProxy(abi)) {
        const client = (0, import_utils92.createViemClient)({
          chainId,
          rpcs: _rpcs2
        });
        const sfProxyAddr = yield client.readContract({
          address: contractAddress,
          abi: import_abis.LOCAL_ABI.SUPERFLUID_PROXY,
          functionName: "getCodeAddress"
        });
        const newData = yield fetchABI2({
          contractAddress: sfProxyAddr,
          chainId,
          rpcs: _rpcs2,
          explorerKeys: _explorerKeys2
        });
        if (newData) {
          return newData;
        } else {
          throw new Error("Could not fetch ABI from proxy");
        }
      } else if (isGnosisProxy(abi)) {
        const gnosisProxyAddress = yield getGnosisMasterCopy(contractAddress, chainId, _rpcs2);
        const newData = yield fetchABI2({
          contractAddress: gnosisProxyAddress,
          chainId,
          rpcs: _rpcs2,
          explorerKeys: _explorerKeys2
        });
        return newData;
      }
      return abi;
    });
    fetchABI = ({
      contractAddress,
      chainId,
      rpcs: _rpcs3 = import_keychain_utils.HAUS_RPC,
      explorerKeys: _explorerKeys3 = import_keychain_utils.ABI_EXPLORER_KEYS
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const cachedABI = yield getCachedABI({
        address: contractAddress,
        chainId
      });
      if (cachedABI) {
        const processedABI = yield processABI({
          abi: cachedABI,
          fetchABI,
          contractAddress,
          chainId,
          rpcs: _rpcs3,
          explorerKeys: _explorerKeys3
        });
        return processedABI;
      }
      const url = getABIUrl({
        contractAddress,
        chainId,
        explorerKeys: _explorerKeys3
      });
      try {
        if (!url) {
          console.log("contractAddress", contractAddress);
          console.log("chainId", chainId);
          console.log("url", url);
          throw new Error("Could generate explorer url with the given arguments");
        }
        const scanResponse = yield fetch(url);
        const data2 = yield scanResponse.json();
        if (data2.message === "OK" && (0, import_utils92.isJSON)(data2.result)) {
          const abi = JSON.parse(data2.result);
          cacheABI({
            address: contractAddress,
            chainId,
            abi
          });
          const processedABI = yield processABI({
            abi,
            fetchABI,
            contractAddress,
            chainId,
            rpcs: _rpcs3,
            explorerKeys: _explorerKeys3
          });
          return processedABI;
        }
        throw new Error("Could not fetch or parse ABI");
      } catch (error) {
        console.error(error);
        return void 0;
      }
    });
    getCode = ({
      contractAddress,
      chainId,
      rpcs: _rpcs4 = import_keychain_utils.HAUS_RPC
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const transport = (0, import_utils92.createTransport)({
        chainId,
        rpcs: _rpcs4
      });
      const client = createPublicClient({
        chain: import_keychain_utils.VIEM_CHAINS[chainId],
        transport
      });
      return yield client.getBytecode({
        address: contractAddress
      });
    });
    whitespaces$2 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    uncurryThis$2 = functionUncurryThis;
    requireObjectCoercible$2 = requireObjectCoercible$9;
    toString$2 = toString$8;
    whitespaces$1 = whitespaces$2;
    replace = uncurryThis$2("".replace);
    ltrim = RegExp("^[" + whitespaces$1 + "]+");
    rtrim = RegExp("(^|[^" + whitespaces$1 + "])[" + whitespaces$1 + "]+$");
    createMethod = function(TYPE) {
      return function($this) {
        var string = toString$2(requireObjectCoercible$2($this));
        if (TYPE & 1)
          string = replace(string, ltrim, "");
        if (TYPE & 2)
          string = replace(string, rtrim, "$1");
        return string;
      };
    };
    stringTrim = {
      start: createMethod(1),
      end: createMethod(2),
      trim: createMethod(3)
    };
    PROPER_FUNCTION_NAME = functionName.PROPER;
    fails = fails$n;
    whitespaces = whitespaces$2;
    non = "\u200B\x85\u180E";
    stringTrimForced = function(METHOD_NAME) {
      return fails(function() {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
    $$2 = _export;
    $trim = stringTrim.trim;
    forcedStringTrimMethod = stringTrimForced;
    $$2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
      trim: function trim2() {
        return $trim(this);
      }
    });
    isRegExp = isRegexp;
    $TypeError = TypeError;
    notARegexp = function(it) {
      if (isRegExp(it)) {
        throw $TypeError("The method doesn't accept regular expressions");
      }
      return it;
    };
    wellKnownSymbol = wellKnownSymbol$i;
    MATCH = wellKnownSymbol("match");
    correctIsRegexpLogic = function(METHOD_NAME) {
      var regexp = /./;
      try {
        "/./"[METHOD_NAME](regexp);
      } catch (error1) {
        try {
          regexp[MATCH] = false;
          return "/./"[METHOD_NAME](regexp);
        } catch (error2) {
        }
      }
      return false;
    };
    $$1 = _export;
    uncurryThis$1 = functionUncurryThis;
    notARegExp$1 = notARegexp;
    requireObjectCoercible$1 = requireObjectCoercible$9;
    toString$1 = toString$8;
    correctIsRegExpLogic$1 = correctIsRegexpLogic;
    stringIndexOf = uncurryThis$1("".indexOf);
    $$1({ target: "String", proto: true, forced: !correctIsRegExpLogic$1("includes") }, {
      includes: function includes2(searchString) {
        return !!~stringIndexOf(
          toString$1(requireObjectCoercible$1(this)),
          toString$1(notARegExp$1(searchString)),
          arguments.length > 1 ? arguments[1] : void 0
        );
      }
    });
    checkArgType = (arg) => {
      if ((0, import_utils92.isArgType)(arg)) {
        return arg;
      }
      throw new Error(`Invalid arg type ${arg}`);
    };
    deepSearch = (appState, pathString) => {
      const path = pathString.trim().split(".").filter(Boolean);
      let state = Object.assign({}, appState);
      for (let i = 0, len = path.length; i < len; i++) {
        state = state === null || state === void 0 ? void 0 : state[path === null || path === void 0 ? void 0 : path[i]];
      }
      return state;
    };
    searchApp = (appState, pathString, shouldThrow = false) => {
      const result = deepSearch(appState, pathString);
      if (result == null) {
        if (shouldThrow) {
          console.log("**Application State**", appState);
          console.log("result", result);
          throw new Error(`Could not find ${pathString}`);
        } else {
          return false;
        }
      }
      return result;
    };
    checkHasCondition = (pathString) => pathString.includes("||");
    handleConditionalPath = (pathString) => {
      const paths = pathString.trim().split("||").map((str) => str.trim()).filter(Boolean);
      return paths;
    };
    searchArg = ({
      appState,
      searchString,
      shouldThrow: _shouldThrow = false
    }) => {
      const hasCondition = checkHasCondition(searchString);
      if (hasCondition) {
        const paths = handleConditionalPath(searchString);
        for (const path of paths) {
          const result = searchApp(appState, path);
          if (result) {
            return checkArgType(result);
          }
        }
        throw new Error(`No paths in conditional path string: ${searchString} returns a value`);
      }
      return checkArgType(searchApp(appState, searchString, _shouldThrow));
    };
    handleDetailsJSON = ({
      arg,
      appState,
      localABIs,
      chainId,
      safeId,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const detailsList = yield Promise.all(Object.entries(arg.jsonSchema).map(([key2, arg2]) => __awaiter17(void 0, void 0, void 0, function* () {
        return {
          id: key2,
          value: yield processArg({
            arg: arg2,
            chainId,
            safeId,
            localABIs,
            appState,
            rpcs,
            pinataApiKeys,
            explorerKeys
          })
        };
      })));
      if (!detailsList) {
        console.log("arg", arg);
        throw new Error(`Error Compiling JSON Details`);
      }
      return JSON.stringify(detailsList.reduce((acc, arg2) => {
        return Object.assign(Object.assign({}, acc), {
          [arg2.id]: arg2.value
        });
      }, {}));
    });
    findTargetAddress = ({
      appState,
      targetAddress,
      chainId
    }) => {
      if (typeof targetAddress === "string" && (0, import_utils92.isEthAddress)(targetAddress)) {
        return targetAddress;
      }
      if (typeof targetAddress === "string" && isSearchArg(targetAddress)) {
        return searchArg({
          searchString: targetAddress,
          appState,
          shouldThrow: true
        });
      }
      if (typeof targetAddress === "object" && typeof targetAddress[chainId] === "string") {
        return targetAddress[chainId];
      }
      throw new Error(`No address found for targetAddress: ${targetAddress}`);
    };
    handleTargetAddress = (args) => {
      const address = findTargetAddress(args);
      if ((0, import_utils92.isEthAddress)(address))
        return address;
      throw new Error(`Target address: ${address} is not a valid ethereum address`);
    };
    processStaticContract = ({
      localContract,
      chainId,
      appState
    }) => {
      const {
        targetAddress,
        abi,
        contractName
      } = localContract;
      const address = handleTargetAddress({
        targetAddress,
        chainId,
        appState
      });
      if (!address) {
        throw new Error(`No address found for contract ${contractName} on ${chainId}`);
      }
      return {
        type: "processed",
        abi,
        address,
        contractName
      };
    };
    processLocalContract = ({
      localContract,
      chainId,
      localABIs,
      appState
    }) => {
      const {
        targetAddress,
        contractName
      } = localContract;
      const abi = localABIs[contractName];
      const address = handleTargetAddress({
        targetAddress,
        chainId,
        appState
      });
      if (!address) {
        throw new Error(`No address found for contract ${contractName} on ${chainId}`);
      }
      return {
        type: "processed",
        abi,
        address,
        contractName
      };
    };
    processRemoteContract = ({
      remoteContract,
      chainId,
      appState,
      rpcs,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const {
        targetAddress,
        contractName
      } = remoteContract;
      const address = handleTargetAddress({
        targetAddress,
        chainId,
        appState
      });
      const abi = yield fetchABI({
        contractAddress: address,
        chainId,
        rpcs,
        explorerKeys
      });
      if (abi && address) {
        return {
          type: "processed",
          abi,
          address,
          contractName
        };
      }
      console.log("**DEBUG**");
      console.log("remoteContract", remoteContract);
      console.log("address", address);
      console.log("abi", abi);
      throw new Error(`Could not process remote contract ${contractName}`);
    });
    processContractLego = ({
      contract,
      chainId,
      localABIs,
      appState,
      rpcs,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      if (contract.type === "static") {
        return processStaticContract({
          localContract: contract,
          chainId,
          appState
        });
      }
      if (contract.type === "local") {
        return processLocalContract({
          localContract: contract,
          chainId,
          localABIs,
          appState
        });
      }
      if (contract.type === "remote") {
        const processedContract = yield processRemoteContract({
          remoteContract: contract,
          chainId,
          appState,
          rpcs,
          explorerKeys
        });
        return processedContract;
      }
      if (contract.type === "processed") {
        return contract;
      }
      throw new Error("ABI not found. Remote fetching not implemented");
    });
    estimateFunctionalGas = ({
      chainId,
      contractAddress,
      from,
      value,
      data: data2,
      rpcs: _rpcs = import_keychain_utils.HAUS_RPC
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const client = (0, import_utils92.createViemClient)({
        chainId,
        rpcs: _rpcs
      });
      const functionGasFees = yield client.estimateGas({
        account: from,
        to: contractAddress,
        value,
        data: data2
      });
      console.log("functionGasFees", functionGasFees);
      return Number(functionGasFees);
    });
    txActionToMetaTx = ({
      abi,
      method,
      address,
      args,
      value: _value2 = 0,
      operation: _operation = 0
    }) => {
      const encodedData = (0, import_utils92.encodeFunction)(abi, method, args);
      if (typeof encodedData !== "string") {
        throw new Error(encodedData.message);
      }
      console.log("operation", _operation);
      return {
        to: address,
        data: encodedData,
        value: _value2.toString(),
        operation: _operation
      };
    };
    handleEncodeCallArg = ({
      arg,
      chainId,
      localABIs,
      appState,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const {
        contract,
        method,
        args
      } = arg.action;
      const processedContract = yield processContractLego({
        contract,
        chainId,
        localABIs,
        appState,
        rpcs,
        explorerKeys
      });
      const processedArgs = yield Promise.all(args.map((arg2) => __awaiter17(void 0, void 0, void 0, function* () {
        return yield processArg({
          arg: arg2,
          chainId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
      })));
      const encodedData = (0, import_utils92.encodeFunction)(processedContract.abi, method, processedArgs);
      if (typeof encodedData !== "string") {
        throw new Error(encodedData.message);
      }
      return encodedData;
    });
    handleMulticallFormActions = ({
      appState
    }) => {
      const validTxs = appState.formValues.tx ? Object.keys(appState.formValues.tx).filter((actionId) => {
        const action = appState.formValues.tx[actionId];
        return !action.deleted;
      }) : [];
      if (!validTxs.length) {
        throw new Error("No actions found");
      }
      return validTxs.map((actionId) => {
        const action = appState.formValues.tx[actionId];
        const {
          to,
          data: data2,
          value,
          operation
        } = action;
        return {
          to,
          data: data2,
          value,
          operation
        };
      });
    };
    handleMulticallArg = ({
      arg,
      chainId,
      localABIs,
      appState,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const encodedActions = yield Promise.all(arg.actions.map((action) => __awaiter17(void 0, void 0, void 0, function* () {
        const {
          contract,
          method,
          args,
          value,
          operations,
          data: data2
        } = action;
        const processedContract = yield processContractLego({
          contract,
          chainId,
          localABIs,
          appState,
          rpcs,
          explorerKeys
        });
        const processValue = value ? yield processArg({
          arg: value,
          chainId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        }) : 0;
        const processedOperations = operations ? yield processArg({
          arg: operations,
          chainId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        }) : 0;
        if (data2) {
          return {
            to: processedContract.address,
            data: yield processArg({
              arg: data2,
              chainId,
              localABIs,
              appState,
              rpcs,
              pinataApiKeys,
              explorerKeys
            }),
            value: processValue.toString(),
            operation: Number(processedOperations)
          };
        }
        const processedArgs = yield Promise.all(args.map((arg2) => __awaiter17(void 0, void 0, void 0, function* () {
          return yield processArg({
            arg: arg2,
            chainId,
            localABIs,
            appState,
            rpcs,
            pinataApiKeys,
            explorerKeys
          });
        })));
        return txActionToMetaTx({
          abi: processedContract.abi,
          method,
          address: processedContract.address,
          args: processedArgs,
          value: Number(processValue),
          operation: Number(processedOperations)
        });
      })));
      const encodedFormActions = arg.formActions ? handleMulticallFormActions({
        appState
      }) : [];
      return [...encodedActions, ...encodedFormActions];
    });
    gasEstimateFromActions = ({
      actions,
      actionsCount,
      chainId,
      daoId
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const esitmatedGases = yield Promise.all(actions.map((action) => __awaiter17(void 0, void 0, void 0, function* () {
        return yield estimateFunctionalGas({
          chainId,
          contractAddress: action.to,
          from: daoId,
          value: BigInt(Number(action.value)),
          data: action.data
        });
      })));
      const totalGasEstimate = esitmatedGases === null || esitmatedGases === void 0 ? void 0 : esitmatedGases.reduce((a, b2) => (a || 0) + (b2 || 0), 0);
      const baalOnlyGas = actionsCount * import_utils92.ACTION_GAS_LIMIT_ADDITION;
      console.log("baalOnlyGas addtition", baalOnlyGas);
      console.log("totalGasEstimate", totalGasEstimate);
      return (totalGasEstimate || 0) + baalOnlyGas;
    });
    handleEncodeMulticallArg = ({
      arg,
      actions
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      if (arg.type === "encodeMulticall") {
        const _result = (0, import_safe_contracts.encodeMultiSend)(actions);
        console.log("arg.type", arg.type);
        console.log("result", _result);
        if (typeof _result !== "string") {
          throw new Error("Could not encode generic multicall");
        }
        return _result;
      }
      const result = encodeMultiAction(actions);
      if (typeof result !== "string") {
        throw new Error(result.message);
      }
      return result;
    });
    handleGasEstimate = ({
      safeId,
      chainId,
      localABIs: _localABIs = {},
      appState,
      arg,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      if (!safeId)
        throw new Error("Safe ID is required to estimate gas");
      const actions = yield handleMulticallArg({
        localABIs: _localABIs,
        chainId,
        appState,
        arg: {
          type: "multicall",
          actions: arg.actions,
          formActions: arg.formActions
        },
        rpcs,
        pinataApiKeys,
        explorerKeys
      });
      const {
        daoId
      } = appState;
      const metaTx = {
        to: import_keychain_utils.CONTRACT_KEYCHAINS.GNOSIS_MULTISEND[chainId],
        data: encodeMultiAction(actions),
        value: "0",
        operation: 1
      };
      const gasEstimate = yield gasEstimateFromActions({
        actions: encodeExecFromModule({
          safeId,
          metaTx
        }),
        actionsCount: actions.length,
        chainId,
        daoId,
        safeId
      });
      if (gasEstimate) {
        const buffer = arg.bufferPercentage || gasBufferMultiplier;
        return Math.round(Number(gasEstimate) * Number(buffer));
      } else {
        console.error(`Failed to estimate gas`);
        return 0;
      }
    });
    encodeMultiAction = (rawMulti) => {
      return (0, import_utils92.encodeFunction)(import_abis.LOCAL_ABI.GNOSIS_MULTISEND, "multiSend", [(0, import_safe_contracts.encodeMultiSend)(rawMulti)]);
    };
    encodeExecFromModule = ({
      safeId,
      metaTx
    }) => {
      return [{
        to: safeId,
        data: (0, import_utils92.encodeFunction)(import_abis.LOCAL_ABI.GNOSIS_MODULE, "execTransactionFromModule", [metaTx.to, metaTx.value, metaTx.data, metaTx.operation]),
        value: "0",
        operation: 0
      }];
    };
    buildMultiCallTX = ({
      id: id4,
      baalAddress: _baalAddress = CURRENT_DAO,
      actions,
      JSONDetails: _JSONDetails = basicDetails,
      formActions: _formActions = false,
      gasBufferPercentage
    }) => {
      return {
        id: id4,
        method: "submitProposal",
        contract: Object.assign(Object.assign({}, BaalContractBase), {
          type: "static",
          targetAddress: _baalAddress
        }),
        args: [{
          type: "multicall",
          actions,
          formActions: _formActions
        }, {
          type: "proposalExpiry",
          search: `${FORM}${EXPIRY}`,
          fallback: 0
        }, {
          type: "estimateGas",
          actions,
          formActions: _formActions,
          bufferPercentage: gasBufferPercentage
        }, _JSONDetails]
      };
    };
    handleArgEncode = ({
      arg,
      chainId,
      safeId,
      localABIs,
      appState,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const {
        args,
        solidityTypes
      } = arg;
      if (args.length !== solidityTypes.length) {
        throw new Error(`Arguments and types must be the same length`);
      }
      const processedArgs = yield Promise.all(args.map((arg2) => __awaiter17(void 0, void 0, void 0, function* () {
        return yield processArg({
          arg: arg2,
          chainId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
      })));
      console.log("processedArgs", processedArgs);
      return (0, import_utils92.encodeValues)(solidityTypes, processedArgs);
    });
    isSearchArg = (arg) => {
      return typeof arg === "string" && arg[0] === ".";
    };
    handleKeychainArg = ({
      chainId,
      keychain
    }) => {
      if (!keychain[chainId]) {
        throw new Error(`Could not find keychain for chainId: ${chainId}`);
      }
      return keychain[chainId];
    };
    handleArgCallback = ({
      tx,
      chainId,
      safeId,
      localABIs,
      appState,
      argCallbackRecord
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const callbackKey = tx.argCallback;
      if (callbackKey && argCallbackRecord[callbackKey]) {
        const callback = argCallbackRecord[callbackKey];
        const result = yield callback({
          tx,
          chainId,
          safeId,
          localABIs,
          appState
        });
        return result;
      }
      throw new Error(`Could not find argCallback: ${callbackKey}`);
    });
    processArg = ({
      arg,
      chainId,
      safeId,
      localABIs,
      appState,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      if (isSearchArg(arg)) {
        return searchArg({
          appState,
          searchString: arg,
          shouldThrow: true
        });
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "static") {
        return arg.value;
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "template") {
        const fragments = arg.value.split(/{|}/g);
        return fragments.map((f2) => f2[0] === "." ? searchArg({
          appState,
          searchString: f2,
          shouldThrow: true
        }) : f2).join("");
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "singleton") {
        return handleKeychainArg({
          chainId,
          keychain: arg.keychain
        });
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "nestedArray") {
        return Promise.all(arg.args.map((arg2) => __awaiter17(void 0, void 0, void 0, function* () {
          return yield processArg({
            arg: arg2,
            chainId,
            safeId,
            localABIs,
            appState,
            rpcs,
            pinataApiKeys,
            explorerKeys
          });
        })));
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "multicall" || arg.type === "encodeMulticall") {
        const actions = yield handleMulticallArg({
          arg,
          chainId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
        const result = yield handleEncodeMulticallArg({
          arg,
          actions
        });
        return result;
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "encodeCall") {
        const result = yield handleEncodeCallArg({
          arg,
          chainId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
        return result;
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "argEncode") {
        const result = yield handleArgEncode({
          arg,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
        return result;
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "ipfsPinata") {
        const result = yield handleIPFSPinata({
          arg,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
        return result;
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "estimateGas") {
        console.log("********ESTIMATE");
        const result = yield handleGasEstimate({
          arg,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
        return result;
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "proposalExpiry") {
        if (arg.search) {
          const result = searchArg({
            appState,
            searchString: arg.search,
            shouldThrow: false
          });
          return typeof result === "number" ? (0, import_utils92.calcExpiry)(result) : (0, import_utils92.calcExpiry)(arg.fallback);
        }
        return (0, import_utils92.calcExpiry)(arg.fallback);
      }
      if ((arg === null || arg === void 0 ? void 0 : arg.type) === "JSONDetails") {
        const result = yield handleDetailsJSON({
          arg,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        });
        return result;
      }
      console.log("**DEBUG**");
      console.log("arg", arg);
      throw new Error(`ArgType not found.`);
    });
    processArgs = ({
      tx,
      chainId,
      safeId,
      localABIs,
      appState,
      argCallbackRecord,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const {
        argCallback,
        args,
        staticArgs
      } = tx;
      if (staticArgs) {
        return staticArgs;
      }
      if (argCallback) {
        return handleArgCallback({
          tx,
          chainId,
          safeId,
          localABIs,
          appState,
          argCallbackRecord
        });
      }
      if (args) {
        return yield Promise.all(args === null || args === void 0 ? void 0 : args.map((arg) => __awaiter17(void 0, void 0, void 0, function* () {
          return yield processArg({
            arg,
            chainId,
            safeId,
            localABIs,
            appState,
            rpcs,
            pinataApiKeys,
            explorerKeys
          });
        })));
      }
      throw new Error("TX Lego must have a valid arg type, use either a string alias for an argument callback or an array of valid arguments");
    });
    handleProposalOfferingValue = ({
      appState,
      overrides,
      chainId,
      safeId,
      localABIs,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      var _a2, _b;
      if ((_a2 = appState["formValues"]) === null || _a2 === void 0 ? void 0 : _a2.proposalOffering) {
        return BigInt((_b = appState["formValues"]) === null || _b === void 0 ? void 0 : _b.proposalOffering);
      }
      return (overrides === null || overrides === void 0 ? void 0 : overrides.value) ? (0, import_utils92.toBigInt)(yield processArg({
        arg: overrides.value,
        chainId,
        safeId,
        localABIs,
        appState,
        rpcs,
        pinataApiKeys,
        explorerKeys
      })) : BigInt(0);
    });
    processOverrides = ({
      tx,
      chainId,
      safeId,
      localABIs,
      appState,
      rpcs,
      pinataApiKeys,
      explorerKeys
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const {
        overrides,
        staticOverrides
      } = tx;
      if (staticOverrides) {
        return Object.assign({
          value: BigInt(0)
        }, staticOverrides);
      }
      return {
        value: yield handleProposalOfferingValue({
          appState,
          overrides,
          chainId,
          safeId,
          localABIs,
          rpcs,
          pinataApiKeys,
          explorerKeys
        }),
        gasLimit: (overrides === null || overrides === void 0 ? void 0 : overrides.gasLimit) && (0, import_utils92.toBigInt)(yield processArg({
          arg: overrides.gasLimit,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        })),
        gasPrice: (overrides === null || overrides === void 0 ? void 0 : overrides.gasPrice) && (0, import_utils92.toBigInt)(yield processArg({
          arg: overrides.gasPrice,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        })),
        from: (overrides === null || overrides === void 0 ? void 0 : overrides.from) && (yield processArg({
          arg: overrides.from,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        })),
        blockTag: (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) && (yield processArg({
          arg: overrides.blockTag,
          chainId,
          safeId,
          localABIs,
          appState,
          rpcs,
          pinataApiKeys,
          explorerKeys
        }))
      };
    });
    sleep = (ms) => {
      return new Promise((resolve2) => setTimeout(resolve2, ms));
    };
    executeTx = (args) => __awaiter17(void 0, void 0, void 0, function* () {
      var _a2, _b, _c, _d, _e, _f;
      const {
        tx,
        txHash,
        publicClient,
        setTransactions,
        chainId,
        lifeCycleFns,
        graphApiKeys,
        appState
      } = args;
      console.log("**Transaction Initatiated**");
      console.log("txHash", txHash);
      console.log("publicClient", publicClient);
      try {
        (_a2 = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onTxHash) === null || _a2 === void 0 ? void 0 : _a2.call(lifeCycleFns, txHash);
        setTransactions((prevState) => Object.assign(Object.assign({}, prevState), {
          [txHash]: Object.assign(Object.assign({}, tx), {
            status: "idle"
          })
        }));
        console.log("**Transaction Pending**");
        const receipt = yield publicClient.waitForTransactionReceipt({
          hash: txHash
        });
        console.log("**Transaction Mined**");
        console.log("**Transaction Receipt**", receipt);
        if (receipt.status === "reverted") {
          throw new Error("CALL_EXCEPTION: txReceipt status 0");
        }
        setTransactions((prevState) => Object.assign(Object.assign({}, prevState), {
          [txHash]: Object.assign(Object.assign({}, tx), {
            status: "polling"
          })
        }));
        console.log("**Transaction Successful**");
        (_b = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onTxSuccess) === null || _b === void 0 ? void 0 : _b.call(lifeCycleFns, receipt, txHash, appState);
        if (!tx.disablePoll) {
          standardGraphPoll({
            poll: ((_c = tx === null || tx === void 0 ? void 0 : tx.customPoll) === null || _c === void 0 ? void 0 : _c.fetch) || pollLastTX,
            test: ((_d = tx === null || tx === void 0 ? void 0 : tx.customPoll) === null || _d === void 0 ? void 0 : _d.test) || testLastTX,
            variables: {
              chainId,
              txHash,
              graphApiKeys
            },
            onPollStart() {
              var _a3;
              (_a3 = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onPollStart) === null || _a3 === void 0 ? void 0 : _a3.call(lifeCycleFns);
              console.log("**Polling**");
            },
            onPollSuccess(result) {
              var _a3;
              (_a3 = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onPollSuccess) === null || _a3 === void 0 ? void 0 : _a3.call(lifeCycleFns, result, receipt, appState);
              console.log("**Poll Successful**");
              setTransactions((prevState) => Object.assign(Object.assign({}, prevState), {
                [txHash]: Object.assign(Object.assign({}, tx), {
                  status: "success"
                })
              }));
            },
            onPollError(error) {
              var _a3;
              (_a3 = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onPollError) === null || _a3 === void 0 ? void 0 : _a3.call(lifeCycleFns, error);
              console.log("**Poll Error**");
              setTransactions((prevState) => Object.assign(Object.assign({}, prevState), {
                [txHash]: Object.assign(Object.assign({}, tx), {
                  status: "pollFailed"
                })
              }));
            }
          });
        }
        return {
          receipt,
          txHash
        };
      } catch (error) {
        console.log("**TX Error**");
        console.error(error);
        if (String(error).indexOf("TransactionNotFoundError") > -1) {
          console.log("**Something went wrong in retrieving transaction hash...**");
          console.log("**wait for a few seconds and check safe service**");
          yield sleep(6e3);
          const url = import_keychain_utils.ENDPOINTS["GNOSIS_API"][chainId];
          if (!url) {
            return {
              error: (0, import_data_fetch_utils.formatFetchError)({
                type: "INVALID_NETWORK_ERROR"
              })
            };
          }
          try {
            const safeReceipt = yield import_data_fetch_utils.fetch.get(`${url}/multisig-transactions/${txHash}`);
            console.log("**safeReceipt with onchain transactionHash**", safeReceipt);
            console.log("**Rerun with new hash**");
            executeTx(Object.assign(Object.assign({}, args), {
              txHash: safeReceipt.transactionHash || txHash
            }));
          } catch (err) {
            console.error({
              error: (0, import_data_fetch_utils.formatFetchError)({
                type: "GNOSIS_ERROR",
                errorObject: err
              })
            });
            console.log("**Cant find hash, bail out.**");
            setTransactions((prevState) => Object.assign(Object.assign({}, prevState), {
              [txHash]: Object.assign(Object.assign({}, tx), {
                status: "success"
              })
            }));
            (_e = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onPollSuccess) === null || _e === void 0 ? void 0 : _e.call(lifeCycleFns, "Something went wrong in retrieving transaction hash...", {
              blockHash: zeroAddress,
              blockNumber: BigInt(0),
              from: zeroAddress,
              status: "success",
              contractAddress: zeroAddress,
              cumulativeGasUsed: BigInt(0),
              effectiveGasPrice: BigInt(0),
              gasUsed: BigInt(0),
              logs: [],
              logsBloom: zeroAddress,
              to: zeroAddress,
              transactionHash: txHash,
              transactionIndex: 0,
              type: "none"
            }, appState);
            return;
          }
        } else {
          (_f = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onTxError) === null || _f === void 0 ? void 0 : _f.call(lifeCycleFns, error);
          setTransactions((prevState) => Object.assign(Object.assign({}, prevState), {
            [txHash]: Object.assign(Object.assign({}, tx), {
              status: "failed"
            })
          }));
        }
        return;
      }
    });
    bundleLifeCycleFns = ({
      appEffects,
      componentEffects
    }) => {
      const allCycles = ["onRequestSign", "onTxHash", "onTxError", "onTxSuccess", "onPollStart", "onPollError", "onPollSuccess"];
      const blended = allCycles.reduce((acc, cycle) => {
        if (appEffects[cycle] && componentEffects[cycle]) {
          return Object.assign(Object.assign({}, acc), {
            [cycle]: (...args) => {
              var _a2, _b;
              (_a2 = appEffects[cycle]) === null || _a2 === void 0 ? void 0 : _a2.call(appEffects, ...args);
              (_b = componentEffects[cycle]) === null || _b === void 0 ? void 0 : _b.call(componentEffects, ...args);
            }
          });
        }
        if (appEffects[cycle]) {
          return Object.assign(Object.assign({}, acc), {
            [cycle]: appEffects[cycle]
          });
        }
        if (componentEffects[cycle]) {
          return Object.assign(Object.assign({}, acc), {
            [cycle]: componentEffects[cycle]
          });
        }
        return acc;
      }, {});
      return blended;
    };
    TxBuilderContext = (0, import_react.createContext)({
      transactions: {},
      fireTransaction: () => void 0,
      txAmt: 0,
      appState: void 0
    });
    TXBuilder = ({
      chainId,
      safeId,
      daoId,
      appState,
      children,
      localABIs: _localABIs = {},
      txLifeCycleFns: _txLifeCycleFns = {},
      argCallbackRecord: _argCallbackRecord = {},
      rpcs: _rpcs = import_keychain_utils.HAUS_RPC,
      graphApiKeys: _graphApiKeys = import_keychain_utils.GRAPH_API_KEYS,
      pinataApiKeys: _pinataApiKeys = import_keychain_utils.PINATA_API_KEYS,
      explorerKeys: _explorerKeys = import_keychain_utils.ABI_EXPLORER_KEYS,
      publicClient
    }) => {
      const [transactions, setTransactions] = (0, import_react.useState)({});
      const txAmt = (0, import_react.useMemo)(() => {
        return Object.values(transactions).length;
      }, [transactions]);
      const fireTransaction = ({
        tx,
        callerState,
        lifeCycleFns: _lifeCycleFns = {}
      }) => __awaiter17(void 0, void 0, void 0, function* () {
        var _a2;
        if (!chainId || !(0, import_keychain_utils.isValidNetwork)(chainId) || !publicClient) {
          (_a2 = _lifeCycleFns === null || _lifeCycleFns === void 0 ? void 0 : _lifeCycleFns.onTxError) === null || _a2 === void 0 ? void 0 : _a2.call(_lifeCycleFns, Error("Invalid Network or no Web3 Wallet detected"));
          return false;
        }
        const wholeState = Object.assign(Object.assign(Object.assign({}, appState), callerState), {
          chainId,
          safeId,
          daoId,
          localABIs: _localABIs
        });
        yield prepareTX({
          tx,
          chainId,
          safeId,
          setTransactions,
          appState: wholeState,
          argCallbackRecord: _argCallbackRecord,
          lifeCycleFns: bundleLifeCycleFns({
            appEffects: _txLifeCycleFns,
            componentEffects: _lifeCycleFns
          }),
          localABIs: _localABIs,
          rpcs: _rpcs,
          graphApiKeys: _graphApiKeys,
          pinataApiKeys: _pinataApiKeys,
          explorerKeys: _explorerKeys,
          publicClient
        });
        return true;
      });
      return (0, import_jsx_runtime.jsx)(TxBuilderContext.Provider, Object.assign({
        value: {
          transactions,
          fireTransaction,
          txAmt,
          appState
        }
      }, {
        children
      }));
    };
    useTxBuilder = () => (0, import_react.useContext)(TxBuilderContext);
    isActionError = (action) => {
      return action.error;
    };
    $ = _export;
    uncurryThis = functionUncurryThisClause;
    getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
    toLength = toLength$4;
    toString3 = toString$8;
    notARegExp = notARegexp;
    requireObjectCoercible = requireObjectCoercible$9;
    correctIsRegExpLogic = correctIsRegexpLogic;
    nativeStartsWith = uncurryThis("".startsWith);
    stringSlice = uncurryThis("".slice);
    min = Math.min;
    CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
    MDN_POLYFILL_BUG = !CORRECT_IS_REGEXP_LOGIC && !!function() {
      var descriptor = getOwnPropertyDescriptor2(String.prototype, "startsWith");
      return descriptor && !descriptor.writable;
    }();
    $({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
      startsWith: function startsWith(searchString) {
        var that = toString3(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
        var search = toString3(searchString);
        return nativeStartsWith ? nativeStartsWith(that, search, index) : stringSlice(that, index, index + search.length) === search;
      }
    });
    ({
      MultiABILoader: MultiABILoader2,
      SourcifyABILoader: SourcifyABILoader2
    } = loaders_exports);
    EtherscanABILoader2 = class {
      constructor(options) {
        this.chainId = options.chainId;
        this.rpcs = options.rpcs;
        this.explorerKeys = options.explorerKeys;
      }
      loadABI(address) {
        return __awaiter17(this, void 0, void 0, function* () {
          const abi = yield fetchABI({
            chainId: this.chainId,
            contractAddress: address,
            rpcs: this.rpcs,
            explorerKeys: this.explorerKeys
          });
          if (!abi || !(abi === null || abi === void 0 ? void 0 : abi.length)) {
            throw new Error("No ABI found for this contract");
          }
          return abi;
        });
      }
    };
    deepDecodeProposalActions = ({
      chainId,
      actionData,
      rpcs: _rpcs = import_keychain_utils.HAUS_RPC,
      explorerKeys: _explorerKeys = import_keychain_utils.ABI_EXPLORER_KEYS
    }) => __awaiter17(void 0, void 0, void 0, function* () {
      const abiLoader = new MultiABILoader2([new EtherscanABILoader2({
        chainId,
        rpcs: _rpcs,
        explorerKeys: _explorerKeys
      }), new SourcifyABILoader2()]);
      const options = {
        chainId,
        rpcs: _rpcs,
        explorerKeys: _explorerKeys,
        loader: abiLoader
      };
      return decodeMultiCall(options, actionData);
    });
    createActionError = (data2, message) => ({
      error: true,
      message,
      data: data2
    });
    decodeMultiCall = (options, data2) => __awaiter17(void 0, void 0, void 0, function* () {
      const proposalActions = decodeMulti(data2);
      const decodedProposalActions = yield Promise.all(proposalActions.map((action) => __awaiter17(void 0, void 0, void 0, function* () {
        try {
          return yield decodeAction(options, action);
        } catch (e) {
          return {
            error: true,
            message: e.message,
            data: data2
          };
        }
      })));
      return decodedProposalActions;
    });
    decodeValue = (value) => {
      if (typeof value === "string") {
        if (value.startsWith("0x")) {
          return fromHex(value, "bigint").toString();
        }
        return value;
      }
      if (typeof value === "number" || typeof value === "bigint") {
        return BigInt(value).toString();
      }
      return "0";
    };
    decodeMethod = (options) => {
      const result = decodeFunctionData(options);
      const functionDetails = getAbiItem({
        abi: options.abi,
        name: result.functionName
      });
      const inputs = functionDetails["inputs"] || [];
      const inputsWithValues = inputs.map((input, index) => {
        var _a2, _b, _c, _d, _e;
        return {
          name: input.name,
          type: input.type,
          value: Array.isArray((_a2 = result.args) === null || _a2 === void 0 ? void 0 : _a2[index]) ? ((_b = result.args) === null || _b === void 0 ? void 0 : _b[index]).length ? ((_c = result.args) === null || _c === void 0 ? void 0 : _c[index]).toString() : "[]" : ((_e = (_d = result.args) === null || _d === void 0 ? void 0 : _d[index]) === null || _e === void 0 ? void 0 : _e.toString()) || "0x"
        };
      });
      return {
        functionName: result.functionName,
        inputs: inputsWithValues
      };
    };
    actionDecoders = {
      "0x8d80ff0a": (options, action, decodedMethod) => __awaiter17(void 0, void 0, void 0, function* () {
        if (decodedMethod.functionName !== "multiSend" || decodedMethod.inputs.length !== 1) {
          return createActionError(action.data, "Could not decode action: multiSend");
        }
        const input = decodedMethod.inputs[0];
        if (input.type !== "bytes") {
          return createActionError(action.data, "Could not decode action: multiSend");
        }
        const decodedActions = yield decodeMultiCall(options, action.data);
        return {
          to: action.to,
          operation: action.operation || OperationType.DelegateCall,
          name: decodedMethod.functionName,
          value: decodeValue(action.value),
          params: decodedMethod.inputs,
          decodedActions
        };
      }),
      "0x468721a7": (options, action, decodedMethod) => __awaiter17(void 0, void 0, void 0, function* () {
        if (decodedMethod.functionName !== "execTransactionFromModule" || decodedMethod.inputs.length !== 4) {
          return createActionError(action.data, "Could not decode action: execTransactionFromModule");
        }
        const inputTo = decodedMethod.inputs[0];
        const inputValue = decodedMethod.inputs[1];
        const inputData = decodedMethod.inputs[2];
        const inputOperation = decodedMethod.inputs[3];
        if (inputTo.type !== "address" || inputValue.type !== "uint256" || inputData.type !== "bytes" || inputOperation.type !== "uint8") {
          return createActionError(action.data, "Could not decode action: execTransactionFromModule");
        }
        const decodedAction = yield decodeAction(options, {
          to: inputTo.value,
          data: inputData.value,
          value: decodeValue(inputValue === null || inputValue === void 0 ? void 0 : inputValue.value),
          operation: decodeValue(inputOperation === null || inputOperation === void 0 ? void 0 : inputOperation.value) === "1" ? OperationType.DelegateCall : OperationType.Call
        });
        return {
          to: action.to,
          operation: action.operation || OperationType.Call,
          name: decodedMethod.functionName,
          value: decodeValue(action.value),
          params: decodedMethod.inputs,
          decodedActions: [decodedAction]
        };
      }),
      "0xb3c98bbb": (options, action, decodedMethod) => __awaiter17(void 0, void 0, void 0, function* () {
        if (decodedMethod.functionName !== "executeAsBaal" || decodedMethod.inputs.length !== 3) {
          return createActionError(action.data, "Could not decode action: executeAsBaal");
        }
        const inputTo = decodedMethod.inputs[0];
        const inputValue = decodedMethod.inputs[1];
        const inputData = decodedMethod.inputs[2];
        if (inputTo.type !== "address" || inputValue.type !== "uint256" || inputData.type !== "bytes") {
          return createActionError(action.data, "Could not decode action: executeAsBaal");
        }
        const decodedAction = yield decodeAction(options, {
          to: inputTo.value,
          data: inputData.value,
          value: decodeValue(inputValue === null || inputValue === void 0 ? void 0 : inputValue.value),
          operation: OperationType.Call
        });
        return {
          to: action.to,
          operation: action.operation || OperationType.Call,
          name: decodedMethod.functionName,
          value: decodeValue(action.value),
          params: decodedMethod.inputs,
          decodedActions: [decodedAction]
        };
      }),
      "0xee4d88ed": (options, action, decodedMethod) => __awaiter17(void 0, void 0, void 0, function* () {
        const govTypes = [{
          name: "voting",
          type: "uint32"
        }, {
          name: "grace",
          type: "uint32"
        }, {
          name: "newOffering",
          type: "uint256"
        }, {
          name: "quorum",
          type: "uint256"
        }, {
          name: "sponsor",
          type: "uint256"
        }, {
          name: "minRetention",
          type: "uint256"
        }];
        const govValues = decodeAbiParameters(govTypes, decodedMethod.inputs[0].value);
        const govParams = govTypes.map((govType, i) => {
          return Object.assign(Object.assign({}, govType), {
            value: govValues[i]
          });
        });
        return {
          to: action.to,
          operation: action.operation || OperationType.Call,
          name: decodedMethod.functionName,
          value: decodeValue(action.value),
          params: govParams,
          decodedActions: []
        };
      })
    };
    decodeAction = (options, action) => __awaiter17(void 0, void 0, void 0, function* () {
      var _a2;
      const {
        data: data2,
        to,
        value,
        operation
      } = action;
      const {
        chainId,
        rpcs,
        loader
      } = options;
      if (!data2 || data2 === "0x" || !data2.startsWith("0x") || data2 === import_utils92.ENCODED_0X0_DATA || (yield getCode({
        chainId,
        contractAddress: action.to,
        rpcs
      })) === "0x") {
        return {
          to,
          operation: operation || OperationType.Call,
          name: `${(_a2 = import_keychain_utils.HAUS_NETWORK_DATA[chainId]) === null || _a2 === void 0 ? void 0 : _a2.symbol} Transfer`,
          value: decodeValue(value),
          params: [],
          decodedActions: []
        };
      }
      const {
        abi
      } = yield whatsabi_exports.autoload(to, {
        provider: new lib_exports21.JsonRpcProvider(rpcs[chainId]),
        followProxies: true,
        abiLoader: loader
      });
      if (!abi || !(abi === null || abi === void 0 ? void 0 : abi.length)) {
        return createActionError(data2, "Could not decode action: abi not found");
      }
      const decodedMethod = decodeMethod({
        abi,
        data: data2
      });
      if (!decodedMethod) {
        return createActionError(data2, "Could not decode action: method not found");
      }
      const methodSignature = data2.slice(0, 10);
      const actionDecoder = actionDecoders[methodSignature];
      if (actionDecoder) {
        return yield actionDecoder(options, action, decodedMethod);
      }
      return {
        to,
        operation: operation || OperationType.Call,
        name: decodedMethod.functionName,
        value: decodeValue(value),
        params: decodedMethod.inputs,
        decodedActions: []
      };
    });
    createEthersContract = ({
      address,
      abi,
      chainId,
      rpcs: _rpcs = import_keychain_utils.HAUS_RPC
    }) => {
      const rpcUrl = _rpcs[chainId];
      const ethersProvider = new ethers_exports.providers.JsonRpcProvider(rpcUrl);
      return new ethers_exports.Contract(address, abi, ethersProvider);
    };
  }
});

export {
  require_buffer,
  lib_exports,
  init_lib,
  lib_exports2,
  init_lib2,
  lib_exports3,
  init_lib4 as init_lib3,
  require_sha3,
  lib_exports4,
  init_lib5 as init_lib4,
  lib_exports5,
  init_lib6 as init_lib5,
  lib_exports6,
  init_lib7 as init_lib6,
  lib_exports8 as lib_exports7,
  init_lib9 as init_lib7,
  lib_exports9 as lib_exports8,
  init_lib10 as init_lib8,
  hashMessage,
  lib_exports10 as lib_exports9,
  init_lib12 as init_lib9,
  lib_exports11 as lib_exports10,
  init_lib13 as init_lib10,
  lib_exports12 as lib_exports11,
  init_lib16 as init_lib11,
  recoverAddress,
  lib_exports13 as lib_exports12,
  init_lib17 as init_lib12,
  lib_exports14 as lib_exports13,
  init_lib19 as init_lib13,
  lib_exports15 as lib_exports14,
  init_lib20 as init_lib14,
  lib_exports16 as lib_exports15,
  init_lib23 as init_lib15,
  lib_exports17 as lib_exports16,
  init_lib24 as init_lib16,
  lib_exports18 as lib_exports17,
  init_lib25 as init_lib17,
  lib_exports19 as lib_exports18,
  init_lib26 as init_lib18,
  lib_exports20 as lib_exports19,
  init_lib28 as init_lib19,
  lib_exports22 as lib_exports20,
  init_lib30 as init_lib20,
  lib_exports23 as lib_exports21,
  init_lib31 as init_lib21,
  getABIstore,
  getCachedABI,
  cacheABI,
  isProxyABI,
  getImplementation,
  processABI,
  fetchABI,
  getCode,
  checkArgType,
  deepSearch,
  searchApp,
  checkHasCondition,
  handleConditionalPath,
  searchArg,
  handleDetailsJSON,
  estimateFunctionalGas,
  txActionToMetaTx,
  handleEncodeCallArg,
  handleMulticallArg,
  gasEstimateFromActions,
  handleEncodeMulticallArg,
  handleGasEstimate,
  encodeMultiAction,
  encodeExecFromModule,
  buildMultiCallTX,
  handleArgEncode,
  executeTx,
  prepareTX,
  TxBuilderContext,
  TXBuilder,
  useTxBuilder,
  isActionError,
  deepDecodeProposalActions,
  createEthersContract,
  tx_builder_exports,
  init_tx_builder
};
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
//# sourceMappingURL=chunk-D5VMCTSK.js.map
