{
  "version": 3,
  "sources": ["../../viem/src/accounts/utils/parseAccount.ts", "../../viem/src/constants/abis.ts", "../../viem/src/constants/contract.ts", "../../viem/src/errors/version.ts", "../../viem/src/errors/utils.ts", "../../viem/src/errors/base.ts", "../../viem/src/errors/chain.ts", "../../viem/src/constants/solidity.ts", "../../viem/src/utils/abi/formatAbiItem.ts", "../../viem/src/utils/data/isHex.ts", "../../viem/src/utils/data/size.ts", "../../viem/src/errors/abi.ts", "../../viem/src/errors/data.ts", "../../viem/src/utils/data/slice.ts", "../../viem/src/utils/contract/extractFunctionParts.ts", "../../viem/src/utils/data/pad.ts", "../../viem/src/errors/encoding.ts", "../../viem/src/utils/data/trim.ts", "../../viem/src/utils/encoding/fromHex.ts", "../../viem/src/utils/encoding/toHex.ts", "../../viem/src/utils/encoding/toBytes.ts", "../../viem/node_modules/@noble/hashes/src/_assert.ts", "../../viem/node_modules/@noble/hashes/src/_u64.ts", "../../viem/node_modules/@noble/hashes/src/crypto.ts", "../../viem/node_modules/@noble/hashes/src/utils.ts", "../../viem/node_modules/@noble/hashes/src/sha3.ts", "../../viem/src/utils/hash/keccak256.ts", "../../viem/src/utils/hash/hashFunction.ts", "../../viem/src/utils/hash/getFunctionSelector.ts", "../../viem/src/errors/address.ts", "../../viem/src/utils/address/isAddress.ts", "../../viem/src/utils/address/getAddress.ts", "../../viem/src/utils/data/concat.ts", "../../viem/src/utils/abi/encodeAbiParameters.ts", "../../viem/src/utils/abi/decodeAbiParameters.ts", "../../viem/src/utils/abi/decodeErrorResult.ts", "../../viem/src/utils/stringify.ts", "../../viem/src/utils/abi/formatAbiItemWithArgs.ts", "../../viem/src/utils/abi/getAbiItem.ts", "../../viem/src/constants/unit.ts", "../../viem/src/utils/unit/formatUnits.ts", "../../viem/src/utils/unit/formatEther.ts", "../../viem/src/utils/unit/formatGwei.ts", "../../viem/src/errors/transaction.ts", "../../viem/src/errors/contract.ts", "../../viem/src/utils/abi/decodeFunctionResult.ts", "../../viem/src/utils/abi/encodeFunctionData.ts", "../../viem/src/utils/chain.ts", "../../viem/src/errors/node.ts", "../../viem/src/errors/request.ts", "../../viem/src/errors/rpc.ts", "../../viem/src/utils/errors/getNodeError.ts", "../../viem/src/utils/errors/getCallError.ts", "../../viem/src/utils/formatters/extract.ts", "../../viem/src/utils/formatters/formatter.ts", "../../viem/src/utils/formatters/transactionRequest.ts", "../../viem/src/utils/promise/createBatchScheduler.ts", "../../viem/src/utils/transaction/assertRequest.ts", "../../viem/src/actions/public/call.ts", "../../viem/src/errors/ccip.ts", "../../viem/src/utils/address/isAddressEqual.ts", "../../viem/src/utils/ccip.ts"],
  "sourcesContent": ["import type { Address } from 'abitype'\n\nimport type { Account } from '../types.js'\n\nexport function parseAccount(account: Address | Account): Account {\n  if (typeof account === 'string') return { address: account, type: 'json-rpc' }\n  return account\n}\n", "/* [Multicall3](https://github.com/mds1/multicall) */\nexport const multicall3Abi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            name: 'target',\n            type: 'address',\n          },\n          {\n            name: 'allowFailure',\n            type: 'bool',\n          },\n          {\n            name: 'callData',\n            type: 'bytes',\n          },\n        ],\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'aggregate3',\n    outputs: [\n      {\n        components: [\n          {\n            name: 'success',\n            type: 'bool',\n          },\n          {\n            name: 'returnData',\n            type: 'bytes',\n          },\n        ],\n        name: 'returnData',\n        type: 'tuple[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n\nconst universalResolverErrors = [\n  {\n    inputs: [],\n    name: 'ResolverNotFound',\n    type: 'error',\n  },\n  {\n    inputs: [],\n    name: 'ResolverWildcardNotSupported',\n    type: 'error',\n  },\n] as const\n\nexport const universalResolverResolveAbi = [\n  ...universalResolverErrors,\n  {\n    name: 'resolve',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes' },\n      { name: 'data', type: 'bytes' },\n    ],\n    outputs: [\n      { name: '', type: 'bytes' },\n      { name: 'address', type: 'address' },\n    ],\n  },\n] as const\n\nexport const universalResolverReverseAbi = [\n  ...universalResolverErrors,\n  {\n    name: 'reverse',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes', name: 'reverseName' }],\n    outputs: [\n      { type: 'string', name: 'resolvedName' },\n      { type: 'address', name: 'resolvedAddress' },\n      { type: 'address', name: 'reverseResolver' },\n      { type: 'address', name: 'resolver' },\n    ],\n  },\n] as const\n\nexport const textResolverAbi = [\n  {\n    name: 'text',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes32' },\n      { name: 'key', type: 'string' },\n    ],\n    outputs: [{ name: '', type: 'string' }],\n  },\n] as const\n\nexport const addressResolverAbi = [\n  {\n    name: 'addr',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ name: 'name', type: 'bytes32' }],\n    outputs: [{ name: '', type: 'address' }],\n  },\n  {\n    name: 'addr',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes32' },\n      { name: 'coinType', type: 'uint256' },\n    ],\n    outputs: [{ name: '', type: 'bytes' }],\n  },\n] as const\n\n// ERC-1271\n// isValidSignature(bytes32 hash, bytes signature) \u2192 bytes4 magicValue\nexport const smartAccountAbi = [\n  {\n    name: 'isValidSignature',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'hash', type: 'bytes32' },\n      { name: 'signature', type: 'bytes' },\n    ],\n    outputs: [{ name: '', type: 'bytes4' }],\n  },\n] as const\n\n// ERC-6492 - universal deployless signature validator contract\n// constructor(address _signer, bytes32 _hash, bytes _signature) \u2192 bytes4 returnValue\n// returnValue is either 0x1 (valid) or 0x0 (invalid)\nexport const universalSignatureValidatorAbi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_signer',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_hash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_signature',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n] as const\n", "export const aggregate3Signature = '0x82ad56cb'\n", "export const version = '1.5.4'\n", "import type { Address } from 'abitype'\n\nimport { version } from './version.js'\n\nexport const getContractAddress = (address: Address) => address\nexport const getUrl = (url: string) => url\nexport const getVersion = () => `viem@${version}`\n", "import { getVersion } from './utils.js'\n\ntype BaseErrorParameters = {\n  docsPath?: string\n  docsSlug?: string\n  metaMessages?: string[]\n} & (\n  | {\n      cause?: never\n      details?: string\n    }\n  | {\n      cause: BaseError | Error\n      details?: never\n    }\n)\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string\n  metaMessages?: string[]\n  shortMessage: string\n\n  override name = 'ViemError'\n  version = getVersion()\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    super()\n\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n        ? args.cause.message\n        : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n\n    this.message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath\n        ? [\n            `Docs: https://viem.sh${docsPath}.html${\n              args.docsSlug ? `#${args.docsSlug}` : ''\n            }`,\n          ]\n        : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: ${this.version}`,\n    ].join('\\n')\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nfunction walk(err: unknown, fn?: (err: unknown) => boolean): unknown {\n  if (fn?.(err)) return err\n  if (err && typeof err === 'object' && 'cause' in err)\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n", "import type { Chain } from '../types/chain.js'\n\nimport { BaseError } from './base.js'\n\nexport class ChainDoesNotSupportContract extends BaseError {\n  override name = 'ChainDoesNotSupportContract'\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint\n    chain: Chain\n    contract: { name: string; blockCreated?: number }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n      },\n    )\n  }\n}\n\nexport class ChainMismatchError extends BaseError {\n  override name = 'ChainMismatchError'\n\n  constructor({\n    chain,\n    currentChainId,\n  }: {\n    chain: Chain\n    currentChainId: number\n  }) {\n    super(\n      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`,\n        ],\n      },\n    )\n  }\n}\n\nexport class ChainNotFoundError extends BaseError {\n  override name = 'ChainNotFoundError'\n\n  constructor() {\n    super(\n      [\n        'No chain was provided to the request.',\n        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class ClientChainNotConfiguredError extends BaseError {\n  override name = 'ClientChainNotConfiguredError'\n\n  constructor() {\n    super('No chain was provided to the Client.')\n  }\n}\n\nexport class InvalidChainIdError extends BaseError {\n  override name = 'InvalidChainIdError'\n\n  constructor({ chainId }: { chainId: number }) {\n    super(`Chain ID \"${chainId}\" is invalid.`)\n  }\n}\n", "import type { AbiError } from 'abitype'\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as const\n\nexport const solidityError: AbiError = {\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n}\nexport const solidityPanic: AbiError = {\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint256',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n}\n", "import type { AbiParameter } from 'abitype'\n\nimport { InvalidDefinitionTypeError } from '../../errors/abi.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n", "import type { Hex } from '../../types/misc.js'\n\nexport function isHex(\n  value: unknown,\n  { strict = true }: { strict?: boolean } = {},\n): value is Hex {\n  if (!value) return false\n  if (typeof value !== 'string') return false\n  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x')\n}\n", "import type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { isHex } from './isHex.js'\n\n/**\n * @description Retrieves the size of the value (in bytes).\n *\n * @param value The value (hex or byte array) to retrieve the size of.\n * @returns The size of the value (in bytes).\n */\nexport function size(value: Hex | ByteArray) {\n  if (isHex(value, { strict: false })) return Math.ceil((value.length - 2) / 2)\n  return value.length\n}\n", "import type { AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport class AbiConstructorNotFoundError extends BaseError {\n  override name = 'AbiConstructorNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  override name = 'AbiConstructorParamsNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  override name = 'AbiDecodingDataSizeInvalidError'\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      { metaMessages: [`Data: ${data} (${size} bytes)`] },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  override name = 'AbiDecodingDataSizeTooSmallError'\n\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class AbiDecodingZeroDataError extends BaseError {\n  override name = 'AbiDecodingZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  override name = 'AbiEncodingBytesSizeMismatchError'\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  override name = 'AbiErrorInputsNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorNotFoundError extends BaseError {\n  override name = 'AbiErrorNotFoundError'\n  constructor(errorName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  override name = 'AbiErrorSignatureNotFoundError'\n\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  override name = 'AbiEventSignatureEmptyTopicsError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n    })\n  }\n}\n\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  override name = 'AbiEventSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiEventNotFoundError extends BaseError {\n  override name = 'AbiEventNotFoundError'\n  constructor(eventName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionNotFoundError extends BaseError {\n  override name = 'AbiFunctionNotFoundError'\n  constructor(functionName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  override name = 'AbiFunctionOutputsNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  override name = 'AbiFunctionSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class BytesSizeMismatchError extends BaseError {\n  override name = 'BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\nexport class DecodeLogDataMismatch extends BaseError {\n  override name = 'DecodeLogDataMismatch'\n\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class DecodeLogTopicsMismatch extends BaseError {\n  override name = 'DecodeLogTopicsMismatch'\n\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  override name = 'InvalidAbiEncodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  override name = 'InvalidAbiDecodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidArrayError extends BaseError {\n  override name = 'InvalidArrayError'\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'))\n  }\n}\n\nexport class InvalidDefinitionTypeError extends BaseError {\n  override name = 'InvalidDefinitionTypeError'\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class UnsupportedPackedAbiType extends BaseError {\n  override name = 'UnsupportedPackedAbiType'\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`)\n  }\n}\n", "import { BaseError } from './base.js'\n\nexport class SliceOffsetOutOfBoundsError extends BaseError {\n  override name = 'SliceOffsetOutOfBoundsError'\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \"${offset}\" is out-of-bounds (size: ${size}).`,\n    )\n  }\n}\n\nexport class SizeExceedsPaddingSizeError extends BaseError {\n  override name = 'SizeExceedsPaddingSizeError'\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'hex' | 'bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`,\n    )\n  }\n}\n", "import { SliceOffsetOutOfBoundsError } from '../../errors/data.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { isHex } from './isHex.js'\nimport { size } from './size.js'\n\nexport type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<TValue extends ByteArray | Hex>(\n  value: TValue,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): SliceReturnType<TValue> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<TValue>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<TValue>\n}\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nfunction assertEndOffset(value: Hex | ByteArray, start?: number, end?: number) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n", "const paramsRegex = /((function|event)\\s)?(.*)(\\((.*)\\))/\n\nexport function extractFunctionParts(def: string) {\n  const parts = def.match(paramsRegex)\n  const type = parts?.[2] || undefined\n  const name = parts?.[3]\n  const params = parts?.[5] || undefined\n  return { type, name, params }\n}\n\nexport function extractFunctionName(def: string) {\n  return extractFunctionParts(def).name\n}\n\nexport function extractFunctionParams(def: string) {\n  const params = extractFunctionParts(def).params\n  const splitParams = params?.split(',').map((x) => x.trim().split(' '))\n  return splitParams?.map((param) => ({\n    type: param[0],\n    name: param[1] === 'indexed' ? param[2] : param[1],\n    ...(param[1] === 'indexed' ? { indexed: true } : {}),\n  }))\n}\n\nexport function extractFunctionType(def: string) {\n  return extractFunctionParts(def).type\n}\n", "import { SizeExceedsPaddingSizeError } from '../../errors/data.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\ntype PadOptions = {\n  dir?: 'left' | 'right'\n  size?: number | null\n}\nexport type PadReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport function pad<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir, size = 32 }: PadOptions = {},\n): PadReturnType<TValue> {\n  if (typeof hexOrBytes === 'string')\n    return padHex(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n  return padBytes(hexOrBytes, { dir, size }) as PadReturnType<TValue>\n}\n\nexport function padHex(hex_: Hex, { dir, size = 32 }: PadOptions = {}) {\n  if (size === null) return hex_\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](\n    size * 2,\n    '0',\n  )}` as Hex\n}\n\nexport function padBytes(\n  bytes: ByteArray,\n  { dir, size = 32 }: PadOptions = {},\n) {\n  if (size === null) return bytes\n  if (bytes.length > size)\n    throw new SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]\n  }\n  return paddedBytes\n}\n", "import type { ByteArray, Hex } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport class DataLengthTooLongError extends BaseError {\n  override name = 'DataLengthTooLongError'\n  constructor({ consumed, length }: { consumed: number; length: number }) {\n    super(\n      `Consumed bytes (${consumed}) is shorter than data length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport class DataLengthTooShortError extends BaseError {\n  override name = 'DataLengthTooShortError'\n  constructor({ length, dataLength }: { length: number; dataLength: number }) {\n    super(\n      `Data length (${dataLength - 1}) is shorter than prefix length (${\n        length - 1\n      }).`,\n    )\n  }\n}\n\nexport class IntegerOutOfRangeError extends BaseError {\n  override name = 'IntegerOutOfRangeError'\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string\n    min: string\n    signed?: boolean\n    size?: number\n    value: string\n  }) {\n    super(\n      `Number \"${value}\" is not in safe ${\n        size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''\n      }integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`,\n    )\n  }\n}\n\nexport class InvalidBytesBooleanError extends BaseError {\n  override name = 'InvalidBytesBooleanError'\n  constructor(bytes: ByteArray) {\n    super(\n      `Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`,\n    )\n  }\n}\n\nexport class InvalidHexBooleanError extends BaseError {\n  override name = 'InvalidHexBooleanError'\n  constructor(hex: Hex) {\n    super(\n      `Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`,\n    )\n  }\n}\n\nexport class InvalidHexValueError extends BaseError {\n  override name = 'InvalidHexValueError'\n  constructor(value: Hex) {\n    super(\n      `Hex value \"${value}\" is an odd length (${value.length}). It must be an even length.`,\n    )\n  }\n}\n\nexport class OffsetOutOfBoundsError extends BaseError {\n  override name = 'OffsetOutOfBoundsError'\n  constructor({ nextOffset, offset }: { nextOffset: number; offset: number }) {\n    super(\n      `Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`,\n    )\n  }\n}\n\nexport class SizeOverflowError extends BaseError {\n  override name = 'SizeOverflowError'\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`,\n    )\n  }\n}\n", "import type { ByteArray, Hex } from '../../types/misc.js'\n\ntype TrimOptions = {\n  dir?: 'left' | 'right'\n}\nexport type TrimReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\nexport function trim<TValue extends ByteArray | Hex>(\n  hexOrBytes: TValue,\n  { dir = 'left' }: TrimOptions = {},\n): TrimReturnType<TValue> {\n  let data: any =\n    typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (typeof hexOrBytes === 'string') {\n    if (data.length === 1 && dir === 'right') data = `${data}0`\n    return `0x${\n      data.length % 2 === 1 ? `0${data}` : data\n    }` as TrimReturnType<TValue>\n  }\n  return data as TrimReturnType<TValue>\n}\n", "import {\n  InvalidHexBooleanError,\n  SizeOverflowError,\n} from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { size as size_ } from '../data/size.js'\nimport { trim } from '../data/trim.js'\n\nimport { hexToBytes } from './toBytes.js'\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | TTo\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number\n      /** Type to convert to. */\n      to: TTo\n    }\n\nexport type FromHexReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'bigint'\n  ? bigint\n  : TTo extends 'number'\n  ? number\n  : TTo extends 'bytes'\n  ? ByteArray\n  : TTo extends 'boolean'\n  ? boolean\n  : never\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html\n * - Example: https://viem.sh/docs/utilities/fromHex.html#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<TTo>): FromHexReturnType<TTo> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<TTo>\n  return hexToBytes(hex, opts) as FromHexReturnType<TTo>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n", "import { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { pad } from '../data/pad.js'\n\nimport { assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let hexString = ''\n  for (let i = 0; i < value.length; i++) {\n    hexString += hexes[value[i]]\n  }\n\n  const hex: Hex = `0x${hexString}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: never\n      /** The size (in bytes) of the output hex value. */\n      size?: number\n    }\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n", "import { BaseError } from '../../errors/base.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isHex } from '../data/isHex.js'\nimport { pad } from '../data/pad.js'\n\nimport { assertSize } from './fromHex.js'\nimport { type NumberToHexOpts, numberToHex } from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html\n * - Example: https://viem.sh/docs/utilities/toBytes.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToHexOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const bytes = new Uint8Array(hexString.length / 2)\n  for (let index = 0; index < bytes.length; index++) {\n    const start = index * 2\n    const hexByte = hexString.slice(start, start + 2)\n    const byte = Number.parseInt(hexByte, 16)\n    if (Number.isNaN(byte) || byte < 0)\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexByte}\" in \"${hexString}\").`,\n      )\n    bytes[index] = byte\n  }\n  return bytes\n}\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value: bigint | number, opts?: NumberToHexOpts) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n", "export function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nexport function bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nexport function bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nexport function hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nexport function exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexport function output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output,\n};\n\nexport default assert;\n", "const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nexport function split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nexport const toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h: number, l: number) => l;\nconst rotr32L = (h: number, l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "declare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use `globalThis.crypto`, but node.js versions earlier than v19 don't\n// declare it in global scope. For node.js, package.json#exports field mapping\n// rewrites import from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'\n */\nexport function bytesToHex(uint8a: Uint8Array): string {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('deadbeef') // Uint8Array.from([0xde, 0xad, 0xbe, 0xef])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\n\nexport type Input = Uint8Array | string;\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  if (!arrays.every((a) => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashConstructor: () => Hash<T>) {\n  const hashC = (message: Input): Uint8Array => hashConstructor().update(toBytes(message)).digest();\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashConstructor();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\nconst rotlL = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \u03B8\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (\u03C1) and Pi (\u03C0)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (\u03C7)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (\u03B9)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    assert.number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    assert.exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    assert.exists(this, false);\n    assert.bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    assert.number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    assert.output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = gen(0x06, 136, 256 / 8);\nexport const sha3_384 = gen(0x06, 104, 384 / 8);\nexport const sha3_512 = gen(0x06, 72, 512 / 8);\nexport const keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = gen(0x01, 136, 256 / 8);\nexport const keccak_384 = gen(0x01, 104, 384 / 8);\nexport const keccak_512 = gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructorWithOpts<Keccak, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = genShake(0x1f, 168, 128 / 8);\nexport const shake256 = genShake(0x1f, 136, 256 / 8);\n", "import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isHex } from '../data/isHex.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport function keccak256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo,\n): Keccak256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<TTo>\n  return toHex(bytes) as Keccak256Hash<TTo>\n}\n", "import { formatAbiItem } from '../abi/formatAbiItem.js'\nimport {\n  extractFunctionName,\n  extractFunctionParams,\n} from '../contract/extractFunctionParts.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport type { AbiEvent, AbiFunction } from 'abitype'\n\nimport { keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport function hashFunction(def: string) {\n  const name = extractFunctionName(def)\n  const params = extractFunctionParams(def) || []\n  return hash(`${name}(${params.map(({ type }) => type).join(',')})`)\n}\n\nexport function hashAbiItem(abiItem: AbiFunction | AbiEvent) {\n  return hash(formatAbiItem(abiItem))\n}\n", "import { slice } from '../data/slice.js'\nimport type { AbiFunction } from 'abitype'\n\nimport { hashAbiItem, hashFunction } from './hashFunction.js'\n\nexport const getFunctionSelector = (fn: string | AbiFunction) => {\n  if (typeof fn === 'string') return slice(hashFunction(fn), 0, 4)\n  return slice(hashAbiItem(fn), 0, 4)\n}\n", "import { BaseError } from './base.js'\n\nexport class InvalidAddressError extends BaseError {\n  override name = 'InvalidAddressError'\n  constructor({ address }: { address: string }) {\n    super(`Address \"${address}\" is invalid.`)\n  }\n}\n", "import type { Address } from 'abitype'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\nexport function isAddress(address: string): address is Address {\n  return addressRegex.test(address)\n}\n", "import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport { stringToBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\nimport { isAddress } from './isAddress.js'\n\nexport function checksumAddress(address_: Address, chainId?: number): Address {\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  return `0x${address.join('')}`\n}\n\nexport function getAddress(address: string, chainId?: number): Address {\n  if (!isAddress(address)) throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n", "import type { ByteArray, Hex } from '../../types/misc.js'\n\nexport type ConcatReturnType<TValue extends Hex | ByteArray> =\n  TValue extends Hex ? Hex : ByteArray\n\nexport function concat<TValue extends Hex | ByteArray>(\n  values: TValue[],\n): ConcatReturnType<TValue> {\n  if (typeof values[0] === 'string')\n    return concatHex(values as Hex[]) as ConcatReturnType<TValue>\n  return concatBytes(values as ByteArray[]) as ConcatReturnType<TValue>\n}\n\nexport function concatBytes(values: ByteArray[]): ByteArray {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  let offset = 0\n  for (const arr of values) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n  return result\n}\n\nexport function concatHex(values: Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace('0x', ''),\n    '',\n  )}`\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  AbiEncodingBytesSizeMismatchError,\n  AbiEncodingLengthMismatchError,\n  InvalidAbiEncodingTypeError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { Hex } from '../../types/misc.js'\nimport { isAddress } from '../address/isAddress.js'\nimport { concat } from '../data/concat.js'\nimport { padHex } from '../data/pad.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n */\nexport function encodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: Narrow<TParams>,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\nfunction prepareParams<TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: Narrow<TParams>\n  values: AbiParametersToPrimitiveTypes<TParams>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\nfunction prepareParam<TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam\n  value: AbiParameterToPrimitiveType<TParam>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\nfunction encodeArray<TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: TParam\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nfunction encodeBytes<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== parseInt(paramSize))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: parseInt(paramSize),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\nfunction encodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n} from '../../errors/abi.js'\nimport type { Hex } from '../../types/misc.js'\nimport { checksumAddress } from '../address/getAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { trim } from '../data/trim.js'\nimport {\n  hexToBigInt,\n  hexToBool,\n  hexToNumber,\n  hexToString,\n} from '../encoding/fromHex.js'\n\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends\n    | readonly AbiParameter[]\n    | readonly unknown[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport function decodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(params: Narrow<TParams>, data: Hex): DecodeAbiParametersReturnType<TParams> {\n  if (data === '0x' && (params as unknown[]).length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n  return decodeParams({\n    data,\n    params: params as readonly AbiParameter[],\n  }) as unknown as DecodeAbiParametersReturnType<TParams>\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\nfunction decodeParams<TParams extends readonly AbiParameter[]>({\n  data,\n  params,\n}: { data: Hex; params: TParams }) {\n  const decodedValues: unknown[] = []\n  let position = 0\n\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data))\n      throw new AbiDecodingDataSizeTooSmallError({\n        data,\n        params,\n        size: size(data),\n      })\n\n    const param = params[i]\n    const { consumed, value } = decodeParam({ data, param, position })\n    decodedValues.push(value)\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed\n  }\n\n  return decodedValues as unknown as AbiParametersToPrimitiveTypes<TParams>\n}\n\nfunction decodeParam({\n  data,\n  param,\n  position,\n}: { data: Hex; param: AbiParameter; position: number }): {\n  consumed: number\n  value: any\n} {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(data, {\n      length,\n      param: { ...param, type: type } as AbiParameter,\n      position,\n    })\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, { param: param as TupleAbiParameter, position })\n  }\n  if (param.type === 'string') {\n    return decodeString(data, { position })\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, { param, position })\n  }\n\n  const value = slice(data, position, position + 32, { strict: true }) as Hex\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, { param })\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value)\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value)\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n\nfunction decodeAddress(value: Hex) {\n  return { consumed: 32, value: checksumAddress(slice(value, -20)) }\n}\n\nfunction decodeArray<TParam extends AbiParameter>(\n  data: Hex,\n  {\n    param,\n    length,\n    position,\n  }: {\n    param: TParam\n    length: number | null\n    position: number\n  },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Get the length of the array from the offset.\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type)\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0]\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(\n        slice(data, position, position + 32, { strict: true }),\n      )\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0\n  const value: AbiParameterToPrimitiveType<TParam>[] = []\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value.push(decodedChild.value)\n  }\n  return { value, consumed }\n}\n\nfunction decodeBool(value: Hex) {\n  return { consumed: 32, value: hexToBool(value) }\n}\n\nfunction decodeBytes<TParam extends AbiParameter>(\n  data: Hex,\n  { param, position }: { param: TParam; position: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n    // If there is no length, we have zero data.\n    if (length === 0) return { consumed: 32, value: '0x' }\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true,\n    })\n    return { consumed: 32, value }\n  }\n\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true,\n  })\n  return { consumed: 32, value }\n}\n\nfunction decodeNumber<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n) {\n  const signed = param.type.startsWith('int')\n  const size = parseInt(param.type.split('int')[1] || '256')\n  return {\n    consumed: 32,\n    value:\n      size > 48\n        ? hexToBigInt(value, { signed })\n        : hexToNumber(value, { signed }),\n  }\n}\n\nfunction decodeString(data: Hex, { position }: { position: number }) {\n  const offset = hexToNumber(\n    slice(data, position, position + 32, { strict: true }),\n  )\n  const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }))\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return { consumed: 32, value: '' }\n  const value = hexToString(\n    trim(slice(data, offset + 32, offset + 32 + length, { strict: true })),\n  )\n  return { consumed: 32, value }\n}\n\nfunction decodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(data: Hex, { param, position }: { param: TParam; position: number }) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n    }\n    return { consumed: 32, value }\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n  }\n  return { consumed, value }\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n", "import type {\n  Abi,\n  ExtractAbiError,\n  ExtractAbiErrorNames,\n  Narrow,\n} from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  AbiErrorSignatureNotFoundError,\n} from '../../errors/abi.js'\nimport type { AbiItem, GetErrorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { slice } from '../data/slice.js'\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = { abi?: Narrow<TAbi>; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  _ErrorNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiErrorNames<TAbi>\n    : string,\n> = {\n  [TName in _ErrorNames]: {\n    abiItem: TAbi extends Abi ? ExtractAbiError<TAbi, TName> : AbiItem\n    args: GetErrorArgs<TAbi, TName>['args']\n    errorName: TName\n  }\n}[_ErrorNames]\n\nexport function decodeErrorResult<TAbi extends Abi | readonly unknown[]>({\n  abi,\n  data,\n}: DecodeErrorResultParameters<TAbi>): DecodeErrorResultReturnType<TAbi> {\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...((abi as Abi) || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === getFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args: ('inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n      ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<TAbi>\n}\n", "export const stringify: typeof JSON.stringify = (value, replacer, space) =>\n  JSON.stringify(\n    value,\n    (key, value_) => {\n      const value = typeof value_ === 'bigint' ? value_.toString() : value_\n      return typeof replacer === 'function' ? replacer(key, value) : value\n    },\n    space,\n  )\n", "import type { AbiParameter } from 'abitype'\n\nimport type { AbiItem } from '../../types/contract.js'\nimport { stringify } from '../stringify.js'\n\nexport function formatAbiItemWithArgs({\n  abiItem,\n  args,\n  includeFunctionName = true,\n  includeName = false,\n}: {\n  abiItem: AbiItem\n  args: readonly unknown[]\n  includeFunctionName?: boolean\n  includeName?: boolean\n}) {\n  if (!('name' in abiItem)) return\n  if (!('inputs' in abiItem)) return\n  if (!abiItem.inputs) return\n  return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs\n    .map(\n      (input: AbiParameter, i: number) =>\n        `${includeName && input.name ? `${input.name}: ` : ''}${\n          typeof args[i] === 'object' ? stringify(args[i]) : args[i]\n        }`,\n    )\n    .join(', ')})`\n}\n", "import type { Abi, AbiParameter, Address, Narrow } from 'abitype'\n\nimport type { GetFunctionArgs, InferItemName } from '../../types/contract.js'\nimport { isAddress } from '../address/isAddress.js'\n\nexport type GetAbiItemParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  name: InferItemName<TAbi, TItemName>\n} & Partial<GetFunctionArgs<TAbi, TItemName>>\n\nexport type GetAbiItemReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = Extract<\n  TAbi[number],\n  {\n    name: TItemName\n  }\n>\n\nexport function getAbiItem<\n  TAbi extends Abi | readonly unknown[],\n  TItemName extends string,\n>({\n  abi,\n  args = [],\n  name,\n}: GetAbiItemParameters<TAbi, TItemName>): GetAbiItemReturnType<\n  TAbi,\n  TItemName\n> {\n  const abiItems = (abi as Abi).filter((x) => 'name' in x && x.name === name)\n\n  if (abiItems.length === 0) return undefined as any\n  if (abiItems.length === 1) return abiItems[0] as any\n\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem as any\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = (args as readonly unknown[]).every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter as AbiParameter)\n    })\n    if (matched) return abiItem as any\n  }\n  return abiItems[0] as any\n}\n\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address)\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n", "export const etherUnits = {\n  gwei: 9,\n  wei: 18,\n}\nexport const gweiUnits = {\n  ether: -9,\n  wei: 9,\n}\nexport const weiUnits = {\n  ether: -18,\n  gwei: -9,\n}\n", "export function formatUnits(value: bigint, decimals: number) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n", "import { etherUnits } from '../../constants/unit.js'\n\nimport { formatUnits } from './formatUnits.js'\n\nexport function formatEther(wei: bigint, unit: 'wei' | 'gwei' = 'wei') {\n  return formatUnits(wei, etherUnits[unit])\n}\n", "import { gweiUnits } from '../../constants/unit.js'\n\nimport { formatUnits } from './formatUnits.js'\n\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n", "import type { Account } from '../accounts/types.js'\nimport type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'\nimport type { BlockTag } from '../types/block.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hash, Hex } from '../types/misc.js'\nimport type { TransactionType } from '../types/transaction.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport class FeeConflictError extends BaseError {\n  override name = 'FeeConflictError'\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class InvalidLegacyVError extends BaseError {\n  override name = 'InvalidLegacyVError'\n\n  constructor({ v }: { v: bigint }) {\n    super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`)\n  }\n}\n\nexport class InvalidSerializableTransactionError extends BaseError {\n  override name = 'InvalidSerializableTransactionError'\n\n  constructor({ transaction }: { transaction: Record<string, unknown> }) {\n    super('Cannot infer a transaction type from provided transaction.', {\n      metaMessages: [\n        'Provided Transaction:',\n        '{',\n        prettyPrint(transaction),\n        '}',\n        '',\n        'To infer the type, either provide:',\n        '- a `type` to the Transaction, or',\n        '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n        '- a Legacy Transaction with `gasPrice`',\n      ],\n    })\n  }\n}\n\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n  override name = 'InvalidSerializedTransactionType'\n\n  serializedType: Hex\n\n  constructor({ serializedType }: { serializedType: Hex }) {\n    super(`Serialized transaction type \"${serializedType}\" is invalid.`)\n\n    this.serializedType = serializedType\n  }\n}\n\nexport class InvalidSerializedTransactionError extends BaseError {\n  override name = 'InvalidSerializedTransactionError'\n\n  serializedTransaction: Hex\n  type: TransactionType\n\n  constructor({\n    attributes,\n    serializedTransaction,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serializedTransaction: Hex\n    type: TransactionType\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serializedTransaction}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n    })\n\n    this.serializedTransaction = serializedTransaction\n    this.type = type\n  }\n}\n\nexport class InvalidStorageKeySizeError extends BaseError {\n  override name = 'InvalidStorageKeySizeError'\n\n  constructor({ storageKey }: { storageKey: Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor(\n        (storageKey.length - 2) / 2,\n      )} bytes.`,\n    )\n  }\n}\n\nexport class TransactionExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'TransactionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {\n      account: Account\n      chain?: Chain\n      docsPath?: string\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport class TransactionNotFoundError extends BaseError {\n  override name = 'TransactionNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash\n    blockNumber?: bigint\n    blockTag?: BlockTag\n    hash?: Hash\n    index?: number\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n\nexport class TransactionReceiptNotFoundError extends BaseError {\n  override name = 'TransactionReceiptNotFoundError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n    )\n  }\n}\n\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  override name = 'WaitForTransactionReceiptTimeoutError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n    )\n  }\n}\n", "import type { Abi, Address } from 'abitype'\n\nimport { parseAccount } from '../accounts/utils/parseAccount.js'\nimport type { CallParameters } from '../actions/public/call.js'\nimport { panicReasons } from '../constants/solidity.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\nimport {\n  type DecodeErrorResultReturnType,\n  decodeErrorResult,\n} from '../utils/abi/decodeErrorResult.js'\nimport { formatAbiItem } from '../utils/abi/formatAbiItem.js'\nimport { formatAbiItemWithArgs } from '../utils/abi/formatAbiItemWithArgs.js'\nimport { getAbiItem } from '../utils/abi/getAbiItem.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { AbiErrorSignatureNotFoundError } from './abi.js'\nimport { BaseError } from './base.js'\nimport { prettyPrint } from './transaction.js'\nimport { getContractAddress } from './utils.js'\n\nexport class CallExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'CallExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account: account_,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: CallParameters & { chain?: Chain; docsPath?: string },\n  ) {\n    const account = account_ ? parseAccount(account_) : undefined\n    const prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Raw Call Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport class ContractFunctionExecutionError extends BaseError {\n  abi: Abi\n  args?: unknown[]\n  override cause: BaseError\n  contractAddress?: Address\n  formattedArgs?: string\n  functionName: string\n  sender?: Address\n\n  override name = 'ContractFunctionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      abi,\n      args,\n      contractAddress,\n      docsPath,\n      functionName,\n      sender,\n    }: {\n      abi: Abi\n      args?: any\n      contractAddress?: Address\n      docsPath?: string\n      functionName: string\n      sender?: Address\n    },\n  ) {\n    const abiItem = getAbiItem({ abi, args, name: functionName })\n    const formattedArgs = abiItem\n      ? formatAbiItemWithArgs({\n          abiItem,\n          args,\n          includeFunctionName: false,\n          includeName: false,\n        })\n      : undefined\n    const functionWithParams = abiItem\n      ? formatAbiItem(abiItem, { includeName: true })\n      : undefined\n\n    const prettyArgs = prettyPrint({\n      address: contractAddress && getContractAddress(contractAddress),\n      function: functionWithParams,\n      args:\n        formattedArgs &&\n        formattedArgs !== '()' &&\n        `${[...Array(functionName?.length ?? 0).keys()]\n          .map(() => ' ')\n          .join('')}${formattedArgs}`,\n      sender,\n    })\n\n    super(\n      cause.shortMessage ||\n        `An unknown error occurred while executing the contract function \"${functionName}\".`,\n      {\n        cause,\n        docsPath,\n        metaMessages: [\n          ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n          'Contract Call:',\n          prettyArgs,\n        ].filter(Boolean) as string[],\n      },\n    )\n    this.abi = abi\n    this.args = args\n    this.cause = cause\n    this.contractAddress = contractAddress\n    this.functionName = functionName\n    this.sender = sender\n  }\n}\n\nexport class ContractFunctionRevertedError extends BaseError {\n  override name = 'ContractFunctionRevertedError'\n\n  data?: DecodeErrorResultReturnType\n  reason?: string\n  signature?: Hex\n\n  constructor({\n    abi,\n    data,\n    functionName,\n    message,\n  }: { abi: Abi; data?: Hex; functionName: string; message?: string }) {\n    let cause: Error | undefined\n    let decodedData: DecodeErrorResultReturnType | undefined = undefined\n    let metaMessages\n    let reason\n    if (data && data !== '0x') {\n      try {\n        decodedData = decodeErrorResult({ abi, data })\n        const { abiItem, errorName, args: errorArgs } = decodedData\n        if (errorName === 'Error') {\n          reason = (errorArgs as [string])[0]\n        } else if (errorName === 'Panic') {\n          const [firstArg] = errorArgs as [number]\n          reason = panicReasons[firstArg as keyof typeof panicReasons]\n        } else {\n          const errorWithParams = abiItem\n            ? formatAbiItem(abiItem, { includeName: true })\n            : undefined\n          const formattedArgs =\n            abiItem && errorArgs\n              ? formatAbiItemWithArgs({\n                  abiItem,\n                  args: errorArgs,\n                  includeFunctionName: false,\n                  includeName: false,\n                })\n              : undefined\n\n          metaMessages = [\n            errorWithParams ? `Error: ${errorWithParams}` : '',\n            formattedArgs && formattedArgs !== '()'\n              ? `       ${[...Array(errorName?.length ?? 0).keys()]\n                  .map(() => ' ')\n                  .join('')}${formattedArgs}`\n              : '',\n          ]\n        }\n      } catch (err) {\n        cause = err as Error\n      }\n    } else if (message) reason = message\n\n    let signature: Hex | undefined\n    if (cause instanceof AbiErrorSignatureNotFoundError) {\n      signature = cause.signature\n      metaMessages = [\n        `Unable to decode signature \"${signature}\" as it was not found on the provided ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ]\n    }\n\n    super(\n      (reason && reason !== 'execution reverted') || signature\n        ? [\n            `The contract function \"${functionName}\" reverted with the following ${\n              signature ? 'signature' : 'reason'\n            }:`,\n            reason || signature,\n          ].join('\\n')\n        : `The contract function \"${functionName}\" reverted.`,\n      {\n        cause,\n        metaMessages,\n      },\n    )\n\n    this.data = decodedData\n    this.reason = reason\n    this.signature = signature\n  }\n}\n\nexport class ContractFunctionZeroDataError extends BaseError {\n  override name = 'ContractFunctionZeroDataError'\n  constructor({ functionName }: { functionName: string }) {\n    super(`The contract function \"${functionName}\" returned no data (\"0x\").`, {\n      metaMessages: [\n        'This could be due to any of the following:',\n        `  - The contract does not have the function \"${functionName}\",`,\n        '  - The parameters passed to the contract function may be invalid, or',\n        '  - The address is not a contract.',\n      ],\n    })\n  }\n}\n\nexport class RawContractError extends BaseError {\n  code = 3\n  override name = 'RawContractError'\n\n  data?: Hex | { data?: Hex }\n\n  constructor({\n    data,\n    message,\n  }: { data?: Hex | { data?: Hex }; message?: string }) {\n    super(message || '')\n    this.data = data\n  }\n}\n", "import type { Abi, ExtractAbiFunctionNames, Narrow } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n} from '../../errors/abi.js'\nimport type {\n  AbiItem,\n  ContractFunctionResult,\n  GetFunctionArgs,\n  InferFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/decodeFunctionResult'\n\nexport type DecodeFunctionResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName = InferFunctionName<TAbi, TFunctionName>,\n> = {\n  functionName?: _FunctionName\n  data: Hex\n} & (TFunctionName extends string\n  ? { abi: Narrow<TAbi> } & Partial<GetFunctionArgs<TAbi, TFunctionName>>\n  : _FunctionName extends string\n  ? { abi: [Narrow<TAbi[number]>] } & Partial<\n      GetFunctionArgs<TAbi, _FunctionName>\n    >\n  : never)\n\nexport type DecodeFunctionResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiFunctionNames<TAbi>[number]\n    : string,\n> = TFunctionName extends string\n  ? ContractFunctionResult<TAbi, TFunctionName>\n  : ContractFunctionResult<TAbi, _FunctionName>\n\nexport function decodeFunctionResult<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = undefined,\n>({\n  abi,\n  args,\n  functionName,\n  data,\n}: DecodeFunctionResultParameters<\n  TAbi,\n  TFunctionName\n>): DecodeFunctionResultReturnType<TAbi, TFunctionName> {\n  let abiItem = abi[0] as AbiItem\n  if (functionName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    } as GetAbiItemParameters)\n    if (!abiItem) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = decodeAbiParameters(abiItem.outputs, data)\n  if (values && values.length > 1) return values as any\n  if (values && values.length === 1) return values[0] as any\n  return undefined as any\n}\n", "import type { Abi, Narrow } from 'abitype'\n\nimport { AbiFunctionNotFoundError } from '../../errors/abi.js'\nimport type {\n  AbiItem,\n  GetFunctionArgs,\n  InferFunctionName,\n} from '../../types/contract.js'\nimport { concatHex } from '../data/concat.js'\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js'\n\nimport { encodeAbiParameters } from './encodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nexport type EncodeFunctionDataParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName = InferFunctionName<TAbi, TFunctionName>,\n> = {\n  functionName?: _FunctionName\n} & (TFunctionName extends string\n  ? { abi: Narrow<TAbi> } & GetFunctionArgs<TAbi, TFunctionName>\n  : _FunctionName extends string\n  ? { abi: [Narrow<TAbi[number]>] } & GetFunctionArgs<TAbi, _FunctionName>\n  : never)\n\nexport function encodeFunctionData<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = undefined,\n>({\n  abi,\n  args,\n  functionName,\n}: EncodeFunctionDataParameters<TAbi, TFunctionName>) {\n  let abiItem = abi[0] as AbiItem\n  if (functionName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    } as GetAbiItemParameters)\n    if (!abiItem)\n      throw new AbiFunctionNotFoundError(functionName, {\n        docsPath: '/docs/contract/encodeFunctionData',\n      })\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, {\n      docsPath: '/docs/contract/encodeFunctionData',\n    })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = getFunctionSelector(definition)\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, (args ?? []) as readonly unknown[])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n", "import {\n  ChainDoesNotSupportContract,\n  ChainMismatchError,\n  ChainNotFoundError,\n} from '../errors/chain.js'\nimport type {\n  Chain,\n  ChainConfig,\n  ChainContract,\n  ChainFormatters,\n} from '../types/chain.js'\nimport type { Assign } from '../types/utils.js'\n\nexport type AssertCurrentChainParameters = {\n  chain?: Chain\n  currentChainId: number\n}\n\nexport function assertCurrentChain({\n  chain,\n  currentChainId,\n}: AssertCurrentChainParameters): void {\n  if (!chain) throw new ChainNotFoundError()\n  if (currentChainId !== chain.id)\n    throw new ChainMismatchError({ chain, currentChainId })\n}\n\nexport function defineChain<\n  chain extends Chain,\n  formatters extends ChainFormatters,\n>(\n  chain: chain,\n  config: ChainConfig<formatters> = {},\n): Assign<chain, ChainConfig<formatters>> {\n  const {\n    fees = chain.fees,\n    formatters = chain.formatters,\n    serializers = chain.serializers,\n  } = config\n  return {\n    ...chain,\n    fees,\n    formatters,\n    serializers,\n  } as unknown as Assign<chain, ChainConfig<formatters>>\n}\n\nexport function getChainContractAddress({\n  blockNumber,\n  chain,\n  contract: name,\n}: {\n  blockNumber?: bigint\n  chain: Chain\n  contract: string\n}) {\n  const contract = (chain?.contracts as Record<string, ChainContract>)?.[name]\n  if (!contract)\n    throw new ChainDoesNotSupportContract({\n      chain,\n      contract: { name },\n    })\n\n  if (\n    blockNumber &&\n    contract.blockCreated &&\n    contract.blockCreated > blockNumber\n  )\n    throw new ChainDoesNotSupportContract({\n      blockNumber,\n      chain,\n      contract: {\n        name,\n        blockCreated: contract.blockCreated,\n      },\n    })\n\n  return contract.address\n}\n", "import { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\n\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted/\n\n  override name = 'ExecutionRevertedError'\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError; message?: string } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  override name = 'FeeCapTooHigh'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  override name = 'FeeCapTooLow'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: { cause?: BaseError; maxFeePerGas?: bigint } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  override name = 'NonceTooHighError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause },\n    )\n  }\n}\n\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage =\n    /nonce too low|transaction already imported|already known/\n  override name = 'NonceTooLowError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause },\n    )\n  }\n}\n\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  override name = 'NonceMaxValueError'\n  constructor({ cause, nonce }: { cause?: BaseError; nonce?: number } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause },\n    )\n  }\n}\n\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage = /insufficient funds/\n  override name = 'InsufficientFundsError'\n  constructor({ cause }: { cause?: BaseError } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n      },\n    )\n  }\n}\n\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  override name = 'IntrinsicGasTooHighError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  override name = 'IntrinsicGasTooLowError'\n  constructor({ cause, gas }: { cause?: BaseError; gas?: bigint } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  override name = 'TransactionTypeNotSupportedError'\n  constructor({ cause }: { cause?: BaseError }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n    })\n  }\n}\n\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  override name = 'TipAboveFeeCapError'\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError\n    maxPriorityFeePerGas?: bigint\n    maxFeePerGas?: bigint\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport class UnknownNodeError extends BaseError {\n  override name = 'UnknownNodeError'\n\n  constructor({ cause }: { cause?: BaseError }) {\n    super(`An error occurred while executing: ${cause?.message}`, {\n      cause,\n    })\n  }\n}\n", "import { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport class HttpRequestError extends BaseError {\n  override name = 'HttpRequestError'\n\n  body?: { [x: string]: unknown } | { [y: string]: unknown }[]\n  headers?: Headers\n  status?: number\n  url: string\n\n  constructor({\n    body,\n    details,\n    headers,\n    status,\n    url,\n  }: {\n    body?: { [x: string]: unknown } | { [y: string]: unknown }[]\n    details?: string\n    headers?: Headers\n    status?: number\n    url: string\n  }) {\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [\n        status && `Status: ${status}`,\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n    })\n    this.body = body\n    this.headers = headers\n    this.status = status\n    this.url = url\n  }\n}\n\nexport class WebSocketRequestError extends BaseError {\n  override name = 'WebSocketRequestError'\n\n  constructor({\n    body,\n    details,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    details: string\n    url: string\n  }) {\n    super('WebSocket request failed.', {\n      details,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n\nexport class RpcRequestError extends BaseError {\n  override name = 'RpcRequestError'\n\n  code: number\n\n  constructor({\n    body,\n    error,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    error: { code: number; message: string }\n    url: string\n  }) {\n    super('RPC Request failed.', {\n      cause: error as any,\n      details: error.message,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n    this.code = error.code\n  }\n}\n\nexport class TimeoutError extends BaseError {\n  override name = 'TimeoutError'\n\n  constructor({\n    body,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    url: string\n  }) {\n    super('The request took too long to respond.', {\n      details: 'The request timed out.',\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n", "import type { Prettify } from '../types/utils.js'\nimport { BaseError } from './base.js'\nimport { RpcRequestError } from './request.js'\n\nconst unknownErrorCode = -1\n\nexport type RpcErrorCode =\n  | -1\n  | -32700 // Parse error\n  | -32600 // Invalid request\n  | -32601 // Method not found\n  | -32602 // Invalid params\n  | -32603 // Internal error\n  | -32000 // Invalid input\n  | -32001 // Resource not found\n  | -32002 // Resource unavailable\n  | -32003 // Transaction rejected\n  | -32004 // Method not supported\n  | -32005 // Limit exceeded\n  | -32006 // JSON-RPC version not supported\n  | -32042 // Method not found\n\ntype RpcErrorOptions<TCode extends number = RpcErrorCode> = {\n  code?: TCode | (number & {})\n  docsPath?: string\n  metaMessages?: string[]\n  shortMessage: string\n}\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1474\n */\nexport class RpcError<TCode extends number = RpcErrorCode> extends BaseError {\n  override name = 'RpcError'\n\n  code: TCode | (number & {})\n\n  constructor(\n    cause: Error,\n    { code, docsPath, metaMessages, shortMessage }: RpcErrorOptions<TCode>,\n  ) {\n    super(shortMessage, {\n      cause,\n      docsPath,\n      metaMessages:\n        metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,\n    })\n    this.name = cause.name\n    this.code = (\n      cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode\n    ) as TCode\n  }\n}\n\nexport type ProviderRpcErrorCode =\n  | 4001 // User Rejected Request\n  | 4100 // Unauthorized\n  | 4200 // Unsupported Method\n  | 4900 // Disconnected\n  | 4901 // Chain Disconnected\n  | 4902 // Chain Not Recongnized\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1193\n */\nexport class ProviderRpcError<\n  T = undefined,\n> extends RpcError<ProviderRpcErrorCode> {\n  override name = 'ProviderRpcError'\n\n  data?: T\n\n  constructor(\n    cause: Error,\n    options: Prettify<\n      RpcErrorOptions<ProviderRpcErrorCode> & {\n        data?: T\n      }\n    >,\n  ) {\n    super(cause, options)\n\n    this.data = options.data\n  }\n}\n\n/**\n * Subclass for a \"Parse error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ParseRpcError extends RpcError {\n  override name = 'ParseRpcError'\n  static code = -32700 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ParseRpcError.code,\n      shortMessage:\n        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Invalid request\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidRequestRpcError extends RpcError {\n  override name = 'InvalidRequestRpcError'\n  static code = -32600 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidRequestRpcError.code,\n      shortMessage: 'JSON is not a valid request object.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class MethodNotFoundRpcError extends RpcError {\n  override name = 'MethodNotFoundRpcError'\n  static code = -32601 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: MethodNotFoundRpcError.code,\n      shortMessage: 'The method does not exist / is not available.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid params\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidParamsRpcError extends RpcError {\n  override name = 'InvalidParamsRpcError'\n  static code = -32602 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidParamsRpcError.code,\n      shortMessage: [\n        'Invalid parameters were provided to the RPC method.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for an \"Internal error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InternalRpcError extends RpcError {\n  override name = 'InternalRpcError'\n  static code = -32603 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InternalRpcError.code,\n      shortMessage: 'An internal error was received.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid input\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidInputRpcError extends RpcError {\n  override name = 'InvalidInputRpcError'\n  static code = -32000 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidInputRpcError.code,\n      shortMessage: [\n        'Missing or invalid parameters.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ResourceNotFoundRpcError extends RpcError {\n  override name = 'ResourceNotFoundRpcError'\n  static code = -32001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceNotFoundRpcError.code,\n      shortMessage: 'Requested resource not found.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource unavailable\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ResourceUnavailableRpcError extends RpcError {\n  override name = 'ResourceUnavailableRpcError'\n  static code = -32002 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceUnavailableRpcError.code,\n      shortMessage: 'Requested resource not available.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Transaction rejected\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class TransactionRejectedRpcError extends RpcError {\n  override name = 'TransactionRejectedRpcError'\n  static code = -32003 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: TransactionRejectedRpcError.code,\n      shortMessage: 'Transaction creation failed.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class MethodNotSupportedRpcError extends RpcError {\n  override name = 'MethodNotSupportedRpcError'\n  static code = -32004 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: MethodNotSupportedRpcError.code,\n      shortMessage: 'Method is not implemented.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Limit exceeded\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class LimitExceededRpcError extends RpcError {\n  override name = 'LimitExceededRpcError'\n  static code = -32005 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: LimitExceededRpcError.code,\n      shortMessage: 'Request exceeds defined limit.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"JSON-RPC version not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class JsonRpcVersionUnsupportedError extends RpcError {\n  override name = 'JsonRpcVersionUnsupportedError'\n  static code = -32006 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: JsonRpcVersionUnsupportedError.code,\n      shortMessage: 'Version of JSON-RPC protocol is not supported.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"User Rejected Request\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  override name = 'UserRejectedRequestError'\n  static code = 4001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UserRejectedRequestError.code,\n      shortMessage: 'User rejected the request.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unauthorized\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UnauthorizedProviderError extends ProviderRpcError {\n  override name = 'UnauthorizedProviderError'\n  static code = 4100 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnauthorizedProviderError.code,\n      shortMessage:\n        'The requested method and/or account has not been authorized by the user.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unsupported Method\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n  override name = 'UnsupportedProviderMethodError'\n  static code = 4200 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnsupportedProviderMethodError.code,\n      shortMessage: 'The Provider does not support the requested method.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class ProviderDisconnectedError extends ProviderRpcError {\n  override name = 'ProviderDisconnectedError'\n  static code = 4900 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ProviderDisconnectedError.code,\n      shortMessage: 'The Provider is disconnected from all chains.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Chain Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  override name = 'ChainDisconnectedError'\n  static code = 4901 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ChainDisconnectedError.code,\n      shortMessage: 'The Provider is not connected to the requested chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Switch Chain\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class SwitchChainError extends ProviderRpcError {\n  override name = 'SwitchChainError'\n  static code = 4902 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: SwitchChainError.code,\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an unknown RPC error.\n */\nexport class UnknownRpcError extends RpcError {\n  override name = 'UnknownRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      shortMessage: 'An unknown RPC error occurred.',\n    })\n  }\n}\n", "import type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport {\n  ExecutionRevertedError,\n  FeeCapTooHighError,\n  FeeCapTooLowError,\n  InsufficientFundsError,\n  IntrinsicGasTooHighError,\n  IntrinsicGasTooLowError,\n  NonceMaxValueError,\n  NonceTooHighError,\n  NonceTooLowError,\n  TipAboveFeeCapError,\n  TransactionTypeNotSupportedError,\n  UnknownNodeError,\n} from '../../errors/node.js'\nimport { RpcRequestError } from '../../errors/request.js'\nimport {\n  InvalidInputRpcError,\n  TransactionRejectedRpcError,\n} from '../../errors/rpc.js'\n\nexport function containsNodeError(err: BaseError) {\n  return (\n    err instanceof TransactionRejectedRpcError ||\n    err instanceof InvalidInputRpcError ||\n    (err instanceof RpcRequestError && err.code === ExecutionRevertedError.code)\n  )\n}\n\nexport type GetNodeErrorParameters = Partial<SendTransactionParameters<any>>\n\nexport function getNodeError(err: BaseError, args: GetNodeErrorParameters) {\n  const message = err.details.toLowerCase()\n  if (FeeCapTooHighError.nodeMessage.test(message))\n    return new FeeCapTooHighError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (FeeCapTooLowError.nodeMessage.test(message))\n    return new FeeCapTooLowError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (NonceTooHighError.nodeMessage.test(message))\n    return new NonceTooHighError({ cause: err, nonce: args?.nonce })\n  else if (NonceTooLowError.nodeMessage.test(message))\n    return new NonceTooLowError({ cause: err, nonce: args?.nonce })\n  else if (NonceMaxValueError.nodeMessage.test(message))\n    return new NonceMaxValueError({ cause: err, nonce: args?.nonce })\n  else if (InsufficientFundsError.nodeMessage.test(message))\n    return new InsufficientFundsError({ cause: err })\n  else if (IntrinsicGasTooHighError.nodeMessage.test(message))\n    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas })\n  else if (IntrinsicGasTooLowError.nodeMessage.test(message))\n    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas })\n  else if (TransactionTypeNotSupportedError.nodeMessage.test(message))\n    return new TransactionTypeNotSupportedError({ cause: err })\n  else if (TipAboveFeeCapError.nodeMessage.test(message))\n    return new TipAboveFeeCapError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n      maxPriorityFeePerGas: args?.maxPriorityFeePerGas,\n    })\n  else if (\n    message.match(ExecutionRevertedError.nodeMessage) ||\n    ('code' in (err.cause as BaseError) &&\n      (err.cause as { code: number })?.code === ExecutionRevertedError.code)\n  )\n    return new ExecutionRevertedError({\n      cause: err,\n      message: (err.cause as BaseError).details || err.details,\n    })\n  return new UnknownNodeError({\n    cause: (err.cause as BaseError).cause as BaseError,\n  })\n}\n", "import type { CallParameters } from '../../actions/public/call.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  containsNodeError,\n  getNodeError,\n} from './getNodeError.js'\n\nexport function getCallError(\n  err: BaseError,\n  {\n    docsPath,\n    ...args\n  }: CallParameters & {\n    chain?: Chain\n    docsPath?: string\n  },\n) {\n  let cause = err\n  if (containsNodeError(err))\n    cause = getNodeError(err, args as GetNodeErrorParameters)\n  return new CallExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n", "import type { ChainFormatter } from '../../types/chain.js'\n\n/**\n * @description Picks out the keys from `value` that exist in the formatter.\n */\nexport function extract(\n  value: Record<string, unknown>,\n  { format }: { format?: ChainFormatter['format'] },\n) {\n  if (!format) return {}\n  const keys = Object.keys(format({}))\n  return keys.reduce((data: Record<string, unknown>, key) => {\n    // rome-ignore lint/suspicious/noPrototypeBuiltins:\n    if (value?.hasOwnProperty(key)) {\n      data[key] = value[key]\n    }\n    return data\n  }, {})\n}\n", "import type { Assign, Prettify } from '../../types/utils.js'\n\nexport function defineFormatter<TType extends string, TParameters, TReturnType>(\n  type: TType,\n  format: (_: TParameters) => TReturnType,\n) {\n  return <\n    TOverrideParameters,\n    TOverrideReturnType,\n    TExclude extends (keyof TParameters)[] = [],\n  >({\n    exclude,\n    format: overrides,\n  }: {\n    exclude?: TExclude\n    format: (_: TOverrideParameters) => TOverrideReturnType\n  }) => {\n    return {\n      exclude,\n      format: (args: Assign<TParameters, TOverrideParameters>) => {\n        const formatted = format(args as any)\n        if (exclude) {\n          for (const key of exclude) {\n            delete (formatted as any)[key]\n          }\n        }\n        return {\n          ...formatted,\n          ...overrides(args),\n        } as Prettify<Assign<TReturnType, TOverrideReturnType>> & {\n          [K in TExclude[number]]: never\n        }\n      },\n      type,\n    }\n  }\n}\n", "import type {\n  Chain,\n  ExtractChainFormatterParameters,\n} from '../../types/chain.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport { numberToHex } from '../encoding/toHex.js'\nimport { defineFormatter } from './formatter.js'\n\nexport type FormattedTransactionRequest<\n  TChain extends Chain | undefined = Chain | undefined,\n> = ExtractChainFormatterParameters<\n  TChain,\n  'transactionRequest',\n  TransactionRequest\n>\n\nexport function formatTransactionRequest(\n  transactionRequest: Partial<TransactionRequest>,\n) {\n  return {\n    ...transactionRequest,\n    gas:\n      typeof transactionRequest.gas !== 'undefined'\n        ? numberToHex(transactionRequest.gas)\n        : undefined,\n    gasPrice:\n      typeof transactionRequest.gasPrice !== 'undefined'\n        ? numberToHex(transactionRequest.gasPrice)\n        : undefined,\n    maxFeePerGas:\n      typeof transactionRequest.maxFeePerGas !== 'undefined'\n        ? numberToHex(transactionRequest.maxFeePerGas)\n        : undefined,\n    maxPriorityFeePerGas:\n      typeof transactionRequest.maxPriorityFeePerGas !== 'undefined'\n        ? numberToHex(transactionRequest.maxPriorityFeePerGas)\n        : undefined,\n    nonce:\n      typeof transactionRequest.nonce !== 'undefined'\n        ? numberToHex(transactionRequest.nonce)\n        : undefined,\n    value:\n      typeof transactionRequest.value !== 'undefined'\n        ? numberToHex(transactionRequest.value)\n        : undefined,\n  } as RpcTransactionRequest\n}\n\nexport const defineTransactionRequest = /*#__PURE__*/ defineFormatter(\n  'transactionRequest',\n  formatTransactionRequest,\n)\n", "type Resolved<TReturnType extends readonly unknown[] = any> = [\n  result: TReturnType[number],\n  results: TReturnType,\n]\n\ntype PendingPromise<TReturnType extends readonly unknown[] = any> = {\n  resolve?: (data: Resolved<TReturnType>) => void\n  reject?: (reason?: unknown) => void\n}\n\ntype SchedulerItem = { args: unknown; pendingPromise: PendingPromise }\n\nexport type CreateBatchSchedulerArguments<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  fn: (args: TParameters[]) => Promise<TReturnType>\n  id: number | string\n  shouldSplitBatch?: (args: TParameters[]) => boolean\n  wait?: number\n}\nexport type CreateBatchSchedulerReturnType<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  flush: () => void\n  schedule: TParameters extends undefined\n    ? (args?: TParameters) => Promise<Resolved<TReturnType>>\n    : (args: TParameters) => Promise<Resolved<TReturnType>>\n}\n\nconst schedulerCache = /*#__PURE__*/ new Map<number | string, SchedulerItem[]>()\n\nexport function createBatchScheduler<\n  TParameters,\n  TReturnType extends readonly unknown[],\n>({\n  fn,\n  id,\n  shouldSplitBatch,\n  wait = 0,\n}: CreateBatchSchedulerArguments<\n  TParameters,\n  TReturnType\n>): CreateBatchSchedulerReturnType<TParameters, TReturnType> {\n  const exec = async () => {\n    const scheduler = getScheduler()\n    flush()\n\n    const args = scheduler.map(({ args }) => args)\n\n    if (args.length === 0) return\n\n    fn(args as TParameters[])\n      .then((data) => {\n        scheduler.forEach(({ pendingPromise }, i) =>\n          pendingPromise.resolve?.([data[i], data]),\n        )\n      })\n      .catch((err) => {\n        scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err))\n      })\n  }\n\n  const flush = () => schedulerCache.delete(id)\n\n  const getBatchedArgs = () =>\n    getScheduler().map(({ args }) => args) as TParameters[]\n\n  const getScheduler = () => schedulerCache.get(id) || []\n\n  const setScheduler = (item: SchedulerItem) =>\n    schedulerCache.set(id, [...getScheduler(), item])\n\n  return {\n    flush,\n    async schedule(args: TParameters) {\n      const pendingPromise: PendingPromise<TReturnType> = {}\n      const promise = new Promise<Resolved<TReturnType>>((resolve, reject) => {\n        pendingPromise.resolve = resolve\n        pendingPromise.reject = reject\n      })\n\n      const split = shouldSplitBatch?.([...getBatchedArgs(), args])\n\n      if (split) exec()\n\n      const hasActiveScheduler = getScheduler().length > 0\n      if (hasActiveScheduler) {\n        setScheduler({ args, pendingPromise })\n        return promise\n      }\n\n      setScheduler({ args, pendingPromise })\n      setTimeout(exec, wait)\n      return promise\n    },\n  } as unknown as CreateBatchSchedulerReturnType<TParameters, TReturnType>\n}\n", "import { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport { FeeCapTooHighError, TipAboveFeeCapError } from '../../errors/node.js'\nimport { FeeConflictError } from '../../errors/transaction.js'\nimport type { Chain } from '../../types/chain.js'\nimport { isAddress } from '../address/isAddress.js'\n\nexport type AssertRequestParameters = Partial<SendTransactionParameters<Chain>>\n\nexport function assertRequest(args: AssertRequestParameters) {\n  const {\n    account: account_,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    to,\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n  if (account && !isAddress(account.address))\n    throw new InvalidAddressError({ address: account.address })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (\n    typeof gasPrice !== 'undefined' &&\n    (typeof maxFeePerGas !== 'undefined' ||\n      typeof maxPriorityFeePerGas !== 'undefined')\n  )\n    throw new FeeConflictError()\n\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { aggregate3Signature } from '../../constants/contract.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ChainDoesNotSupportContract,\n  ClientChainNotConfiguredError,\n} from '../../errors/chain.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getCallError } from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport type { AssertRequestParameters } from '../../utils/transaction/assertRequest.js'\n\nexport type FormattedCall<\n  TChain extends Chain | undefined = Chain | undefined,\n> = FormattedTransactionRequest<TChain>\n\nexport type CallParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedCall<TChain>, 'from'> & {\n  account?: Account | Address\n  batch?: boolean\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint\n        blockTag?: never\n      }\n    | {\n        blockNumber?: never\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag\n      }\n  )\n\nexport type CallReturnType = { data: Hex | undefined }\n\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call.html\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  args: CallParameters<TChain>,\n): Promise<CallReturnType> {\n  const {\n    account: account_,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const format =\n      client.chain?.formatters?.transactionRequest?.format ||\n      formatTransactionRequest\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format }),\n      from: account?.address,\n      accessList,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest) as TransactionRequest\n\n    if (batch && shouldPerformMulticall({ request })) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag,\n        } as unknown as ScheduleMulticallParameters<TChain>)\n      } catch (err) {\n        if (\n          !(err instanceof ClientChainNotConfiguredError) &&\n          !(err instanceof ChainDoesNotSupportContract)\n        )\n          throw err\n      }\n    }\n\n    const response = await client.request({\n      method: 'eth_call',\n      params: block\n        ? [request as Partial<RpcTransactionRequest>, block]\n        : [request as Partial<RpcTransactionRequest>],\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    const data = getRevertErrorData(err)\n    const { offchainLookup, offchainLookupSignature } = await import(\n      '../../utils/ccip.js'\n    )\n    if (data?.slice(0, 10) === offchainLookupSignature && to) {\n      return { data: await offchainLookup(client, { data, to }) }\n    }\n    throw getCallError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({ request }: { request: TransactionRequest }) {\n  const { data, to, ...request_ } = request\n  if (!data) return false\n  if (data.startsWith(aggregate3Signature)) return false\n  if (!to) return false\n  if (\n    Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0\n  )\n    return false\n  return true\n}\n\ntype ScheduleMulticallParameters<TChain extends Chain | undefined> = Pick<\n  CallParameters<TChain>,\n  'blockNumber' | 'blockTag'\n> & {\n  data: Hex\n  multicallAddress?: Address\n  to: Address\n}\n\nasync function scheduleMulticall<TChain extends Chain | undefined,>(\n  client: Client<Transport>,\n  args: ScheduleMulticallParameters<TChain>,\n) {\n  const { batchSize = 1024, wait = 0 } =\n    typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to,\n  } = args\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError()\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const block = blockNumberHex || blockTag\n\n  const { schedule } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, { data }) => size + (data.length - 2), 0)\n      return size > batchSize * 2\n    },\n    fn: async (\n      requests: {\n        data: Hex\n        to: Address\n      }[],\n    ) => {\n      const calls = requests.map((request) => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to,\n      }))\n\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n      })\n\n      const data = await client.request({\n        method: 'eth_call',\n        params: [\n          {\n            data: calldata,\n            to: multicallAddress,\n          },\n          block,\n        ],\n      })\n\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x',\n      })\n    },\n  })\n\n  const [{ returnData, success }] = await schedule({ data, to })\n\n  if (!success) throw new RawContractError({ data: returnData })\n  if (returnData === '0x') return { data: undefined }\n  return { data: returnData }\n}\n\nexport function getRevertErrorData(err: unknown) {\n  if (!(err instanceof BaseError)) return undefined\n  const error = err.walk() as RawContractError\n  return typeof error.data === 'object' ? error.data.data : error.data\n}\n", "import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport class OffchainLookupError extends BaseError {\n  override name = 'OffchainLookupError'\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n      },\n    )\n  }\n}\n\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  override name = 'OffchainLookupResponseMalformedError'\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n      },\n    )\n  }\n}\n\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  override name = 'OffchainLookupSenderMismatchError'\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n      },\n    )\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\n\nimport { isAddress } from './isAddress.js'\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a)) throw new InvalidAddressError({ address: a })\n  if (!isAddress(b)) throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n", "import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport { type BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { GetErrorArgs } from '../types/contract.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport async function offchainLookup<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  }) as unknown as GetErrorArgs<\n    [typeof offchainLookupAbiItem],\n    'OffchainLookup'\n  >\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipFetch({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport async function ccipFetch({\n  data,\n  sender,\n  urls,\n}: { data: Hex; sender: Address; urls: readonly string[] }) {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method =\n      url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],
  "mappings": "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",
  "names": ["hash", "length", "length", "consumed", "value", "value", "args", "data", "args", "size"]
}
