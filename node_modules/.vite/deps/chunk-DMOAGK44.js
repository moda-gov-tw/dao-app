import {
  AbiConstructorNotFoundError,
  AbiConstructorParamsNotFoundError,
  AbiDecodingDataSizeTooSmallError,
  AbiDecodingZeroDataError,
  AbiEventNotFoundError,
  AbiEventSignatureEmptyTopicsError,
  AbiEventSignatureNotFoundError,
  AbiFunctionSignatureNotFoundError,
  BaseError,
  BytesSizeMismatchError,
  ChainDisconnectedError,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  DecodeLogDataMismatch,
  DecodeLogTopicsMismatch,
  FeeCapTooHighError,
  HttpRequestError,
  InternalRpcError,
  InvalidAddressError,
  InvalidChainIdError,
  InvalidInputRpcError,
  InvalidLegacyVError,
  InvalidParamsRpcError,
  InvalidRequestRpcError,
  InvalidSerializableTransactionError,
  InvalidStorageKeySizeError,
  JsonRpcVersionUnsupportedError,
  LimitExceededRpcError,
  MethodNotFoundRpcError,
  MethodNotSupportedRpcError,
  ParseRpcError,
  ProviderDisconnectedError,
  RawContractError,
  ResourceNotFoundRpcError,
  ResourceUnavailableRpcError,
  SwitchChainError,
  TimeoutError,
  TipAboveFeeCapError,
  TransactionExecutionError,
  TransactionRejectedRpcError,
  UnauthorizedProviderError,
  UnknownRpcError,
  UnsupportedProviderMethodError,
  UserRejectedRequestError,
  WebSocketRequestError,
  addressResolverAbi,
  assertRequest,
  bytesToHex,
  call,
  concat,
  concatHex,
  containsNodeError,
  createBatchScheduler,
  decodeAbiParameters,
  decodeFunctionResult,
  defineChain,
  defineFormatter,
  defineTransactionRequest,
  encodeAbiParameters,
  encodeFunctionData,
  extract,
  formatAbiItem,
  formatEther,
  formatGwei,
  formatTransactionRequest,
  getAbiItem,
  getChainContractAddress,
  getFunctionSelector,
  getNodeError,
  hashAbiItem,
  hashFunction,
  hexToBigInt,
  hexToNumber,
  init_abi,
  init_abis,
  init_address,
  init_assertRequest,
  init_base,
  init_call,
  init_ccip,
  init_chain,
  init_chain2,
  init_concat,
  init_contract,
  init_createBatchScheduler,
  init_decodeAbiParameters,
  init_decodeErrorResult,
  init_decodeFunctionResult,
  init_encodeAbiParameters,
  init_encodeFunctionData,
  init_encoding,
  init_extract,
  init_extractFunctionParts,
  init_formatAbiItem,
  init_formatAbiItemWithArgs,
  init_formatEther,
  init_formatGwei,
  init_formatUnits,
  init_formatter,
  init_fromHex,
  init_getAbiItem,
  init_getAddress,
  init_getCallError,
  init_getFunctionSelector,
  init_getNodeError,
  init_hashFunction,
  init_isAddress,
  init_isAddressEqual,
  init_isHex,
  init_keccak256,
  init_node,
  init_pad,
  init_parseAccount,
  init_request,
  init_rpc,
  init_size,
  init_slice,
  init_solidity,
  init_stringify,
  init_toBytes,
  init_toHex,
  init_transaction,
  init_transactionRequest,
  init_trim,
  init_unit,
  isAddress,
  isHex,
  keccak256,
  numberToHex,
  panicReasons,
  parseAccount,
  prettyPrint,
  size,
  slice,
  stringToBytes,
  stringify,
  textResolverAbi,
  toBytes,
  toHex,
  trim,
  universalResolverResolveAbi,
  universalResolverReverseAbi
} from "./chunk-JP6YUYUV.js";
import {
  __esm,
  __export
} from "./chunk-LMAYTEU7.js";

// node_modules/viem/dist/esm/utils/abi/decodeFunctionData.js
function decodeFunctionData({ abi, data }) {
  const signature = slice(data, 0, 4);
  const description = abi.find((x) => x.type === "function" && signature === getFunctionSelector(formatAbiItem(x)));
  if (!description)
    throw new AbiFunctionSignatureNotFoundError(signature, {
      docsPath: "/docs/contract/decodeFunctionData"
    });
  return {
    functionName: description.name,
    args: "inputs" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : void 0
  };
}
var init_decodeFunctionData = __esm({
  "node_modules/viem/dist/esm/utils/abi/decodeFunctionData.js"() {
    init_abi();
    init_slice();
    init_getFunctionSelector();
    init_decodeAbiParameters();
    init_formatAbiItem();
  }
});

// node_modules/viem/dist/esm/utils/formatters/transaction.js
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction_.type === "legacy") {
    delete transaction_["accessList"];
    delete transaction_["maxFeePerGas"];
    delete transaction_["maxPriorityFeePerGas"];
  }
  if (transaction_.type === "eip2930") {
    delete transaction_["maxFeePerGas"];
    delete transaction_["maxPriorityFeePerGas"];
  }
  return transaction_;
}
var transactionType, defineTransaction;
var init_transaction2 = __esm({
  "node_modules/viem/dist/esm/utils/formatters/transaction.js"() {
    init_fromHex();
    init_formatter();
    transactionType = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559"
    };
    defineTransaction = defineFormatter("transaction", formatTransaction);
  }
});

// node_modules/viem/dist/esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = block.transactions?.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock;
var init_block = __esm({
  "node_modules/viem/dist/esm/utils/formatters/block.js"() {
    init_formatter();
    init_transaction2();
    defineBlock = defineFormatter("block", formatBlock);
  }
});

// node_modules/viem/dist/esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}
var init_log = __esm({
  "node_modules/viem/dist/esm/utils/formatters/log.js"() {
  }
});

// node_modules/viem/dist/esm/utils/formatters/transactionReceipt.js
function formatTransactionReceipt(transactionReceipt) {
  return {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
}
var statuses, defineTransactionReceipt;
var init_transactionReceipt = __esm({
  "node_modules/viem/dist/esm/utils/formatters/transactionReceipt.js"() {
    init_fromHex();
    init_formatter();
    init_log();
    init_transaction2();
    statuses = {
      "0x0": "reverted",
      "0x1": "success"
    };
    defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);
  }
});

// node_modules/viem/dist/esm/utils/encoding/toRlp.js
function toRlp(hexOrBytes, to_) {
  const to = to_ || "hex";
  return format(bytesToRlp(parse(hexOrBytes)), to);
}
function parse(hexOrBytes) {
  if (Array.isArray(hexOrBytes))
    return hexOrBytes.map(parse);
  return typeof hexOrBytes === "string" ? toBytes(hexOrBytes) : hexOrBytes;
}
function format(bytes, type = "bytes") {
  return type === "hex" ? bytesToHex(bytes) : bytes;
}
function bytesToRlp(bytes) {
  if (Array.isArray(bytes)) {
    const encoded = concat(bytes.map(bytesToRlp));
    return new Uint8Array([...encodeLength(encoded.length, 192), ...encoded]);
  }
  if (bytes.length === 1 && bytes[0] < 128)
    return bytes;
  return new Uint8Array([...encodeLength(bytes.length, 128), ...bytes]);
}
function encodeLength(length, offset) {
  if (length < 56)
    return [offset + length];
  return [toBytes(length).length + offset + 55, ...toBytes(length)];
}
var init_toRlp = __esm({
  "node_modules/viem/dist/esm/utils/encoding/toRlp.js"() {
    init_concat();
    init_toBytes();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/utils/transaction/serializeAccessList.js
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i = 0; i < accessList.length; i++) {
    const { address, storageKeys } = accessList[i];
    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
      }
    }
    if (!isAddress(address)) {
      throw new InvalidAddressError({ address });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}
var init_serializeAccessList = __esm({
  "node_modules/viem/dist/esm/utils/transaction/serializeAccessList.js"() {
    init_address();
    init_transaction();
    init_isAddress();
    init_toRlp();
  }
});

// node_modules/viem/dist/esm/utils/transaction/assertTransaction.js
function assertTransactionEIP1559(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
  if (accessList)
    throw new BaseError("`accessList` is not a valid Legacy Transaction attribute.");
}
var init_assertTransaction = __esm({
  "node_modules/viem/dist/esm/utils/transaction/assertTransaction.js"() {
    init_address();
    init_base();
    init_chain();
    init_node();
    init_isAddress();
  }
});

// node_modules/viem/dist/esm/utils/transaction/getTransactionType.js
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
    return "eip1559";
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}
var init_getTransactionType = __esm({
  "node_modules/viem/dist/esm/utils/transaction/getTransactionType.js"() {
    init_transaction();
  }
});

// node_modules/viem/dist/esm/utils/transaction/serializeTransaction.js
function serializeTransaction(transaction, signature) {
  const type = getTransactionType(transaction);
  if (type === "eip1559")
    return serializeTransactionEIP1559(transaction, signature);
  if (type === "eip2930")
    return serializeTransactionEIP2930(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP1559(transaction, signature) {
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList
  ];
  if (signature)
    serializedTransaction.push(
      signature.v === 27n ? "0x" : toHex(1),
      trim(signature.r),
      trim(signature.s)
    );
  return concatHex([
    "0x02",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList
  ];
  if (signature)
    serializedTransaction.push(
      signature.v === 27n ? "0x" : toHex(1),
      signature.r,
      signature.s
    );
  return concatHex([
    "0x01",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionLegacy(transaction, signature) {
  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x"
  ];
  if (signature) {
    let v = 27n + (signature.v === 27n ? 0n : 1n);
    if (chainId > 0)
      v = BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
    else if (signature.v !== v)
      throw new InvalidLegacyVError({ v: signature.v });
    serializedTransaction = [
      ...serializedTransaction,
      toHex(v),
      signature.r,
      signature.s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
var init_serializeTransaction = __esm({
  "node_modules/viem/dist/esm/utils/transaction/serializeTransaction.js"() {
    init_transaction();
    init_concat();
    init_trim();
    init_toHex();
    init_toRlp();
    init_assertTransaction();
    init_getTransactionType();
    init_serializeAccessList();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/version.js
var init_version = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/version.js"() {
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/errors.js
var init_errors = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/errors.js"() {
    init_version();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
var init_abiItem = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js"() {
    init_errors();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
var init_abiParameter = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js"() {
    init_errors();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/signature.js
var init_signature = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/signature.js"() {
    init_errors();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/struct.js
var init_struct = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/struct.js"() {
    init_errors();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
var init_splitParameters = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js"() {
    init_errors();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/regex.js
var init_regex = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/regex.js"() {
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
var init_signatures = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js"() {
    init_regex();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/cache.js
var init_cache = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/cache.js"() {
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/utils.js
var init_utils = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/utils.js"() {
    init_regex();
    init_abiItem();
    init_abiParameter();
    init_signature();
    init_splitParameters();
    init_cache();
    init_signatures();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/structs.js
var init_structs = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/runtime/structs.js"() {
    init_regex();
    init_abiItem();
    init_abiParameter();
    init_signature();
    init_struct();
    init_signatures();
    init_utils();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js
var init_parseAbi = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbi.js"() {
    init_signatures();
    init_structs();
    init_utils();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/narrow.js
var init_narrow = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/narrow.js"() {
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
var init_formatAbiParameter = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js"() {
    init_regex();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
var init_formatAbiParameters = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js"() {
    init_formatAbiParameter();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
var init_formatAbiItem2 = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js"() {
    init_formatAbiParameters();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbi.js
var init_formatAbi = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbi.js"() {
    init_formatAbiItem2();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameter.js
var init_parseAbiParameter = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameter.js"() {
    init_esm();
    init_signatures();
    init_structs();
    init_utils();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js
var init_parseAbiParameters = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js"() {
    init_esm();
    init_signatures();
    init_structs();
    init_utils();
    init_utils();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/index.js
var init_esm = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/index.js"() {
    init_errors();
    init_narrow();
    init_formatAbi();
    init_formatAbiItem2();
    init_formatAbiParameter();
    init_formatAbiParameters();
    init_parseAbi();
    init_parseAbiItem();
    init_parseAbiParameter();
    init_parseAbiParameters();
    init_abiItem();
    init_abiParameter();
    init_signature();
    init_splitParameters();
    init_struct();
  }
});

// node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js
var init_parseAbiItem = __esm({
  "node_modules/viem/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js"() {
    init_esm();
    init_signatures();
    init_structs();
    init_utils();
  }
});

// node_modules/viem/dist/esm/errors/log.js
var FilterTypeNotSupportedError;
var init_log2 = __esm({
  "node_modules/viem/dist/esm/errors/log.js"() {
    init_base();
    FilterTypeNotSupportedError = class extends BaseError {
      constructor(type) {
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FilterTypeNotSupportedError"
        });
      }
    };
  }
});

// node_modules/viem/dist/esm/utils/hash/getEventSelector.js
var getEventSelector;
var init_getEventSelector = __esm({
  "node_modules/viem/dist/esm/utils/hash/getEventSelector.js"() {
    init_hashFunction();
    getEventSelector = (event) => {
      if (typeof event === "string")
        return hashFunction(event);
      return hashAbiItem(event);
    };
  }
});

// node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js
function encodeEventTopics({ abi, eventName, args }) {
  let abiItem = abi[0];
  if (eventName) {
    abiItem = getAbiItem({
      abi,
      args,
      name: eventName
    });
    if (!abiItem)
      throw new AbiEventNotFoundError(eventName, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, {
      docsPath: "/docs/contract/encodeEventTopics"
    });
  const definition = formatAbiItem(abiItem);
  const signature = getEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}
var init_encodeEventTopics = __esm({
  "node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js"() {
    init_abi();
    init_log2();
    init_toBytes();
    init_getEventSelector();
    init_keccak256();
    init_encodeAbiParameters();
    init_formatAbiItem();
    init_getAbiItem();
  }
});

// node_modules/viem/dist/esm/utils/errors/getContractError.js
function getContractError(err, { abi, address, args, docsPath: docsPath3, functionName, sender }) {
  const { code, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
  let cause = err;
  if (err instanceof AbiDecodingZeroDataError) {
    cause = new ContractFunctionZeroDataError({ functionName });
  } else if (code === EXECUTION_REVERTED_ERROR_CODE && (data || message || shortMessage)) {
    cause = new ContractFunctionRevertedError({
      abi,
      data: typeof data === "object" ? data.data : data,
      functionName,
      message: shortMessage ?? message
    });
  }
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}
var EXECUTION_REVERTED_ERROR_CODE;
var init_getContractError = __esm({
  "node_modules/viem/dist/esm/utils/errors/getContractError.js"() {
    init_abi();
    init_base();
    init_contract();
    EXECUTION_REVERTED_ERROR_CODE = 3;
  }
});

// node_modules/viem/dist/esm/errors/estimateGas.js
var EstimateGasExecutionError;
var init_estimateGas = __esm({
  "node_modules/viem/dist/esm/errors/estimateGas.js"() {
    init_formatEther();
    init_formatGwei();
    init_base();
    init_transaction();
    EstimateGasExecutionError = class extends BaseError {
      constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = prettyPrint({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath: docsPath3,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Estimate Gas Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EstimateGasExecutionError"
        });
        this.cause = cause;
      }
    };
  }
});

// node_modules/viem/dist/esm/errors/block.js
var BlockNotFoundError;
var init_block2 = __esm({
  "node_modules/viem/dist/esm/errors/block.js"() {
    init_base();
    BlockNotFoundError = class extends BaseError {
      constructor({ blockHash, blockNumber }) {
        let identifier = "Block";
        if (blockHash)
          identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
          identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BlockNotFoundError"
        });
      }
    };
  }
});

// node_modules/viem/dist/esm/errors/account.js
var AccountNotFoundError;
var init_account = __esm({
  "node_modules/viem/dist/esm/errors/account.js"() {
    init_base();
    AccountNotFoundError = class extends BaseError {
      constructor({ docsPath: docsPath3 } = {}) {
        super([
          "Could not find an Account to execute with this Action.",
          "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
        ].join("\n"), {
          docsPath: docsPath3,
          docsSlug: "account"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AccountNotFoundError"
        });
      }
    };
  }
});

// node_modules/viem/dist/esm/utils/errors/getEstimateGasError.js
function getEstimateGasError(err, { docsPath: docsPath3, ...args }) {
  let cause = err;
  if (containsNodeError(err))
    cause = getNodeError(err, args);
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}
var init_getEstimateGasError = __esm({
  "node_modules/viem/dist/esm/utils/errors/getEstimateGasError.js"() {
    init_estimateGas();
    init_getNodeError();
  }
});

// node_modules/viem/dist/esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  const account_ = args.account ?? client.account;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/public/estimateGas"
    });
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await prepareRequest(client, args) : args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const format2 = client.chain?.formatters?.transactionRequest?.format || formatTransactionRequest;
    const request = format2({
      ...extract(rest, { format: format2 }),
      from: account.address,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    const balance = await client.request({
      method: "eth_estimateGas",
      params: block ? [request, block] : [request]
    });
    return BigInt(balance);
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}
var init_estimateGas2 = __esm({
  "node_modules/viem/dist/esm/actions/public/estimateGas.js"() {
    init_parseAccount();
    init_account();
    init_toHex();
    init_getEstimateGasError();
    init_extract();
    init_transactionRequest();
    init_assertRequest();
    init_prepareRequest();
  }
});

// node_modules/viem/dist/esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format2 = client.chain?.formatters?.block?.format || formatBlock;
  return format2(block);
}
var init_getBlock = __esm({
  "node_modules/viem/dist/esm/actions/public/getBlock.js"() {
    init_block2();
    init_toHex();
    init_block();
  }
});

// node_modules/viem/dist/esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}
var init_getGasPrice = __esm({
  "node_modules/viem/dist/esm/actions/public/getGasPrice.js"() {
  }
});

// node_modules/viem/dist/esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  });
  return hexToNumber(count);
}
var init_getTransactionCount = __esm({
  "node_modules/viem/dist/esm/actions/public/getTransactionCount.js"() {
    init_fromHex();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/utils/transaction/prepareRequest.js
async function prepareRequest(client, args) {
  const { account: account_, chain = client.chain, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  const block = await getBlock(client, { blockTag: "latest" });
  const request = { ...args, from: account.address };
  if (typeof nonce === "undefined")
    request.nonce = await getTransactionCount(client, {
      address: account.address,
      blockTag: "pending"
    });
  if (typeof block.baseFeePerGas === "bigint" && typeof gasPrice === "undefined") {
    let defaultPriorityFee = 1500000000n;
    if (typeof chain?.fees?.defaultPriorityFee !== "undefined") {
      defaultPriorityFee = typeof chain.fees.defaultPriorityFee === "bigint" ? chain.fees.defaultPriorityFee : await chain.fees.defaultPriorityFee({
        block,
        request
      });
    }
    if (typeof maxFeePerGas === "undefined") {
      request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultPriorityFee;
      request.maxFeePerGas = block.baseFeePerGas * 120n / 100n + request.maxPriorityFeePerGas;
    } else {
      if (typeof maxPriorityFeePerGas === "undefined" && maxFeePerGas < defaultPriorityFee)
        throw new BaseError("`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).");
      request.maxFeePerGas = maxFeePerGas;
      request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultPriorityFee;
    }
  } else if (typeof gasPrice === "undefined") {
    if (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined")
      throw new BaseError("Chain does not support EIP-1559 fees.");
    request.gasPrice = await getGasPrice(client) * 120n / 100n;
  }
  if (typeof gas === "undefined")
    request.gas = await estimateGas(client, {
      ...request,
      account: { address: account.address, type: "json-rpc" }
    });
  assertRequest(request);
  return request;
}
var init_prepareRequest = __esm({
  "node_modules/viem/dist/esm/utils/transaction/prepareRequest.js"() {
    init_parseAccount();
    init_estimateGas2();
    init_getBlock();
    init_getGasPrice();
    init_getTransactionCount();
    init_account();
    init_base();
    init_assertRequest();
  }
});

// node_modules/viem/dist/esm/utils/abi/decodeEventLog.js
function decodeEventLog({ abi, data, strict: strict_, topics }) {
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({
      docsPath
    });
  const abiItem = abi.find((x) => x.type === "event" && signature === getEventSelector(formatAbiItem(x)));
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, {
      docsPath
    });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
  if (argTopics.length > 0) {
    for (let i = 0; i < indexedInputs.length; i++) {
      const param = indexedInputs[i];
      const topic = argTopics[i];
      if (!topic)
        throw new DecodeLogTopicsMismatch({
          abiItem,
          param
        });
      args[param.name || i] = decodeTopic({ param, value: topic });
    }
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              args[nonIndexedInputs[i].name] = decodedData[i];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data: err.data,
              params: err.params,
              size: err.size
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}
var docsPath;
var init_decodeEventLog = __esm({
  "node_modules/viem/dist/esm/utils/abi/decodeEventLog.js"() {
    init_abi();
    init_getEventSelector();
    init_decodeAbiParameters();
    init_formatAbiItem();
    docsPath = "/docs/contract/decodeEventLog";
  }
});

// node_modules/viem/dist/esm/utils/regex.js
var bytesRegex2, integerRegex2;
var init_regex2 = __esm({
  "node_modules/viem/dist/esm/utils/regex.js"() {
    bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  }
});

// node_modules/viem/dist/esm/utils/typedData.js
function validateTypedData({ domain, message, primaryType, types: types_ }) {
  const types = types_;
  const validateData = (struct, value_) => {
    for (const param of struct) {
      const { name, type: type_ } = param;
      const type = type_;
      const value = value_[name];
      const integerMatch = type.match(integerRegex2);
      if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
        const [_type, base3, size_] = integerMatch;
        numberToHex(value, {
          signed: base3 === "int",
          size: parseInt(size_) / 8
        });
      }
      if (type === "address" && typeof value === "string" && !isAddress(value))
        throw new InvalidAddressError({ address: value });
      const bytesMatch = type.match(bytesRegex2);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value) !== parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: parseInt(size_),
            givenSize: size(value)
          });
      }
      const struct2 = types[type];
      if (struct2)
        validateData(struct2, value);
    }
  };
  if (types["EIP712Domain"] && domain)
    validateData(types["EIP712Domain"], domain);
  if (primaryType !== "EIP712Domain") {
    const type = types[primaryType];
    validateData(type, message);
  }
}
var init_typedData = __esm({
  "node_modules/viem/dist/esm/utils/typedData.js"() {
    init_abi();
    init_address();
    init_isAddress();
    init_size();
    init_toHex();
    init_regex2();
  }
});

// node_modules/viem/dist/esm/utils/abi/encodeDeployData.js
function encodeDeployData({ abi, args, bytecode }) {
  if (!args || args.length === 0)
    return bytecode;
  const description = abi.find((x) => "type" in x && x.type === "constructor");
  if (!description)
    throw new AbiConstructorNotFoundError({ docsPath: docsPath2 });
  if (!("inputs" in description))
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath2 });
  if (!description.inputs || description.inputs.length === 0)
    throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath2 });
  const data = encodeAbiParameters(description.inputs, args);
  return concatHex([bytecode, data]);
}
var docsPath2;
var init_encodeDeployData = __esm({
  "node_modules/viem/dist/esm/utils/abi/encodeDeployData.js"() {
    init_abi();
    init_concat();
    init_encodeAbiParameters();
    docsPath2 = "/docs/contract/encodeDeployData";
  }
});

// node_modules/viem/dist/esm/utils/abi/encodeErrorResult.js
var init_encodeErrorResult = __esm({
  "node_modules/viem/dist/esm/utils/abi/encodeErrorResult.js"() {
    init_abi();
    init_concat();
    init_getFunctionSelector();
    init_encodeAbiParameters();
    init_formatAbiItem();
    init_getAbiItem();
  }
});

// node_modules/viem/dist/esm/utils/abi/encodeFunctionResult.js
var init_encodeFunctionResult = __esm({
  "node_modules/viem/dist/esm/utils/abi/encodeFunctionResult.js"() {
    init_abi();
    init_encodeAbiParameters();
    init_getAbiItem();
  }
});

// node_modules/viem/dist/esm/utils/abi/encodePacked.js
var init_encodePacked = __esm({
  "node_modules/viem/dist/esm/utils/abi/encodePacked.js"() {
    init_abi();
    init_address();
    init_isAddress();
    init_concat();
    init_pad();
    init_toHex();
    init_regex2();
  }
});

// node_modules/viem/dist/esm/utils/data/isBytes.js
var init_isBytes = __esm({
  "node_modules/viem/dist/esm/utils/data/isBytes.js"() {
  }
});

// node_modules/viem/dist/esm/utils/address/getContractAddress.js
var init_getContractAddress = __esm({
  "node_modules/viem/dist/esm/utils/address/getContractAddress.js"() {
    init_concat();
    init_isBytes();
    init_pad();
    init_slice();
    init_toBytes();
    init_toRlp();
    init_keccak256();
    init_getAddress();
  }
});

// node_modules/viem/dist/esm/utils/encoding/fromBytes.js
var init_fromBytes = __esm({
  "node_modules/viem/dist/esm/utils/encoding/fromBytes.js"() {
    init_encoding();
    init_trim();
    init_fromHex();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/utils/encoding/fromRlp.js
var init_fromRlp = __esm({
  "node_modules/viem/dist/esm/utils/encoding/fromRlp.js"() {
    init_encoding();
    init_fromBytes();
    init_toBytes();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/utils/hash/isHash.js
var init_isHash = __esm({
  "node_modules/viem/dist/esm/utils/hash/isHash.js"() {
    init_isHex();
    init_size();
  }
});

// node_modules/viem/dist/esm/utils/signature/hashTypedData.js
function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
  const domain = typeof domain_ === "undefined" ? {} : domain_;
  const types = {
    EIP712Domain: [
      typeof domain?.name === "string" && { name: "name", type: "string" },
      domain?.version && { name: "version", type: "string" },
      typeof domain?.chainId === "number" && {
        name: "chainId",
        type: "uint256"
      },
      domain?.verifyingContract && {
        name: "verifyingContract",
        type: "address"
      },
      domain?.salt && { name: "salt", type: "bytes32" }
    ].filter(Boolean),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  const parts = ["0x1901"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types
    }));
  if (primaryType !== "EIP712Domain") {
    parts.push(hashStruct({
      data: message,
      primaryType,
      types
    }));
  }
  return keccak256(concat(parts));
}
function hashDomain({ domain, types }) {
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types
  });
}
function hashStruct({ data, primaryType, types }) {
  const encoded = encodeData({
    data,
    primaryType,
    types
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types })];
  for (const field of types[primaryType]) {
    const [type, value] = encodeField({
      types,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type);
    encodedValues.push(value);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
  const encodedHashType = toHex(encodeType({ primaryType, types }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type of deps) {
    result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match?.[0];
  if (results.has(primaryType) || types[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types }, results);
  }
  return results;
}
function encodeField({ types, name, type, value }) {
  if (types[type] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value, primaryType: type, types }))
    ];
  }
  if (type === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value)];
  }
  if (type === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value))];
  if (type.lastIndexOf("]") === type.length - 1) {
    const parsedType = type.slice(0, type.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type }, value];
}
var init_hashTypedData = __esm({
  "node_modules/viem/dist/esm/utils/signature/hashTypedData.js"() {
    init_encodeAbiParameters();
    init_concat();
    init_toHex();
    init_keccak256();
    init_typedData();
  }
});

// node_modules/viem/dist/esm/utils/signature/recoverPublicKey.js
var init_recoverPublicKey = __esm({
  "node_modules/viem/dist/esm/utils/signature/recoverPublicKey.js"() {
    init_isHex();
    init_fromHex();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/accounts/utils/publicKeyToAddress.js
var init_publicKeyToAddress = __esm({
  "node_modules/viem/dist/esm/accounts/utils/publicKeyToAddress.js"() {
    init_getAddress();
    init_keccak256();
  }
});

// node_modules/viem/dist/esm/utils/signature/recoverAddress.js
var init_recoverAddress = __esm({
  "node_modules/viem/dist/esm/utils/signature/recoverAddress.js"() {
    init_publicKeyToAddress();
    init_recoverPublicKey();
  }
});

// node_modules/viem/dist/esm/utils/signature/hashMessage.js
function hashMessage(message, to_) {
  const messageBytes = (() => {
    if (typeof message === "string")
      return stringToBytes(message);
    if (message.raw instanceof Uint8Array)
      return message.raw;
    return toBytes(message.raw);
  })();
  const prefixBytes = stringToBytes(`Ethereum Signed Message:
${messageBytes.length}`);
  return keccak256(concat([prefixBytes, messageBytes]), to_);
}
var init_hashMessage = __esm({
  "node_modules/viem/dist/esm/utils/signature/hashMessage.js"() {
    init_concat();
    init_toBytes();
    init_keccak256();
  }
});

// node_modules/viem/dist/esm/utils/signature/recoverMessageAddress.js
var init_recoverMessageAddress = __esm({
  "node_modules/viem/dist/esm/utils/signature/recoverMessageAddress.js"() {
    init_hashMessage();
    init_recoverAddress();
  }
});

// node_modules/viem/dist/esm/utils/signature/recoverTypedDataAddress.js
var init_recoverTypedDataAddress = __esm({
  "node_modules/viem/dist/esm/utils/signature/recoverTypedDataAddress.js"() {
    init_hashTypedData();
    init_recoverAddress();
  }
});

// node_modules/viem/dist/esm/utils/signature/verifyMessage.js
var init_verifyMessage = __esm({
  "node_modules/viem/dist/esm/utils/signature/verifyMessage.js"() {
    init_getAddress();
    init_isAddressEqual();
    init_recoverMessageAddress();
  }
});

// node_modules/viem/dist/esm/utils/signature/verifyTypedData.js
var init_verifyTypedData = __esm({
  "node_modules/viem/dist/esm/utils/signature/verifyTypedData.js"() {
    init_getAddress();
    init_isAddressEqual();
    init_recoverTypedDataAddress();
  }
});

// node_modules/viem/dist/esm/utils/transaction/getSerializedTransactionType.js
var init_getSerializedTransactionType = __esm({
  "node_modules/viem/dist/esm/utils/transaction/getSerializedTransactionType.js"() {
    init_transaction();
    init_slice();
    init_fromHex();
  }
});

// node_modules/viem/dist/esm/utils/transaction/parseTransaction.js
var init_parseTransaction = __esm({
  "node_modules/viem/dist/esm/utils/transaction/parseTransaction.js"() {
    init_address();
    init_transaction();
    init_isAddress();
    init_isHex();
    init_pad();
    init_trim();
    init_fromHex();
    init_fromRlp();
    init_isHash();
    init_assertTransaction();
    init_getSerializedTransactionType();
  }
});

// node_modules/viem/dist/esm/utils/unit/parseUnits.js
var init_parseUnits = __esm({
  "node_modules/viem/dist/esm/utils/unit/parseUnits.js"() {
  }
});

// node_modules/viem/dist/esm/utils/unit/parseEther.js
var init_parseEther = __esm({
  "node_modules/viem/dist/esm/utils/unit/parseEther.js"() {
    init_unit();
    init_parseUnits();
  }
});

// node_modules/viem/dist/esm/utils/unit/parseGwei.js
var init_parseGwei = __esm({
  "node_modules/viem/dist/esm/utils/unit/parseGwei.js"() {
    init_unit();
    init_parseUnits();
  }
});

// node_modules/viem/dist/esm/utils/wait.js
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}
var init_wait = __esm({
  "node_modules/viem/dist/esm/utils/wait.js"() {
  }
});

// node_modules/viem/dist/esm/utils/promise/withRetry.js
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
  return new Promise((resolve, reject) => {
    const attemptRetry = async ({ count = 0 } = {}) => {
      const retry = async ({ error }) => {
        const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
        if (delay)
          await wait(delay);
        attemptRetry({ count: count + 1 });
      };
      try {
        const data = await fn();
        resolve(data);
      } catch (err) {
        if (count < retryCount && await shouldRetry({ count, error: err }))
          return retry({ error: err });
        reject(err);
      }
    };
    attemptRetry();
  });
}
var init_withRetry = __esm({
  "node_modules/viem/dist/esm/utils/promise/withRetry.js"() {
    init_wait();
  }
});

// node_modules/viem/dist/esm/utils/buildRequest.js
function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
  return async (args) => withRetry(async () => {
    try {
      return await request(args);
    } catch (err_) {
      const err = err_;
      switch (err.code) {
        case ParseRpcError.code:
          throw new ParseRpcError(err);
        case InvalidRequestRpcError.code:
          throw new InvalidRequestRpcError(err);
        case MethodNotFoundRpcError.code:
          throw new MethodNotFoundRpcError(err);
        case InvalidParamsRpcError.code:
          throw new InvalidParamsRpcError(err);
        case InternalRpcError.code:
          throw new InternalRpcError(err);
        case InvalidInputRpcError.code:
          throw new InvalidInputRpcError(err);
        case ResourceNotFoundRpcError.code:
          throw new ResourceNotFoundRpcError(err);
        case ResourceUnavailableRpcError.code:
          throw new ResourceUnavailableRpcError(err);
        case TransactionRejectedRpcError.code:
          throw new TransactionRejectedRpcError(err);
        case MethodNotSupportedRpcError.code:
          throw new MethodNotSupportedRpcError(err);
        case LimitExceededRpcError.code:
          throw new LimitExceededRpcError(err);
        case JsonRpcVersionUnsupportedError.code:
          throw new JsonRpcVersionUnsupportedError(err);
        case UserRejectedRequestError.code:
          throw new UserRejectedRequestError(err);
        case UnauthorizedProviderError.code:
          throw new UnauthorizedProviderError(err);
        case UnsupportedProviderMethodError.code:
          throw new UnsupportedProviderMethodError(err);
        case ProviderDisconnectedError.code:
          throw new ProviderDisconnectedError(err);
        case ChainDisconnectedError.code:
          throw new ChainDisconnectedError(err);
        case SwitchChainError.code:
          throw new SwitchChainError(err);
        default:
          if (err_ instanceof BaseError)
            throw err_;
          throw new UnknownRpcError(err);
      }
    }
  }, {
    delay: ({ count, error }) => {
      if (error && error instanceof HttpRequestError) {
        const retryAfter = error?.headers?.get("Retry-After");
        if (retryAfter?.match(/\d/))
          return parseInt(retryAfter) * 1e3;
      }
      return ~~(1 << count) * retryDelay;
    },
    retryCount,
    shouldRetry: ({ error }) => !isDeterministicError(error)
  });
}
var isDeterministicError;
var init_buildRequest = __esm({
  "node_modules/viem/dist/esm/utils/buildRequest.js"() {
    init_base();
    init_request();
    init_rpc();
    init_withRetry();
    isDeterministicError = (error) => {
      if ("code" in error)
        return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
      if (error instanceof HttpRequestError && error.status)
        return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
      return false;
    };
  }
});

// node_modules/viem/dist/esm/utils/promise/withTimeout.js
function withTimeout(fn, { errorInstance, timeout, signal }) {
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        }
        resolve(await fn({ signal: controller?.signal }));
      } catch (err) {
        if (err.name === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
var init_withTimeout = __esm({
  "node_modules/viem/dist/esm/utils/promise/withTimeout.js"() {
  }
});

// node_modules/viem/dist/esm/utils/rpc.js
async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
  const { headers, method, signal: signal_ } = fetchOptions;
  try {
    const response = await withTimeout(async ({ signal }) => {
      const response2 = await fetch(url, {
        ...fetchOptions,
        body: Array.isArray(body) ? stringify(body.map((body2) => ({
          jsonrpc: "2.0",
          id: id++,
          ...body2
        }))) : stringify({ jsonrpc: "2.0", id: id++, ...body }),
        headers: {
          ...headers,
          "Content-Type": "application/json"
        },
        method: method || "POST",
        signal: signal_ || (timeout > 0 ? signal : void 0)
      });
      return response2;
    }, {
      errorInstance: new TimeoutError({ body, url }),
      timeout,
      signal: true
    });
    let data;
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
      data = await response.json();
    } else {
      data = await response.text();
    }
    if (!response.ok) {
      throw new HttpRequestError({
        body,
        details: stringify(data.error) || response.statusText,
        headers: response.headers,
        status: response.status,
        url
      });
    }
    return data;
  } catch (err) {
    if (err instanceof HttpRequestError)
      throw err;
    if (err instanceof TimeoutError)
      throw err;
    throw new HttpRequestError({
      body,
      details: err.message,
      url
    });
  }
}
async function getSocket(url_) {
  const url = new URL(url_);
  const urlKey = url.toString();
  let socket = sockets.get(urlKey);
  if (socket)
    return socket;
  const { schedule } = createBatchScheduler({
    id: urlKey,
    fn: async () => {
      let WebSocket = await import("./browser-VSZKQ24D.js");
      if (WebSocket.default?.constructor)
        WebSocket = WebSocket.default;
      else
        WebSocket = WebSocket.WebSocket;
      const webSocket2 = new WebSocket(url);
      const requests = /* @__PURE__ */ new Map();
      const subscriptions = /* @__PURE__ */ new Map();
      const onMessage = ({ data }) => {
        const message = JSON.parse(data);
        const isSubscription = message.method === "eth_subscription";
        const id2 = isSubscription ? message.params.subscription : message.id;
        const cache = isSubscription ? subscriptions : requests;
        const callback = cache.get(id2);
        if (callback)
          callback({ data });
        if (!isSubscription)
          cache.delete(id2);
      };
      const onClose = () => {
        sockets.delete(urlKey);
        webSocket2.removeEventListener("close", onClose);
        webSocket2.removeEventListener("message", onMessage);
      };
      webSocket2.addEventListener("close", onClose);
      webSocket2.addEventListener("message", onMessage);
      if (webSocket2.readyState === WebSocket.CONNECTING) {
        await new Promise((resolve, reject) => {
          if (!webSocket2)
            return;
          webSocket2.onopen = resolve;
          webSocket2.onerror = reject;
        });
      }
      socket = Object.assign(webSocket2, {
        requests,
        subscriptions
      });
      sockets.set(urlKey, socket);
      return [socket];
    }
  });
  const [_, [socket_]] = await schedule();
  return socket_;
}
function webSocket(socket, { body, onResponse }) {
  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
    throw new WebSocketRequestError({
      body,
      url: socket.url,
      details: "Socket is closed."
    });
  const id_ = id++;
  const callback = ({ data }) => {
    const message = JSON.parse(data);
    if (typeof message.id === "number" && id_ !== message.id)
      return;
    onResponse?.(message);
    if (body.method === "eth_subscribe" && typeof message.result === "string") {
      socket.subscriptions.set(message.result, callback);
    }
    if (body.method === "eth_unsubscribe") {
      socket.subscriptions.delete(body.params?.[0]);
    }
  };
  socket.requests.set(id_, callback);
  socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
  return socket;
}
async function webSocketAsync(socket, { body, timeout = 1e4 }) {
  return withTimeout(() => new Promise((onResponse) => rpc.webSocket(socket, {
    body,
    onResponse
  })), {
    errorInstance: new TimeoutError({ body, url: socket.url }),
    timeout
  });
}
var id, sockets, rpc;
var init_rpc2 = __esm({
  "node_modules/viem/dist/esm/utils/rpc.js"() {
    init_request();
    init_createBatchScheduler();
    init_withTimeout();
    init_stringify();
    id = 0;
    sockets = /* @__PURE__ */ new Map();
    rpc = {
      http,
      webSocket,
      webSocketAsync
    };
  }
});

// node_modules/viem/dist/esm/utils/errors/getTransactionError.js
function getTransactionError(err, { docsPath: docsPath3, ...args }) {
  let cause = err;
  if (containsNodeError(err))
    cause = getNodeError(err, args);
  return new TransactionExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}
var init_getTransactionError = __esm({
  "node_modules/viem/dist/esm/utils/errors/getTransactionError.js"() {
    init_transaction();
    init_getNodeError();
  }
});

// node_modules/viem/dist/esm/utils/index.js
var init_utils2 = __esm({
  "node_modules/viem/dist/esm/utils/index.js"() {
    init_buildRequest();
    init_ccip();
    init_chain2();
    init_regex2();
    init_rpc2();
    init_stringify();
    init_typedData();
    init_decodeAbiParameters();
    init_decodeErrorResult();
    init_decodeEventLog();
    init_decodeFunctionData();
    init_decodeFunctionResult();
    init_encodeAbiParameters();
    init_encodeDeployData();
    init_encodeErrorResult();
    init_encodeEventTopics();
    init_encodeFunctionData();
    init_encodeFunctionResult();
    init_getAbiItem();
    init_esm();
    init_encodePacked();
    init_formatAbiItemWithArgs();
    init_formatAbiItem();
    init_parseAccount();
    init_publicKeyToAddress();
    init_getContractAddress();
    init_getAddress();
    init_isAddress();
    init_isAddressEqual();
    init_extractFunctionParts();
    init_concat();
    init_isBytes();
    init_isHex();
    init_pad();
    init_size();
    init_slice();
    init_trim();
    init_block();
    init_transaction2();
    init_log();
    init_transactionReceipt();
    init_transactionRequest();
    init_extract();
    init_toRlp();
    init_toBytes();
    init_toHex();
    init_fromBytes();
    init_fromHex();
    init_fromRlp();
    init_getNodeError();
    init_getCallError();
    init_getContractError();
    init_getEstimateGasError();
    init_getTransactionError();
    init_formatter();
    init_getEventSelector();
    init_getFunctionSelector();
    init_isHash();
    init_keccak256();
    init_hashTypedData();
    init_recoverAddress();
    init_recoverMessageAddress();
    init_recoverPublicKey();
    init_recoverTypedDataAddress();
    init_verifyMessage();
    init_verifyTypedData();
    init_hashMessage();
    init_getSerializedTransactionType();
    init_getTransactionType();
    init_assertRequest();
    init_assertTransaction();
    init_parseTransaction();
    init_prepareRequest();
    init_serializeTransaction();
    init_serializeAccessList();
    init_formatEther();
    init_formatGwei();
    init_formatUnits();
    init_parseUnits();
    init_parseEther();
    init_parseGwei();
  }
});

// node_modules/viem/dist/esm/utils/ens/encodedLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash = `0x${label.slice(1, 65)}`;
  if (!isHex(hash))
    return null;
  return hash;
}
var init_encodedLabelToLabelhash = __esm({
  "node_modules/viem/dist/esm/utils/ens/encodedLabelToLabelhash.js"() {
    init_utils2();
  }
});

// node_modules/viem/dist/esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}
var init_namehash = __esm({
  "node_modules/viem/dist/esm/utils/ens/namehash.js"() {
    init_concat();
    init_toBytes();
    init_toHex();
    init_keccak256();
    init_encodedLabelToLabelhash();
  }
});

// node_modules/viem/dist/esm/utils/ens/labelhash.js
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}
var init_labelhash = __esm({
  "node_modules/viem/dist/esm/utils/ens/labelhash.js"() {
    init_toBytes();
    init_toHex();
    init_keccak256();
    init_encodedLabelToLabelhash();
  }
});

// node_modules/viem/dist/esm/errors/ens.js
var EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUriResolutionError, EnsAvatarUnsupportedNamespaceError;
var init_ens = __esm({
  "node_modules/viem/dist/esm/errors/ens.js"() {
    init_base();
    EnsAvatarInvalidMetadataError = class extends BaseError {
      constructor({ data }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: [
            "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
            "",
            `Provided data: ${JSON.stringify(data)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidMetadataError"
        });
      }
    };
    EnsAvatarInvalidNftUriError = class extends BaseError {
      constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidNftUriError"
        });
      }
    };
    EnsAvatarUriResolutionError = class extends BaseError {
      constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUriResolutionError"
        });
      }
    };
    EnsAvatarUnsupportedNamespaceError = class extends BaseError {
      constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUnsupportedNamespaceError"
        });
      }
    };
  }
});

// node_modules/@adraffy/ens-normalize/dist/index.js
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N = 31;
  const FULL = 2 ** N;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0; i < N; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n = s.length;
  let ret = new Uint8Array(6 * n >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n, next) {
  let v = Array(n);
  for (let i = 0, x = 0; i < n; i++)
    v[i] = x += signed(next());
  return v;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n = next();
    if (!n)
      break;
    prev += x;
    for (let i = 0; i < n; i++) {
      ret.push(prev + i);
    }
    prev += n + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length)
      return v;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x)
      break;
    v.push(x);
  }
  return v;
}
function read_transposed(n, w, next) {
  let m = Array(n).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n, next).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next) {
  let n = 1 + next();
  let m = read_transposed(n, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
}
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b) {
  if (a >= L0 && a < L1 && b >= V0 && b < V1) {
    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  let ret = [];
  let buf = [];
  let check_order = false;
  function add(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add(L0 + l_index);
        add(V0 + v_index);
        if (t_index > 0)
          add(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
function read_set() {
  return new Set(read_sorted(r$1));
}
function read_chunked() {
  return new Set([read_sorted(r$1).map((i) => CHUNKS[i]), read_sorted(r$1)].flat(2));
}
function read_emoji_trie(cps) {
  let B = read_array_while(() => {
    let keys = read_sorted(r$1).map((i) => EMOJI_SORTED[i]);
    if (keys.length)
      return read_emoji_trie(keys);
  }).sort((a, b) => b.Q.size - a.Q.size);
  let temp = r$1();
  let V = temp % 3;
  temp = temp / 3 | 0;
  let F = temp & 1;
  temp >>= 1;
  let S = temp & 1;
  let C = temp & 2;
  return { B, V, F, S, C, Q: new Set(cps) };
}
function safe_str_from_cps(cps, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("\u25CC");
  let prev = 0;
  let n = cps.length;
  for (let i = 0; i < n; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n)));
  return buf.join("");
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"\u200E`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error("invalid label extension");
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n = cps.length;
  let last = -1;
  for (let i = 1; i < n; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i)
        throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n)
    throw error_placement(`trailing ${prev}`);
}
function is_combining_mark(cp) {
  return CM.has(cp);
}
function should_escape(cp) {
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(ens_split(name));
}
function ens_split(name, preserve_emoji) {
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    let norm;
    try {
      let tokens = info.tokens = process(input, nfc);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      } else {
        let chars = tokens[0];
        let emoji = token_count > 1 || chars.is_emoji;
        if (!emoji && chars.every((cp) => cp < 128)) {
          norm = chars;
          check_leading_underscore(norm);
          check_label_extension(norm);
          type = "ASCII";
        } else {
          if (emoji) {
            info.emoji = true;
            chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
          }
          norm = tokens.flatMap((x) => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);
          check_leading_underscore(norm);
          if (!chars.length) {
            type = "Emoji";
          } else {
            if (CM.has(norm[0]))
              throw error_placement("leading combining mark");
            for (let i = 1; i < token_count; i++) {
              let cps = tokens[i];
              if (!cps.is_emoji && CM.has(cps[0])) {
                throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
              }
            }
            check_fenced(norm);
            let unique = [...new Set(chars)];
            let [g] = determine_group(unique);
            check_group(g, chars);
            check_whole(g, unique);
            type = g.N;
          }
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    info.output = norm;
    return info;
  });
}
function check_whole(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : [...set];
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => g.V.has(cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => g.V.has(cp));
    if (!gs.length) {
      if (groups === GROUPS) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
}
function flatten(split) {
  return split.map(({ input, error, output }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  let { V, M } = g;
  for (let cp of cps) {
    if (!V.has(cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function process(input, nf) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(emoji);
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node = node.B.find((x) => x.Q.has(cp));
    if (!node)
      break;
    if (node.S) {
      saved = cp;
    } else if (node.C) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.F) {
      stack.push(FE0F);
      if (pos > 0 && cps[pos - 1] == FE0F)
        pos--;
    }
    if (node.V) {
      emoji = conform_emoji_copy(stack, node);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}
function conform_emoji_copy(cps, node) {
  let copy = Emoji.from(cps);
  if (node.V == 2)
    copy.splice(1, 1);
  return copy;
}
var r$1, FENCED, NSM_MAX, r, SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP, S0, L0, V0, T0, L_COUNT, V_COUNT, T_COUNT, N_COUNT, S_COUNT, S1, L1, V1, T1, FE0F, STOP_CH, UNIQUE_PH, HYPHEN, MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, CHUNKS, UNRESTRICTED, GROUPS, WHOLE_VALID, WHOLE_MAP, union, multi, VALID, EMOJI_SORTED, EMOJI_ROOT, Emoji;
var init_dist = __esm({
  "node_modules/@adraffy/ens-normalize/dist/index.js"() {
    r$1 = read_compressed_payload("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");
    FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
    NSM_MAX = 4;
    r = read_compressed_payload("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");
    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
    EXCLUSIONS = new Set(read_sorted(r));
    DECOMP = /* @__PURE__ */ new Map();
    RECOMP = /* @__PURE__ */ new Map();
    for (let [cp, cps] of read_mapped(r)) {
      if (!EXCLUSIONS.has(cp) && cps.length == 2) {
        let [a, b] = cps;
        let bucket = RECOMP.get(a);
        if (!bucket) {
          bucket = /* @__PURE__ */ new Map();
          RECOMP.set(a, bucket);
        }
        bucket.set(b, cp);
      }
      DECOMP.set(cp, cps.reverse());
    }
    S0 = 44032;
    L0 = 4352;
    V0 = 4449;
    T0 = 4519;
    L_COUNT = 19;
    V_COUNT = 21;
    T_COUNT = 28;
    N_COUNT = V_COUNT * T_COUNT;
    S_COUNT = L_COUNT * N_COUNT;
    S1 = S0 + S_COUNT;
    L1 = L0 + L_COUNT;
    V1 = V0 + V_COUNT;
    T1 = T0 + T_COUNT;
    FE0F = 65039;
    STOP_CH = ".";
    UNIQUE_PH = 1;
    HYPHEN = 45;
    MAPPED = new Map(read_mapped(r$1));
    IGNORED = read_set();
    CM = read_set();
    NSM = new Set(read_sorted(r$1).map(function(i) {
      return this[i];
    }, [...CM]));
    ESCAPE = read_set();
    NFC_CHECK = read_set();
    CHUNKS = read_sorted_arrays(r$1);
    UNRESTRICTED = r$1();
    GROUPS = read_array_while((i) => {
      let N = read_array_while(r$1).map((x) => x + 96);
      if (N.length) {
        let R = i >= UNRESTRICTED;
        N[0] -= 32;
        N = str_from_cps(N);
        if (R)
          N = `Restricted[${N}]`;
        let P = read_chunked();
        let Q = read_chunked();
        let V = [...P, ...Q].sort((a, b) => a - b);
        let M = !r$1();
        return { N, P, M, R, V: new Set(V) };
      }
    });
    WHOLE_VALID = read_set();
    WHOLE_MAP = /* @__PURE__ */ new Map();
    [...WHOLE_VALID, ...read_set()].sort((a, b) => a - b).map((cp, i, v) => {
      let d = r$1();
      let w = v[i] = d ? v[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
      w.V.push(cp);
      if (!WHOLE_VALID.has(cp)) {
        WHOLE_MAP.set(cp, w);
      }
    });
    for (let { V, M } of new Set(WHOLE_MAP.values())) {
      let recs = [];
      for (let cp of V) {
        let gs = GROUPS.filter((g) => g.V.has(cp));
        let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
        if (!rec) {
          rec = { G: /* @__PURE__ */ new Set(), V: [] };
          recs.push(rec);
        }
        rec.V.push(cp);
        gs.forEach((g) => rec.G.add(g));
      }
      let union2 = recs.flatMap(({ G }) => [...G]);
      for (let { G, V: V2 } of recs) {
        let complement = new Set(union2.filter((g) => !G.has(g)));
        for (let cp of V2) {
          M.set(cp, complement);
        }
      }
    }
    union = /* @__PURE__ */ new Set();
    multi = /* @__PURE__ */ new Set();
    for (let g of GROUPS) {
      for (let cp of g.V) {
        (union.has(cp) ? multi : union).add(cp);
      }
    }
    for (let cp of union) {
      if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
        WHOLE_MAP.set(cp, UNIQUE_PH);
      }
    }
    VALID = /* @__PURE__ */ new Set([...union, ...nfd(union)]);
    EMOJI_SORTED = read_sorted(r$1);
    EMOJI_ROOT = read_emoji_trie([]);
    Emoji = class extends Array {
      get is_emoji() {
        return true;
      }
    };
  }
});

// node_modules/viem/dist/esm/utils/ens/normalize.js
function normalize(name) {
  return ens_normalize(name);
}
var init_normalize = __esm({
  "node_modules/viem/dist/esm/utils/ens/normalize.js"() {
    init_dist();
  }
});

// node_modules/viem/dist/esm/utils/ens/errors.js
function isNullUniversalResolverError(err, callType) {
  if (!(err instanceof BaseError))
    return false;
  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause instanceof ContractFunctionRevertedError))
    return false;
  if (cause.data?.errorName === "ResolverNotFound")
    return true;
  if (cause.data?.errorName === "ResolverWildcardNotSupported")
    return true;
  if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause.reason === panicReasons[50])
    return true;
  return false;
}
var init_errors2 = __esm({
  "node_modules/viem/dist/esm/utils/ens/errors.js"() {
    init_solidity();
    init_base();
    init_contract();
  }
});

// node_modules/viem/dist/esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash) {
  return `[${hash.slice(2)}]`;
}
var init_encodeLabelhash = __esm({
  "node_modules/viem/dist/esm/utils/ens/encodeLabelhash.js"() {
  }
});

// node_modules/viem/dist/esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value = packet.replace(/^\.|\.$/gm, "");
  if (value.length === 0)
    return new Uint8Array(1);
  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);
  let offset = 0;
  const list = value.split(".");
  for (let i = 0; i < list.length; i++) {
    let encoded = stringToBytes(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes.byteLength !== offset + 1)
    return bytes.slice(0, offset + 1);
  return bytes;
}
var init_packetToBytes = __esm({
  "node_modules/viem/dist/esm/utils/ens/packetToBytes.js"() {
    init_toBytes();
    init_encodeLabelhash();
    init_labelhash();
  }
});

// node_modules/viem/dist/esm/actions/public/readContract.js
async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await call(client, {
      data: calldata,
      to: address,
      ...callRequest
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (err) {
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}
var init_readContract = __esm({
  "node_modules/viem/dist/esm/actions/public/readContract.js"() {
    init_decodeFunctionResult();
    init_encodeFunctionData();
    init_getContractError();
    init_call();
  }
});

// node_modules/viem/dist/esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
    });
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [toHex(packetToBytes(name)), functionData],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address = trim(decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    }));
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
var init_getEnsAddress = __esm({
  "node_modules/viem/dist/esm/actions/ens/getEnsAddress.js"() {
    init_abis();
    init_decodeFunctionResult();
    init_encodeFunctionData();
    init_chain2();
    init_trim();
    init_toHex();
    init_errors2();
    init_namehash();
    init_packetToBytes();
    init_readContract();
  }
});

// node_modules/viem/dist/esm/utils/ens/avatar/utils.js
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType?.startsWith("image/");
    }
    return false;
  } catch (error) {
    if (typeof error === "object" && typeof error.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom, defaultGateway) {
  if (!custom)
    return defaultGateway;
  if (custom.endsWith("/"))
    return custom.slice(0, -1);
  return custom;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls?.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  } else if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
var networkRegex, ipfsHashRegex, base64Regex, dataURIRegex;
var init_utils3 = __esm({
  "node_modules/viem/dist/esm/utils/ens/avatar/utils.js"() {
    init_readContract();
    init_ens();
    networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
  }
});

// node_modules/viem/dist/esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record }) {
  if (/eip155:/i.test(record))
    return parseNftAvatarUri(client, { gatewayUrls, record });
  return parseAvatarUri({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
  const nft = parseNftUri(record);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}
var init_parseAvatarRecord = __esm({
  "node_modules/viem/dist/esm/utils/ens/avatar/parseAvatarRecord.js"() {
    init_utils3();
  }
});

// node_modules/viem/dist/esm/actions/ens/getEnsText.js
async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  } catch (err) {
    if (isNullUniversalResolverError(err, "resolve"))
      return null;
    throw err;
  }
}
var init_getEnsText = __esm({
  "node_modules/viem/dist/esm/actions/ens/getEnsText.js"() {
    init_abis();
    init_decodeFunctionResult();
    init_encodeFunctionData();
    init_chain2();
    init_toHex();
    init_errors2();
    init_namehash();
    init_packetToBytes();
    init_readContract();
  }
});

// node_modules/viem/dist/esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
  const record = await getEnsText(client, {
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress
  });
  if (!record)
    return null;
  try {
    return await parseAvatarRecord(client, { record, gatewayUrls });
  } catch {
    return null;
  }
}
var init_getEnsAvatar = __esm({
  "node_modules/viem/dist/esm/actions/ens/getEnsAvatar.js"() {
    init_parseAvatarRecord();
    init_getEnsText();
  }
});

// node_modules/viem/dist/esm/actions/ens/getEnsName.js
async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    });
    return res[0];
  } catch (err) {
    if (isNullUniversalResolverError(err, "reverse"))
      return null;
    throw err;
  }
}
var init_getEnsName = __esm({
  "node_modules/viem/dist/esm/actions/ens/getEnsName.js"() {
    init_abis();
    init_chain2();
    init_toHex();
    init_errors2();
    init_packetToBytes();
    init_readContract();
  }
});

// node_modules/viem/dist/esm/actions/ens/getEnsResolver.js
async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [resolverAddress] = await readContract(client, {
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}
var init_getEnsResolver = __esm({
  "node_modules/viem/dist/esm/actions/ens/getEnsResolver.js"() {
    init_chain2();
    init_toHex();
    init_packetToBytes();
    init_readContract();
  }
});

// node_modules/viem/dist/esm/ens.js
var ens_exports = {};
__export(ens_exports, {
  getEnsAddress: () => getEnsAddress,
  getEnsAvatar: () => getEnsAvatar,
  getEnsName: () => getEnsName,
  getEnsResolver: () => getEnsResolver,
  getEnsText: () => getEnsText,
  labelhash: () => labelhash,
  namehash: () => namehash,
  normalize: () => normalize
});
var init_ens2 = __esm({
  "node_modules/viem/dist/esm/ens.js"() {
    init_normalize();
    init_getEnsAddress();
    init_getEnsAvatar();
    init_getEnsName();
    init_getEnsResolver();
    init_getEnsText();
    init_labelhash();
    init_namehash();
  }
});

// node_modules/viem/node_modules/@wagmi/chains/dist/index.mjs
var arbitrum, arbitrumGoerli, aurora, auroraTestnet, avalanche, avalancheFuji, base, baseGoerli, boba, bronos, bronosTestnet, bsc, bscTestnet, canto, celo, celoAlfajores, celoCannoli, cronos, crossbell, dfk, dogechain, evmos, evmosTestnet, fantom, fantomTestnet, filecoin, filecoinCalibration, filecoinHyperspace, flare, flareTestnet, foundry, iotex, iotexTestnet, goerli, gnosis, gnosisChiado, hardhat, harmonyOne, haqqMainnet, haqqTestedge2, klaytn, lineaTestnet, localhost, mainnet, metis, metisGoerli, mev, mevTestnet, moonbaseAlpha, moonbeam, moonriver, nexi, okc, optimism, optimismGoerli, polygon, polygonMumbai, polygonZkEvmTestnet, polygonZkEvm, pulsechain, pulsechainV4, scrollTestnet, sepolia, skaleBlockBrawlers, skaleCalypso, skaleCalypsoTestnet, skaleChaosTestnet, skaleCryptoBlades, skaleCryptoColosseum, skaleEuropa, skaleEuropaTestnet, skaleExorde, skaleHumanProtocol, skaleNebula, skaleNebulaTestnet, skaleRazor, skaleTitan, skaleTitanTestnet, songbird, songbirdTestnet, shardeumSphinx, syscoin, taraxa, taraxaTestnet, telos, telosTestnet, thunderTestnet, wanchain, wanchainTestnet, xdc, xdcTestnet, zhejiang, zkSync, zkSyncTestnet, zora, zoraTestnet;
var init_dist2 = __esm({
  "node_modules/viem/node_modules/@wagmi/chains/dist/index.mjs"() {
    arbitrum = {
      id: 42161,
      name: "Arbitrum One",
      network: "arbitrum",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://arb-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://arbitrum-mainnet.infura.io/v3"],
          webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://arb1.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://arb1.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
        default: { name: "Arbiscan", url: "https://arbiscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7654707
        }
      }
    };
    arbitrumGoerli = {
      id: 421613,
      name: "Arbitrum Goerli",
      network: "arbitrum-goerli",
      nativeCurrency: {
        name: "Arbitrum Goerli Ether",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: {
        alchemy: {
          http: ["https://arb-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://arbitrum-goerli.infura.io/v3"],
          webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://goerli-rollup.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://goerli-rollup.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" },
        default: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 88114
        }
      },
      testnet: true
    };
    aurora = {
      id: 1313161554,
      name: "Aurora",
      network: "aurora",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        infura: { http: ["https://aurora-mainnet.infura.io/v3"] },
        default: { http: ["https://mainnet.aurora.dev"] },
        public: { http: ["https://mainnet.aurora.dev"] }
      },
      blockExplorers: {
        etherscan: { name: "Aurorascan", url: "https://aurorascan.dev" },
        default: { name: "Aurorascan", url: "https://aurorascan.dev" }
      }
    };
    auroraTestnet = {
      id: 1313161555,
      name: "Aurora Testnet",
      network: "aurora-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        infura: { http: ["https://aurora-testnet.infura.io/v3"] },
        default: { http: ["https://testnet.aurora.dev"] },
        public: { http: ["https://testnet.aurora.dev"] }
      },
      blockExplorers: {
        etherscan: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" },
        default: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" }
      },
      testnet: true
    };
    avalanche = {
      id: 43114,
      name: "Avalanche",
      network: "avalanche",
      nativeCurrency: {
        decimals: 18,
        name: "Avalanche",
        symbol: "AVAX"
      },
      rpcUrls: {
        default: { http: ["https://api.avax.network/ext/bc/C/rpc"] },
        public: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
      },
      blockExplorers: {
        etherscan: { name: "SnowTrace", url: "https://snowtrace.io" },
        default: { name: "SnowTrace", url: "https://snowtrace.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 11907934
        }
      }
    };
    avalancheFuji = {
      id: 43113,
      name: "Avalanche Fuji",
      network: "avalanche-fuji",
      nativeCurrency: {
        decimals: 18,
        name: "Avalanche Fuji",
        symbol: "AVAX"
      },
      rpcUrls: {
        default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] },
        public: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
      },
      blockExplorers: {
        etherscan: { name: "SnowTrace", url: "https://testnet.snowtrace.io" },
        default: { name: "SnowTrace", url: "https://testnet.snowtrace.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7096959
        }
      },
      testnet: true
    };
    base = {
      id: 8453,
      network: "base",
      name: "Base",
      nativeCurrency: { name: "Base", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://developer-access-mainnet.base.org"]
        },
        public: {
          http: ["https://developer-access-mainnet.base.org"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Basescout",
          url: "https://base.blockscout.com"
        },
        default: {
          name: "Basescan",
          url: "https://basescan.org"
        },
        etherscan: {
          name: "Basescan",
          url: "https://basescan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 5022
        }
      }
    };
    baseGoerli = {
      id: 84531,
      network: "base-goerli",
      name: "Base Goerli",
      nativeCurrency: { name: "Base Goerli", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://goerli.base.org"]
        },
        public: {
          http: ["https://goerli.base.org"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Basescan",
          url: "https://goerli.basescan.org"
        },
        default: {
          name: "Basescan",
          url: "https://goerli.basescan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1376988
        }
      },
      testnet: true
    };
    boba = {
      id: 288,
      name: "Boba Network",
      network: "boba",
      nativeCurrency: {
        decimals: 18,
        name: "Boba",
        symbol: "BOBA"
      },
      rpcUrls: {
        default: { http: ["https://mainnet.boba.network"] },
        public: { http: ["https://mainnet.boba.network"] }
      },
      blockExplorers: {
        etherscan: { name: "BOBAScan", url: "https://bobascan.com" },
        default: { name: "BOBAScan", url: "https://bobascan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 446859
        }
      }
    };
    bronos = {
      id: 1039,
      name: "Bronos",
      network: "bronos",
      nativeCurrency: {
        decimals: 18,
        name: "BRO",
        symbol: "BRO"
      },
      rpcUrls: {
        default: { http: ["https://evm.bronos.org"] },
        public: { http: ["https://evm.bronos.org"] }
      },
      blockExplorers: {
        default: { name: "BronoScan", url: "https://broscan.bronos.org" }
      }
    };
    bronosTestnet = {
      id: 1038,
      name: "Bronos Testnet",
      network: "bronos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Bronos Coin",
        symbol: "tBRO"
      },
      rpcUrls: {
        default: { http: ["https://evm-testnet.bronos.org"] },
        public: { http: ["https://evm-testnet.bronos.org"] }
      },
      blockExplorers: {
        default: { name: "BronoScan", url: "https://tbroscan.bronos.org" }
      },
      testnet: true
    };
    bsc = {
      id: 56,
      name: "BNB Smart Chain",
      network: "bsc",
      nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "BNB"
      },
      rpcUrls: {
        default: { http: ["https://rpc.ankr.com/bsc"] },
        public: { http: ["https://rpc.ankr.com/bsc"] }
      },
      blockExplorers: {
        etherscan: { name: "BscScan", url: "https://bscscan.com" },
        default: { name: "BscScan", url: "https://bscscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 15921452
        }
      }
    };
    bscTestnet = {
      id: 97,
      name: "Binance Smart Chain Testnet",
      network: "bsc-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "tBNB"
      },
      rpcUrls: {
        default: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] },
        public: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] }
      },
      blockExplorers: {
        etherscan: { name: "BscScan", url: "https://testnet.bscscan.com" },
        default: { name: "BscScan", url: "https://testnet.bscscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 17422483
        }
      },
      testnet: true
    };
    canto = {
      id: 7700,
      name: "Canto",
      network: "canto",
      nativeCurrency: {
        decimals: 18,
        name: "Canto",
        symbol: "CANTO"
      },
      rpcUrls: {
        default: { http: ["https://canto.gravitychain.io"] },
        public: { http: ["https://canto.gravitychain.io"] }
      },
      blockExplorers: {
        default: {
          name: "Tuber.Build (Blockscout)",
          url: "https://tuber.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 2905789
        }
      }
    };
    celo = {
      id: 42220,
      name: "Celo",
      network: "celo",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "CELO"
      },
      rpcUrls: {
        default: { http: ["https://forno.celo.org"] },
        infura: {
          http: ["https://celo-mainnet.infura.io/v3"]
        },
        public: {
          http: ["https://forno.celo.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/mainnet"
        },
        etherscan: { name: "CeloScan", url: "https://celoscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 13112599
        }
      },
      testnet: false
    };
    celoAlfajores = {
      id: 44787,
      name: "Alfajores",
      network: "celo-alfajores",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "A-CELO"
      },
      rpcUrls: {
        default: {
          http: ["https://alfajores-forno.celo-testnet.org"]
        },
        infura: {
          http: ["https://celo-alfajores.infura.io/v3"]
        },
        public: {
          http: ["https://alfajores-forno.celo-testnet.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/alfajores"
        },
        etherscan: { name: "CeloScan", url: "https://alfajores.celoscan.io/" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 14569001
        }
      },
      testnet: true
    };
    celoCannoli = {
      id: 17323,
      name: "Cannoli",
      network: "celo-cannoli",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "C-CELO"
      },
      rpcUrls: {
        default: {
          http: ["https://forno.cannoli.celo-testnet.org"]
        },
        public: {
          http: ["https://forno.cannoli.celo-testnet.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/cannoli"
        }
      },
      contracts: {
        multicall3: {
          address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
          blockCreated: 87429
        }
      },
      testnet: true
    };
    cronos = {
      id: 25,
      name: "Cronos",
      network: "cronos",
      nativeCurrency: {
        decimals: 18,
        name: "Cronos",
        symbol: "CRO"
      },
      rpcUrls: {
        default: { http: ["https://node.croswap.com/rpc"] },
        public: { http: ["https://node.croswap.com/rpc"] }
      },
      blockExplorers: {
        default: { name: "CronosScan", url: "https://cronoscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1963112
        }
      }
    };
    crossbell = {
      id: 3737,
      network: "crossbell",
      name: "Crossbell",
      nativeCurrency: {
        decimals: 18,
        name: "CSB",
        symbol: "CSB"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.crossbell.io"]
        },
        public: {
          http: ["https://rpc.crossbell.io"]
        }
      },
      blockExplorers: {
        default: { name: "CrossScan", url: "https://scan.crossbell.io" }
      },
      contracts: {
        multicall3: {
          address: "0xBB9759009cDaC82774EfC84D94cD9F7440f75Fcf",
          blockCreated: 23499787
        }
      }
    };
    dfk = {
      id: 53935,
      name: "DFK Chain",
      network: "dfk",
      nativeCurrency: {
        decimals: 18,
        name: "Jewel",
        symbol: "JEWEL"
      },
      rpcUrls: {
        default: {
          http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
        },
        public: {
          http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "DFKSubnetScan",
          url: "https://subnets.avax.network/defi-kingdoms"
        },
        default: {
          name: "DFKSubnetScan",
          url: "https://subnets.avax.network/defi-kingdoms"
        }
      }
    };
    dogechain = {
      id: 2e3,
      name: "Dogechain",
      network: "dogechain",
      nativeCurrency: {
        decimals: 18,
        name: "Dogechain",
        symbol: "DC"
      },
      rpcUrls: {
        default: { http: ["https://rpc.dogechain.dog"] },
        public: { http: ["https://rpc.dogechain.dog"] }
      },
      blockExplorers: {
        etherscan: {
          name: "DogeChainExplorer",
          url: "https://explorer.dogechain.dog"
        },
        default: {
          name: "DogeChainExplorer",
          url: "https://explorer.dogechain.dog"
        }
      }
    };
    evmos = {
      id: 9001,
      name: "Evmos",
      network: "evmos",
      nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
      },
      rpcUrls: {
        default: { http: ["https://eth.bd.evmos.org:8545"] },
        public: { http: ["https://eth.bd.evmos.org:8545"] }
      },
      blockExplorers: {
        default: { name: "Evmos Block Explorer", url: "https://escan.live" }
      }
    };
    evmosTestnet = {
      id: 9e3,
      name: "Evmos Testnet",
      network: "evmos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
      },
      rpcUrls: {
        default: { http: ["https://eth.bd.evmos.dev:8545"] },
        public: { http: ["https://eth.bd.evmos.dev:8545"] }
      },
      blockExplorers: {
        default: {
          name: "Evmos Testnet Block Explorer",
          url: "https://evm.evmos.dev/"
        }
      }
    };
    fantom = {
      id: 250,
      name: "Fantom",
      network: "fantom",
      nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
      },
      rpcUrls: {
        default: { http: ["https://rpc.ankr.com/fantom"] },
        public: { http: ["https://rpc.ankr.com/fantom"] }
      },
      blockExplorers: {
        etherscan: { name: "FTMScan", url: "https://ftmscan.com" },
        default: { name: "FTMScan", url: "https://ftmscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 33001987
        }
      }
    };
    fantomTestnet = {
      id: 4002,
      name: "Fantom Testnet",
      network: "fantom-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
      },
      rpcUrls: {
        default: { http: ["https://rpc.testnet.fantom.network"] },
        public: { http: ["https://rpc.testnet.fantom.network"] }
      },
      blockExplorers: {
        etherscan: { name: "FTMScan", url: "https://testnet.ftmscan.com" },
        default: { name: "FTMScan", url: "https://testnet.ftmscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 8328688
        }
      }
    };
    filecoin = {
      id: 314,
      name: "Filecoin Mainnet",
      network: "filecoin-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "filecoin",
        symbol: "FIL"
      },
      rpcUrls: {
        default: { http: ["https://api.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filfox", url: "https://filfox.info/en" },
        filscan: { name: "Filscan", url: "https://filscan.io" },
        filscout: { name: "Filscout", url: "https://filscout.io/en" },
        glif: { name: "Glif", url: "https://explorer.glif.io" }
      }
    };
    filecoinCalibration = {
      id: 314159,
      name: "Filecoin Calibration",
      network: "filecoin-calibration",
      nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
      },
      rpcUrls: {
        default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filscan", url: "https://calibration.filscan.io" }
      }
    };
    filecoinHyperspace = {
      id: 3141,
      name: "Filecoin Hyperspace",
      network: "filecoin-hyperspace",
      nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
      },
      rpcUrls: {
        default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filfox", url: "https://hyperspace.filfox.info/en" },
        filscan: { name: "Filscan", url: "https://hyperspace.filscan.io" }
      }
    };
    flare = {
      id: 14,
      name: "Flare Mainnet",
      network: "flare-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "flare",
        symbol: "FLR"
      },
      rpcUrls: {
        default: { http: ["https://flare-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Flare Explorer",
          url: "https://flare-explorer.flare.network"
        }
      }
    };
    flareTestnet = {
      id: 114,
      name: "Coston2",
      network: "coston2",
      nativeCurrency: {
        decimals: 18,
        name: "coston2flare",
        symbol: "C2FLR"
      },
      rpcUrls: {
        default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Coston2 Explorer",
          url: "https://coston2-explorer.flare.network"
        }
      },
      testnet: true
    };
    foundry = {
      id: 31337,
      name: "Foundry",
      network: "foundry",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["http://127.0.0.1:8545"],
          webSocket: ["ws://127.0.0.1:8545"]
        },
        public: {
          http: ["http://127.0.0.1:8545"],
          webSocket: ["ws://127.0.0.1:8545"]
        }
      }
    };
    iotex = {
      id: 4689,
      name: "IoTeX",
      network: "iotex",
      nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
      },
      rpcUrls: {
        default: {
          http: ["https://babel-api.mainnet.iotex.io"],
          webSocket: ["wss://babel-api.mainnet.iotex.io"]
        },
        public: {
          http: ["https://babel-api.mainnet.iotex.io"],
          webSocket: ["wss://babel-api.mainnet.iotex.io"]
        }
      },
      blockExplorers: {
        default: { name: "IoTeXScan", url: "https://iotexscan.io" }
      }
    };
    iotexTestnet = {
      id: 4690,
      name: "IoTeX Testnet",
      network: "iotex-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
      },
      rpcUrls: {
        default: {
          http: ["https://babel-api.testnet.iotex.io"],
          webSocket: ["wss://babel-api.testnet.iotex.io"]
        },
        public: {
          http: ["https://babel-api.testnet.iotex.io"],
          webSocket: ["wss://babel-api.testnet.iotex.io"]
        }
      },
      blockExplorers: {
        default: { name: "IoTeXScan", url: "https://testnet.iotexscan.io" }
      }
    };
    goerli = {
      id: 5,
      network: "goerli",
      name: "Goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://goerli.infura.io/v3"],
          webSocket: ["wss://goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.ankr.com/eth_goerli"]
        },
        public: {
          http: ["https://rpc.ankr.com/eth_goerli"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
          address: "0x56522D00C410a43BFfDF00a9A569489297385790",
          blockCreated: 8765204
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 6507670
        }
      },
      testnet: true
    };
    gnosis = {
      id: 100,
      name: "Gnosis",
      network: "gnosis",
      nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
      },
      rpcUrls: {
        default: { http: ["https://rpc.gnosischain.com"] },
        public: { http: ["https://rpc.gnosischain.com"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Gnosisscan",
          url: "https://gnosisscan.io"
        },
        default: {
          name: "Gnosis Chain Explorer",
          url: "https://blockscout.com/xdai/mainnet"
        }
      }
    };
    gnosisChiado = {
      id: 10200,
      name: "Gnosis Chiado",
      network: "chiado",
      nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
      },
      rpcUrls: {
        default: { http: ["https://rpc.chiadochain.net"] },
        public: { http: ["https://rpc.chiadochain.net"] }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.chiadochain.net"
        }
      }
    };
    hardhat = {
      id: 31337,
      name: "Hardhat",
      network: "hardhat",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["http://127.0.0.1:8545"] },
        public: { http: ["http://127.0.0.1:8545"] }
      }
    };
    harmonyOne = {
      id: 16666e5,
      name: "Harmony One",
      network: "harmony",
      nativeCurrency: {
        name: "Harmony",
        symbol: "ONE",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://rpc.ankr.com/harmony"] },
        default: { http: ["https://rpc.ankr.com/harmony"] }
      },
      blockExplorers: {
        default: { name: "Harmony Explorer", url: "https://explorer.harmony.one" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 24185753
        }
      }
    };
    haqqMainnet = {
      id: 11235,
      name: "HAQQ Mainnet",
      network: "haqq-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLM"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.eth.haqq.network"]
        },
        public: {
          http: ["https://rpc.eth.haqq.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "HAQQ Explorer",
          url: "https://explorer.haqq.network"
        }
      }
    };
    haqqTestedge2 = {
      id: 54211,
      name: "HAQQ Testedge 2",
      network: "haqq-testedge-2",
      nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLMT"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.eth.testedge2.haqq.network"]
        },
        public: {
          http: ["https://rpc.eth.testedge2.haqq.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "HAQQ Explorer",
          url: "https://explorer.testedge2.haqq.network"
        }
      }
    };
    klaytn = {
      id: 8217,
      name: "Klaytn",
      network: "klaytn",
      nativeCurrency: {
        decimals: 18,
        name: "Klaytn",
        symbol: "KLAY"
      },
      rpcUrls: {
        default: { http: ["https://cypress.fautor.app/archive"] },
        public: { http: ["https://cypress.fautor.app/archive"] }
      },
      blockExplorers: {
        etherscan: { name: "KlaytnScope", url: "https://scope.klaytn.com" },
        default: { name: "KlaytnScope", url: "https://scope.klaytn.com" }
      }
    };
    lineaTestnet = {
      id: 59140,
      name: "Linea Goerli Testnet",
      network: "linea-testnet",
      nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        infura: {
          http: ["https://consensys-zkevm-goerli-prealpha.infura.io/v3"],
          webSocket: ["wss://consensys-zkevm-goerli-prealpha.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.goerli.linea.build"],
          webSocket: ["wss://rpc.goerli.linea.build"]
        },
        public: {
          http: ["https://rpc.goerli.linea.build"],
          webSocket: ["wss://rpc.goerli.linea.build"]
        }
      },
      blockExplorers: {
        default: {
          name: "BlockScout",
          url: "https://explorer.goerli.linea.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 498623
        }
      },
      testnet: true
    };
    localhost = {
      id: 1337,
      name: "Localhost",
      network: "localhost",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["http://127.0.0.1:8545"] },
        public: { http: ["http://127.0.0.1:8545"] }
      }
    };
    mainnet = {
      id: 1,
      network: "homestead",
      name: "Ethereum",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://mainnet.infura.io/v3"],
          webSocket: ["wss://mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://cloudflare-eth.com"]
        },
        public: {
          http: ["https://cloudflare-eth.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://etherscan.io"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
          address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
          blockCreated: 16966585
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    };
    metis = {
      id: 1088,
      name: "Metis",
      network: "andromeda",
      nativeCurrency: {
        decimals: 18,
        name: "Metis",
        symbol: "METIS"
      },
      rpcUrls: {
        default: { http: ["https://andromeda.metis.io/?owner=1088"] },
        public: { http: ["https://andromeda.metis.io/?owner=1088"] }
      },
      blockExplorers: {
        default: {
          name: "Andromeda Explorer",
          url: "https://andromeda-explorer.metis.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 2338552
        }
      }
    };
    metisGoerli = {
      id: 599,
      name: "Metis Goerli",
      network: "metis-goerli",
      nativeCurrency: {
        decimals: 18,
        name: "Metis Goerli",
        symbol: "METIS"
      },
      rpcUrls: {
        default: { http: ["https://goerli.gateway.metisdevops.link"] },
        public: { http: ["https://goerli.gateway.metisdevops.link"] }
      },
      blockExplorers: {
        default: {
          name: "Metis Goerli Explorer",
          url: "https://goerli.explorer.metisdevops.link"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1006207
        }
      }
    };
    mev = {
      id: 7518,
      network: "MEVerse",
      name: "MEVerse Chain Mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "MEVerse",
        symbol: "MEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.meversemainnet.io"]
        },
        public: {
          http: ["https://rpc.meversemainnet.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://www.meversescan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 86881340
        }
      }
    };
    mevTestnet = {
      id: 4759,
      network: "MEVerse Testnet",
      name: "MEVerse Chain Testnet",
      nativeCurrency: {
        decimals: 18,
        name: "MEVerse",
        symbol: "MEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.meversetestnet.io"]
        },
        public: {
          http: ["https://rpc.meversetestnet.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://testnet.meversescan.io/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 64371115
        }
      },
      testnet: true
    };
    moonbaseAlpha = {
      id: 1287,
      name: "Moonbase Alpha",
      network: "moonbase-alpha",
      nativeCurrency: {
        decimals: 18,
        name: "DEV",
        symbol: "DEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.api.moonbase.moonbeam.network"],
          webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
        },
        public: {
          http: ["https://rpc.api.moonbase.moonbeam.network"],
          webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonbase.moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonbase.moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1850686
        }
      },
      testnet: true
    };
    moonbeam = {
      id: 1284,
      name: "Moonbeam",
      network: "moonbeam",
      nativeCurrency: {
        decimals: 18,
        name: "GLMR",
        symbol: "GLMR"
      },
      rpcUrls: {
        public: {
          http: ["https://moonbeam.public.blastapi.io"],
          webSocket: ["wss://moonbeam.public.blastapi.io"]
        },
        default: {
          http: ["https://moonbeam.public.blastapi.io"],
          webSocket: ["wss://moonbeam.public.blastapi.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 609002
        }
      },
      testnet: false
    };
    moonriver = {
      id: 1285,
      name: "Moonriver",
      network: "moonriver",
      nativeCurrency: {
        decimals: 18,
        name: "MOVR",
        symbol: "MOVR"
      },
      rpcUrls: {
        public: {
          http: ["https://moonriver.public.blastapi.io"],
          webSocket: ["wss://moonriver.public.blastapi.io"]
        },
        default: {
          http: ["https://moonriver.public.blastapi.io"],
          webSocket: ["wss://moonriver.public.blastapi.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonriver.moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonriver.moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1597904
        }
      },
      testnet: false
    };
    nexi = {
      id: 4242,
      name: "Nexi",
      network: "nexi",
      nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.chain.nexi.technology"]
        },
        public: {
          http: ["https://rpc.chain.nexi.technology"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "NexiScan",
          url: "https://www.nexiscan.com"
        },
        default: {
          name: "NexiScan",
          url: "https://www.nexiscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
          blockCreated: 25770160
        }
      }
    };
    okc = {
      id: 66,
      name: "OKC",
      network: "okc",
      nativeCurrency: {
        decimals: 18,
        name: "OKT",
        symbol: "OKT"
      },
      rpcUrls: {
        default: { http: ["https://exchainrpc.okex.org"] },
        public: { http: ["https://exchainrpc.okex.org"] }
      },
      blockExplorers: {
        default: { name: "oklink", url: "https://www.oklink.com/okc" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 10364792
        }
      }
    };
    optimism = {
      id: 10,
      name: "OP Mainnet",
      network: "optimism",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://opt-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://optimism-mainnet.infura.io/v3"],
          webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://mainnet.optimism.io"]
        },
        public: {
          http: ["https://mainnet.optimism.io"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://optimistic.etherscan.io"
        },
        default: {
          name: "Optimism Explorer",
          url: "https://explorer.optimism.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 4286263
        }
      }
    };
    optimismGoerli = {
      id: 420,
      name: "Optimism Goerli",
      network: "optimism-goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://opt-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://optimism-goerli.infura.io/v3"],
          webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://goerli.optimism.io"]
        },
        public: {
          http: ["https://goerli.optimism.io"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://goerli-optimism.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://goerli-optimism.etherscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 49461
        }
      },
      testnet: true
    };
    polygon = {
      id: 137,
      name: "Polygon",
      network: "matic",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://polygon-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://polygon-mainnet.infura.io/v3"],
          webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://polygon-rpc.com"]
        },
        public: {
          http: ["https://polygon-rpc.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "PolygonScan",
          url: "https://polygonscan.com"
        },
        default: {
          name: "PolygonScan",
          url: "https://polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 25770160
        }
      }
    };
    polygonMumbai = {
      id: 80001,
      name: "Polygon Mumbai",
      network: "maticmum",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://polygon-mumbai.g.alchemy.com/v2"],
          webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://polygon-mumbai.infura.io/v3"],
          webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
        },
        default: {
          http: ["https://matic-mumbai.chainstacklabs.com"]
        },
        public: {
          http: ["https://matic-mumbai.chainstacklabs.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "PolygonScan",
          url: "https://mumbai.polygonscan.com"
        },
        default: {
          name: "PolygonScan",
          url: "https://mumbai.polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 25770160
        }
      },
      testnet: true
    };
    polygonZkEvmTestnet = {
      id: 1442,
      name: "Polygon zkEVM Testnet",
      network: "polygon-zkevm-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.public.zkevm-test.net"]
        },
        public: {
          http: ["https://rpc.public.zkevm-test.net"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Blockscout",
          url: "https://explorer.public.zkevm-test.net"
        },
        default: {
          name: "PolygonScan",
          url: "https://testnet-zkevm.polygonscan.com"
        }
      },
      testnet: true,
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 525686
        }
      }
    };
    polygonZkEvm = {
      id: 1101,
      name: "Polygon zkEVM",
      network: "polygon-zkevm",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://zkevm-rpc.com"]
        },
        public: {
          http: ["https://zkevm-rpc.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PolygonScan",
          url: "https://zkevm.polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 57746
        }
      }
    };
    pulsechain = {
      id: 369,
      network: "pulsechain",
      name: "PulseChain",
      nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
      testnet: false,
      rpcUrls: {
        default: {
          http: ["https://rpc.pulsechain.com"],
          webSocket: ["wss://ws.pulsechain.com"]
        },
        public: {
          http: ["https://rpc.pulsechain.com"],
          webSocket: ["wss://ws.pulsechain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PulseScan",
          url: "https://scan.pulsechain.com"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    };
    pulsechainV4 = {
      id: 943,
      network: "pulsechainV4",
      name: "PulseChain V4",
      testnet: true,
      nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.v4.testnet.pulsechain.com"],
          webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
        },
        public: {
          http: ["https://rpc.v4.testnet.pulsechain.com"],
          webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PulseScan",
          url: "https://scan.v4.testnet.pulsechain.com"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    };
    scrollTestnet = {
      id: 534353,
      name: "Scroll Testnet",
      network: "scroll-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://alpha-rpc.scroll.io/l2"],
          webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
        },
        public: {
          http: ["https://alpha-rpc.scroll.io/l2"],
          webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.scroll.io"
        }
      },
      testnet: true
    };
    sepolia = {
      id: 11155111,
      network: "sepolia",
      name: "Sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-sepolia.g.alchemy.com/v2"],
          webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://sepolia.infura.io/v3"],
          webSocket: ["wss://sepolia.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.sepolia.org"]
        },
        public: {
          http: ["https://rpc.sepolia.org"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 6507670
        }
      },
      testnet: true
    };
    skaleBlockBrawlers = {
      id: 391845894,
      name: "SKALE | Block Brawlers",
      network: "skale-brawl",
      nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleCalypso = {
      id: 1564830818,
      name: "SKALE | Calypso NFT Hub",
      network: "skale-calypso",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleCalypsoTestnet = {
      id: 344106930,
      name: "SKALE | Calypso NFT Hub Testnet",
      network: "skale-calypso-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
          ]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {},
      testnet: true
    };
    skaleChaosTestnet = {
      id: 1351057110,
      name: "SKALE | Chaos Testnet",
      network: "skale-chaos-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
          ]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {},
      testnet: true
    };
    skaleCryptoBlades = {
      id: 1026062157,
      name: "SKALE | CryptoBlades",
      network: "skale-cryptoblades",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleCryptoColosseum = {
      id: 2046399126,
      name: "SKALE | Crypto Colosseum",
      network: "skale-crypto-coloseeum",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleEuropa = {
      id: 2046399126,
      name: "SKALE | Europa Liquidity Hub",
      network: "skale-europa",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleEuropaTestnet = {
      id: 476158412,
      name: "SKALE | Europa Liquidity Hub Testnet",
      network: "skale-europa-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
        },
        public: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {},
      testnet: true
    };
    skaleExorde = {
      id: 2139927552,
      name: "SKALE | Exorde",
      network: "skale-exorde",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleHumanProtocol = {
      id: 1273227453,
      name: "SKALE | Human Protocol",
      network: "skale-human-protocol",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleNebula = {
      id: 1482601649,
      name: "SKALE | Nebula Gaming Hub",
      network: "skale-nebula",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleNebulaTestnet = {
      id: 503129905,
      name: "SKALE | Nebula Gaming Hub Testnet",
      network: "skale-nebula-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
        },
        public: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {},
      testnet: true
    };
    skaleRazor = {
      id: 278611351,
      name: "SKALE | Razor Network",
      network: "skale-razor",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleTitan = {
      id: 1350216234,
      name: "SKALE | Titan Community Hub",
      network: "skale-titan",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    };
    skaleTitanTestnet = {
      id: 1517929550,
      name: "SKALE | Titan Community Hub Testnet",
      network: "skale-titan-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
          ]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "SKALE Explorer",
          url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {},
      testnet: true
    };
    songbird = {
      id: 19,
      name: "Songbird Mainnet",
      network: "songbird-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "songbird",
        symbol: "SGB"
      },
      rpcUrls: {
        default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Songbird Explorer",
          url: "https://songbird-explorer.flare.network"
        }
      }
    };
    songbirdTestnet = {
      id: 16,
      name: "Coston",
      network: "coston",
      nativeCurrency: {
        decimals: 18,
        name: "costonflare",
        symbol: "CFLR"
      },
      rpcUrls: {
        default: { http: ["https://coston-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Coston Explorer",
          url: "https://coston-explorer.flare.network"
        }
      },
      testnet: true
    };
    shardeumSphinx = {
      id: 8082,
      name: "Shardeum Sphinx",
      network: "shmSphinx",
      nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sphinx.shardeum.org"]
        },
        public: {
          http: ["https://sphinx.shardeum.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Shardeum Explorer",
          url: "https://explorer-sphinx.shardeum.org"
        }
      },
      testnet: true
    };
    syscoin = {
      id: 57,
      name: "Syscoin Mainnet",
      network: "syscoin",
      nativeCurrency: {
        decimals: 8,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: { http: ["https://rpc.syscoin.org"] },
        public: { http: ["https://rpc.syscoin.org"] }
      },
      blockExplorers: {
        default: { name: "SyscoinExplorer", url: "https://explorer.syscoin.org" }
      },
      contracts: {
        multicall3: {
          address: "0x000562033783B1136159E10d976B519C929cdE8e",
          blockCreated: 80637
        }
      }
    };
    taraxa = {
      id: 841,
      name: "Taraxa Mainnet",
      network: "taraxa",
      nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.mainnet.taraxa.io"]
        },
        public: {
          http: ["https://rpc.mainnet.taraxa.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Taraxa Explorer",
          url: "https://explorer.mainnet.taraxa.io"
        }
      }
    };
    taraxaTestnet = {
      id: 842,
      name: "Taraxa Testnet",
      network: "taraxa-testnet",
      nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.testnet.taraxa.io"]
        },
        public: {
          http: ["https://rpc.testnet.taraxa.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Taraxa Explorer",
          url: "https://explorer.testnet.taraxa.io"
        }
      },
      testnet: true
    };
    telos = {
      id: 40,
      name: "Telos",
      network: "telos",
      nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
      },
      rpcUrls: {
        default: { http: ["https://mainnet.telos.net/evm"] },
        public: { http: ["https://mainnet.telos.net/evm"] }
      },
      blockExplorers: {
        default: {
          name: "Teloscan",
          url: "https://www.teloscan.io/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 246530709
        }
      }
    };
    telosTestnet = {
      id: 41,
      name: "Telos",
      network: "telosTestnet",
      nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
      },
      rpcUrls: {
        default: { http: ["https://testnet.telos.net/evm"] },
        public: { http: ["https://testnet.telos.net/evm"] }
      },
      blockExplorers: {
        default: {
          name: "Teloscan (testnet)",
          url: "https://testnet.teloscan.io/"
        }
      },
      testnet: true
    };
    thunderTestnet = {
      id: 997,
      name: "5ireChain Thunder Testnet",
      network: "5ireChain",
      nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc-testnet.5ire.network"]
        },
        public: {
          http: ["https://rpc-testnet.5ire.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "5ireChain Explorer",
          url: "https://explorer.5ire.network"
        }
      },
      testnet: true
    };
    wanchain = {
      id: 888,
      name: "Wanchain",
      network: "wanchain",
      nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://gwan-ssl.wandevs.org:56891",
            "https://gwan2-ssl.wandevs.org"
          ]
        },
        public: {
          http: [
            "https://gwan-ssl.wandevs.org:56891",
            "https://gwan2-ssl.wandevs.org"
          ]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "WanScan",
          url: "https://wanscan.org"
        },
        default: {
          name: "WanScan",
          url: "https://wanscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
          blockCreated: 25312390
        }
      }
    };
    wanchainTestnet = {
      id: 999,
      name: "Wanchain Testnet",
      network: "wanchainTestnet",
      nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://gwan-ssl.wandevs.org:46891"]
        },
        public: {
          http: ["https://gwan-ssl.wandevs.org:46891"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "WanScanTest",
          url: "https://wanscan.org"
        },
        default: {
          name: "WanScanTest",
          url: "https://wanscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
          blockCreated: 24743448
        }
      },
      testnet: true
    };
    xdc = {
      id: 50,
      name: "XinFin Network",
      network: "xdc",
      nativeCurrency: {
        decimals: 18,
        name: "XDC",
        symbol: "XDC"
      },
      rpcUrls: {
        default: { http: ["https://rpc.xinfin.network"] },
        public: { http: ["https://rpc.xinfin.network"] }
      },
      blockExplorers: {
        xinfin: { name: "XinFin", url: "https://explorer.xinfin.network" },
        default: { name: "Blocksscan", url: "https://xdc.blocksscan.io" }
      }
    };
    xdcTestnet = {
      id: 51,
      name: "Apothem Network",
      network: "xdc-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "TXDC",
        symbol: "TXDC"
      },
      rpcUrls: {
        default: { http: ["https://erpc.apothem.network"] },
        public: { http: ["https://erpc.apothem.network"] }
      },
      blockExplorers: {
        xinfin: { name: "XinFin", url: "https://explorer.apothem.network" },
        default: { name: "Blocksscan", url: "https://apothem.blocksscan.io" }
      }
    };
    zhejiang = {
      id: 1337803,
      network: "zhejiang",
      name: "Zhejiang",
      nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.zhejiang.ethpandaops.io"]
        },
        public: {
          http: ["https://rpc.zhejiang.ethpandaops.io"]
        }
      },
      blockExplorers: {
        beaconchain: {
          name: "Etherscan",
          url: "https://zhejiang.beaconcha.in"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://blockscout.com/eth/zhejiang-testnet"
        },
        default: {
          name: "Beaconchain",
          url: "https://zhejiang.beaconcha.in"
        }
      },
      testnet: true
    };
    zkSync = {
      id: 324,
      name: "zkSync Era",
      network: "zksync-era",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://mainnet.era.zksync.io"],
          webSocket: ["wss://mainnet.era.zksync.io/ws"]
        },
        public: {
          http: ["https://mainnet.era.zksync.io"],
          webSocket: ["wss://mainnet.era.zksync.io/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkExplorer",
          url: "https://explorer.zksync.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
      }
    };
    zkSyncTestnet = {
      id: 280,
      name: "zkSync Era Testnet",
      network: "zksync-era-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://testnet.era.zksync.dev"],
          webSocket: ["wss://testnet.era.zksync.dev/ws"]
        },
        public: {
          http: ["https://testnet.era.zksync.dev"],
          webSocket: ["wss://testnet.era.zksync.dev/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkExplorer",
          url: "https://goerli.explorer.zksync.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
      },
      testnet: true
    };
    zora = {
      id: 7777777,
      name: "Zora",
      network: "zora",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.zora.energy"],
          webSocket: ["wss://rpc.zora.energy"]
        },
        public: {
          http: ["https://rpc.zora.energy"],
          webSocket: ["wss://rpc.zora.energy"]
        }
      },
      blockExplorers: {
        default: { name: "Explorer", url: "https://explorer.zora.energy" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 5882
        }
      }
    };
    zoraTestnet = {
      id: 999,
      name: "Zora Goerli Testnet",
      network: "zora-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Zora Goerli",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://testnet.rpc.zora.energy"],
          webSocket: ["wss://testnet.rpc.zora.energy"]
        },
        public: {
          http: ["https://testnet.rpc.zora.energy"],
          webSocket: ["wss://testnet.rpc.zora.energy"]
        }
      },
      blockExplorers: {
        default: { name: "Explorer", url: "https://testnet.explorer.zora.energy" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 189123
        }
      },
      testnet: true
    };
  }
});

// node_modules/viem/dist/esm/types/chain.js
var init_chain3 = __esm({
  "node_modules/viem/dist/esm/types/chain.js"() {
  }
});

// node_modules/viem/dist/esm/chains/celo/formatters.js
var formattersCelo;
var init_formatters = __esm({
  "node_modules/viem/dist/esm/chains/celo/formatters.js"() {
    init_chain3();
    init_fromHex();
    init_toHex();
    init_block();
    init_transaction2();
    init_transactionReceipt();
    init_transactionRequest();
    formattersCelo = {
      block: defineBlock({
        exclude: ["difficulty", "gasLimit", "mixHash", "nonce", "uncles"],
        format(args) {
          const transactions = args.transactions?.map((transaction) => {
            if (typeof transaction === "string")
              return transaction;
            return {
              ...formatTransaction(transaction),
              feeCurrency: transaction.feeCurrency,
              gatewayFee: transaction.gatewayFee ? hexToBigInt(transaction.gatewayFee) : null,
              gatewayFeeRecipient: transaction.gatewayFeeRecipient
            };
          });
          return {
            randomness: args.randomness,
            transactions
          };
        }
      }),
      transaction: defineTransaction({
        format(args) {
          return {
            feeCurrency: args.feeCurrency,
            gatewayFee: args.gatewayFee ? hexToBigInt(args.gatewayFee) : null,
            gatewayFeeRecipient: args.gatewayFeeRecipient
          };
        }
      }),
      transactionReceipt: defineTransactionReceipt({
        format(args) {
          return {
            feeCurrency: args.feeCurrency,
            gatewayFee: args.gatewayFee ? hexToBigInt(args.gatewayFee) : null,
            gatewayFeeRecipient: args.gatewayFeeRecipient
          };
        }
      }),
      transactionRequest: defineTransactionRequest({
        format(args) {
          return {
            feeCurrency: args.feeCurrency,
            gatewayFee: typeof args.gatewayFee !== "undefined" ? numberToHex(args.gatewayFee) : void 0,
            gatewayFeeRecipient: args.gatewayFeeRecipient
          };
        }
      })
    };
  }
});

// node_modules/viem/dist/esm/chains/celo/serializers.js
function serializeTransactionCIP42(transaction, signature) {
  assertTransactionCIP42(transaction);
  const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, gatewayFeeRecipient, gatewayFee, data } = transaction;
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    feeCurrency ?? "0x",
    gatewayFeeRecipient ?? "0x",
    gatewayFee ? toHex(gatewayFee) : "0x",
    to ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializeAccessList(accessList)
  ];
  if (signature) {
    serializedTransaction.push(
      signature.v === 27n ? "0x" : toHex(1),
      trim(signature.r),
      trim(signature.s)
    );
  }
  return concatHex([
    "0x7c",
    toRlp(serializedTransaction)
  ]);
}
function isCIP42(transaction) {
  if ("maxFeePerGas" in transaction && "maxPriorityFeePerGas" in transaction && ("feeCurrency" in transaction || "gatewayFee" in transaction || "gatewayFeeRecipient" in transaction))
    return true;
  return false;
}
function assertTransactionCIP42(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency, gatewayFee, gatewayFeeRecipient } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to && !isAddress(to))
    throw new InvalidAddressError({ address: to });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid CIP-42 Transaction attribute.");
  if (maxFeePerGas && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (gatewayFee && !gatewayFeeRecipient || gatewayFeeRecipient && !gatewayFee) {
    throw new BaseError("`gatewayFee` and `gatewayFeeRecipient` must be provided together.");
  }
  if (feeCurrency && !feeCurrency?.startsWith("0x")) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-42 transactions.");
  }
  if (!feeCurrency && !gatewayFeeRecipient) {
    throw new BaseError("Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.");
  }
}
var serializeTransactionCelo, serializersCelo, MAX_MAX_FEE_PER_GAS;
var init_serializers = __esm({
  "node_modules/viem/dist/esm/chains/celo/serializers.js"() {
    init_address();
    init_base();
    init_chain();
    init_node();
    init_isAddress();
    init_concat();
    init_trim();
    init_toHex();
    init_toRlp();
    init_serializeAccessList();
    init_serializeTransaction();
    serializeTransactionCelo = (tx, signature) => {
      if (isCIP42(tx))
        return serializeTransactionCIP42(tx, signature);
      return serializeTransaction(tx, signature);
    };
    serializersCelo = {
      transaction: serializeTransactionCelo
    };
    MAX_MAX_FEE_PER_GAS = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;
  }
});

// node_modules/viem/dist/esm/chains/optimism/fees.js
var feesOptimism;
var init_fees = __esm({
  "node_modules/viem/dist/esm/chains/optimism/fees.js"() {
    feesOptimism = {
      defaultPriorityFee: 1000000n
    };
  }
});

// node_modules/viem/dist/esm/types/rpc.js
var init_rpc3 = __esm({
  "node_modules/viem/dist/esm/types/rpc.js"() {
  }
});

// node_modules/viem/dist/esm/chains/optimism/formatters.js
var formattersOptimism;
var init_formatters2 = __esm({
  "node_modules/viem/dist/esm/chains/optimism/formatters.js"() {
    init_chain3();
    init_rpc3();
    init_fromHex();
    init_block();
    init_transaction2();
    init_transactionReceipt();
    formattersOptimism = {
      block: defineBlock({
        format(args) {
          const transactions = args.transactions?.map((transaction) => {
            if (typeof transaction === "string")
              return transaction;
            const formatted = formatTransaction(transaction);
            if (formatted.typeHex === "0x7e") {
              formatted.isSystemTx = transaction.isSystemTx;
              formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
              formatted.sourceHash = transaction.sourceHash;
              formatted.type = "deposit";
            }
            return formatted;
          });
          return {
            transactions,
            stateRoot: args.stateRoot
          };
        }
      }),
      transaction: defineTransaction({
        format(args) {
          const transaction = {};
          if (args.type === "0x7e") {
            transaction.isSystemTx = args.isSystemTx;
            transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
            transaction.sourceHash = args.sourceHash;
            transaction.type = "deposit";
          }
          return transaction;
        }
      }),
      transactionReceipt: defineTransactionReceipt({
        format(args) {
          return {
            l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
            l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
            l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
            l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
          };
        }
      })
    };
  }
});

// node_modules/viem/dist/esm/chains/index.js
var chains_exports = {};
__export(chains_exports, {
  arbitrum: () => arbitrum2,
  arbitrumGoerli: () => arbitrumGoerli2,
  aurora: () => aurora2,
  auroraTestnet: () => auroraTestnet2,
  avalanche: () => avalanche2,
  avalancheFuji: () => avalancheFuji2,
  base: () => base2,
  baseGoerli: () => baseGoerli2,
  boba: () => boba2,
  bronos: () => bronos2,
  bronosTestnet: () => bronosTestnet2,
  bsc: () => bsc2,
  bscTestnet: () => bscTestnet2,
  canto: () => canto2,
  celo: () => celo2,
  celoAlfajores: () => celoAlfajores2,
  celoCannoli: () => celoCannoli2,
  cronos: () => cronos2,
  crossbell: () => crossbell2,
  dfk: () => dfk2,
  dogechain: () => dogechain2,
  evmos: () => evmos2,
  evmosTestnet: () => evmosTestnet2,
  fantom: () => fantom2,
  fantomTestnet: () => fantomTestnet2,
  filecoin: () => filecoin2,
  filecoinCalibration: () => filecoinCalibration2,
  filecoinHyperspace: () => filecoinHyperspace2,
  flare: () => flare2,
  flareTestnet: () => flareTestnet2,
  foundry: () => foundry2,
  gnosis: () => gnosis2,
  gnosisChiado: () => gnosisChiado2,
  goerli: () => goerli2,
  haqqMainnet: () => haqqMainnet2,
  haqqTestedge2: () => haqqTestedge22,
  hardhat: () => hardhat2,
  harmonyOne: () => harmonyOne2,
  iotex: () => iotex2,
  iotexTestnet: () => iotexTestnet2,
  klaytn: () => klaytn2,
  lineaTestnet: () => lineaTestnet2,
  localhost: () => localhost2,
  mainnet: () => mainnet2,
  metis: () => metis2,
  metisGoerli: () => metisGoerli2,
  mev: () => mev2,
  mevTestnet: () => mevTestnet2,
  moonbaseAlpha: () => moonbaseAlpha2,
  moonbeam: () => moonbeam2,
  moonriver: () => moonriver2,
  nexi: () => nexi2,
  okc: () => okc2,
  optimism: () => optimism2,
  optimismGoerli: () => optimismGoerli2,
  polygon: () => polygon2,
  polygonMumbai: () => polygonMumbai2,
  polygonZkEvm: () => polygonZkEvm2,
  polygonZkEvmTestnet: () => polygonZkEvmTestnet2,
  pulsechain: () => pulsechain2,
  pulsechainV4: () => pulsechainV42,
  scrollTestnet: () => scrollTestnet2,
  sepolia: () => sepolia2,
  shardeumSphinx: () => shardeumSphinx2,
  skaleBlockBrawlers: () => skaleBlockBrawlers2,
  skaleCalypso: () => skaleCalypso2,
  skaleCalypsoTestnet: () => skaleCalypsoTestnet2,
  skaleChaosTestnet: () => skaleChaosTestnet2,
  skaleCryptoBlades: () => skaleCryptoBlades2,
  skaleCryptoColosseum: () => skaleCryptoColosseum2,
  skaleEuropa: () => skaleEuropa2,
  skaleEuropaTestnet: () => skaleEuropaTestnet2,
  skaleExorde: () => skaleExorde2,
  skaleHumanProtocol: () => skaleHumanProtocol2,
  skaleNebula: () => skaleNebula2,
  skaleNebulaTestnet: () => skaleNebulaTestnet2,
  skaleRazor: () => skaleRazor2,
  skaleTitan: () => skaleTitan2,
  skaleTitanTestnet: () => skaleTitanTestnet2,
  songbird: () => songbird2,
  songbirdTestnet: () => songbirdTestnet2,
  syscoin: () => syscoin2,
  taraxa: () => taraxa2,
  taraxaTestnet: () => taraxaTestnet2,
  telos: () => telos2,
  telosTestnet: () => telosTestnet2,
  thunderTestnet: () => thunderTestnet2,
  wanchain: () => wanchain2,
  wanchainTestnet: () => wanchainTestnet2,
  xdc: () => xdc2,
  xdcTestnet: () => xdcTestnet2,
  zhejiang: () => zhejiang2,
  zkSync: () => zkSync2,
  zkSyncTestnet: () => zkSyncTestnet2,
  zora: () => zora2,
  zoraTestnet: () => zoraTestnet2
});
var arbitrum2, arbitrumGoerli2, aurora2, auroraTestnet2, avalanche2, avalancheFuji2, base2, baseGoerli2, boba2, bronos2, bronosTestnet2, bsc2, bscTestnet2, canto2, celo2, celoAlfajores2, celoCannoli2, cronos2, crossbell2, dfk2, dogechain2, evmos2, evmosTestnet2, fantom2, fantomTestnet2, filecoin2, filecoinCalibration2, filecoinHyperspace2, flare2, flareTestnet2, foundry2, iotex2, iotexTestnet2, goerli2, gnosis2, gnosisChiado2, haqqMainnet2, haqqTestedge22, hardhat2, harmonyOne2, klaytn2, lineaTestnet2, localhost2, mainnet2, metis2, metisGoerli2, mev2, mevTestnet2, moonbaseAlpha2, moonbeam2, moonriver2, nexi2, okc2, optimism2, optimismGoerli2, polygon2, polygonMumbai2, polygonZkEvm2, polygonZkEvmTestnet2, pulsechain2, pulsechainV42, scrollTestnet2, sepolia2, skaleBlockBrawlers2, skaleCalypso2, skaleCalypsoTestnet2, skaleChaosTestnet2, skaleCryptoBlades2, skaleCryptoColosseum2, skaleEuropa2, skaleEuropaTestnet2, skaleExorde2, skaleHumanProtocol2, skaleNebula2, skaleNebulaTestnet2, skaleRazor2, skaleTitan2, skaleTitanTestnet2, songbird2, songbirdTestnet2, shardeumSphinx2, syscoin2, taraxa2, taraxaTestnet2, telos2, telosTestnet2, thunderTestnet2, wanchain2, wanchainTestnet2, xdc2, xdcTestnet2, zhejiang2, zkSync2, zkSyncTestnet2, zora2, zoraTestnet2;
var init_chains = __esm({
  "node_modules/viem/dist/esm/chains/index.js"() {
    init_dist2();
    init_chain2();
    init_formatters();
    init_serializers();
    init_fees();
    init_formatters2();
    arbitrum2 = defineChain(arbitrum);
    arbitrumGoerli2 = defineChain(arbitrumGoerli);
    aurora2 = defineChain(aurora);
    auroraTestnet2 = defineChain(auroraTestnet);
    avalanche2 = defineChain(avalanche);
    avalancheFuji2 = defineChain(avalancheFuji);
    base2 = defineChain(base, {
      fees: feesOptimism,
      formatters: formattersOptimism
    });
    baseGoerli2 = defineChain(baseGoerli, {
      fees: feesOptimism,
      formatters: formattersOptimism
    });
    boba2 = defineChain(boba);
    bronos2 = defineChain(bronos);
    bronosTestnet2 = defineChain(bronosTestnet);
    bsc2 = defineChain(bsc);
    bscTestnet2 = defineChain(bscTestnet);
    canto2 = defineChain(canto);
    celo2 = defineChain(celo, {
      formatters: formattersCelo,
      serializers: serializersCelo
    });
    celoAlfajores2 = defineChain(celoAlfajores, {
      formatters: formattersCelo,
      serializers: serializersCelo
    });
    celoCannoli2 = defineChain(celoCannoli, {
      formatters: formattersCelo,
      serializers: serializersCelo
    });
    cronos2 = defineChain(cronos);
    crossbell2 = defineChain(crossbell);
    dfk2 = defineChain(dfk);
    dogechain2 = defineChain(dogechain);
    evmos2 = defineChain(evmos);
    evmosTestnet2 = defineChain(evmosTestnet);
    fantom2 = defineChain(fantom);
    fantomTestnet2 = defineChain(fantomTestnet);
    filecoin2 = defineChain(filecoin);
    filecoinCalibration2 = defineChain(filecoinCalibration);
    filecoinHyperspace2 = defineChain(filecoinHyperspace);
    flare2 = defineChain(flare);
    flareTestnet2 = defineChain(flareTestnet);
    foundry2 = defineChain(foundry);
    iotex2 = defineChain(iotex);
    iotexTestnet2 = defineChain(iotexTestnet);
    goerli2 = defineChain(goerli);
    gnosis2 = defineChain(gnosis);
    gnosisChiado2 = defineChain(gnosisChiado);
    haqqMainnet2 = defineChain(haqqMainnet);
    haqqTestedge22 = defineChain(haqqTestedge2);
    hardhat2 = defineChain(hardhat);
    harmonyOne2 = defineChain(harmonyOne);
    klaytn2 = defineChain(klaytn);
    lineaTestnet2 = defineChain(lineaTestnet);
    localhost2 = defineChain(localhost);
    mainnet2 = defineChain(mainnet);
    metis2 = defineChain(metis);
    metisGoerli2 = defineChain(metisGoerli);
    mev2 = defineChain(mev);
    mevTestnet2 = defineChain(mevTestnet);
    moonbaseAlpha2 = defineChain(moonbaseAlpha);
    moonbeam2 = defineChain(moonbeam);
    moonriver2 = defineChain(moonriver);
    nexi2 = defineChain(nexi);
    okc2 = defineChain(okc);
    optimism2 = defineChain(optimism, {
      fees: feesOptimism,
      formatters: formattersOptimism
    });
    optimismGoerli2 = defineChain(optimismGoerli, {
      fees: feesOptimism,
      formatters: formattersOptimism
    });
    polygon2 = defineChain(polygon);
    polygonMumbai2 = defineChain(polygonMumbai);
    polygonZkEvm2 = defineChain(polygonZkEvm);
    polygonZkEvmTestnet2 = defineChain(polygonZkEvmTestnet);
    pulsechain2 = defineChain(pulsechain);
    pulsechainV42 = defineChain(pulsechainV4);
    scrollTestnet2 = defineChain(scrollTestnet);
    sepolia2 = defineChain(sepolia);
    skaleBlockBrawlers2 = defineChain(skaleBlockBrawlers);
    skaleCalypso2 = defineChain(skaleCalypso);
    skaleCalypsoTestnet2 = defineChain(skaleCalypsoTestnet);
    skaleChaosTestnet2 = defineChain(skaleChaosTestnet);
    skaleCryptoBlades2 = defineChain(skaleCryptoBlades);
    skaleCryptoColosseum2 = defineChain(skaleCryptoColosseum);
    skaleEuropa2 = defineChain(skaleEuropa);
    skaleEuropaTestnet2 = defineChain(skaleEuropaTestnet);
    skaleExorde2 = defineChain(skaleExorde);
    skaleHumanProtocol2 = defineChain(skaleHumanProtocol);
    skaleNebula2 = defineChain(skaleNebula);
    skaleNebulaTestnet2 = defineChain(skaleNebulaTestnet);
    skaleRazor2 = defineChain(skaleRazor);
    skaleTitan2 = defineChain(skaleTitan);
    skaleTitanTestnet2 = defineChain(skaleTitanTestnet);
    songbird2 = defineChain(songbird);
    songbirdTestnet2 = defineChain(songbirdTestnet);
    shardeumSphinx2 = defineChain(shardeumSphinx);
    syscoin2 = defineChain(syscoin);
    taraxa2 = defineChain(taraxa);
    taraxaTestnet2 = defineChain(taraxaTestnet);
    telos2 = defineChain(telos);
    telosTestnet2 = defineChain(telosTestnet);
    thunderTestnet2 = defineChain(thunderTestnet);
    wanchain2 = defineChain(wanchain);
    wanchainTestnet2 = defineChain(wanchainTestnet);
    xdc2 = defineChain(xdc);
    xdcTestnet2 = defineChain(xdcTestnet);
    zhejiang2 = defineChain(zhejiang);
    zkSync2 = defineChain(zkSync);
    zkSyncTestnet2 = defineChain(zkSyncTestnet);
    zora2 = defineChain(zora, {
      fees: feesOptimism,
      formatters: formattersOptimism
    });
    zoraTestnet2 = defineChain(zoraTestnet, {
      fees: feesOptimism,
      formatters: formattersOptimism
    });
  }
});

export {
  formatTransaction,
  init_transaction2 as init_transaction,
  formatBlock,
  init_block,
  formatLog,
  init_log,
  formatTransactionReceipt,
  init_transactionReceipt,
  init_toRlp,
  init_serializeAccessList,
  init_assertTransaction,
  init_getTransactionType,
  init_serializeTransaction,
  goerli2 as goerli,
  mainnet2 as mainnet,
  chains_exports,
  init_chains,
  init_esm,
  init_log2,
  init_getEventSelector,
  encodeEventTopics,
  init_encodeEventTopics,
  getContractError,
  init_getContractError,
  AccountNotFoundError,
  init_account,
  init_estimateGas,
  init_block2,
  getBlock,
  init_getBlock,
  getGasPrice,
  init_getGasPrice,
  getTransactionCount,
  init_getTransactionCount,
  prepareRequest,
  init_prepareRequest,
  estimateGas,
  init_estimateGas2,
  readContract,
  init_readContract,
  wait,
  init_wait,
  decodeEventLog,
  init_decodeEventLog,
  getTransactionError,
  init_getTransactionError,
  init_publicKeyToAddress,
  withRetry,
  init_withRetry,
  isDeterministicError,
  buildRequest,
  init_buildRequest,
  getSocket,
  rpc,
  init_rpc2 as init_rpc,
  validateTypedData,
  init_typedData,
  decodeFunctionData,
  init_decodeFunctionData,
  encodeDeployData,
  init_encodeDeployData,
  init_encodeErrorResult,
  init_encodeFunctionResult,
  init_encodePacked,
  init_isBytes,
  init_getContractAddress,
  init_fromBytes,
  init_fromRlp,
  init_isHash,
  hashTypedData,
  init_hashTypedData,
  init_recoverPublicKey,
  init_recoverAddress,
  hashMessage,
  init_hashMessage,
  init_recoverMessageAddress,
  init_recoverTypedDataAddress,
  init_verifyMessage,
  init_verifyTypedData,
  init_getSerializedTransactionType,
  init_parseTransaction,
  init_parseUnits,
  init_parseEther,
  init_parseGwei,
  init_utils2 as init_utils,
  init_namehash,
  init_labelhash,
  getEnsAddress,
  init_getEnsAddress,
  init_ens,
  getEnsText,
  init_getEnsText,
  getEnsAvatar,
  init_getEnsAvatar,
  getEnsName,
  init_getEnsName,
  getEnsResolver,
  init_getEnsResolver,
  normalize,
  ens_exports,
  init_ens2
};
//# sourceMappingURL=chunk-DMOAGK44.js.map
