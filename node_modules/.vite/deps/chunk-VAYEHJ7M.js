import {
  init_tx_builder,
  useTxBuilder
} from "./chunk-D5VMCTSK.js";
import {
  ExplorerLink,
  useDHConnect
} from "./chunk-IYRBC5QN.js";
import {
  Button,
  CSInput,
  CheckGate,
  FormLayout,
  FormProvider,
  FormSegment,
  HighlightInputText,
  Loading,
  ParSm,
  ShamanPermission,
  SplitColumn,
  TimePicker,
  WrappedCheckbox,
  WrappedInput,
  WrappedInputSelect,
  WrappedRadio,
  WrappedSelect,
  WrappedSwitch,
  WrappedTextArea,
  useForm,
  useFormContext,
  useToast
} from "./chunk-LHJQX32V.js";
import {
  require_ri
} from "./chunk-BS4HP37B.js";
import {
  Je,
  isPropValid,
  memoize,
  st,
  unitlessKeys
} from "./chunk-AS6NKUTQ.js";
import {
  _extends
} from "./chunk-KNI3CCJ4.js";
import {
  require_src
} from "./chunk-KYOZVWPW.js";
import {
  require_jsx_runtime
} from "./chunk-GYNMGCXV.js";
import {
  require_react
} from "./chunk-T5BEU6ZH.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LMAYTEU7.js";

// node_modules/react-simple-animate/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-simple-animate/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React8 = require_react();
    function _interopNamespace(e2) {
      if (e2 && e2.__esModule)
        return e2;
      var n2 = /* @__PURE__ */ Object.create(null);
      if (e2) {
        Object.keys(e2).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e2, k);
            Object.defineProperty(n2, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e2[k];
              }
            });
          }
        });
      }
      n2["default"] = e2;
      return Object.freeze(n2);
    }
    var React__namespace = _interopNamespace(React8);
    var DEFAULT_DURATION = 0.3;
    var DEFAULT_EASE_TYPE = "linear";
    var DEFAULT_DIRECTION = "normal";
    var DEFAULT_FILLMODE = "none";
    var RUNNING = "running";
    var PAUSED = "paused";
    var ALL = "all";
    var calculateTotalDuration = ({ duration = DEFAULT_DURATION, delay = 0, overlay = 0 }) => duration + delay - overlay || 0;
    var isUndefined2 = (val) => val === void 0;
    function getSequenceId(sequenceIndex, sequenceId, defaultValue) {
      if (isUndefined2(sequenceId) && isUndefined2(sequenceIndex)) {
        return defaultValue || 0;
      }
      if (sequenceIndex && sequenceIndex >= 0) {
        return sequenceIndex;
      }
      if (sequenceId) {
        return sequenceId;
      }
      return 0;
    }
    var AnimateContext = React__namespace.createContext({
      animationStates: {},
      register: () => {
      }
    });
    function AnimateGroup({ play, sequences = [], children }) {
      const [animationStates, setAnimationStates] = React__namespace.useState({});
      const animationsRef = React__namespace.useRef({});
      const register = React__namespace.useCallback((data3) => {
        const { sequenceIndex, sequenceId } = data3;
        if (!isUndefined2(sequenceId) || !isUndefined2(sequenceIndex)) {
          animationsRef.current[getSequenceId(sequenceIndex, sequenceId)] = data3;
        }
      }, []);
      React__namespace.useEffect(() => {
        const sequencesToAnimate = Array.isArray(sequences) && sequences.length ? sequences : Object.values(animationsRef.current);
        const localAnimationState = {};
        (play ? sequencesToAnimate : [...sequencesToAnimate].reverse()).reduce((previous, { sequenceId, sequenceIndex, duration = DEFAULT_DURATION, delay, overlay }, currentIndex) => {
          const id3 = getSequenceId(sequenceIndex, sequenceId, currentIndex);
          const currentTotalDuration = calculateTotalDuration({
            duration,
            delay,
            overlay
          });
          const totalDuration = currentTotalDuration + previous;
          localAnimationState[id3] = {
            play,
            pause: !play,
            delay: (delay || 0) + previous,
            controlled: true
          };
          return totalDuration;
        }, 0);
        setAnimationStates(localAnimationState);
      }, [play]);
      return React__namespace.createElement(AnimateContext.Provider, { value: { animationStates, register } }, children);
    }
    var secToMs = (ms) => (ms || 0) * 1e3;
    function Animate2(props) {
      const { play, children, render, start, end, complete = "", onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE, sequenceId, sequenceIndex } = props;
      const onCompleteTimeRef = React__namespace.useRef();
      const [style, setStyle] = React__namespace.useState(start || {});
      const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);
      const id3 = getSequenceId(sequenceIndex, sequenceId);
      React__namespace.useEffect(() => {
        if (!isUndefined2(sequenceIndex) && sequenceIndex >= 0 || sequenceId) {
          register(props);
        }
      }, []);
      React__namespace.useEffect(() => {
        const animationState = animationStates[id3] || {};
        setStyle({
          ...play || animationState.play ? end : start,
          transition: `${ALL} ${duration}s ${easeType} ${animationState.delay || delay}s`
        });
        if (play && (complete || onComplete)) {
          onCompleteTimeRef.current = setTimeout(() => {
            complete && setStyle(complete);
            onComplete && onComplete();
          }, secToMs((animationState.delay || delay) + duration));
        }
        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
      }, [
        id3,
        animationStates,
        play,
        duration,
        easeType,
        delay,
        onComplete,
        start,
        end,
        complete
      ]);
      return render ? render({ style }) : React__namespace.createElement("div", { style }, children);
    }
    var camelCaseToDash = (camelCase) => camelCase ? camelCase.replace(/[A-Z]/g, (c) => `-${c.toLowerCase()}`) : "";
    var generateKeyframes = (keyframes) => {
      const animationLength = keyframes.length;
      return keyframes.reduce((previous, keyframe, currentIndex) => {
        const keyframePercentage = parseFloat((100 / (animationLength - 1)).toFixed(2)) * currentIndex;
        if (typeof keyframe === "string") {
          return `${previous} ${keyframePercentage}% {${keyframe}}`;
        }
        const keys5 = Object.keys(keyframe);
        if (keys5.length && isNaN(+keys5[0])) {
          const keyframeContent = keys5.reduce((acc, key) => `${acc} ${camelCaseToDash(key)}: ${keyframe[key]};`, "");
          return `${previous} ${keyframePercentage}% {${keyframeContent}}`;
        }
        return `${previous} ${keys5[0]}% {${keyframe[keys5[0]]}}`;
      }, "");
    };
    function createStyle({ keyframes, animationName }) {
      return `@keyframes ${animationName} {${generateKeyframes(keyframes)}}`;
    }
    function createTag({ keyframes, animationName }) {
      var _a, _b, _c, _d;
      let styleTag = document.querySelector("style[data-id=rsi]");
      if (!styleTag) {
        styleTag = document.createElement("style");
        styleTag.setAttribute("data-id", "rsi");
        document.head.appendChild(styleTag);
      }
      const index = (_c = (_b = (_a = styleTag.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
      try {
        (_d = styleTag.sheet) === null || _d === void 0 ? void 0 : _d.insertRule(createStyle({
          keyframes,
          animationName
        }), index);
      } catch (e2) {
        console.error("react simple animate, error found during insert style ", e2);
      }
      return {
        styleTag,
        index
      };
    }
    var deleteRules = (sheet, deleteName) => {
      if (!sheet) {
        return;
      }
      const index = Object.values(sheet.cssRules).findIndex(({ name }) => name === deleteName);
      if (index >= 0) {
        sheet.deleteRule(index);
      }
    };
    var createRandomName = () => `RSI-${Math.random().toString(36).substr(2, 9)}`;
    var getPlayState = (pause) => pause ? PAUSED : RUNNING;
    function AnimateKeyframes(props) {
      const { children, play = false, pause = false, render, duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, sequenceIndex, keyframes, sequenceId } = props;
      let pauseValue;
      const animationNameRef = React__namespace.useRef({
        forward: "",
        reverse: ""
      });
      const controlled = React__namespace.useRef(false);
      const styleTagRef = React__namespace.useRef({
        forward: null,
        reverse: null
      });
      const id3 = getSequenceId(sequenceIndex, sequenceId);
      const { register, animationStates = {} } = React__namespace.useContext(AnimateContext);
      const animateState = animationStates[id3] || {};
      const [, forceUpdate] = React__namespace.useState(false);
      React__namespace.useEffect(() => {
        const styleTag = styleTagRef.current;
        const animationName = animationNameRef.current;
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
          animationName: animationNameRef.current.forward,
          keyframes
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
          animationName: animationNameRef.current.reverse,
          keyframes: keyframes.reverse()
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        if (play) {
          forceUpdate(true);
        }
        return () => {
          var _a, _b;
          deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);
          deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);
        };
      }, []);
      if (animateState.controlled && !controlled.current) {
        pauseValue = animateState.pause;
        if (!animateState.pause) {
          controlled.current = true;
        }
      } else {
        pauseValue = pause;
      }
      const style = {
        animation: `${duration}s ${easeType} ${animateState.delay || delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(pauseValue)} ${((animateState.controlled ? animateState.play : play) ? animationNameRef.current.forward : animationNameRef.current.reverse) || ""}`
      };
      return render ? render({ style }) : React__namespace.createElement("div", { style: style || {} }, children);
    }
    function useAnimate(props) {
      const { start, end, complete, onComplete, delay = 0, duration = DEFAULT_DURATION, easeType = DEFAULT_EASE_TYPE } = props;
      const transition = React__namespace.useMemo(() => `${ALL} ${duration}s ${easeType} ${delay}s`, [duration, easeType, delay]);
      const [animate, setAnimate] = React__namespace.useState({
        isPlaying: false,
        style: { ...start, transition }
      });
      const { isPlaying, style } = animate;
      const onCompleteTimeRef = React__namespace.useRef();
      React__namespace.useEffect(() => {
        if ((onComplete || complete) && isPlaying) {
          onCompleteTimeRef.current = setTimeout(() => {
            if (onComplete) {
              onComplete();
            }
            if (complete) {
              setAnimate((animate2) => ({
                ...animate2,
                style: complete
              }));
            }
          }, secToMs(delay + duration));
        }
        return () => onCompleteTimeRef.current && clearTimeout(onCompleteTimeRef.current);
      }, [animate, complete, delay, duration, isPlaying, onComplete]);
      return {
        isPlaying,
        style,
        play: React__namespace.useCallback((isPlaying2) => {
          setAnimate((animate2) => ({
            ...animate2,
            style: {
              ...isPlaying2 ? end : start,
              transition
            },
            isPlaying: isPlaying2
          }));
        }, [end, start, transition])
      };
    }
    function useAnimateKeyframes(props) {
      const { duration = DEFAULT_DURATION, delay = 0, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, iterationCount = 1, keyframes } = props;
      const animationNameRef = React__namespace.useRef({
        forward: "",
        reverse: ""
      });
      const styleTagRef = React__namespace.useRef({
        forward: null,
        reverse: null
      });
      const { register } = React__namespace.useContext(AnimateContext);
      const [isPlaying, setIsPlaying] = React__namespace.useState(null);
      const [isPaused, setIsPaused] = React__namespace.useState(false);
      React__namespace.useEffect(() => {
        const styleTag = styleTagRef.current;
        const animationName = animationNameRef.current;
        animationNameRef.current.forward = createRandomName();
        let result = createTag({
          animationName: animationNameRef.current.forward,
          keyframes
        });
        styleTagRef.current.forward = result.styleTag;
        animationNameRef.current.reverse = createRandomName();
        result = createTag({
          animationName: animationNameRef.current.reverse,
          keyframes: keyframes.reverse()
        });
        styleTagRef.current.reverse = result.styleTag;
        register(props);
        return () => {
          var _a, _b;
          deleteRules((_a = styleTag.forward) === null || _a === void 0 ? void 0 : _a.sheet, animationName.forward);
          deleteRules((_b = styleTag.reverse) === null || _b === void 0 ? void 0 : _b.sheet, animationName.reverse);
        };
      }, []);
      const style = {
        animation: `${duration}s ${easeType} ${delay}s ${iterationCount} ${direction} ${fillMode} ${getPlayState(isPaused)} ${isPlaying === null ? "" : isPlaying ? animationNameRef.current.forward : animationNameRef.current.reverse}`
      };
      return {
        style,
        play: setIsPlaying,
        pause: setIsPaused,
        isPlaying: !!isPlaying
      };
    }
    function createArrayWithNumbers(length2) {
      return Array.from({ length: length2 }, () => null);
    }
    function useAnimateGroup(props) {
      const { sequences = [] } = props;
      const defaultArray = createArrayWithNumbers(sequences.length).map((_3, index) => props.sequences[index].start);
      const [styles, setStyles] = React__namespace.useState(defaultArray);
      const [isPlaying, setPlaying] = React__namespace.useState(false);
      const animationNamesRef = React__namespace.useRef([]);
      const styleTagRef = React__namespace.useRef([]);
      React__namespace.useEffect(() => {
        sequences.forEach(({ keyframes }, i) => {
          if (!Array.isArray(keyframes)) {
            return;
          }
          if (!animationNamesRef.current[i]) {
            animationNamesRef.current[i] = {};
            styleTagRef.current[i] = {};
          }
          animationNamesRef.current[i].forward = createRandomName();
          let result = createTag({
            animationName: animationNamesRef.current[i].forward,
            keyframes
          });
          styleTagRef.current[i].forward = result.styleTag;
          animationNamesRef.current[i].reverse = createRandomName();
          result = createTag({
            animationName: animationNamesRef.current[i].reverse,
            keyframes: keyframes.reverse()
          });
          styleTagRef.current[i].reverse = result.styleTag;
        });
        const styleTags = styleTagRef.current;
        const animationNames = animationNamesRef.current;
        return () => Object.values(animationNames).forEach(({ forward, reverse }, i) => {
          var _a, _b;
          deleteRules((_a = styleTags[i].forward) === null || _a === void 0 ? void 0 : _a.sheet, forward);
          deleteRules((_b = styleTags[i].reverse) === null || _b === void 0 ? void 0 : _b.sheet, reverse);
        });
      }, []);
      const play = React__namespace.useCallback((isPlay) => {
        let totalDuration = 0;
        const animationRefWithOrder = isPlay ? animationNamesRef.current : [...animationNamesRef.current].reverse();
        const styles2 = (isPlay ? sequences : [...sequences].reverse()).map((current, currentIndex) => {
          const { duration = DEFAULT_DURATION, delay = 0, overlay, keyframes, iterationCount = 1, easeType = DEFAULT_EASE_TYPE, direction = DEFAULT_DIRECTION, fillMode = DEFAULT_FILLMODE, end = {}, start = {} } = current;
          const delayDuration = currentIndex === 0 ? delay : totalDuration;
          const transition = `${ALL} ${duration}s ${easeType} ${delayDuration}s`;
          totalDuration = calculateTotalDuration({ duration, delay, overlay }) + totalDuration;
          return keyframes ? {
            animation: `${duration}s ${easeType} ${delayDuration}s ${iterationCount} ${direction} ${fillMode} ${RUNNING} ${isPlay ? animationRefWithOrder[currentIndex].forward : animationRefWithOrder[currentIndex].reverse}`
          } : {
            ...isPlay ? end : start,
            transition
          };
        });
        setStyles(isPlay ? styles2 : [...styles2].reverse());
        setPlaying(isPlay);
      }, []);
      return { styles, play, isPlaying };
    }
    exports.Animate = Animate2;
    exports.AnimateGroup = AnimateGroup;
    exports.AnimateKeyframes = AnimateKeyframes;
    exports.useAnimate = useAnimate;
    exports.useAnimateGroup = useAnimateGroup;
    exports.useAnimateKeyframes = useAnimateKeyframes;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment5 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment5;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty7 = Object.defineProperty;
    var getOwnPropertyNames3 = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor5 = Object.getOwnPropertyDescriptor;
    var getPrototypeOf2 = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf2(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys5 = getOwnPropertyNames3(sourceComponent);
        if (getOwnPropertySymbols) {
          keys5 = keys5.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys5.length; ++i) {
          var key = keys5[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor5(sourceComponent, key);
            try {
              defineProperty7(targetComponent, key, descriptor);
            } catch (e2) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/lodash/isUndefined.js"(exports, module) {
    function isUndefined2(value) {
      return value === void 0;
    }
    module.exports = isUndefined2;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject4(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject4;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty4 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty4.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol3(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol3;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray = require_isArray();
    var isSymbol3 = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey2(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol3(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey2;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject4 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject4(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction2;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid3 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid3 ? "Symbol(src)_1." + uid3 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject4 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty4 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty4).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject4(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty4 = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data3 = this.__data__;
      if (nativeCreate) {
        var result = data3[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty4.call(data3, key) ? data3[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty4 = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data3 = this.__data__;
      return nativeCreate ? data3[key] !== void 0 : hasOwnProperty4.call(data3, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data3 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data3[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data3 = this.__data__, index = assocIndexOf(data3, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data3.length - 1;
      if (index == lastIndex) {
        data3.pop();
      } else {
        splice.call(data3, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data3 = this.__data__, index = assocIndexOf(data3, key);
      return index < 0 ? void 0 : data3[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data3 = this.__data__, index = assocIndexOf(data3, key);
      if (index < 0) {
        ++this.size;
        data3.push([key, value]);
      } else {
        data3[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data3 = map.__data__;
      return isKeyable(key) ? data3[typeof key == "string" ? "string" : "hash"] : data3.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data3 = getMapData(this, key), size = data3.size;
      data3.set(key, value);
      this.size += data3.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    module.exports = memoize2;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize2 = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize2(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath2 = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match4, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match4);
      });
      return result;
    });
    module.exports = stringToPath2;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index < length2) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol3 = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol3(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString5(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString5;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray = require_isArray();
    var isKey2 = require_isKey();
    var stringToPath2 = require_stringToPath();
    var toString5 = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey2(value, object) ? [value] : stringToPath2(toString5(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol3 = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol3(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet2(object, path) {
      path = castPath(path, object);
      var index = 0, length2 = path.length;
      while (object != null && index < length2) {
        object = object[toKey(path[index++])];
      }
      return index && index == length2 ? object : void 0;
    }
    module.exports = baseGet2;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet2 = require_baseGet();
    function get4(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet2(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get4;
  }
});

// node_modules/@daohaus/form-builder/index.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());

// node_modules/@daohaus/form-builder-base/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react6 = __toESM(require_react());
var import_utils5 = __toESM(require_src());

// node_modules/little-state-machine/dist/little-state-machine.es.js
var e = __toESM(require_react());
var t = function() {
  var e2 = { name: "__LSM__", middleWares: [], persist: "action" }, t2 = {};
  try {
    e2.storageType = "undefined" != typeof sessionStorage ? window.sessionStorage : void 0;
  } catch (e3) {
  }
  return { updateStore: function(n2) {
    try {
      t2 = e2.storageType && JSON.parse(e2.storageType.getItem(e2.name) || "") || n2;
    } catch (e3) {
      t2 = n2;
    }
  }, saveStore: function() {
    e2.storageType && e2.storageType.setItem(e2.name, JSON.stringify(t2));
  }, get state() {
    return t2;
  }, set state(e3) {
    t2 = e3;
  }, get options() {
    return e2;
  }, set options(t3) {
    e2 = t3;
  } };
}();
var n = e.createContext(void 0);
var o = function(o2) {
  var r2 = o2.children, s2 = e.useState(t.state), a2 = s2[0], i = s2[1];
  return e.useEffect(function() {
    "beforeUnload" === t.options.persist && (window.onbeforeunload = function() {
      return t.saveStore();
    }, t.options.storageType && t.options.storageType.removeItem(t.options.name));
  }, []), e.createElement(n.Provider, { value: { state: a2, setState: i } }, r2);
};
function r() {
  return r = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var o2 in n2)
        Object.prototype.hasOwnProperty.call(n2, o2) && (e2[o2] = n2[o2]);
    }
    return e2;
  }, r.apply(this, arguments);
}
function s(e2, n2) {
  n2 && (t.options = r({}, t.options, n2)), "undefined" != typeof window && (window.__LSM_NAME__ = t.options.name, window.__LSM_RESET__ = function() {
    return t.options.storageType && t.options.storageType.removeItem(t.options.name);
  }), t.updateStore(e2);
}
function a(o2) {
  var r2 = e.useContext(n), s2 = r2.state, a2 = r2.setState, i = e.useRef(Object.entries(o2 || {}).reduce(function(e2, n2) {
    var o3;
    return Object.assign({}, e2, ((o3 = {})[n2[0]] = function(e3, n3) {
      return function(o4, r3) {
        window.__LSM_NAME__ = n3.name, t.state = n3(t.state, o4), t.options.middleWares && (t.state = t.options.middleWares.reduce(function(e4, t2) {
          return t2(e4, n3.name, o4) || e4;
        }, t.state)), (!r3 || !r3.skipRender) && e3(t.state), "action" === t.options.persist && t.saveStore();
      };
    }(a2, n2[1]), o3));
  }, {}));
  return { actions: i.current, state: s2, getState: e.useCallback(function() {
    return t.state;
  }, []) };
}

// node_modules/@hookform/devtools/dist/index.esm.js
var React6 = __toESM(require_react());
var import_react5 = __toESM(require_react());

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version3, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version3;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a2;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a2 = md5ff(a2, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a2, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a2, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a2, x[i + 3], 22, -1044525330);
    a2 = md5ff(a2, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a2, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a2, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a2, x[i + 7], 22, -45705983);
    a2 = md5ff(a2, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a2, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a2, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a2, x[i + 11], 22, -1990404162);
    a2 = md5ff(a2, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a2, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a2, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a2, x[i + 15], 22, 1236535329);
    a2 = md5gg(a2, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a2, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a2, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a2, x[i], 20, -373897302);
    a2 = md5gg(a2, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a2, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a2, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a2, x[i + 4], 20, -405537848);
    a2 = md5gg(a2, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a2, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a2, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a2, x[i + 8], 20, 1163531501);
    a2 = md5gg(a2, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a2, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a2, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a2, x[i + 12], 20, -1926607734);
    a2 = md5hh(a2, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a2, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a2, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a2, x[i + 14], 23, -35309556);
    a2 = md5hh(a2, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a2, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a2, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a2, x[i + 10], 23, -1094730640);
    a2 = md5hh(a2, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a2, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a2, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a2, x[i + 6], 23, 76029189);
    a2 = md5hh(a2, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a2, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a2, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a2, x[i + 2], 23, -995338651);
    a2 = md5ii(a2, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a2, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a2, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a2, x[i + 5], 21, -57434055);
    a2 = md5ii(a2, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a2, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a2, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a2, x[i + 1], 21, -2054922799);
    a2 = md5ii(a2, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a2, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a2, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a2, x[i + 13], 21, 1309151649);
    a2 = md5ii(a2, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a2, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a2, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a2, x[i + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a2, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b, x, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t2)), s2), b);
}
function md5ff(a2, b, c, d, x, s2, t2) {
  return md5cmn(b & c | ~b & d, a2, b, x, s2, t2);
}
function md5gg(a2, b, c, d, x, s2, t2) {
  return md5cmn(b & d | c & ~d, a2, b, x, s2, t2);
}
function md5hh(a2, b, c, d, x, s2, t2) {
  return md5cmn(b ^ c ^ d, a2, b, x, s2, t2);
}
function md5ii(a2, b, c, d, x, s2, t2) {
  return md5cmn(c ^ (b | ~d), a2, b, x, s2, t2);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s2, x, y, z) {
  switch (s2) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[_i2][t2];
    }
    for (var _t3 = 16; _t3 < 80; ++_t3) {
      W[_t3] = ROTL(W[_t3 - 3] ^ W[_t3 - 8] ^ W[_t3 - 14] ^ W[_t3 - 16], 1);
    }
    var a2 = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e2 = H[4];
    for (var _t23 = 0; _t23 < 80; ++_t23) {
      var s2 = Math.floor(_t23 / 20);
      var T = ROTL(a2, 5) + f(s2, b, c, d) + e2 + K[s2] + W[_t23] >>> 0;
      e2 = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/@hookform/devtools/dist/index.esm.js
var import_react_simple_animate = __toESM(require_dist());

// node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
var React4 = __toESM(require_react());

// node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var React2 = __toESM(require_react());
var import_react = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.browser.esm.js
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (true) {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e2);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    if (true) {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement3) {
  return value.replace(pattern, replacement3);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse2(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
      if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
        props[k++] = z;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify2(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
  return function(element, index, children) {
    if (element.type !== "rule" || cache.compat)
      return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : children;
      for (var i = commentContainer.length - 1; i >= 0; i--) {
        var node2 = commentContainer[i];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix2(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  if (true) {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  if (true) {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify2, true ? function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (serialized.map !== void 0) {
        currentSheet = {
          insert: function insert2(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if ((isStringTag === false || isBrowser === false) && cache.registered[className] === void 0) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= k >>> 24;
    h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/serialize/dist/emotion-serialize.browser.esm.js
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match4, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
if (true) {
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        if (interpolation.map !== void 0) {
          styles += interpolation.map;
        }
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else if (true) {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      if (true) {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(match4, p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
        }
      }
      break;
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && true) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (_key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
if (true) {
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
}
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    if (strings[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      if (strings[i] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += strings[i];
    }
  }
  var sourceMap;
  if (true) {
    styles = styles.replace(sourceMapPattern, function(match5) {
      sourceMap = match5;
      return "";
    });
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match4;
  while ((match4 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match4[1];
  }
  var name = murmur2(styles) + identifierName;
  if (true) {
    return {
      name,
      styles,
      map: sourceMap,
      next: cursor,
      toString: function toString5() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
  }
  return {
    name,
    styles,
    next: cursor
  };
};

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React = __toESM(require_react());
var syncFallback = function syncFallback2(create3) {
  return create3();
};
var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-c39617d8.browser.esm.js
var isBrowser2 = true;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = React2.createContext(
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
if (true) {
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return (0, import_react.forwardRef)(function(props, ref) {
    var cache = (0, import_react.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
if (!isBrowser2) {
  withEmotionCache = function withEmotionCache3(func) {
    return function(props) {
      var cache = (0, import_react.useContext)(EmotionCacheContext);
      if (cache === null) {
        cache = createCache({
          key: "css"
        });
        return React2.createElement(EmotionCacheContext.Provider, {
          value: cache
        }, func(props, cache));
      } else {
        return func(props, cache);
      }
    };
  };
}
var ThemeContext = React2.createContext({});
if (true) {
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return React2.createElement(React2.Fragment, null, React2.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React2.createElement(WrappedComponent, newProps));
});
if (true) {
  Emotion.displayName = "EmotionCssPropInternal";
}

// node_modules/@emotion/react/dist/emotion-react.browser.esm.js
var React3 = __toESM(require_react());
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
var pkg = {
  name: "@emotion/react",
  version: "11.11.1",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        "default": "./dist/emotion-react.esm.js"
      },
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.2",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.0",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props, cache) {
  if (!warnedAboutCssPropForGlobal && (props.className || props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, React3.useContext(ThemeContext));
  if (!isBrowser2) {
    var _ref;
    var serializedNames = serialized.name;
    var serializedStyles = serialized.styles;
    var next2 = serialized.next;
    while (next2 !== void 0) {
      serializedNames += " " + next2.name;
      serializedStyles += next2.styles;
      next2 = next2.next;
    }
    var shouldCache = cache.compat === true;
    var rules = cache.insert("", {
      name: serializedNames,
      styles: serializedStyles
    }, cache.sheet, shouldCache);
    if (shouldCache) {
      return null;
    }
    return React3.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
      __html: rules
    }, _ref.nonce = cache.sheet.nonce, _ref));
  }
  var sheetRef = React3.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
if (true) {
  Global.displayName = "EmotionGlobal";
}
var classnames = function classnames2(args) {
  var len = args.length;
  var i = 0;
  var cls = "";
  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k in arg) {
            if (arg[k] && k) {
              toAdd && (toAdd += " ");
              toAdd += k;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css(registeredStyles);
}
var Insertion3 = function Insertion4(_ref) {
  var cache = _ref.cache, serializedArr = _ref.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache, serializedArr[i], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css = function css2() {
    if (hasRendered && true) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && true) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css, classnames(args));
  };
  var content = {
    css,
    cx,
    theme: React3.useContext(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return React3.createElement(React3.Fragment, null, React3.createElement(Insertion3, {
    cache,
    serializedArr
  }), ele);
});
if (true) {
  ClassNames.displayName = "EmotionClassNames";
}
if (true) {
  isBrowser3 = true;
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser3 && !isTestEnv) {
    globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser3 ? window : globalThis;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser3;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@emotion/styled/base/dist/emotion-styled-base.browser.esm.js
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var ILLEGAL_ESCAPE_SEQUENCE_ERROR2 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var Insertion5 = function Insertion6(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  if (true) {
    if (tag === void 0) {
      throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
    }
  }
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles.push.apply(styles, args);
    } else {
      if (args[0][0] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
      }
      styles.push(args[0][0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        if (args[0][i] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR2);
        }
        styles.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = React4.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return React4.createElement(React4.Fragment, null, React4.createElement(Insertion5, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), React4.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && true) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };
    return Styled;
  };
};

// node_modules/@emotion/styled/dist/emotion-styled.browser.esm.js
var import_react3 = __toESM(require_react());
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});

// node_modules/@hookform/devtools/dist/index.esm.js
var import_isUndefined = __toESM(require_isUndefined());
var import_isObject = __toESM(require_isObject());
var import_get = __toESM(require_get());

// node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js
var React5 = __toESM(require_react());

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/use-deep-compare-effect/dist/use-deep-compare-effect.esm.js
function checkDeps(deps) {
  if (!deps || !deps.length) {
    throw new Error("useDeepCompareEffect should not be used with no dependencies. Use React.useEffect instead.");
  }
  if (deps.every(isPrimitive)) {
    throw new Error("useDeepCompareEffect should not be used with dependencies that are all primitive values. Use React.useEffect instead.");
  }
}
function isPrimitive(val) {
  return val == null || /^[sbn]/.test(typeof val);
}
function useDeepCompareMemoize(value) {
  var ref = React5.useRef(value);
  var signalRef = React5.useRef(0);
  if (!dequal(value, ref.current)) {
    ref.current = value;
    signalRef.current += 1;
  }
  return React5.useMemo(function() {
    return ref.current;
  }, [signalRef.current]);
}
function useDeepCompareEffect(callback, dependencies) {
  if (true) {
    checkDeps(dependencies);
  }
  return React5.useEffect(callback, useDeepCompareMemoize(dependencies));
}

// node_modules/@hookform/devtools/dist/index.esm.js
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data3) {
  let copy2;
  const isArray = Array.isArray(data3);
  if (data3 instanceof Date) {
    copy2 = new Date(data3);
  } else if (data3 instanceof Set) {
    copy2 = new Set(data3);
  } else if (!(isWeb && (data3 instanceof Blob || data3 instanceof FileList)) && (isArray || isObject(data3))) {
    copy2 = isArray ? [] : {};
    if (!Array.isArray(data3) && !isPlainObject(data3)) {
      copy2 = data3;
    } else {
      for (const key in data3) {
        copy2[key] = cloneObject(data3[key]);
      }
    }
  } else {
    return data3;
  }
  return copy2;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (obj, path, defaultValue) => {
  if (!path || !isObject(obj)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], obj);
  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
var HookFormContext = import_react5.default.createContext(null);
var useFormContext2 = () => import_react5.default.useContext(HookFormContext);
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var shouldSubscribeByName = (name, signalName, exact) => exact && signalName ? name === signalName : !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = import_react5.default.useRef(props);
  _props.current = props;
  import_react5.default.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}
function useFormState(props) {
  const methods = useFormContext2();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = import_react5.default.useState(control._formState);
  const _mounted = import_react5.default.useRef(true);
  const _localProxyFormState = import_react5.default.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = import_react5.default.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    next: (value) => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState({
      ...control._formState,
      ...value
    }),
    subject: control._subjects.state
  });
  import_react5.default.useEffect(() => {
    _mounted.current = true;
    const isDirty = control._proxyFormState.isDirty && control._getDirty();
    if (isDirty !== control._formState.isDirty) {
      control._subjects.state.next({
        isDirty
      });
    }
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return getProxyFormState(formState, control, _localProxyFormState.current, false);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext2();
  const { control = methods.control, name, defaultValue, disabled, exact } = props || {};
  const _name = import_react5.default.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState) => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value, updateValue] = import_react5.default.useState(control._getWatch(name, defaultValue));
  import_react5.default.useEffect(() => control._removeUnmounted());
  return value;
}
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
function set(object, path, value) {
  let index = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length2 = tempPath.length;
  const lastIndex = length2 - 1;
  while (++index < length2) {
    const key = tempPath[index];
    let newValue = value;
    if (index !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
}
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message || true
  }
} : {};
var focusFieldBy = (fields, callback, fieldsNames) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f && callback(_f.name)) {
        if (_f.ref.focus) {
          _f.ref.focus();
          break;
        } else if (_f.refs && _f.refs[0].focus) {
          _f.refs[0].focus();
          break;
        }
      } else if (isObject(currentField)) {
        focusFieldBy(currentField, callback);
      }
    }
  }
};
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = compact(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isBoolean = (value) => typeof value === "boolean";
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = (value) => isString(value);
var isRadioInput = (element) => element.type === "radio";
var isRegex = (value) => value instanceof RegExp;
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values2 = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values2, isValid: !!values2.length };
    }
    return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult : defaultResult;
  }
  return defaultResult;
};
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min3, max: max3, pattern, validate: validate2, name, valueAsNumber, mount, disabled } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabled) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min3) || !isNullOrUndefined(max3))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max3);
    const minOutput = getValueAndMessage(min3);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => new Date(new Date().toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate2) {
    if (isFunction(validate2)) {
      const result = await validate2(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate2)) {
      let validationResult = {};
      for (const key in validate2) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate2[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
function baseGet(object, updatePath) {
  const length2 = updatePath.slice(0, -1).length;
  let index = 0;
  while (index < length2) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (!isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index = paths.length - 1;
  const key = paths[index];
  if (childObject) {
    delete childObject[key];
  }
  if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
function createSubject() {
  let _observers = [];
  const next2 = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o2) => o2 !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next: next2,
    subscribe,
    unsubscribe
  };
}
var isPrimitive2 = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive2(object1) || isPrimitive2(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys22 = Object.keys(object2);
  if (keys1.length !== keys22.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys22.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
var objectHasFunction = (data3) => {
  for (const key in data3) {
    if (isFunction(data3[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data3, fields = {}) {
  const isParentNodeArray = Array.isArray(data3);
  if (isObject(data3) || isParentNodeArray) {
    for (const key in data3) {
      if (Array.isArray(data3[key]) || isObject(data3[key]) && !objectHasFunction(data3[key])) {
        fields[key] = Array.isArray(data3[key]) ? [] : {};
        markFieldsDirty(data3[key], fields[key]);
      } else if (!isNullOrUndefined(data3[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data3, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data3);
  if (isObject(data3) || isParentNodeArray) {
    for (const key in data3) {
      if (Array.isArray(data3[key]) || isObject(data3[key]) && !objectHasFunction(data3[key])) {
        if (isUndefined(formValues) || isPrimitive2(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data3[key]) ? markFieldsDirty(data3[key], []) : { ...markFieldsDirty(data3[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data3[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data3[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (_f.refs ? _f.refs.every((ref2) => ref2.disabled) : ref.disabled) {
    return;
  }
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}, flushRootRender) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: true,
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    errors: {}
  };
  let _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const shouldCaptureDirtyFields = props.resetOptions && props.resetOptions.keepDirtyValues;
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (_proxyFormState.isValid || shouldUpdateValid) {
      const isValid = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid !== _formState.isValid) {
        _subjects.state.next({
          isValid
        });
      }
    }
  };
  const _updateIsValidating = (value) => _proxyFormState.isValidating && _subjects.state.next({
    isValidating: value
  });
  const _updateFieldArray = (name, values2 = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values2),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values2);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!isBlurEvent || shouldDirty) {
      if (_proxyFormState.isDirty) {
        isPreviousDirty = _formState.isDirty;
        _formState.isDirty = output.isDirty = _getDirty();
        shouldUpdateField = isPreviousDirty !== output.isDirty;
      }
      const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
      isPreviousDirty = get(_formState.dirtyFields, name);
      isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
      output.dirtyFields = _formState.dirtyFields;
      shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
    }
    if (isBlurEvent) {
      const isPreviousFieldTouched = get(_formState.touchedFields, name);
      if (!isPreviousFieldTouched) {
        set(_formState.touchedFields, name, isBlurEvent);
        output.touchedFields = _formState.touchedFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
      }
    }
    shouldUpdateField && shouldRender && _subjects.state.next(output);
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid) && _formState.isValid !== isValid;
    if (props.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(props.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid) ? { isValid } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
    _updateIsValidating(false);
  };
  const _executeSchema = async (name) => _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema();
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation, isFieldArrayRoot);
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        fieldValue && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data3) => (name && data3 && set(_formValues, name, data3), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data3) => data3 === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || !isPrimitive2(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name,
      values: { ..._formValues }
    });
    !_state.mount && flushRootRender();
  };
  const onChange = async (event) => {
    const target = event.target;
    let name = target.name;
    const field = get(_fields, name);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    if (field) {
      let error;
      let isValid;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        _proxyFormState.isValid && _updateValid();
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      _updateIsValidating(true);
      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);
        const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
        const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
        error = errorLookupResult.error;
        name = errorLookupResult.name;
        isValid = isEmptyObject(errors);
      } else {
        error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        if (error) {
          isValid = false;
        } else if (_proxyFormState.isValid) {
          isValid = await executeBuiltInValidation(_fields, true);
        }
      }
      field._f.deps && trigger(field._f.deps);
      shouldRenderByError(name, isValid, error, fieldState);
    }
  };
  const trigger = async (name, options = {}) => {
    let isValid;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    _updateIsValidating(true);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || _proxyFormState.isValid && isValid !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid } : {},
      errors: _formState.errors,
      isValidating: false
    });
    options.shouldFocus && !validationResult && focusFieldBy(_fields, (key) => key && get(_formState.errors, key), name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values2 = {
      ..._defaultValues,
      ..._state.mount ? _formValues : {}
    };
    return isUndefined(fieldNames) ? values2 : isString(fieldNames) ? get(values2, fieldNames) : fieldNames.map((name) => get(values2, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name),
    error: get((formState || _formState).errors, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    set(_formState.errors, name, {
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.values.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (get(_fields, fieldName)) {
        if (!options.keepValue) {
          unset(_fields, fieldName);
          unset(_formValues, fieldName);
        }
        !options.keepError && unset(_formState.errors, fieldName);
        !options.keepDirty && unset(_formState.dirtyFields, fieldName);
        !options.keepTouched && unset(_formState.touchedFields, fieldName);
        !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
      }
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const register = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    field ? disabledIsDefined && set(_formValues, name, options.disabled ? void 0 : get(_formValues, name, getFieldValue(field._f))) : updateValidAndValue(name, true, options.value);
    return {
      ...disabledIsDefined ? { disabled: options.disabled } : {},
      ..._options.shouldUseNativeValidation ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && focusFieldBy(_fields, (key) => key && get(_formState.errors, key), _names.mount);
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values: values2 } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values2;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      await onValid(fieldValues, e2);
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors),
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
  };
  const resetField = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, get(_defaultValues, name));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, options.defaultValue);
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, get(_defaultValues, name)) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues || _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const values2 = formValues && !isEmptyObject(formValues) ? cloneUpdatedValues : _defaultValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues || shouldCaptureDirtyFields) {
        for (const fieldName of _names.mount) {
          get(_formState.dirtyFields, fieldName) ? set(values2, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values2, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneUpdatedValues;
      _subjects.array.next({
        values: { ...values2 }
      });
      _subjects.values.next({
        values: { ...values2 }
      });
    }
    _names = {
      mount: /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    !_state.mount && flushRootRender();
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid;
    _state.watch = !!props.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: keepStateOptions.keepDirtyValues ? _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitting: false,
      isSubmitSuccessful: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  if (isFunction(_options.defaultValues)) {
    _options.defaultValues().then((values2) => {
      reset(values2, _options.resetOptions);
      _subjects.state.next({
        isLoading: false
      });
    });
  }
  return {
    control: {
      register,
      unregister,
      getFieldState,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _getFieldArray,
      _reset,
      _updateFormState,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm2(props = {}) {
  const _formControl = import_react5.default.useRef();
  const [formState, updateFormState] = import_react5.default.useState({
    isDirty: false,
    isValidating: false,
    isLoading: true,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    errors: {},
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props, () => updateFormState((formState2) => ({ ...formState2 }))),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value) => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  import_react5.default.useEffect(() => {
    if (props.values && !deepEqual(props.values, control._defaultValues)) {
      control._reset(props.values, control._options.resetOptions);
    }
  }, [props.values, control]);
  import_react5.default.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
var colors = {
  primary: "#0e101c",
  secondary: "#bf1650",
  lightBlue: "#516391",
  blue: "#1e2a4a",
  lightPink: "#ec5990",
  errorPink: "#fbecf2",
  buttonBlue: "#191d3a",
  link: "#ff7aa8",
  green: "#1bda2b"
};
var paraGraphDefaultStyle = {
  fontSize: 13,
  lineHeight: "20px"
};
var Button2 = newStyled.button`
  appearance: none;
  margin: 0;
  border: 0;
  color: white;
  padding: 5px !important;
  border-radius: 0 !important;
  background: ${(props) => props.hideBackground ? `` : `${colors.blue} !important`};
  transition: 0.2s all;

  &:hover {
    background: ${colors.lightBlue};
  }
`;
Button2.defaultProps = { type: "button" };
var CircleButton = newStyled(Button2)`
  font-size: 14px;
  font-weight: bold;
  margin: 0 4px 0 auto;
  background: none !important;
  display: flex;
  width: 25px;
  height: 25px;
  justify-content: center;
  line-height: 14px !important;
  border-radius: 50% !important;
  padding: 0 !important;
  transition: 0.2s all;

  &:hover {
    background: ${colors.lightBlue};
  }

  &:active {
    background: black;
  }
`;
var Input = newStyled.input`
  &::placeholder {
    color: #b3b3b3;
  }

  &:focus::placeholder {
    color: white;
  }
`;
var Table = newStyled.table`
  transition: 0.3s all;

  &:hover {
    background: ${colors.primary};
  }
`;
var Header = ({ setVisible: setVisible2, control }) => {
  const { isValid } = useFormState({
    control
  });
  return React6.createElement(
    "header",
    { style: {
      display: "flex",
      alignItems: "center",
      paddingLeft: 10,
      backgroundColor: "transparent"
    } },
    React6.createElement(
      "p",
      { style: Object.assign(Object.assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0, fontWeight: 400, fontSize: 12 }) },
      React6.createElement("span", { style: {
        transition: "0.5s all",
        color: isValid ? colors.green : colors.lightPink
      } }, "\u25A0"),
      " ",
      "React Hook Form"
    ),
    React6.createElement(CircleButton, { title: "Close dev panel", onClick: () => setVisible2(false) }, "\u2715")
  );
};
var PanelTable = ({ refObject, hasError, isDirty, fieldsValues, isNative, errorMessage, errorType, type, isTouched, name, collapseAll }) => {
  const [collapse, setCollapse2] = React6.useState(false);
  React6.useEffect(() => {
    setCollapse2(!collapseAll);
  }, [collapseAll]);
  let value = fieldsValues ? get(fieldsValues, name) : "";
  let isValueWrappedInPre = false;
  if (!(0, import_isUndefined.default)(value)) {
    if ((0, import_isObject.default)(value)) {
      try {
        value = React6.createElement(
          "pre",
          { style: { margin: 0 } },
          React6.createElement("code", { style: { fontSize: 12 } }, JSON.stringify(value, null, 2))
        );
        isValueWrappedInPre = true;
      } catch (_a) {
        value = React6.createElement("span", null, "[Nested Object]");
      }
    } else if (typeof value !== "string") {
      value = String(value);
    }
  }
  return React6.createElement(
    Table,
    { style: {
      padding: "5px 8px",
      width: "100%",
      transition: ".3s all",
      borderLeft: `2px solid ${hasError ? colors.secondary : colors.buttonBlue}`,
      background: "none"
    } },
    React6.createElement(
      "thead",
      null,
      React6.createElement(
        "tr",
        null,
        React6.createElement(
          "td",
          { valign: "top", style: { width: 85, lineHeight: "22px" } },
          React6.createElement(Button2, { onClick: () => setCollapse2(!collapse), title: "Toggle field table", style: {
            border: `1px solid ${colors.lightBlue}`,
            borderRadius: 2,
            padding: "3px 5px",
            display: "inline-block",
            fontSize: 9,
            lineHeight: "13px",
            width: 20,
            textAlign: "center",
            marginRight: 8
          } }, collapse ? "+" : "-"),
          React6.createElement(Button2, { onClick: () => {
            if (refObject.scrollIntoView) {
              refObject.scrollIntoView({ behavior: "smooth" });
            }
          }, title: "Scroll into view", style: Object.assign({ border: `1px solid ${colors.lightBlue}`, borderRadius: 2, padding: "3px 5px", display: "inline-block", fontSize: 9, lineHeight: "13px", textAlign: "center", width: "calc(100% - 30px)" }, isNative ? {} : { cursor: "not-allowed", background: colors.lightBlue }) }, isNative ? "Native" : "Custom")
        ),
        React6.createElement(
          "td",
          { style: {
            display: "block",
            maxWidth: 140
          } },
          React6.createElement("p", { style: Object.assign(Object.assign({ margin: 0, padding: 0, top: 0, position: "relative", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }, paraGraphDefaultStyle), { lineHeight: "24px" }), title: name }, name)
        )
      )
    ),
    !collapse && React6.createElement(
      "tbody",
      null,
      type && React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: "top" }, paraGraphDefaultStyle) }, "Type:"),
        React6.createElement("td", { style: Object.assign({ display: "block", maxWidth: 100 }, paraGraphDefaultStyle) }, type)
      ),
      errorType && React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: "top" }, paraGraphDefaultStyle) }, "ERROR Type:"),
        React6.createElement("td", { style: Object.assign({ display: "block", maxWidth: 100 }, paraGraphDefaultStyle) }, errorType)
      ),
      errorMessage && React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: "top" }, paraGraphDefaultStyle) }, "MESSAGE:"),
        React6.createElement("td", { style: Object.assign({ display: "block", maxWidth: 100 }, paraGraphDefaultStyle) }, typeof errorMessage === "string" ? errorMessage.trim() : JSON.stringify(errorMessage))
      ),
      !(0, import_isUndefined.default)(value) && React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: "top" }, paraGraphDefaultStyle) }, "Value:"),
        React6.createElement(
          "td",
          { "data-testid": `${name}-field-value`, style: Object.assign({ display: "block", maxWidth: 100 }, paraGraphDefaultStyle) },
          !isValueWrappedInPre && React6.createElement("p", { title: value, style: Object.assign(Object.assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0 }) }, value),
          isValueWrappedInPre && React6.createElement("div", { style: Object.assign(Object.assign({}, paraGraphDefaultStyle), { margin: 0, padding: 0 }) }, value)
        )
      ),
      React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: "top" }, paraGraphDefaultStyle) }, "Touched:"),
        React6.createElement(
          "td",
          null,
          React6.createElement("code", { style: Object.assign(Object.assign({ color: isTouched ? colors.green : colors.lightPink }, paraGraphDefaultStyle), { fontSize: 12 }) }, isTouched ? "true" : "false")
        )
      ),
      React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({ paddingRight: 5, fontWeight: 500, verticalAlign: "top" }, paraGraphDefaultStyle) }, "Dirty:"),
        React6.createElement(
          "td",
          null,
          React6.createElement("code", { style: Object.assign(Object.assign({ color: isDirty ? colors.green : colors.lightPink }, paraGraphDefaultStyle), { fontSize: 12 }) }, isDirty ? "true" : "false")
        )
      )
    )
  );
};
var FormStateTable = ({ formState, showFormState, setShowFormState }) => React6.createElement(
  "div",
  { style: {
    alignSelf: "end"
  } },
  React6.createElement(import_react_simple_animate.Animate, { play: showFormState, start: { opacity: 0 }, end: { opacity: 1 }, render: ({ style }) => React6.createElement(
    "table",
    { style: Object.assign({ padding: "5px 10px", display: "block", background: "black", borderTop: `1px solid ${colors.lightPink}`, pointerEvents: "none" }, style) },
    React6.createElement(
      "tbody",
      null,
      React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({ width: 90 }, paraGraphDefaultStyle) }, "Valid:"),
        React6.createElement("td", { style: Object.assign({ color: formState.isValid ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.isValid ? "true" : "false")
      ),
      React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({}, paraGraphDefaultStyle) }, "Dirty:"),
        React6.createElement("td", { style: Object.assign({ color: formState.isDirty ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.isDirty ? "true" : "false")
      ),
      React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({}, paraGraphDefaultStyle) }, "Submitted:"),
        React6.createElement("td", { style: Object.assign({ color: formState.isSubmitted ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.isSubmitted ? "true" : "false")
      ),
      React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({}, paraGraphDefaultStyle) }, "Count:"),
        React6.createElement("td", { style: Object.assign({ color: formState.submitCount ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.submitCount)
      ),
      React6.createElement(
        "tr",
        null,
        React6.createElement("td", { align: "right", style: Object.assign({}, paraGraphDefaultStyle) }, "Submitting:"),
        React6.createElement("td", { style: Object.assign({ color: formState.isSubmitting ? colors.green : colors.lightPink }, paraGraphDefaultStyle) }, formState.isSubmitting ? "true" : "false")
      )
    )
  ) }),
  React6.createElement(
    Button2,
    { style: {
      margin: 0,
      width: "100%",
      padding: "8px 10px",
      textTransform: "none",
      fontSize: 12,
      lineHeight: "14px",
      cursor: "pointer"
    }, title: "Toggle form state panel", onClick: () => {
      setShowFormState(!showFormState);
    } },
    React6.createElement("span", { style: {
      transition: "0.5s all",
      color: formState.isValid ? colors.green : colors.lightPink
    } }, "\u25A0"),
    " ",
    "Form State: ",
    showFormState ? "OFF" : "ON"
  )
);
function setVisible(state, payload) {
  return Object.assign(Object.assign({}, state), { visible: payload });
}
function setCollapse(state, payload) {
  return Object.assign(Object.assign({}, state), { isCollapse: payload });
}
var childIndex = 0;
function PanelChildren({ fields, searchTerm, touchedFields, errors, dirtyFields, state, fieldsValues }) {
  return React6.createElement(React6.Fragment, null, fields && Object.entries(fields).filter(([name]) => (name && name.toLowerCase && name.toLowerCase().includes(searchTerm) || !name && !searchTerm || searchTerm === "") && name).map(([name, value], index) => {
    childIndex++;
    if (!(value === null || value === void 0 ? void 0 : value._f)) {
      return React6.createElement(PanelChildren, Object.assign({ key: name + childIndex }, {
        fields: value,
        searchTerm,
        touchedFields,
        errors,
        dirtyFields,
        state,
        fieldsValues
      }));
    } else {
      const error = get(errors, value._f.name);
      const errorMessage = get(error, "message", void 0);
      const errorType = get(error, "type", void 0);
      const type = get(value, "ref.type", void 0);
      const isTouched = !!get(touchedFields, value._f.name);
      const isNative = !!(value && value._f.ref.type);
      const isDirty = !!get(dirtyFields, value._f.name);
      const hasError = !!error;
      const ref = get(value, "_f.ref");
      return React6.createElement(
        "section",
        { key: (value === null || value === void 0 ? void 0 : value._f.name) + childIndex, style: {
          borderBottom: `1px dashed ${colors.secondary}`,
          margin: 0
        } },
        React6.createElement(PanelTable, { refObject: ref, index, collapseAll: state.isCollapse, name: value === null || value === void 0 ? void 0 : value._f.name, isTouched, type, hasError, isNative, errorMessage, errorType, isDirty, fieldsValues })
      );
    }
  }));
}
var Panel = ({ control, control: { _fields } }) => {
  const formState = useFormState({
    control
  });
  const { dirtyFields, touchedFields, errors } = formState;
  formState.isDirty;
  const { state, actions } = a({
    setCollapse
  });
  const [, setData] = React6.useState({});
  const [showFormState, setShowFormState] = React6.useState(false);
  const fieldsValues = useWatch({
    control
  });
  const { register, watch } = useForm2();
  const searchTerm = watch("search", "");
  (0, import_react5.useEffect)(() => {
    setData({});
  }, []);
  return React6.createElement(
    "div",
    { style: {
      display: "grid",
      gridTemplateRows: "56px auto",
      height: false ? "100vh" : "calc(100vh - 40px)"
    } },
    React6.createElement(
      "div",
      { style: {
        display: "grid",
        gridTemplateColumns: `1fr 1fr`,
        gridTemplateRows: "28px 28px"
      } },
      React6.createElement(Button2, { style: {
        borderRight: `1px solid ${colors.primary}`,
        textTransform: "none",
        fontSize: 11,
        lineHeight: 1
      }, title: "Update values and state the form", onClick: () => setData({}) }, "\u267A REFRESH"),
      React6.createElement(Button2, { style: {
        borderRight: `1px solid ${colors.primary}`,
        textTransform: "none",
        fontSize: 11,
        lineHeight: 1
      }, title: "Toggle entire fields", onClick: () => {
        actions.setCollapse(!state.isCollapse);
      } }, state.isCollapse ? "[-] COLLAPSE" : "[+] EXPAND"),
      React6.createElement(Input, Object.assign({ style: {
        display: "inline-block",
        borderRadius: 0,
        width: "100%",
        margin: 0,
        padding: "5px 10px",
        WebkitAppearance: "none",
        appearance: "none",
        fontSize: 14,
        border: 0,
        color: "white",
        gridColumnStart: 1,
        gridColumnEnd: 4,
        background: "black"
      } }, register("search"), { placeholder: "Filter name...", type: "search" }))
    ),
    React6.createElement(
      "div",
      { style: {
        overflow: "auto"
      } },
      React6.createElement(PanelChildren, { fields: _fields, searchTerm, errors, touchedFields, dirtyFields, fieldsValues, state })
    ),
    React6.createElement(FormStateTable, { formState, showFormState, setShowFormState })
  );
};
var Logo = ({ style, actions }) => {
  return React6.createElement(
    "svg",
    { fill: "white", viewBox: "0 0 100 100", style: Object.assign({ height: 14, padding: 3, borderRadius: 2, background: colors.lightPink }, style), onClick: () => {
      actions.setVisible(true);
    }, "aria-label": "React Hook Form Logo" },
    React6.createElement("path", { d: "M73.56,13.32H58.14a8.54,8.54,0,0,0-16.27,0H26.44a11,11,0,0,0-11,11V81.63a11,11,0,0,0,11,11H73.56a11,11,0,0,0,11-11V24.32A11,11,0,0,0,73.56,13.32Zm-30.92,2a1,1,0,0,0,1-.79,6.54,6.54,0,0,1,12.78,0,1,1,0,0,0,1,.79h5.38v6.55a3,3,0,0,1-3,3H40.25a3,3,0,0,1-3-3V15.32ZM82.56,81.63a9,9,0,0,1-9,9H26.44a9,9,0,0,1-9-9V24.32a9,9,0,0,1,9-9h8.81v6.55a5,5,0,0,0,5,5h19.5a5,5,0,0,0,5-5V15.32h8.81a9,9,0,0,1,9,9Z" }),
    React6.createElement("path", { style: { transform: "translateX(-25px)" }, d: "M71.6,45.92H54a1,1,0,0,0,0,2H71.6a1,1,0,0,0,0-2Z" }),
    React6.createElement("path", { d: "M71.6,45.92H54a1,1,0,0,0,0,2H71.6a1,1,0,0,0,0-2Z" }),
    React6.createElement("path", { style: { transform: "translateX(-25px)" }, d: "M71.1,69.49H53.45a1,1,0,1,0,0,2H71.1a1,1,0,0,0,0-2Z" }),
    React6.createElement("path", { d: "M71.1,69.49H53.45a1,1,0,1,0,0,2H71.1a1,1,0,0,0,0-2Z" })
  );
};
function getPositionByPlacement(placement, defaultX = 0, defaultY = 0) {
  const [x, y] = placement.split("-");
  return {
    [x]: defaultX,
    [y]: defaultY
  };
}
var DevToolUI = ({ control, placement = "top-right", styles }) => {
  const { state, actions } = a({
    setVisible
  });
  const position2 = getPositionByPlacement(placement, 0, 0);
  return React6.createElement(
    React6.Fragment,
    null,
    React6.createElement(
      import_react_simple_animate.Animate,
      { play: state.visible, duration: 0.2, start: Object.assign(Object.assign({}, position2), { position: "fixed", transform: placement.includes("right") ? "translateX(280px)" : "translateX(-280px)", zIndex: 99999 }), end: Object.assign(Object.assign({}, position2), { position: "fixed", transform: "translateX(0)", zIndex: 99999 }) },
      React6.createElement(
        "div",
        { style: Object.assign(Object.assign(Object.assign({}, position2), { position: "fixed", height: "100vh", width: 250, zIndex: 99999, background: colors.buttonBlue, display: "grid", textAlign: "left", color: "white", fontSize: 14, gridTemplateRows: "40px auto", fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif" }), styles === null || styles === void 0 ? void 0 : styles.panel) },
        React6.createElement(Header, { setVisible: actions.setVisible, control }),
        React6.createElement(Panel, { control })
      )
    ),
    !state.visible && React6.createElement(
      Button2,
      { title: "Show dev panel", hideBackground: true, style: Object.assign(Object.assign(Object.assign({ position: "fixed", zIndex: 99999 }, getPositionByPlacement(placement, 3, 3)), { padding: 3, margin: 0, background: "none" }), styles === null || styles === void 0 ? void 0 : styles.button) },
      React6.createElement(Logo, { actions })
    )
  );
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
      t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t2[p[i]] = s2[p[i]];
    }
  return t2;
}
function proxyToObject(proxy) {
  return Reflect.ownKeys(proxy).reduce((prev2, key) => {
    prev2[key] = proxy[key];
    return prev2;
  }, {});
}
function nestToFlat(flatKeys, obj, defaultValue) {
  return flatKeys.reduce((prev2, name) => {
    prev2[name] = (0, import_get.default)(obj, name) || defaultValue;
    return prev2;
  }, {});
}
function useExportControlToExtension({ id: id3, control }) {
  const nestedFormValues = useWatch({ control });
  const formState = useFormState({ control });
  const [isExtensionEnabled, setIsExtensionEnabled] = (0, import_react5.useState)(false);
  const handleInitMessage = (message) => {
    if (message.data.source !== "react-hook-form-bridge" || message.data.type !== "INIT") {
      return;
    }
    window.postMessage({
      source: "react-hook-form-bridge",
      type: "WELCOME"
    });
    setIsExtensionEnabled(true);
  };
  (0, import_react5.useEffect)(() => {
    window.addEventListener("message", handleInitMessage);
    return () => window.removeEventListener("message", handleInitMessage);
  }, []);
  useDeepCompareEffect(() => {
    if (!isExtensionEnabled) {
      return;
    }
    const _a = proxyToObject(formState), { errors: nestedErrors, dirtyFields: nestedDirtyFields, touchedFields: nestedTouchedFields } = _a, formStatus = __rest(_a, ["errors", "dirtyFields", "touchedFields"]);
    const flatFieldNames = [...control._names.mount];
    const formValues = nestToFlat(flatFieldNames, nestedFormValues, "");
    const dirtyFields = nestToFlat(flatFieldNames, nestedDirtyFields, false);
    const touchedFields = nestToFlat(flatFieldNames, nestedTouchedFields, false);
    const flatErrors = nestToFlat(flatFieldNames, nestedErrors);
    const errors = Object.entries(flatErrors).reduce((prev2, [key, value]) => {
      prev2[key] = {
        type: value === null || value === void 0 ? void 0 : value.type,
        message: value === null || value === void 0 ? void 0 : value.message
      };
      return prev2;
    }, {});
    const nativeFields = flatFieldNames.reduce((prev2, name) => {
      var _a2, _b, _c;
      prev2[name] = !!((_c = (_b = (_a2 = (0, import_get.default)(control._fields, name)) === null || _a2 === void 0 ? void 0 : _a2._f) === null || _b === void 0 ? void 0 : _b.ref) === null || _c === void 0 ? void 0 : _c.type);
      return prev2;
    }, {});
    const updateMessagePayload = {
      id: id3,
      data: {
        formValues,
        formState: Object.assign({
          errors,
          dirtyFields,
          touchedFields,
          nativeFields
        }, formStatus)
      }
    };
    window.postMessage({
      source: "react-hook-form-bridge",
      type: "UPDATE",
      payload: updateMessagePayload
    });
  }, [isExtensionEnabled, nestedFormValues, proxyToObject(formState)]);
  return { isExtensionEnabled };
}
if (typeof window !== "undefined") {
  s({
    visible: false,
    isCollapse: false,
    filterName: ""
  }, {
    name: "__REACT_HOOK_FORM_DEVTOOLS__",
    middleWares: [],
    storageType: window.localStorage
  });
}
var DevTool = (props) => {
  var _a, _b, _c;
  const methods = useFormContext2();
  const uuid = React6.useRef("");
  React6.useEffect(() => {
    uuid.current = v4_default();
  }, []);
  const { isExtensionEnabled } = useExportControlToExtension({
    id: (_a = props === null || props === void 0 ? void 0 : props.id) !== null && _a !== void 0 ? _a : uuid.current,
    control: (_b = props === null || props === void 0 ? void 0 : props.control) !== null && _b !== void 0 ? _b : methods.control
  });
  if (isExtensionEnabled) {
    return null;
  }
  return React6.createElement(
    o,
    null,
    React6.createElement(DevToolUI, { control: (_c = props === null || props === void 0 ? void 0 : props.control) !== null && _c !== void 0 ? _c : methods.control, placement: props === null || props === void 0 ? void 0 : props.placement, styles: props === null || props === void 0 ? void 0 : props.styles })
  );
};

// node_modules/@daohaus/form-builder-base/index.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
var check = function(it) {
  return it && it.Math == Math && it;
};
var global$b = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || commonjsGlobal || Function("return this")();
var objectGetOwnPropertyDescriptor = {};
var fails$a = function(exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};
var fails$9 = fails$a;
var descriptors = !fails$9(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$8 = fails$a;
var functionBindNative = !fails$8(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$1 = functionBindNative;
var call$5 = Function.prototype.call;
var functionCall = NATIVE_BIND$1 ? call$5.bind(call$5) : function() {
  return call$5.apply(call$5, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor$1(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;
var createPropertyDescriptor$2 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND = functionBindNative;
var FunctionPrototype$1 = Function.prototype;
var call$4 = FunctionPrototype$1.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype$1.bind.bind(call$4, call$4);
var functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
  return function() {
    return call$4.apply(fn, arguments);
  };
};
var uncurryThis$9 = functionUncurryThis;
var toString$1 = uncurryThis$9({}.toString);
var stringSlice$1 = uncurryThis$9("".slice);
var classofRaw = function(it) {
  return stringSlice$1(toString$1(it), 8, -1);
};
var uncurryThis$8 = functionUncurryThis;
var fails$7 = fails$a;
var classof$1 = classofRaw;
var $Object$2 = Object;
var split = uncurryThis$8("".split);
var indexedObject = fails$7(function() {
  return !$Object$2("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$1(it) == "String" ? split(it, "") : $Object$2(it);
} : $Object$2;
var isNullOrUndefined$2 = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$1 = isNullOrUndefined$2;
var $TypeError$6 = TypeError;
var requireObjectCoercible$2 = function(it) {
  if (isNullOrUndefined$1(it))
    throw $TypeError$6("Can't call method on " + it);
  return it;
};
var IndexedObject$2 = indexedObject;
var requireObjectCoercible$1 = requireObjectCoercible$2;
var toIndexedObject$3 = function(it) {
  return IndexedObject$2(requireObjectCoercible$1(it));
};
var documentAll$2 = typeof document == "object" && document.all;
var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
var documentAll_1 = {
  all: documentAll$2,
  IS_HTMLDDA
};
var $documentAll$1 = documentAll_1;
var documentAll$1 = $documentAll$1.all;
var isCallable$a = $documentAll$1.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$1;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$9 = isCallable$a;
var $documentAll = documentAll_1;
var documentAll = $documentAll.all;
var isObject$5 = $documentAll.IS_HTMLDDA ? function(it) {
  return typeof it == "object" ? it !== null : isCallable$9(it) || it === documentAll;
} : function(it) {
  return typeof it == "object" ? it !== null : isCallable$9(it);
};
var global$a = global$b;
var isCallable$8 = isCallable$a;
var aFunction = function(argument) {
  return isCallable$8(argument) ? argument : void 0;
};
var getBuiltIn$2 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$a[namespace]) : global$a[namespace] && global$a[namespace][method];
};
var uncurryThis$7 = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$7({}.isPrototypeOf);
var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
var global$9 = global$b;
var userAgent = engineUserAgent;
var process$1 = global$9.process;
var Deno = global$9.Deno;
var versions = process$1 && process$1.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match2;
var version;
if (v8) {
  match2 = v8.split(".");
  version = match2[0] > 0 && match2[0] < 4 ? 1 : +(match2[0] + match2[1]);
}
if (!version && userAgent) {
  match2 = userAgent.match(/Edge\/(\d+)/);
  if (!match2 || match2[1] >= 74) {
    match2 = userAgent.match(/Chrome\/(\d+)/);
    if (match2)
      version = +match2[1];
  }
}
var engineV8Version = version;
var V8_VERSION = engineV8Version;
var fails$6 = fails$a;
var global$8 = global$b;
var $String$3 = global$8.String;
var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$6(function() {
  var symbol = Symbol();
  return !$String$3(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});
var NATIVE_SYMBOL$1 = symbolConstructorDetection;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$1 = getBuiltIn$2;
var isCallable$7 = isCallable$a;
var isPrototypeOf = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$1 = Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn$1("Symbol");
  return isCallable$7($Symbol) && isPrototypeOf($Symbol.prototype, $Object$1(it));
};
var $String$2 = String;
var tryToString$1 = function(argument) {
  try {
    return $String$2(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$6 = isCallable$a;
var tryToString = tryToString$1;
var $TypeError$5 = TypeError;
var aCallable$2 = function(argument) {
  if (isCallable$6(argument))
    return argument;
  throw $TypeError$5(tryToString(argument) + " is not a function");
};
var aCallable$1 = aCallable$2;
var isNullOrUndefined2 = isNullOrUndefined$2;
var getMethod$1 = function(V, P) {
  var func = V[P];
  return isNullOrUndefined2(func) ? void 0 : aCallable$1(func);
};
var call$3 = functionCall;
var isCallable$5 = isCallable$a;
var isObject$4 = isObject$5;
var $TypeError$4 = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$5(fn = input.toString) && !isObject$4(val = call$3(fn, input)))
    return val;
  if (isCallable$5(fn = input.valueOf) && !isObject$4(val = call$3(fn, input)))
    return val;
  if (pref !== "string" && isCallable$5(fn = input.toString) && !isObject$4(val = call$3(fn, input)))
    return val;
  throw $TypeError$4("Can't convert object to primitive value");
};
var shared$3 = { exports: {} };
var global$7 = global$b;
var defineProperty$2 = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$2(global$7, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$7[key] = value;
  }
  return value;
};
var global$6 = global$b;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = global$6[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$3.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.32.0",
  mode: "global",
  copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var requireObjectCoercible = requireObjectCoercible$2;
var $Object = Object;
var toObject$3 = function(argument) {
  return $Object(requireObjectCoercible(argument));
};
var uncurryThis$6 = functionUncurryThis;
var toObject$2 = toObject$3;
var hasOwnProperty2 = uncurryThis$6({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty2(toObject$2(it), key);
};
var uncurryThis$5 = functionUncurryThis;
var id = 0;
var postfix = Math.random();
var toString = uncurryThis$5(1 .toString);
var uid$2 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
};
var global$5 = global$b;
var shared$2 = shared$3.exports;
var hasOwn$6 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = symbolConstructorDetection;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var Symbol$1 = global$5.Symbol;
var WellKnownSymbolsStore = shared$2("wks");
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1["for"] || Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
var wellKnownSymbol$1 = function(name) {
  if (!hasOwn$6(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$6(Symbol$1, name) ? Symbol$1[name] : createWellKnownSymbol("Symbol." + name);
  }
  return WellKnownSymbolsStore[name];
};
var call$2 = functionCall;
var isObject$3 = isObject$5;
var isSymbol$1 = isSymbol$2;
var getMethod = getMethod$1;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol = wellKnownSymbol$1;
var $TypeError$3 = TypeError;
var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$3(input) || isSymbol$1(input))
    return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$2(exoticToPrim, input, pref);
    if (!isObject$3(result) || isSymbol$1(result))
      return result;
    throw $TypeError$3("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$2 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$4 = global$b;
var isObject$2 = isObject$5;
var document$1 = global$4.document;
var EXISTS$1 = isObject$2(document$1) && isObject$2(document$1.createElement);
var documentCreateElement = function(it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};
var DESCRIPTORS$7 = descriptors;
var fails$5 = fails$a;
var createElement6 = documentCreateElement;
var ie8DomDefine = !DESCRIPTORS$7 && !fails$5(function() {
  return Object.defineProperty(createElement6("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$6 = descriptors;
var call$1 = functionCall;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$1 = createPropertyDescriptor$2;
var toIndexedObject$2 = toIndexedObject$3;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$5 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject$2(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error) {
    }
  if (hasOwn$5(O, P))
    return createPropertyDescriptor$1(!call$1(propertyIsEnumerableModule$1.f, O, P), O[P]);
};
var objectDefineProperty = {};
var DESCRIPTORS$5 = descriptors;
var fails$4 = fails$a;
var v8PrototypeDefineBug = DESCRIPTORS$5 && fails$4(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var isObject$12 = isObject$5;
var $String$1 = String;
var $TypeError$2 = TypeError;
var anObject$2 = function(argument) {
  if (isObject$12(argument))
    return argument;
  throw $TypeError$2($String$1(argument) + " is not an object");
};
var DESCRIPTORS$4 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var anObject$1 = anObject$2;
var toPropertyKey = toPropertyKey$2;
var $TypeError$1 = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject$1(O);
  P = toPropertyKey(P);
  anObject$1(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty2(O, P, Attributes) {
  anObject$1(O);
  P = toPropertyKey(P);
  anObject$1(Attributes);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty(O, P, Attributes);
    } catch (error) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError$1("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$3 = descriptors;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$2;
var createNonEnumerableProperty$2 = DESCRIPTORS$3 ? function(object, key, value) {
  return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltIn$2 = { exports: {} };
var DESCRIPTORS$2 = descriptors;
var hasOwn$4 = hasOwnProperty_1;
var FunctionPrototype = Function.prototype;
var getDescriptor = DESCRIPTORS$2 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$4(FunctionPrototype, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$2 || DESCRIPTORS$2 && getDescriptor(FunctionPrototype, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$4 = functionUncurryThis;
var isCallable$4 = isCallable$a;
var store$1 = sharedStore;
var functionToString = uncurryThis$4(Function.toString);
if (!isCallable$4(store$1.inspectSource)) {
  store$1.inspectSource = function(it) {
    return functionToString(it);
  };
}
var inspectSource$1 = store$1.inspectSource;
var global$3 = global$b;
var isCallable$3 = isCallable$a;
var WeakMap$1 = global$3.WeakMap;
var weakMapBasicDetection = isCallable$3(WeakMap$1) && /native code/.test(String(WeakMap$1));
var shared$1 = shared$3.exports;
var uid = uid$2;
var keys = shared$1("keys");
var sharedKey$1 = function(key) {
  return keys[key] || (keys[key] = uid(key));
};
var hiddenKeys$3 = {};
var NATIVE_WEAK_MAP = weakMapBasicDetection;
var global$2 = global$b;
var isObject2 = isObject$5;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$2;
var hasOwn$3 = hasOwnProperty_1;
var shared = sharedStore;
var sharedKey = sharedKey$1;
var hiddenKeys$2 = hiddenKeys$3;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$1 = global$2.TypeError;
var WeakMap2 = global$2.WeakMap;
var set2;
var get2;
var has2;
var enforce = function(it) {
  return has2(it) ? get2(it) : set2(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject2(it) || (state = get2(it)).type !== TYPE) {
      throw TypeError$1("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared.state) {
  store = shared.state || (shared.state = new WeakMap2());
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  set2 = function(it, metadata) {
    if (store.has(it))
      throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get2 = function(it) {
    return store.get(it) || {};
  };
  has2 = function(it) {
    return store.has(it);
  };
} else {
  STATE = sharedKey("state");
  hiddenKeys$2[STATE] = true;
  set2 = function(it, metadata) {
    if (hasOwn$3(it, STATE))
      throw TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$1(it, STATE, metadata);
    return metadata;
  };
  get2 = function(it) {
    return hasOwn$3(it, STATE) ? it[STATE] : {};
  };
  has2 = function(it) {
    return hasOwn$3(it, STATE);
  };
}
var store;
var STATE;
var internalState = {
  set: set2,
  get: get2,
  has: has2,
  enforce,
  getterFor
};
var uncurryThis$3 = functionUncurryThis;
var fails$3 = fails$a;
var isCallable$2 = isCallable$a;
var hasOwn$2 = hasOwnProperty_1;
var DESCRIPTORS$1 = descriptors;
var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
var inspectSource = inspectSource$1;
var InternalStateModule = internalState;
var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
var defineProperty$1 = Object.defineProperty;
var stringSlice = uncurryThis$3("".slice);
var replace2 = uncurryThis$3("".replace);
var join = uncurryThis$3([].join);
var CONFIGURABLE_LENGTH = DESCRIPTORS$1 && !fails$3(function() {
  return defineProperty$1(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {
  if (stringSlice($String(name), 0, 7) === "Symbol(") {
    name = "[" + replace2($String(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter)
    name = "get " + name;
  if (options && options.setter)
    name = "set " + name;
  if (!hasOwn$2(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
    if (DESCRIPTORS$1)
      defineProperty$1(value, "name", { value: name, configurable: true });
    else
      value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$2(options, "arity") && value.length !== options.arity) {
    defineProperty$1(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$2(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$1)
        defineProperty$1(value, "prototype", { writable: false });
    } else if (value.prototype)
      value.prototype = void 0;
  } catch (error) {
  }
  var state = enforceInternalState(value);
  if (!hasOwn$2(state, "source")) {
    state.source = join(TEMPLATE, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$1(function toString2() {
  return isCallable$2(this) && getInternalState(this).source || inspectSource(this);
}, "toString");
var isCallable$1 = isCallable$a;
var definePropertyModule$1 = objectDefineProperty;
var makeBuiltIn = makeBuiltIn$2.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$1 = function(O, key, value, options) {
  if (!options)
    options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$1(value))
    makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple)
      O[key] = value;
    else
      defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe)
        delete O[key];
      else if (O[key])
        simple = true;
    } catch (error) {
    }
    if (simple)
      O[key] = value;
    else
      definePropertyModule$1.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
  }
  return O;
};
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor = Math.floor;
var mathTrunc = Math.trunc || function trunc(x) {
  var n2 = +x;
  return (n2 > 0 ? floor : ceil)(n2);
};
var trunc2 = mathTrunc;
var toIntegerOrInfinity$2 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc2(number);
};
var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
var max = Math.max;
var min$1 = Math.min;
var toAbsoluteIndex$1 = function(index, length2) {
  var integer = toIntegerOrInfinity$1(index);
  return integer < 0 ? max(integer + length2, 0) : min$1(integer, length2);
};
var toIntegerOrInfinity = toIntegerOrInfinity$2;
var min = Math.min;
var toLength$1 = function(argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
};
var toLength = toLength$1;
var lengthOfArrayLike$2 = function(obj) {
  return toLength(obj.length);
};
var toIndexedObject$1 = toIndexedObject$3;
var toAbsoluteIndex = toAbsoluteIndex$1;
var lengthOfArrayLike$1 = lengthOfArrayLike$2;
var createMethod$1 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$1($this);
    var length2 = lengthOfArrayLike$1(O);
    var index = toAbsoluteIndex(fromIndex, length2);
    var value;
    if (IS_INCLUDES && el != el)
      while (length2 > index) {
        value = O[index++];
        if (value != value)
          return true;
      }
    else
      for (; length2 > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$1(true),
  indexOf: createMethod$1(false)
};
var uncurryThis$2 = functionUncurryThis;
var hasOwn$1 = hasOwnProperty_1;
var toIndexedObject = toIndexedObject$3;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$1 = hiddenKeys$3;
var push = uncurryThis$2([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$1(hiddenKeys$1, key) && hasOwn$1(O, key) && push(result, key);
  while (names.length > i)
    if (hasOwn$1(O, key = names[i++])) {
      ~indexOf(result, key) || push(result, key);
    }
  return result;
};
var enumBugKeys$2 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$2;
var hiddenKeys = enumBugKeys$1.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn = getBuiltIn$2;
var uncurryThis$1 = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject = anObject$2;
var concat$1 = uncurryThis$1([].concat);
var ownKeys$1 = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
  var keys5 = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
  return getOwnPropertySymbols ? concat$1(keys5, getOwnPropertySymbols(it)) : keys5;
};
var hasOwn2 = hasOwnProperty_1;
var ownKeys2 = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys5 = ownKeys2(source);
  var defineProperty7 = definePropertyModule.f;
  var getOwnPropertyDescriptor5 = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys5.length; i++) {
    var key = keys5[i];
    if (!hasOwn2(target, key) && !(exceptions && hasOwn2(exceptions, key))) {
      defineProperty7(target, key, getOwnPropertyDescriptor5(source, key));
    }
  }
};
var fails$2 = fails$a;
var isCallable = isCallable$a;
var replacement = /#|\.prototype\./;
var isForced$1 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails$2(detection) : !!detection;
};
var normalize = isForced$1.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = "N";
var POLYFILL = isForced$1.POLYFILL = "P";
var isForced_1 = isForced$1;
var global$1 = global$b;
var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty = createNonEnumerableProperty$2;
var defineBuiltIn = defineBuiltIn$1;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$1;
  } else if (STATIC) {
    target = global$1[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$1[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor2(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty(sourceProperty, "sham", true);
      }
      defineBuiltIn(target, key, sourceProperty, options);
    }
};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$2;
var objectKeys$1 = Object.keys || function keys2(O) {
  return internalObjectKeys(O, enumBugKeys);
};
var DESCRIPTORS = descriptors;
var uncurryThis = functionUncurryThis;
var call = functionCall;
var fails$1 = fails$a;
var objectKeys = objectKeys$1;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$1 = toObject$3;
var IndexedObject$1 = indexedObject;
var $assign = Object.assign;
var defineProperty3 = Object.defineProperty;
var concat = uncurryThis([].concat);
var objectAssign = !$assign || fails$1(function() {
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty3({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty3(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A = {};
  var B = {};
  var symbol = Symbol();
  var alphabet = "abcdefghijklmnopqrst";
  A[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join("") != alphabet;
}) ? function assign2(target, source) {
  var T = toObject$1(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable3 = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject$1(arguments[index++]);
    var keys5 = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length2 = keys5.length;
    var j = 0;
    var key;
    while (length2 > j) {
      key = keys5[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable3, S, key))
        T[key] = S[key];
    }
  }
  return T;
} : $assign;
var $$1 = _export;
var assign3 = objectAssign;
$$1({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign3 }, {
  assign: assign3
});
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var useFormBuilder = () => {
  const methods = useFormContext();
  const builderFeatures = (0, import_react6.useContext)(FormBaseContext);
  return Object.assign(Object.assign({}, methods), builderFeatures);
};
var aCallable = aCallable$2;
var toObject = toObject$3;
var IndexedObject = indexedObject;
var lengthOfArrayLike = lengthOfArrayLike$2;
var $TypeError = TypeError;
var createMethod = function(IS_RIGHT) {
  return function(that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O = toObject(that);
    var self2 = IndexedObject(O);
    var length2 = lengthOfArrayLike(O);
    var index = IS_RIGHT ? length2 - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2)
      while (true) {
        if (index in self2) {
          memo = self2[index];
          index += i;
          break;
        }
        index += i;
        if (IS_RIGHT ? index < 0 : length2 <= index) {
          throw $TypeError("Reduce of empty array with no initial value");
        }
      }
    for (; IS_RIGHT ? index >= 0 : length2 > index; index += i)
      if (index in self2) {
        memo = callbackfn(memo, self2[index], index, O);
      }
    return memo;
  };
};
var arrayReduce = {
  left: createMethod(false),
  right: createMethod(true)
};
var fails = fails$a;
var arrayMethodIsStrict$1 = function(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function() {
    method.call(null, argument || function() {
      return 1;
    }, 1);
  });
};
var classof = classofRaw;
var engineIsNode = typeof process != "undefined" && classof(process) == "process";
var $ = _export;
var $reduce = arrayReduce.left;
var arrayMethodIsStrict = arrayMethodIsStrict$1;
var CHROME_VERSION = engineV8Version;
var IS_NODE = engineIsNode;
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED = CHROME_BUG || !arrayMethodIsStrict("reduce");
$({ target: "Array", proto: true, forced: FORCED }, {
  reduce: function reduce(callbackfn) {
    var length2 = arguments.length;
    return $reduce(this, callbackfn, length2, length2 > 1 ? arguments[1] : void 0);
  }
});
var pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);
var createUpdaterFn = (option) => (newOptions) => (oldOptions) => newOptions[option] ? Object.assign(Object.assign({}, oldOptions), {
  [option]: newOptions[option]
}) : oldOptions;
var updateRequired = createUpdaterFn("required");
var updateValidate = createUpdaterFn("validate");
var isRequiredField = (field, requiredFields) => requiredFields[field.id];
var generateRequiredRule = (field) => {
  const {
    label
  } = field;
  if (typeof label === "string") {
    return {
      required: `${label} is required`
    };
  }
  return {
    required: `Field is required`
  };
};
var handleRequiredField = (field, requiredFields) => isRequiredField(field, requiredFields) ? generateRequiredRule(field) : {};
var allowEmpty = (value, validateFn) => {
  if (!value) {
    return true;
  }
  return validateFn(value);
};
var hasTypeValidation = (field) => field.expectType !== void 0;
var handleTypeValidation = (field) => hasTypeValidation(field) ? {
  validate: (val) => allowEmpty(val, import_utils5.ValidateField[field.expectType])
} : {};
var generateRules = ({
  field,
  requiredFields: _requiredFields = {}
}) => {
  const oldRules = field.rules || {};
  return pipe(updateRequired(handleRequiredField(field, _requiredFields)), updateValidate(handleTypeValidation(field)))(oldRules);
};
var _ = (t2) => t2;
var _t;
var FormBuilderFactory = ({
  field
}) => {
  const {
    type
  } = field;
  const {
    formState: {
      errors
    }
  } = useFormContext();
  const formState = errors;
  const {
    formDisabled,
    requiredFields,
    fieldObj,
    fieldSpacing,
    applyToEach,
    submitDisabled
  } = useFormBuilder();
  const GeneratedField = (0, import_react6.useMemo)(
    () => {
      const Field = fieldObj[type];
      const newRules = generateRules({
        field,
        requiredFields: requiredFields || {}
      });
      return (0, import_jsx_runtime.jsx)(Field, Object.assign({}, field, {
        rules: newRules,
        disabled: formDisabled || field.disabled
      }, applyToEach));
    },
    [type, formDisabled, field, requiredFields, fieldObj, formState, submitDisabled]
  );
  return (0, import_jsx_runtime.jsx)(Spacer, Object.assign({
    "$fieldSpacing": fieldSpacing
  }, {
    children: GeneratedField
  }));
};
var Spacer = st.div(_t || (_t = _`
  margin-bottom: ${0};
`), ({
  $fieldSpacing
}) => $fieldSpacing || "0");
var Logger = () => {
  const {
    watch
  } = useFormContext();
  const formValues = watch();
  (0, import_react6.useEffect)(() => {
    if (formValues) {
      console.log("formValues", formValues);
    }
  }, [formValues]);
  return null;
};
var FAKE_FORM = {
  id: "FAKE_FORM",
  title: "Form Title",
  description: "Form Description",
  subtitle: "Form Subtitle",
  fields: []
};
var FormBaseContext = import_react6.default.createContext({
  form: FAKE_FORM,
  requiredFields: {},
  formDisabled: false,
  submitDisabled: false,
  isLoading: false,
  fieldObj: {}
});
var FormBuilderBase = ({
  form,
  formDisabled: _formDisabled = false,
  fieldObj,
  defaultValues,
  formValidationMode: _formValidationMode = "onChange",
  submitDisabled: _submitDisabled = false,
  onSubmit,
  footer,
  fieldSpacing: _fieldSpacing = "0",
  isLoading: _isLoading = false,
  applyToEach: _applyToEach = {}
}) => {
  const methods = useForm({
    mode: _formValidationMode,
    defaultValues
  });
  const {
    formState: {
      isValid
    },
    control
  } = methods;
  const {
    fields,
    log,
    devtool,
    requiredFields = {}
  } = form;
  const handleTopLevelSubmit = (formValues) => __awaiter(void 0, void 0, void 0, function* () {
    yield onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(formValues);
  });
  const isSubmitDisabled = !isValid || _submitDisabled;
  return (0, import_jsx_runtime.jsxs)(FormProvider, Object.assign({}, methods, {
    children: [log && (0, import_jsx_runtime.jsx)(Logger, {}), devtool && (0, import_jsx_runtime.jsx)(DevTool, {
      control
    }), (0, import_jsx_runtime.jsx)(FormBaseContext.Provider, Object.assign({
      value: {
        form,
        requiredFields,
        formDisabled: _formDisabled,
        submitDisabled: isSubmitDisabled,
        fieldObj,
        isLoading: _isLoading,
        fieldSpacing: _fieldSpacing,
        applyToEach: _applyToEach
      }
    }, {
      children: (0, import_jsx_runtime.jsxs)("form", Object.assign({
        onSubmit: methods.handleSubmit(handleTopLevelSubmit),
        className: "builder-inner-form",
        noValidate: true
      }, {
        children: [fields === null || fields === void 0 ? void 0 : fields.map((field) => (0, import_jsx_runtime.jsx)(FormBuilderFactory, {
          field
        }, field.id)), footer]
      }))
    }))]
  }));
};

// node_modules/@daohaus/form-builder/index.js
var import_utils6 = __toESM(require_src());
var import_ri = __toESM(require_ri());
var import_react7 = __toESM(require_react());
init_tx_builder();
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : {};
var check2 = function(it) {
  return it && it.Math == Math && it;
};
var global$d = check2(typeof globalThis == "object" && globalThis) || check2(typeof window == "object" && window) || check2(typeof self == "object" && self) || check2(typeof commonjsGlobal2 == "object" && commonjsGlobal2) || function() {
  return this;
}() || commonjsGlobal2 || Function("return this")();
var objectGetOwnPropertyDescriptor2 = {};
var fails$b = function(exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};
var fails$a2 = fails$b;
var descriptors2 = !fails$a2(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$92 = fails$b;
var functionBindNative2 = !fails$92(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$12 = functionBindNative2;
var call$6 = Function.prototype.call;
var functionCall2 = NATIVE_BIND$12 ? call$6.bind(call$6) : function() {
  return call$6.apply(call$6, arguments);
};
var objectPropertyIsEnumerable2 = {};
var $propertyIsEnumerable2 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$12 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG2 = getOwnPropertyDescriptor$12 && !$propertyIsEnumerable2.call({ 1: 2 }, 1);
objectPropertyIsEnumerable2.f = NASHORN_BUG2 ? function propertyIsEnumerable2(V) {
  var descriptor = getOwnPropertyDescriptor$12(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable2;
var createPropertyDescriptor$3 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND2 = functionBindNative2;
var FunctionPrototype$12 = Function.prototype;
var call$52 = FunctionPrototype$12.call;
var uncurryThisWithBind2 = NATIVE_BIND2 && FunctionPrototype$12.bind.bind(call$52, call$52);
var functionUncurryThis2 = NATIVE_BIND2 ? uncurryThisWithBind2 : function(fn) {
  return function() {
    return call$52.apply(fn, arguments);
  };
};
var uncurryThis$b = functionUncurryThis2;
var toString$3 = uncurryThis$b({}.toString);
var stringSlice$2 = uncurryThis$b("".slice);
var classofRaw$1 = function(it) {
  return stringSlice$2(toString$3(it), 8, -1);
};
var uncurryThis$a = functionUncurryThis2;
var fails$82 = fails$b;
var classof$2 = classofRaw$1;
var $Object$4 = Object;
var split2 = uncurryThis$a("".split);
var indexedObject2 = fails$82(function() {
  return !$Object$4("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$2(it) == "String" ? split2(it, "") : $Object$4(it);
} : $Object$4;
var isNullOrUndefined$22 = function(it) {
  return it === null || it === void 0;
};
var isNullOrUndefined$12 = isNullOrUndefined$22;
var $TypeError$62 = TypeError;
var requireObjectCoercible$22 = function(it) {
  if (isNullOrUndefined$12(it))
    throw $TypeError$62("Can't call method on " + it);
  return it;
};
var IndexedObject$12 = indexedObject2;
var requireObjectCoercible$12 = requireObjectCoercible$22;
var toIndexedObject$5 = function(it) {
  return IndexedObject$12(requireObjectCoercible$12(it));
};
var documentAll$22 = typeof document == "object" && document.all;
var IS_HTMLDDA2 = typeof documentAll$22 == "undefined" && documentAll$22 !== void 0;
var documentAll_12 = {
  all: documentAll$22,
  IS_HTMLDDA: IS_HTMLDDA2
};
var $documentAll$12 = documentAll_12;
var documentAll$12 = $documentAll$12.all;
var isCallable$g = $documentAll$12.IS_HTMLDDA ? function(argument) {
  return typeof argument == "function" || argument === documentAll$12;
} : function(argument) {
  return typeof argument == "function";
};
var isCallable$f = isCallable$g;
var $documentAll2 = documentAll_12;
var documentAll2 = $documentAll2.all;
var isObject$6 = $documentAll2.IS_HTMLDDA ? function(it) {
  return typeof it == "object" ? it !== null : isCallable$f(it) || it === documentAll2;
} : function(it) {
  return typeof it == "object" ? it !== null : isCallable$f(it);
};
var global$c = global$d;
var isCallable$e = isCallable$g;
var aFunction2 = function(argument) {
  return isCallable$e(argument) ? argument : void 0;
};
var getBuiltIn$3 = function(namespace, method) {
  return arguments.length < 2 ? aFunction2(global$c[namespace]) : global$c[namespace] && global$c[namespace][method];
};
var uncurryThis$92 = functionUncurryThis2;
var objectIsPrototypeOf2 = uncurryThis$92({}.isPrototypeOf);
var engineUserAgent2 = typeof navigator != "undefined" && String(navigator.userAgent) || "";
var global$b2 = global$d;
var userAgent2 = engineUserAgent2;
var process2 = global$b2.process;
var Deno2 = global$b2.Deno;
var versions2 = process2 && process2.versions || Deno2 && Deno2.version;
var v82 = versions2 && versions2.v8;
var match3;
var version2;
if (v82) {
  match3 = v82.split(".");
  version2 = match3[0] > 0 && match3[0] < 4 ? 1 : +(match3[0] + match3[1]);
}
if (!version2 && userAgent2) {
  match3 = userAgent2.match(/Edge\/(\d+)/);
  if (!match3 || match3[1] >= 74) {
    match3 = userAgent2.match(/Chrome\/(\d+)/);
    if (match3)
      version2 = +match3[1];
  }
}
var engineV8Version2 = version2;
var V8_VERSION2 = engineV8Version2;
var fails$72 = fails$b;
var global$a2 = global$d;
var $String$5 = global$a2.String;
var symbolConstructorDetection2 = !!Object.getOwnPropertySymbols && !fails$72(function() {
  var symbol = Symbol();
  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION2 && V8_VERSION2 < 41;
});
var NATIVE_SYMBOL$2 = symbolConstructorDetection2;
var useSymbolAsUid2 = NATIVE_SYMBOL$2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$22 = getBuiltIn$3;
var isCallable$d = isCallable$g;
var isPrototypeOf$1 = objectIsPrototypeOf2;
var USE_SYMBOL_AS_UID$12 = useSymbolAsUid2;
var $Object$3 = Object;
var isSymbol$22 = USE_SYMBOL_AS_UID$12 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn$22("Symbol");
  return isCallable$d($Symbol) && isPrototypeOf$1($Symbol.prototype, $Object$3(it));
};
var $String$4 = String;
var tryToString$12 = function(argument) {
  try {
    return $String$4(argument);
  } catch (error) {
    return "Object";
  }
};
var isCallable$c = isCallable$g;
var tryToString2 = tryToString$12;
var $TypeError$52 = TypeError;
var aCallable$22 = function(argument) {
  if (isCallable$c(argument))
    return argument;
  throw $TypeError$52(tryToString2(argument) + " is not a function");
};
var aCallable$12 = aCallable$22;
var isNullOrUndefined3 = isNullOrUndefined$22;
var getMethod$12 = function(V, P) {
  var func = V[P];
  return isNullOrUndefined3(func) ? void 0 : aCallable$12(func);
};
var call$42 = functionCall2;
var isCallable$b = isCallable$g;
var isObject$52 = isObject$6;
var $TypeError$42 = TypeError;
var ordinaryToPrimitive$12 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$b(fn = input.toString) && !isObject$52(val = call$42(fn, input)))
    return val;
  if (isCallable$b(fn = input.valueOf) && !isObject$52(val = call$42(fn, input)))
    return val;
  if (pref !== "string" && isCallable$b(fn = input.toString) && !isObject$52(val = call$42(fn, input)))
    return val;
  throw $TypeError$42("Can't convert object to primitive value");
};
var shared$32 = { exports: {} };
var global$92 = global$d;
var defineProperty$6 = Object.defineProperty;
var defineGlobalProperty$32 = function(key, value) {
  try {
    defineProperty$6(global$92, key, { value, configurable: true, writable: true });
  } catch (error) {
    global$92[key] = value;
  }
  return value;
};
var global$82 = global$d;
var defineGlobalProperty$22 = defineGlobalProperty$32;
var SHARED2 = "__core-js_shared__";
var store$32 = global$82[SHARED2] || defineGlobalProperty$22(SHARED2, {});
var sharedStore2 = store$32;
var store$22 = sharedStore2;
(shared$32.exports = function(key, value) {
  return store$22[key] || (store$22[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.32.0",
  mode: "global",
  copyright: "\xA9 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var requireObjectCoercible2 = requireObjectCoercible$22;
var $Object$22 = Object;
var toObject$32 = function(argument) {
  return $Object$22(requireObjectCoercible2(argument));
};
var uncurryThis$82 = functionUncurryThis2;
var toObject$22 = toObject$32;
var hasOwnProperty3 = uncurryThis$82({}.hasOwnProperty);
var hasOwnProperty_12 = Object.hasOwn || function hasOwn3(it, key) {
  return hasOwnProperty3(toObject$22(it), key);
};
var uncurryThis$72 = functionUncurryThis2;
var id2 = 0;
var postfix2 = Math.random();
var toString$2 = uncurryThis$72(1 .toString);
var uid$22 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$2(++id2 + postfix2, 36);
};
var global$72 = global$d;
var shared$22 = shared$32.exports;
var hasOwn$9 = hasOwnProperty_12;
var uid$12 = uid$22;
var NATIVE_SYMBOL$12 = symbolConstructorDetection2;
var USE_SYMBOL_AS_UID2 = useSymbolAsUid2;
var Symbol$12 = global$72.Symbol;
var WellKnownSymbolsStore2 = shared$22("wks");
var createWellKnownSymbol2 = USE_SYMBOL_AS_UID2 ? Symbol$12["for"] || Symbol$12 : Symbol$12 && Symbol$12.withoutSetter || uid$12;
var wellKnownSymbol$8 = function(name) {
  if (!hasOwn$9(WellKnownSymbolsStore2, name)) {
    WellKnownSymbolsStore2[name] = NATIVE_SYMBOL$12 && hasOwn$9(Symbol$12, name) ? Symbol$12[name] : createWellKnownSymbol2("Symbol." + name);
  }
  return WellKnownSymbolsStore2[name];
};
var call$32 = functionCall2;
var isObject$42 = isObject$6;
var isSymbol$12 = isSymbol$22;
var getMethod2 = getMethod$12;
var ordinaryToPrimitive2 = ordinaryToPrimitive$12;
var wellKnownSymbol$7 = wellKnownSymbol$8;
var $TypeError$32 = TypeError;
var TO_PRIMITIVE2 = wellKnownSymbol$7("toPrimitive");
var toPrimitive$12 = function(input, pref) {
  if (!isObject$42(input) || isSymbol$12(input))
    return input;
  var exoticToPrim = getMethod2(input, TO_PRIMITIVE2);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$32(exoticToPrim, input, pref);
    if (!isObject$42(result) || isSymbol$12(result))
      return result;
    throw $TypeError$32("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive2(input, pref);
};
var toPrimitive2 = toPrimitive$12;
var isSymbol2 = isSymbol$22;
var toPropertyKey$22 = function(argument) {
  var key = toPrimitive2(argument, "string");
  return isSymbol2(key) ? key : key + "";
};
var global$62 = global$d;
var isObject$32 = isObject$6;
var document$12 = global$62.document;
var EXISTS$12 = isObject$32(document$12) && isObject$32(document$12.createElement);
var documentCreateElement$2 = function(it) {
  return EXISTS$12 ? document$12.createElement(it) : {};
};
var DESCRIPTORS$a = descriptors2;
var fails$62 = fails$b;
var createElement7 = documentCreateElement$2;
var ie8DomDefine2 = !DESCRIPTORS$a && !fails$62(function() {
  return Object.defineProperty(createElement7("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$9 = descriptors2;
var call$22 = functionCall2;
var propertyIsEnumerableModule$12 = objectPropertyIsEnumerable2;
var createPropertyDescriptor$22 = createPropertyDescriptor$3;
var toIndexedObject$4 = toIndexedObject$5;
var toPropertyKey$12 = toPropertyKey$22;
var hasOwn$8 = hasOwnProperty_12;
var IE8_DOM_DEFINE$12 = ie8DomDefine2;
var $getOwnPropertyDescriptor$12 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor2.f = DESCRIPTORS$9 ? $getOwnPropertyDescriptor$12 : function getOwnPropertyDescriptor3(O, P) {
  O = toIndexedObject$4(O);
  P = toPropertyKey$12(P);
  if (IE8_DOM_DEFINE$12)
    try {
      return $getOwnPropertyDescriptor$12(O, P);
    } catch (error) {
    }
  if (hasOwn$8(O, P))
    return createPropertyDescriptor$22(!call$22(propertyIsEnumerableModule$12.f, O, P), O[P]);
};
var objectDefineProperty2 = {};
var DESCRIPTORS$8 = descriptors2;
var fails$52 = fails$b;
var v8PrototypeDefineBug2 = DESCRIPTORS$8 && fails$52(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var isObject$22 = isObject$6;
var $String$32 = String;
var $TypeError$22 = TypeError;
var anObject$5 = function(argument) {
  if (isObject$22(argument))
    return argument;
  throw $TypeError$22($String$32(argument) + " is not an object");
};
var DESCRIPTORS$72 = descriptors2;
var IE8_DOM_DEFINE2 = ie8DomDefine2;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug2;
var anObject$4 = anObject$5;
var toPropertyKey2 = toPropertyKey$22;
var $TypeError$12 = TypeError;
var $defineProperty2 = Object.defineProperty;
var $getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
var ENUMERABLE2 = "enumerable";
var CONFIGURABLE$12 = "configurable";
var WRITABLE2 = "writable";
objectDefineProperty2.f = DESCRIPTORS$72 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty4(O, P, Attributes) {
  anObject$4(O);
  P = toPropertyKey2(P);
  anObject$4(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE2 in Attributes && !Attributes[WRITABLE2]) {
    var current = $getOwnPropertyDescriptor2(O, P);
    if (current && current[WRITABLE2]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$12 in Attributes ? Attributes[CONFIGURABLE$12] : current[CONFIGURABLE$12],
        enumerable: ENUMERABLE2 in Attributes ? Attributes[ENUMERABLE2] : current[ENUMERABLE2],
        writable: false
      };
    }
  }
  return $defineProperty2(O, P, Attributes);
} : $defineProperty2 : function defineProperty5(O, P, Attributes) {
  anObject$4(O);
  P = toPropertyKey2(P);
  anObject$4(Attributes);
  if (IE8_DOM_DEFINE2)
    try {
      return $defineProperty2(O, P, Attributes);
    } catch (error) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError$12("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$62 = descriptors2;
var definePropertyModule$3 = objectDefineProperty2;
var createPropertyDescriptor$12 = createPropertyDescriptor$3;
var createNonEnumerableProperty$4 = DESCRIPTORS$62 ? function(object, key, value) {
  return definePropertyModule$3.f(object, key, createPropertyDescriptor$12(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltIn$3 = { exports: {} };
var DESCRIPTORS$52 = descriptors2;
var hasOwn$7 = hasOwnProperty_12;
var FunctionPrototype2 = Function.prototype;
var getDescriptor2 = DESCRIPTORS$52 && Object.getOwnPropertyDescriptor;
var EXISTS2 = hasOwn$7(FunctionPrototype2, "name");
var PROPER2 = EXISTS2 && function something2() {
}.name === "something";
var CONFIGURABLE2 = EXISTS2 && (!DESCRIPTORS$52 || DESCRIPTORS$52 && getDescriptor2(FunctionPrototype2, "name").configurable);
var functionName2 = {
  EXISTS: EXISTS2,
  PROPER: PROPER2,
  CONFIGURABLE: CONFIGURABLE2
};
var uncurryThis$62 = functionUncurryThis2;
var isCallable$a2 = isCallable$g;
var store$12 = sharedStore2;
var functionToString2 = uncurryThis$62(Function.toString);
if (!isCallable$a2(store$12.inspectSource)) {
  store$12.inspectSource = function(it) {
    return functionToString2(it);
  };
}
var inspectSource$12 = store$12.inspectSource;
var global$52 = global$d;
var isCallable$92 = isCallable$g;
var WeakMap$12 = global$52.WeakMap;
var weakMapBasicDetection2 = isCallable$92(WeakMap$12) && /native code/.test(String(WeakMap$12));
var shared$12 = shared$32.exports;
var uid2 = uid$22;
var keys3 = shared$12("keys");
var sharedKey$3 = function(key) {
  return keys3[key] || (keys3[key] = uid2(key));
};
var hiddenKeys$4 = {};
var NATIVE_WEAK_MAP2 = weakMapBasicDetection2;
var global$42 = global$d;
var isObject$13 = isObject$6;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$4;
var hasOwn$62 = hasOwnProperty_12;
var shared2 = sharedStore2;
var sharedKey$2 = sharedKey$3;
var hiddenKeys$32 = hiddenKeys$4;
var OBJECT_ALREADY_INITIALIZED2 = "Object already initialized";
var TypeError$12 = global$42.TypeError;
var WeakMap3 = global$42.WeakMap;
var set3;
var get3;
var has3;
var enforce2 = function(it) {
  return has3(it) ? get3(it) : set3(it, {});
};
var getterFor2 = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$13(it) || (state = get3(it)).type !== TYPE) {
      throw TypeError$12("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP2 || shared2.state) {
  store = shared2.state || (shared2.state = new WeakMap3());
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  set3 = function(it, metadata) {
    if (store.has(it))
      throw TypeError$12(OBJECT_ALREADY_INITIALIZED2);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get3 = function(it) {
    return store.get(it) || {};
  };
  has3 = function(it) {
    return store.has(it);
  };
} else {
  STATE = sharedKey$2("state");
  hiddenKeys$32[STATE] = true;
  set3 = function(it, metadata) {
    if (hasOwn$62(it, STATE))
      throw TypeError$12(OBJECT_ALREADY_INITIALIZED2);
    metadata.facade = it;
    createNonEnumerableProperty$3(it, STATE, metadata);
    return metadata;
  };
  get3 = function(it) {
    return hasOwn$62(it, STATE) ? it[STATE] : {};
  };
  has3 = function(it) {
    return hasOwn$62(it, STATE);
  };
}
var store;
var STATE;
var internalState2 = {
  set: set3,
  get: get3,
  has: has3,
  enforce: enforce2,
  getterFor: getterFor2
};
var uncurryThis$52 = functionUncurryThis2;
var fails$42 = fails$b;
var isCallable$82 = isCallable$g;
var hasOwn$52 = hasOwnProperty_12;
var DESCRIPTORS$42 = descriptors2;
var CONFIGURABLE_FUNCTION_NAME$1 = functionName2.CONFIGURABLE;
var inspectSource2 = inspectSource$12;
var InternalStateModule$1 = internalState2;
var enforceInternalState2 = InternalStateModule$1.enforce;
var getInternalState$1 = InternalStateModule$1.get;
var $String$22 = String;
var defineProperty$5 = Object.defineProperty;
var stringSlice$12 = uncurryThis$52("".slice);
var replace$1 = uncurryThis$52("".replace);
var join2 = uncurryThis$52([].join);
var CONFIGURABLE_LENGTH2 = DESCRIPTORS$42 && !fails$42(function() {
  return defineProperty$5(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE2 = String(String).split("String");
var makeBuiltIn$22 = makeBuiltIn$3.exports = function(value, name, options) {
  if (stringSlice$12($String$22(name), 0, 7) === "Symbol(") {
    name = "[" + replace$1($String$22(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter)
    name = "get " + name;
  if (options && options.setter)
    name = "set " + name;
  if (!hasOwn$52(value, "name") || CONFIGURABLE_FUNCTION_NAME$1 && value.name !== name) {
    if (DESCRIPTORS$42)
      defineProperty$5(value, "name", { value: name, configurable: true });
    else
      value.name = name;
  }
  if (CONFIGURABLE_LENGTH2 && options && hasOwn$52(options, "arity") && value.length !== options.arity) {
    defineProperty$5(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$52(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$42)
        defineProperty$5(value, "prototype", { writable: false });
    } else if (value.prototype)
      value.prototype = void 0;
  } catch (error) {
  }
  var state = enforceInternalState2(value);
  if (!hasOwn$52(state, "source")) {
    state.source = join2(TEMPLATE2, typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$22(function toString3() {
  return isCallable$82(this) && getInternalState$1(this).source || inspectSource2(this);
}, "toString");
var isCallable$72 = isCallable$g;
var definePropertyModule$22 = objectDefineProperty2;
var makeBuiltIn$12 = makeBuiltIn$3.exports;
var defineGlobalProperty$12 = defineGlobalProperty$32;
var defineBuiltIn$3 = function(O, key, value, options) {
  if (!options)
    options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$72(value))
    makeBuiltIn$12(value, name, options);
  if (options.global) {
    if (simple)
      O[key] = value;
    else
      defineGlobalProperty$12(key, value);
  } else {
    try {
      if (!options.unsafe)
        delete O[key];
      else if (O[key])
        simple = true;
    } catch (error) {
    }
    if (simple)
      O[key] = value;
    else
      definePropertyModule$22.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
  }
  return O;
};
var objectGetOwnPropertyNames2 = {};
var ceil2 = Math.ceil;
var floor2 = Math.floor;
var mathTrunc2 = Math.trunc || function trunc3(x) {
  var n2 = +x;
  return (n2 > 0 ? floor2 : ceil2)(n2);
};
var trunc4 = mathTrunc2;
var toIntegerOrInfinity$22 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc4(number);
};
var toIntegerOrInfinity$12 = toIntegerOrInfinity$22;
var max2 = Math.max;
var min$12 = Math.min;
var toAbsoluteIndex$12 = function(index, length2) {
  var integer = toIntegerOrInfinity$12(index);
  return integer < 0 ? max2(integer + length2, 0) : min$12(integer, length2);
};
var toIntegerOrInfinity2 = toIntegerOrInfinity$22;
var min2 = Math.min;
var toLength$12 = function(argument) {
  return argument > 0 ? min2(toIntegerOrInfinity2(argument), 9007199254740991) : 0;
};
var toLength2 = toLength$12;
var lengthOfArrayLike$12 = function(obj) {
  return toLength2(obj.length);
};
var toIndexedObject$32 = toIndexedObject$5;
var toAbsoluteIndex2 = toAbsoluteIndex$12;
var lengthOfArrayLike2 = lengthOfArrayLike$12;
var createMethod2 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$32($this);
    var length2 = lengthOfArrayLike2(O);
    var index = toAbsoluteIndex2(fromIndex, length2);
    var value;
    if (IS_INCLUDES && el != el)
      while (length2 > index) {
        value = O[index++];
        if (value != value)
          return true;
      }
    else
      for (; length2 > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes2 = {
  includes: createMethod2(true),
  indexOf: createMethod2(false)
};
var uncurryThis$42 = functionUncurryThis2;
var hasOwn$42 = hasOwnProperty_12;
var toIndexedObject$22 = toIndexedObject$5;
var indexOf2 = arrayIncludes2.indexOf;
var hiddenKeys$22 = hiddenKeys$4;
var push2 = uncurryThis$42([].push);
var objectKeysInternal2 = function(object, names) {
  var O = toIndexedObject$22(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$42(hiddenKeys$22, key) && hasOwn$42(O, key) && push2(result, key);
  while (names.length > i)
    if (hasOwn$42(O, key = names[i++])) {
      ~indexOf2(result, key) || push2(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$12 = objectKeysInternal2;
var enumBugKeys$22 = enumBugKeys$3;
var hiddenKeys$12 = enumBugKeys$22.concat("length", "prototype");
objectGetOwnPropertyNames2.f = Object.getOwnPropertyNames || function getOwnPropertyNames2(O) {
  return internalObjectKeys$12(O, hiddenKeys$12);
};
var objectGetOwnPropertySymbols2 = {};
objectGetOwnPropertySymbols2.f = Object.getOwnPropertySymbols;
var getBuiltIn$12 = getBuiltIn$3;
var uncurryThis$32 = functionUncurryThis2;
var getOwnPropertyNamesModule2 = objectGetOwnPropertyNames2;
var getOwnPropertySymbolsModule$12 = objectGetOwnPropertySymbols2;
var anObject$3 = anObject$5;
var concat$12 = uncurryThis$32([].concat);
var ownKeys$12 = getBuiltIn$12("Reflect", "ownKeys") || function ownKeys3(it) {
  var keys5 = getOwnPropertyNamesModule2.f(anObject$3(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule$12.f;
  return getOwnPropertySymbols ? concat$12(keys5, getOwnPropertySymbols(it)) : keys5;
};
var hasOwn$32 = hasOwnProperty_12;
var ownKeys4 = ownKeys$12;
var getOwnPropertyDescriptorModule2 = objectGetOwnPropertyDescriptor2;
var definePropertyModule$12 = objectDefineProperty2;
var copyConstructorProperties$2 = function(target, source, exceptions) {
  var keys5 = ownKeys4(source);
  var defineProperty7 = definePropertyModule$12.f;
  var getOwnPropertyDescriptor5 = getOwnPropertyDescriptorModule2.f;
  for (var i = 0; i < keys5.length; i++) {
    var key = keys5[i];
    if (!hasOwn$32(target, key) && !(exceptions && hasOwn$32(exceptions, key))) {
      defineProperty7(target, key, getOwnPropertyDescriptor5(source, key));
    }
  }
};
var fails$32 = fails$b;
var isCallable$62 = isCallable$g;
var replacement2 = /#|\.prototype\./;
var isForced$12 = function(feature, detection) {
  var value = data2[normalize2(feature)];
  return value == POLYFILL2 ? true : value == NATIVE2 ? false : isCallable$62(detection) ? fails$32(detection) : !!detection;
};
var normalize2 = isForced$12.normalize = function(string) {
  return String(string).replace(replacement2, ".").toLowerCase();
};
var data2 = isForced$12.data = {};
var NATIVE2 = isForced$12.NATIVE = "N";
var POLYFILL2 = isForced$12.POLYFILL = "P";
var isForced_12 = isForced$12;
var global$32 = global$d;
var getOwnPropertyDescriptor4 = objectGetOwnPropertyDescriptor2.f;
var createNonEnumerableProperty$22 = createNonEnumerableProperty$4;
var defineBuiltIn$2 = defineBuiltIn$3;
var defineGlobalProperty2 = defineGlobalProperty$32;
var copyConstructorProperties$12 = copyConstructorProperties$2;
var isForced2 = isForced_12;
var _export2 = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED2, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$32;
  } else if (STATIC) {
    target = global$32[TARGET] || defineGlobalProperty2(TARGET, {});
  } else {
    target = (global$32[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor4(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED2 = isForced2(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED2 && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties$12(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$22(sourceProperty, "sham", true);
      }
      defineBuiltIn$2(target, key, sourceProperty, options);
    }
};
var internalObjectKeys2 = objectKeysInternal2;
var enumBugKeys$12 = enumBugKeys$3;
var objectKeys$2 = Object.keys || function keys4(O) {
  return internalObjectKeys2(O, enumBugKeys$12);
};
var DESCRIPTORS$32 = descriptors2;
var uncurryThis$22 = functionUncurryThis2;
var call$12 = functionCall2;
var fails$22 = fails$b;
var objectKeys$12 = objectKeys$2;
var getOwnPropertySymbolsModule2 = objectGetOwnPropertySymbols2;
var propertyIsEnumerableModule2 = objectPropertyIsEnumerable2;
var toObject$12 = toObject$32;
var IndexedObject2 = indexedObject2;
var $assign2 = Object.assign;
var defineProperty$4 = Object.defineProperty;
var concat2 = uncurryThis$22([].concat);
var objectAssign2 = !$assign2 || fails$22(function() {
  if (DESCRIPTORS$32 && $assign2({ b: 1 }, $assign2(defineProperty$4({}, "a", {
    enumerable: true,
    get: function() {
      defineProperty$4(this, "b", {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1)
    return true;
  var A = {};
  var B = {};
  var symbol = Symbol();
  var alphabet = "abcdefghijklmnopqrst";
  A[symbol] = 7;
  alphabet.split("").forEach(function(chr) {
    B[chr] = chr;
  });
  return $assign2({}, A)[symbol] != 7 || objectKeys$12($assign2({}, B)).join("") != alphabet;
}) ? function assign4(target, source) {
  var T = toObject$12(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule2.f;
  var propertyIsEnumerable3 = propertyIsEnumerableModule2.f;
  while (argumentsLength > index) {
    var S = IndexedObject2(arguments[index++]);
    var keys5 = getOwnPropertySymbols ? concat2(objectKeys$12(S), getOwnPropertySymbols(S)) : objectKeys$12(S);
    var length2 = keys5.length;
    var j = 0;
    var key;
    while (length2 > j) {
      key = keys5[j++];
      if (!DESCRIPTORS$32 || call$12(propertyIsEnumerable3, S, key))
        T[key] = S[key];
    }
  }
  return T;
} : $assign2;
var $$2 = _export2;
var assign5 = objectAssign2;
$$2({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign5 }, {
  assign: assign5
});
function __rest2(s2, e2) {
  var t2 = {};
  for (var p in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p) && e2.indexOf(p) < 0)
      t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t2[p[i]] = s2[p[i]];
    }
  return t2;
}
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var CheckRender = (_a) => {
  var {
    gateLabel
  } = _a, props = __rest2(_a, ["gateLabel"]);
  const {
    setValue
  } = useFormContext();
  return (0, import_jsx_runtime2.jsx)(CheckGate, Object.assign({
    fields: props.components.map((field) => (0, import_jsx_runtime2.jsx)(FormBuilderFactory, {
      field
    }, field === null || field === void 0 ? void 0 : field.id))
  }, props, {
    gateLabel,
    onUnchecked: () => {
      props.components.forEach((field) => {
        if (field.defaultValue)
          setValue(field.id, field.defaultValue);
      });
    }
  }));
};
var SegmentRender = (props) => {
  return (0, import_jsx_runtime2.jsx)(FormSegment, Object.assign({}, props, {
    formArea: props.fields.map((field) => (0, import_jsx_runtime2.jsx)(FormBuilderFactory, {
      field
    }, field.id))
  }));
};
var SplitColumnLayout = (_a) => {
  var {
    rows
  } = _a, props = __rest2(_a, ["rows"]);
  return (0, import_jsx_runtime2.jsx)(SplitColumn, {
    rows: rows.map(({
      left,
      right,
      rowId
    }) => {
      return {
        rowId,
        left: (0, import_jsx_runtime2.jsx)(FormBuilderFactory, Object.assign({}, props, {
          field: left
        })),
        right: (0, import_jsx_runtime2.jsx)(FormBuilderFactory, Object.assign({}, props, {
          field: right
        }))
      };
    })
  });
};
var ToWeiInput = (props) => {
  const newRules = Object.assign({
    setValueAs: (val) => (0, import_utils6.isNumberish)(val) ? (0, import_utils6.toBaseUnits)(val) : val,
    validate: (val) => (0, import_utils6.ignoreEmptyVal)(val, (val2) => import_utils6.ValidateField.number(val2))
  }, props.rules);
  return (0, import_jsx_runtime2.jsx)(WrappedInput, Object.assign({}, props, {
    rules: newRules,
    defaultValue: "0"
  }));
};
var TupleObject = (props) => {
  const newRules = Object.assign({
    setValueAs: (val) => (0, import_utils6.isObject)(val) ? JSON.parse(val) : val,
    validate: (val) => (0, import_utils6.ignoreEmptyVal)(val, (val2) => import_utils6.ValidateField.object(val2))
  }, props.rules);
  return (0, import_jsx_runtime2.jsx)(WrappedTextArea, Object.assign({}, props, {
    rules: newRules
  }));
};
var CoreFieldLookup = {
  input: WrappedInput,
  inputSelect: WrappedInputSelect,
  highlightInputText: HighlightInputText,
  textarea: WrappedTextArea,
  switch: WrappedSwitch,
  radio: WrappedRadio,
  select: WrappedSelect,
  checkBox: WrappedCheckbox,
  csInput: CSInput,
  tributeInput: WrappedInput,
  checkRender: CheckRender,
  formSegment: SegmentRender,
  splitColumn: SplitColumnLayout,
  shamanPermissions: ShamanPermission,
  timePicker: TimePicker,
  toWeiInput: ToWeiInput,
  tupleObject: TupleObject
};
var _$1 = (t2) => t2;
var _t$1;
var FieldSpacer = st.div(_t$1 || (_t$1 = _$1`
  margin-bottom: 3.6rem;
`));
var _2 = (t2) => t2;
var _t2;
var _t22;
var StatusMsg$1;
(function(StatusMsg2) {
  StatusMsg2["Compile"] = "Compiling Transaction Data";
  StatusMsg2["Request"] = "Requesting Signature";
  StatusMsg2["Await"] = "Transaction Submitted";
  StatusMsg2["TxErr"] = "Transaction Error";
  StatusMsg2["TxSuccess"] = "Transaction Success";
  StatusMsg2["PollStart"] = "Syncing TX (Subgraph)";
  StatusMsg2["PollSuccess"] = "Success: TX Confirmed!";
  StatusMsg2["PollError"] = "Sync Error (Subgraph)";
  StatusMsg2["NoContext"] = "Missing TXBuilder Context";
})(StatusMsg$1 || (StatusMsg$1 = {}));
var FooterBox = st.div(_t2 || (_t2 = _2`
  a {
    margin-bottom: 1.6rem;
  }
`));
var FormFooter = ({
  submitButtonText,
  status,
  txHash
}) => {
  const {
    submitDisabled
  } = useFormBuilder() || {};
  return (0, import_jsx_runtime2.jsxs)(FooterBox, {
    children: [txHash && (0, import_jsx_runtime2.jsx)(ExplorerLink, Object.assign({
      type: "tx",
      address: txHash
    }, {
      children: "See Transaction Here"
    })), status && (0, import_jsx_runtime2.jsx)(FormStatusDisplay, {
      status
    }), (0, import_jsx_runtime2.jsx)(Button, Object.assign({
      fullWidth: true,
      type: "submit",
      disabled: submitDisabled
    }, {
      children: submitButtonText || "Submit"
    }))]
  });
};
var getStatusColor = (status, theme) => {
  if (status === StatusMsg$1.PollSuccess) {
    return theme.success.step9;
  }
  if (status === StatusMsg$1.PollError || status === StatusMsg$1.TxErr || status === StatusMsg$1.NoContext) {
    return theme.danger.step9;
  } else {
    return theme.secondary.step9;
  }
};
var getStatusElement = (status, theme) => {
  if (status === StatusMsg$1.PollSuccess) {
    return (0, import_jsx_runtime2.jsx)(import_ri.RiCheckLine, {
      color: theme.success.step9,
      size: "2.25rem"
    });
  }
  if (status === StatusMsg$1.PollError || status === StatusMsg$1.TxErr || status === StatusMsg$1.NoContext) {
    return (0, import_jsx_runtime2.jsx)(import_ri.RiErrorWarningLine, {
      color: theme.danger.step9,
      size: "2.25rem"
    });
  } else
    return (0, import_jsx_runtime2.jsx)(Loading, {
      size: 22.5
    });
};
var StatusBox = st.div(_t22 || (_t22 = _2`
  border-radius: ${0};
  border: 1px ${0}
    solid;
  padding: 1.5rem;
  margin-bottom: 2rem;
  .inner {
    display: flex;
    justify-content: space-between;
    align-items: center;
    p {
      color: ${0};
      margin-right: auto;
    }
  }
`), ({
  theme
}) => theme["card"].radius, ({
  theme,
  status
}) => getStatusColor(status, theme), ({
  theme,
  status
}) => getStatusColor(status, theme));
var FormStatusDisplay = ({
  status
}) => {
  const theme = Je();
  return (0, import_jsx_runtime2.jsx)(StatusBox, Object.assign({
    status
  }, {
    children: (0, import_jsx_runtime2.jsxs)("div", Object.assign({
      className: "inner"
    }, {
      children: [(0, import_jsx_runtime2.jsx)(ParSm, {
        children: status
      }), getStatusElement(status, theme)]
    }))
  }));
};
var wellKnownSymbol$6 = wellKnownSymbol$8;
var TO_STRING_TAG$3 = wellKnownSymbol$6("toStringTag");
var test = {};
test[TO_STRING_TAG$3] = "z";
var toStringTagSupport = String(test) === "[object z]";
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$52 = isCallable$g;
var classofRaw2 = classofRaw$1;
var wellKnownSymbol$5 = wellKnownSymbol$8;
var TO_STRING_TAG$2 = wellKnownSymbol$5("toStringTag");
var $Object$12 = Object;
var CORRECT_ARGUMENTS = classofRaw2(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error) {
  }
};
var classof$12 = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object$12(it), TO_STRING_TAG$2)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O) : (result = classofRaw2(O)) == "Object" && isCallable$52(O.callee) ? "Arguments" : result;
};
var classof2 = classof$12;
var $String$12 = String;
var toString$12 = function(argument) {
  if (classof2(argument) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return $String$12(argument);
};
var makeBuiltIn2 = makeBuiltIn$3.exports;
var defineProperty$3 = objectDefineProperty2;
var defineBuiltInAccessor$1 = function(target, name, descriptor) {
  if (descriptor.get)
    makeBuiltIn2(descriptor.get, name, { getter: true });
  if (descriptor.set)
    makeBuiltIn2(descriptor.set, name, { setter: true });
  return defineProperty$3.f(target, name, descriptor);
};
var $$12 = _export2;
var DESCRIPTORS$22 = descriptors2;
var global$22 = global$d;
var uncurryThis$12 = functionUncurryThis2;
var hasOwn$22 = hasOwnProperty_12;
var isCallable$42 = isCallable$g;
var isPrototypeOf2 = objectIsPrototypeOf2;
var toString4 = toString$12;
var defineBuiltInAccessor = defineBuiltInAccessor$1;
var copyConstructorProperties2 = copyConstructorProperties$2;
var NativeSymbol = global$22.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
if (DESCRIPTORS$22 && isCallable$42(NativeSymbol) && (!("description" in SymbolPrototype) || NativeSymbol().description !== void 0)) {
  EmptyStringDescriptionStore = {};
  SymbolWrapper = function Symbol2() {
    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : toString4(arguments[0]);
    var result = isPrototypeOf2(SymbolPrototype, this) ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
    if (description === "")
      EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties2(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;
  NATIVE_SYMBOL2 = String(NativeSymbol("test")) == "Symbol(test)";
  thisSymbolValue = uncurryThis$12(SymbolPrototype.valueOf);
  symbolDescriptiveString = uncurryThis$12(SymbolPrototype.toString);
  regexp = /^Symbol\((.*)\)[^)]+$/;
  replace3 = uncurryThis$12("".replace);
  stringSlice2 = uncurryThis$12("".slice);
  defineBuiltInAccessor(SymbolPrototype, "description", {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn$22(EmptyStringDescriptionStore, symbol))
        return "";
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL2 ? stringSlice2(string, 7, -1) : replace3(string, regexp, "$1");
      return desc === "" ? void 0 : desc;
    }
  });
  $$12({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}
var EmptyStringDescriptionStore;
var SymbolWrapper;
var NATIVE_SYMBOL2;
var thisSymbolValue;
var symbolDescriptiveString;
var regexp;
var replace3;
var stringSlice2;
var objectDefineProperties = {};
var DESCRIPTORS$12 = descriptors2;
var V8_PROTOTYPE_DEFINE_BUG2 = v8PrototypeDefineBug2;
var definePropertyModule2 = objectDefineProperty2;
var anObject$22 = anObject$5;
var toIndexedObject$12 = toIndexedObject$5;
var objectKeys2 = objectKeys$2;
objectDefineProperties.f = DESCRIPTORS$12 && !V8_PROTOTYPE_DEFINE_BUG2 ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$22(O);
  var props = toIndexedObject$12(Properties);
  var keys5 = objectKeys2(Properties);
  var length2 = keys5.length;
  var index = 0;
  var key;
  while (length2 > index)
    definePropertyModule2.f(O, key = keys5[index++], props[key]);
  return O;
};
var getBuiltIn2 = getBuiltIn$3;
var html$1 = getBuiltIn2("document", "documentElement");
var anObject$12 = anObject$5;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys2 = enumBugKeys$3;
var hiddenKeys2 = hiddenKeys$4;
var html = html$1;
var documentCreateElement$1 = documentCreateElement$2;
var sharedKey$12 = sharedKey$3;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO$1 = sharedKey$12("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement$1("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length2 = enumBugKeys2.length;
  while (length2--)
    delete NullProtoObject[PROTOTYPE][enumBugKeys2[length2]];
  return NullProtoObject();
};
hiddenKeys2[IE_PROTO$1] = true;
var objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject$12(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO$1] = O;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
};
var wellKnownSymbol$4 = wellKnownSymbol$8;
var create$1 = objectCreate;
var defineProperty$22 = objectDefineProperty2.f;
var UNSCOPABLES = wellKnownSymbol$4("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == void 0) {
  defineProperty$22(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create$1(null)
  });
}
var addToUnscopables$1 = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var iterators = {};
var fails$12 = fails$b;
var correctPrototypeGetter = !fails$12(function() {
  function F() {
  }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var hasOwn$12 = hasOwnProperty_12;
var isCallable$32 = isCallable$g;
var toObject2 = toObject$32;
var sharedKey2 = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
var IE_PROTO = sharedKey2("IE_PROTO");
var $Object2 = Object;
var ObjectPrototype = $Object2.prototype;
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object2.getPrototypeOf : function(O) {
  var object = toObject2(O);
  if (hasOwn$12(object, IE_PROTO))
    return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable$32(constructor) && object instanceof constructor) {
    return constructor.prototype;
  }
  return object instanceof $Object2 ? ObjectPrototype : null;
};
var fails2 = fails$b;
var isCallable$22 = isCallable$g;
var isObject3 = isObject$6;
var getPrototypeOf$1 = objectGetPrototypeOf;
var defineBuiltIn$12 = defineBuiltIn$3;
var wellKnownSymbol$3 = wellKnownSymbol$8;
var ITERATOR$2 = wellKnownSymbol$3("iterator");
var BUGGY_SAFARI_ITERATORS$1 = false;
var IteratorPrototype$2;
var PrototypeOfArrayIteratorPrototype;
var arrayIterator;
if ([].keys) {
  arrayIterator = [].keys();
  if (!("next" in arrayIterator))
    BUGGY_SAFARI_ITERATORS$1 = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
      IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
  }
}
var NEW_ITERATOR_PROTOTYPE = !isObject3(IteratorPrototype$2) || fails2(function() {
  var test2 = {};
  return IteratorPrototype$2[ITERATOR$2].call(test2) !== test2;
});
if (NEW_ITERATOR_PROTOTYPE)
  IteratorPrototype$2 = {};
if (!isCallable$22(IteratorPrototype$2[ITERATOR$2])) {
  defineBuiltIn$12(IteratorPrototype$2, ITERATOR$2, function() {
    return this;
  });
}
var iteratorsCore = {
  IteratorPrototype: IteratorPrototype$2,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};
var defineProperty$12 = objectDefineProperty2.f;
var hasOwn4 = hasOwnProperty_12;
var wellKnownSymbol$2 = wellKnownSymbol$8;
var TO_STRING_TAG$1 = wellKnownSymbol$2("toStringTag");
var setToStringTag$2 = function(target, TAG, STATIC) {
  if (target && !STATIC)
    target = target.prototype;
  if (target && !hasOwn4(target, TO_STRING_TAG$1)) {
    defineProperty$12(target, TO_STRING_TAG$1, { configurable: true, value: TAG });
  }
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create2 = objectCreate;
var createPropertyDescriptor2 = createPropertyDescriptor$3;
var setToStringTag$1 = setToStringTag$2;
var Iterators$2 = iterators;
var returnThis$1 = function() {
  return this;
};
var iteratorCreateConstructor = function(IteratorConstructor, NAME, next2, ENUMERABLE_NEXT) {
  var TO_STRING_TAG2 = NAME + " Iterator";
  IteratorConstructor.prototype = create2(IteratorPrototype$1, { next: createPropertyDescriptor2(+!ENUMERABLE_NEXT, next2) });
  setToStringTag$1(IteratorConstructor, TO_STRING_TAG2, false);
  Iterators$2[TO_STRING_TAG2] = returnThis$1;
  return IteratorConstructor;
};
var uncurryThis2 = functionUncurryThis2;
var aCallable2 = aCallable$22;
var functionUncurryThisAccessor = function(object, key, method) {
  try {
    return uncurryThis2(aCallable2(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) {
  }
};
var isCallable$12 = isCallable$g;
var $String2 = String;
var $TypeError2 = TypeError;
var aPossiblePrototype$1 = function(argument) {
  if (typeof argument == "object" || isCallable$12(argument))
    return argument;
  throw $TypeError2("Can't set " + $String2(argument) + " as a prototype");
};
var uncurryThisAccessor = functionUncurryThisAccessor;
var anObject2 = anObject$5;
var aPossiblePrototype = aPossiblePrototype$1;
var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var CORRECT_SETTER = false;
  var test2 = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
    setter(test2, []);
    CORRECT_SETTER = test2 instanceof Array;
  } catch (error) {
  }
  return function setPrototypeOf2(O, proto) {
    anObject2(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER)
      setter(O, proto);
    else
      O.__proto__ = proto;
    return O;
  };
}() : void 0);
var $2 = _export2;
var call2 = functionCall2;
var FunctionName = functionName2;
var isCallable2 = isCallable$g;
var createIteratorConstructor = iteratorCreateConstructor;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf = objectSetPrototypeOf;
var setToStringTag = setToStringTag$2;
var createNonEnumerableProperty$12 = createNonEnumerableProperty$4;
var defineBuiltIn2 = defineBuiltIn$3;
var wellKnownSymbol$12 = wellKnownSymbol$8;
var Iterators$1 = iterators;
var IteratorsCore = iteratorsCore;
var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME2 = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol$12("iterator");
var KEYS = "keys";
var VALUES = "values";
var ENTRIES = "entries";
var returnThis = function() {
  return this;
};
var iteratorDefine = function(Iterable, NAME, IteratorConstructor, next2, DEFAULT, IS_SET, FORCED2) {
  createIteratorConstructor(IteratorConstructor, NAME, next2);
  var getIterationMethod = function(KIND) {
    if (KIND === DEFAULT && defaultIterator)
      return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
      return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS:
        return function keys5() {
          return new IteratorConstructor(this, KIND);
        };
      case VALUES:
        return function values2() {
          return new IteratorConstructor(this, KIND);
        };
      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }
    return function() {
      return new IteratorConstructor(this);
    };
  };
  var TO_STRING_TAG2 = NAME + " Iterator";
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable2(CurrentIteratorPrototype[ITERATOR$1])) {
          defineBuiltIn2(CurrentIteratorPrototype, ITERATOR$1, returnThis);
        }
      }
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true);
    }
  }
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (CONFIGURABLE_FUNCTION_NAME2) {
      createNonEnumerableProperty$12(IterablePrototype, "name", VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values2() {
        return call2(nativeIterator, this);
      };
    }
  }
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED2)
      for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn2(IterablePrototype, KEY, methods[KEY]);
        }
      }
    else
      $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }
  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    defineBuiltIn2(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });
  }
  Iterators$1[NAME] = defaultIterator;
  return methods;
};
var createIterResultObject$1 = function(value, done) {
  return { value, done };
};
var toIndexedObject2 = toIndexedObject$5;
var addToUnscopables = addToUnscopables$1;
var Iterators = iterators;
var InternalStateModule2 = internalState2;
var defineProperty6 = objectDefineProperty2.f;
var defineIterator = iteratorDefine;
var createIterResultObject = createIterResultObject$1;
var DESCRIPTORS2 = descriptors2;
var ARRAY_ITERATOR = "Array Iterator";
var setInternalState = InternalStateModule2.set;
var getInternalState2 = InternalStateModule2.getterFor(ARRAY_ITERATOR);
var es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject2(iterated),
    index: 0,
    kind
  });
}, function() {
  var state = getInternalState2(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = void 0;
    return createIterResultObject(void 0, true);
  }
  if (kind == "keys")
    return createIterResultObject(index, false);
  if (kind == "values")
    return createIterResultObject(target[index], false);
  return createIterResultObject([index, target[index]], false);
}, "values");
var values = Iterators.Arguments = Iterators.Array;
addToUnscopables("keys");
addToUnscopables("values");
addToUnscopables("entries");
if (DESCRIPTORS2 && values.name !== "values")
  try {
    defineProperty6(values, "name", { value: "values" });
  } catch (error) {
  }
var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var documentCreateElement2 = documentCreateElement$2;
var classList = documentCreateElement2("span").classList;
var DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;
var domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? void 0 : DOMTokenListPrototype$1;
var global$12 = global$d;
var DOMIterables = domIterables;
var DOMTokenListPrototype = domTokenListPrototype;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty2 = createNonEnumerableProperty$4;
var wellKnownSymbol2 = wellKnownSymbol$8;
var ITERATOR = wellKnownSymbol2("iterator");
var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
var ArrayValues = ArrayIteratorMethods.values;
var handlePrototype = function(CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    if (CollectionPrototype[ITERATOR] !== ArrayValues)
      try {
        createNonEnumerableProperty2(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty2(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME])
      for (var METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
          try {
            createNonEnumerableProperty2(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
      }
  }
};
for (COLLECTION_NAME in DOMIterables) {
  handlePrototype(global$12[COLLECTION_NAME] && global$12[COLLECTION_NAME].prototype, COLLECTION_NAME);
}
var COLLECTION_NAME;
handlePrototype(DOMTokenListPrototype, "DOMTokenList");
var StatusMsg;
(function(StatusMsg2) {
  StatusMsg2["Compile"] = "Compiling Transaction Data";
  StatusMsg2["Request"] = "Requesting Signature";
  StatusMsg2["Await"] = "Transaction Submitted";
  StatusMsg2["TxErr"] = "Transaction Error";
  StatusMsg2["TxSuccess"] = "Transaction Success";
  StatusMsg2["PollStart"] = "Syncing TX (Subgraph)";
  StatusMsg2["PollSuccess"] = "Success: TX Confirmed!";
  StatusMsg2["PollError"] = "Sync Error (Subgraph)";
  StatusMsg2["NoContext"] = "Missing TXBuilder Context";
})(StatusMsg || (StatusMsg = {}));
var FormBuilder = ({
  form,
  defaultValues,
  customFields: _customFields = CoreFieldLookup,
  submitButtonText: _submitButtonText = "Submit",
  targetNetwork,
  lifeCycleFns,
  onSubmit
}) => {
  const {
    chainId
  } = useDHConnect();
  const {
    fireTransaction
  } = useTxBuilder();
  const {
    defaultToast,
    errorToast,
    successToast
  } = useToast();
  const {
    title,
    description,
    subtitle
  } = form;
  const [isLoading, setIsLoading] = (0, import_react7.useState)(false);
  const [status, setStatus] = (0, import_react7.useState)(null);
  const [txHash, setTxHash] = (0, import_react7.useState)(null);
  const isSameNetwork = targetNetwork ? targetNetwork === chainId : true;
  const submitDisabled = isLoading || !isSameNetwork;
  const handleSubmit = (formValues) => __awaiter2(void 0, void 0, void 0, function* () {
    if (form.tx) {
      setIsLoading(true);
      setTxHash(null);
      setStatus(StatusMsg.Compile);
      const executed = yield fireTransaction({
        tx: form.tx,
        callerState: {
          formValues
        },
        lifeCycleFns: {
          onRequestSign() {
            var _a;
            setStatus(StatusMsg.Request);
            (_a = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onRequestSign) === null || _a === void 0 ? void 0 : _a.call(lifeCycleFns);
          },
          onTxHash(txHash2) {
            var _a;
            setTxHash(txHash2);
            setStatus(StatusMsg.Await);
            (_a = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onTxHash) === null || _a === void 0 ? void 0 : _a.call(lifeCycleFns, txHash2);
          },
          onTxError(error) {
            var _a;
            setStatus(StatusMsg.TxErr);
            const errMsg = (0, import_utils6.handleErrorMessage)({
              error,
              fallback: "Could not decode error message"
            });
            setIsLoading(false);
            (_a = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onTxError) === null || _a === void 0 ? void 0 : _a.call(lifeCycleFns, error);
            errorToast({
              title: StatusMsg.TxErr,
              description: errMsg
            });
          },
          onTxSuccess(...args) {
            var _a, _b, _c;
            setStatus(((_a = form.tx) === null || _a === void 0 ? void 0 : _a.disablePoll) ? StatusMsg.PollSuccess : StatusMsg.TxSuccess);
            (_b = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onTxSuccess) === null || _b === void 0 ? void 0 : _b.call(lifeCycleFns, ...args);
            defaultToast({
              title: StatusMsg.TxSuccess,
              description: ((_c = form.tx) === null || _c === void 0 ? void 0 : _c.disablePoll) ? "Transaction cycle complete." : "Please wait for subgraph to sync"
            });
          },
          onPollStart() {
            var _a;
            setStatus(StatusMsg.PollStart);
            (_a = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onPollStart) === null || _a === void 0 ? void 0 : _a.call(lifeCycleFns);
          },
          onPollError(error) {
            var _a;
            setStatus(StatusMsg.PollError);
            const errMsg = (0, import_utils6.handleErrorMessage)({
              error,
              fallback: "Could not decode poll error message"
            });
            setIsLoading(false);
            (_a = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onPollError) === null || _a === void 0 ? void 0 : _a.call(lifeCycleFns, error);
            errorToast({
              title: StatusMsg.PollError,
              description: errMsg
            });
          },
          onPollSuccess(...args) {
            var _a;
            setStatus(StatusMsg.PollSuccess);
            setIsLoading(false);
            successToast({
              title: StatusMsg.PollSuccess,
              description: "Transaction cycle complete."
            });
            (_a = lifeCycleFns === null || lifeCycleFns === void 0 ? void 0 : lifeCycleFns.onPollSuccess) === null || _a === void 0 ? void 0 : _a.call(lifeCycleFns, ...args);
          }
        }
      });
      if (executed === void 0) {
        setStatus(StatusMsg.NoContext);
        return;
      }
      return executed;
    }
    if (onSubmit) {
      return yield onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit(formValues);
    }
    console.error("FormBuilder: onSubmit not implemented");
  });
  return (0, import_jsx_runtime2.jsx)(FormLayout, Object.assign({
    title,
    description,
    subtitle
  }, {
    children: (0, import_jsx_runtime2.jsx)(FormBuilderBase, {
      form,
      fieldObj: _customFields,
      defaultValues,
      fieldSpacing: "3.6rem",
      applyToEach: {
        full: true
      },
      formDisabled: isLoading,
      submitDisabled,
      onSubmit: handleSubmit,
      footer: (0, import_jsx_runtime2.jsx)(FormFooter, {
        submitButtonText: _submitButtonText,
        status,
        txHash
      })
    })
  }));
};

export {
  require_react_is,
  useFormBuilder,
  FormBuilderFactory,
  ToWeiInput,
  CoreFieldLookup,
  FieldSpacer,
  FormFooter,
  StatusMsg,
  FormBuilder
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=chunk-VAYEHJ7M.js.map
