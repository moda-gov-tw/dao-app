import {
  equalBytes,
  init_secp256k1,
  init_utils
} from "./chunk-QZFIEZKQ.js";
import {
  AccountNotFoundError,
  buildRequest,
  decodeEventLog,
  encodeDeployData,
  encodeEventTopics,
  estimateGas,
  formatBlock,
  formatLog,
  formatTransaction,
  formatTransactionReceipt,
  getBlock,
  getContractError,
  getEnsAddress,
  getEnsAvatar,
  getEnsName,
  getEnsResolver,
  getEnsText,
  getGasPrice,
  getSocket,
  getTransactionCount,
  getTransactionError,
  goerli,
  hashMessage,
  hashTypedData,
  init_account,
  init_assertTransaction,
  init_block,
  init_block2,
  init_buildRequest,
  init_chains,
  init_decodeEventLog,
  init_decodeFunctionData,
  init_encodeDeployData,
  init_encodeErrorResult,
  init_encodeEventTopics,
  init_encodeFunctionResult,
  init_encodePacked,
  init_ens,
  init_ens2,
  init_esm,
  init_estimateGas,
  init_estimateGas2,
  init_fromBytes,
  init_fromRlp,
  init_getBlock,
  init_getContractAddress,
  init_getContractError,
  init_getEnsAddress,
  init_getEnsAvatar,
  init_getEnsName,
  init_getEnsResolver,
  init_getEnsText,
  init_getEventSelector,
  init_getGasPrice,
  init_getSerializedTransactionType,
  init_getTransactionCount,
  init_getTransactionError,
  init_getTransactionType,
  init_hashMessage,
  init_hashTypedData,
  init_isBytes,
  init_isHash,
  init_labelhash,
  init_log,
  init_log2,
  init_namehash,
  init_parseEther,
  init_parseGwei,
  init_parseTransaction,
  init_parseUnits,
  init_prepareRequest,
  init_publicKeyToAddress,
  init_readContract,
  init_recoverAddress,
  init_recoverMessageAddress,
  init_recoverPublicKey,
  init_recoverTypedDataAddress,
  init_rpc as init_rpc2,
  init_serializeAccessList,
  init_serializeTransaction,
  init_toRlp,
  init_transaction,
  init_transactionReceipt,
  init_typedData,
  init_utils as init_utils2,
  init_verifyMessage,
  init_verifyTypedData,
  init_wait,
  init_withRetry,
  isDeterministicError,
  mainnet,
  normalize,
  prepareRequest,
  readContract,
  rpc,
  validateTypedData,
  wait,
  withRetry
} from "./chunk-DMOAGK44.js";
import {
  AbiDecodingZeroDataError,
  BaseError,
  CallExecutionError,
  ContractFunctionExecutionError,
  DecodeLogDataMismatch,
  DecodeLogTopicsMismatch,
  InvalidInputRpcError,
  RawContractError,
  ResourceUnavailableRpcError,
  RpcRequestError,
  SwitchChainError,
  TransactionNotFoundError,
  TransactionReceiptNotFoundError,
  UserRejectedRequestError,
  WaitForTransactionReceiptTimeoutError,
  assertCurrentChain,
  assertRequest,
  call,
  checksumAddress,
  createBatchScheduler,
  decodeFunctionResult,
  encodeFunctionData,
  extract,
  formatTransactionRequest,
  formatUnits,
  getAbiItem,
  getAddress,
  getChainContractAddress,
  hexToBigInt,
  hexToNumber,
  hexToString,
  init_abi,
  init_abis,
  init_address,
  init_assertRequest,
  init_base,
  init_call,
  init_ccip,
  init_chain,
  init_chain2,
  init_concat,
  init_contract,
  init_createBatchScheduler,
  init_data,
  init_decodeAbiParameters,
  init_decodeErrorResult,
  init_decodeFunctionResult,
  init_encodeAbiParameters,
  init_encodeFunctionData,
  init_encoding,
  init_extract,
  init_formatEther,
  init_formatGwei,
  init_formatUnits,
  init_fromHex,
  init_getAbiItem,
  init_getAddress,
  init_getFunctionSelector,
  init_isAddress,
  init_isAddressEqual,
  init_isHex,
  init_keccak256,
  init_node,
  init_pad,
  init_parseAccount,
  init_request,
  init_rpc,
  init_size,
  init_slice,
  init_stringify,
  init_toBytes,
  init_toHex,
  init_transaction as init_transaction2,
  init_transactionRequest,
  init_trim,
  init_unit,
  isHex,
  multicall3Abi,
  numberToHex,
  parseAccount,
  stringToHex,
  stringify,
  toBytes,
  toHex,
  trim,
  universalSignatureValidatorAbi,
  weiUnits
} from "./chunk-JP6YUYUV.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  init_chunk_GUCHKZEA,
  init_chunk_MQXBDTVK
} from "./chunk-EBQ4QPBR.js";
import {
  __commonJS,
  __esm,
  __toESM
} from "./chunk-LMAYTEU7.js";

// node_modules/viem/dist/esm/utils/accounts.js
var init_accounts = __esm({
  "node_modules/viem/dist/esm/utils/accounts.js"() {
    init_parseAccount();
    init_publicKeyToAddress();
  }
});

// node_modules/viem/dist/esm/utils/uid.js
function uid(length = 11) {
  if (!buffer || index + length > size * 2) {
    buffer = "";
    index = 0;
    for (let i = 0; i < size; i++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}
var size, index, buffer;
var init_uid = __esm({
  "node_modules/viem/dist/esm/utils/uid.js"() {
    size = 256;
    index = size;
  }
});

// node_modules/viem/dist/esm/clients/createClient.js
function createClient(parameters) {
  const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
  const chain = parameters.chain;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request, value } = parameters.transport({
    chain,
    pollingInterval
  });
  const transport = { ...config2, ...value };
  const client = {
    account,
    batch,
    cacheTime,
    chain,
    key,
    name,
    pollingInterval,
    request,
    transport,
    type,
    uid: uid()
  };
  function extend(base) {
    return (extendFn) => {
      const extended = extendFn(base);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend(combined) });
    };
  }
  return Object.assign(client, { extend: extend(client) });
}
var init_createClient = __esm({
  "node_modules/viem/dist/esm/clients/createClient.js"() {
    init_accounts();
    init_uid();
  }
});

// node_modules/viem/dist/esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}
var init_createFilterRequestScope = __esm({
  "node_modules/viem/dist/esm/utils/filters/createFilterRequestScope.js"() {
  }
});

// node_modules/viem/dist/esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id, request: getRequest(id), type: "block" };
}
var init_createBlockFilter = __esm({
  "node_modules/viem/dist/esm/actions/public/createBlockFilter.js"() {
    init_createFilterRequestScope();
  }
});

// node_modules/viem/dist/esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : void 0;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict,
    type: "event"
  };
}
var init_createContractEventFilter = __esm({
  "node_modules/viem/dist/esm/actions/public/createContractEventFilter.js"() {
    init_encodeEventTopics();
    init_toHex();
    init_createFilterRequestScope();
  }
});

// node_modules/viem/dist/esm/actions/public/createEventFilter.js
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args,
    eventName: event ? event.name : void 0,
    fromBlock,
    id,
    request: getRequest(id),
    strict,
    toBlock,
    type: "event"
  };
}
var init_createEventFilter = __esm({
  "node_modules/viem/dist/esm/actions/public/createEventFilter.js"() {
    init_encodeEventTopics();
    init_toHex();
    init_createFilterRequestScope();
  }
});

// node_modules/viem/dist/esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id, request: getRequest(id), type: "transaction" };
}
var init_createPendingTransactionFilter = __esm({
  "node_modules/viem/dist/esm/actions/public/createPendingTransactionFilter.js"() {
    init_createFilterRequestScope();
  }
});

// node_modules/viem/dist/esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await estimateGas(client, {
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (err) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}
var init_estimateContractGas = __esm({
  "node_modules/viem/dist/esm/actions/public/estimateContractGas.js"() {
    init_parseAccount();
    init_encodeFunctionData();
    init_getContractError();
    init_estimateGas2();
  }
});

// node_modules/viem/dist/esm/actions/public/getBalance.js
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}
var init_getBalance = __esm({
  "node_modules/viem/dist/esm/actions/public/getBalance.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/utils/promise/withCache.js
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data) => cache.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Infinity }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = new Date().getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}
var promiseCache, responseCache;
var init_withCache = __esm({
  "node_modules/viem/dist/esm/utils/promise/withCache.js"() {
    promiseCache = /* @__PURE__ */ new Map();
    responseCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/viem/dist/esm/actions/public/getBlockNumber.js
async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
  return BigInt(blockNumberHex);
}
var cacheKey;
var init_getBlockNumber = __esm({
  "node_modules/viem/dist/esm/actions/public/getBlockNumber.js"() {
    init_withCache();
    cacheKey = (id) => `blockNumber.${id}`;
  }
});

// node_modules/viem/dist/esm/actions/public/getBlockTransactionCount.js
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count;
  if (blockHash) {
    count = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  } else {
    count = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    });
  }
  return hexToNumber(count);
}
var init_getBlockTransactionCount = __esm({
  "node_modules/viem/dist/esm/actions/public/getBlockTransactionCount.js"() {
    init_fromHex();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/public/getBytecode.js
async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  });
  if (hex === "0x")
    return void 0;
  return hex;
}
var init_getBytecode = __esm({
  "node_modules/viem/dist/esm/actions/public/getBytecode.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/public/getChainId.js
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  });
  return hexToNumber(chainIdHex);
}
var init_getChainId = __esm({
  "node_modules/viem/dist/esm/actions/public/getChainId.js"() {
    init_fromHex();
  }
});

// node_modules/viem/dist/esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
  };
}
var init_feeHistory = __esm({
  "node_modules/viem/dist/esm/utils/formatters/feeHistory.js"() {
  }
});

// node_modules/viem/dist/esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  });
  return formatFeeHistory(feeHistory);
}
var init_getFeeHistory = __esm({
  "node_modules/viem/dist/esm/actions/public/getFeeHistory.js"() {
    init_toHex();
    init_feeHistory();
  }
});

// node_modules/viem/dist/esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  return logs.map((log) => {
    if (typeof log === "string")
      return log;
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log.data,
        topics: log.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
      }
      return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
var init_getFilterChanges = __esm({
  "node_modules/viem/dist/esm/actions/public/getFilterChanges.js"() {
    init_abi();
    init_decodeEventLog();
    init_log();
  }
});

// node_modules/viem/dist/esm/actions/public/getFilterLogs.js
async function getFilterLogs(_client, { filter }) {
  const strict = filter.strict ?? false;
  const logs = await filter.request({
    method: "eth_getFilterLogs",
    params: [filter.id]
  });
  return logs.map((log) => {
    try {
      const { eventName, args } = "abi" in filter && filter.abi ? decodeEventLog({
        abi: filter.abi,
        data: log.data,
        topics: log.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log, { args, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if ("strict" in filter && filter.strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
      }
      return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
var init_getFilterLogs = __esm({
  "node_modules/viem/dist/esm/actions/public/getFilterLogs.js"() {
    init_abi();
    init_decodeEventLog();
    init_log();
  }
});

// node_modules/viem/dist/esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events) {
    topics = [
      events.flatMap((event2) => encodeEventTopics({
        abi: [event2],
        eventName: event2.name,
        args
      }))
    ];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  return logs.map((log) => {
    try {
      const { eventName, args: args2 } = events ? decodeEventLog({
        abi: events,
        data: log.data,
        topics: log.topics,
        strict
      }) : { eventName: void 0, args: void 0 };
      return formatLog(log, { args: args2, eventName });
    } catch (err) {
      let eventName;
      let isUnnamed;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return;
        eventName = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
      }
      return formatLog(log, { args: isUnnamed ? [] : {}, eventName });
    }
  }).filter(Boolean);
}
var init_getLogs = __esm({
  "node_modules/viem/dist/esm/actions/public/getLogs.js"() {
    init_abi();
    init_decodeEventLog();
    init_encodeEventTopics();
    init_toHex();
    init_log();
  }
});

// node_modules/viem/dist/esm/actions/public/getStorageAt.js
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}
var init_getStorageAt = __esm({
  "node_modules/viem/dist/esm/actions/public/getStorageAt.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/public/getTransaction.js
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index: index2 }) {
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash]
    });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index2)]
    });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index2)]
    });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash,
      index: index2
    });
  const format = client.chain?.formatters?.transaction?.format || formatTransaction;
  return format(transaction);
}
var init_getTransaction = __esm({
  "node_modules/viem/dist/esm/actions/public/getTransaction.js"() {
    init_transaction2();
    init_toHex();
    init_transaction();
  }
});

// node_modules/viem/dist/esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getBlockNumber(client),
    hash ? getTransaction(client, { hash }) : void 0
  ]);
  const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}
var init_getTransactionConfirmations = __esm({
  "node_modules/viem/dist/esm/actions/public/getTransactionConfirmations.js"() {
    init_getBlockNumber();
    init_getTransaction();
  }
});

// node_modules/viem/dist/esm/actions/public/getTransactionReceipt.js
async function getTransactionReceipt(client, { hash }) {
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash]
  });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash });
  const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;
  return format(receipt);
}
var init_getTransactionReceipt = __esm({
  "node_modules/viem/dist/esm/actions/public/getTransactionReceipt.js"() {
    init_transaction2();
    init_transactionReceipt();
  }
});

// node_modules/viem/dist/esm/actions/public/multicall.js
async function multicall(client, args) {
  const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_ } = args;
  const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
  const contracts = contracts_;
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0; i < contracts.length; i++) {
    const { abi, address, args: args2, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({
        abi,
        args: args2,
        functionName
      });
      currentChunkSize += callData.length;
      if (batchSize > 0 && currentChunkSize > batchSize) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err) {
      const error = getContractError(err, {
        abi,
        address,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const results = await Promise.all(chunkedCalls.map((calls) => readContract(client, {
    abi: multicall3Abi,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3"
  })));
  return results.flat().map(({ returnData, success }, i) => {
    const calls = chunkedCalls.flat();
    const { callData } = calls[i];
    const { abi, address, functionName, args: args2 } = contracts[i];
    try {
      if (callData === "0x")
        throw new AbiDecodingZeroDataError();
      if (!success)
        throw new RawContractError({ data: returnData });
      const result = decodeFunctionResult({
        abi,
        args: args2,
        data: returnData,
        functionName
      });
      return allowFailure ? { result, status: "success" } : result;
    } catch (err) {
      const error = getContractError(err, {
        abi,
        address,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName
      });
      if (!allowFailure)
        throw error;
      return { error, result: void 0, status: "failure" };
    }
  });
}
var init_multicall = __esm({
  "node_modules/viem/dist/esm/actions/public/multicall.js"() {
    init_abis();
    init_abi();
    init_contract();
    init_decodeFunctionResult();
    init_encodeFunctionData();
    init_chain2();
    init_getContractError();
    init_readContract();
  }
});

// node_modules/viem/dist/esm/actions/public/simulateContract.js
async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
  const account = callRequest.account ? parseAccount(callRequest.account) : void 0;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await call(client, {
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    return {
      result,
      request: {
        abi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest
      }
    };
  } catch (err) {
    throw getContractError(err, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}
var init_simulateContract = __esm({
  "node_modules/viem/dist/esm/actions/public/simulateContract.js"() {
    init_parseAccount();
    init_decodeFunctionResult();
    init_encodeFunctionData();
    init_getContractError();
    init_call();
  }
});

// node_modules/viem/dist/esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}
var init_uninstallFilter = __esm({
  "node_modules/viem/dist/esm/actions/public/uninstallFilter.js"() {
  }
});

// node_modules/viem/dist/esm/constants/contracts.js
var universalSignatureValidatorByteCode;
var init_contracts = __esm({
  "node_modules/viem/dist/esm/constants/contracts.js"() {
    universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
  }
});

// node_modules/viem/dist/esm/utils/observe.js
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      listeners2.forEach((listener) => listener.fns[key]?.(...args));
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}
var listenersCache, cleanupCache, callbackCount;
var init_observe = __esm({
  "node_modules/viem/dist/esm/utils/observe.js"() {
    listenersCache = /* @__PURE__ */ new Map();
    cleanupCache = /* @__PURE__ */ new Map();
    callbackCount = 0;
  }
});

// node_modules/viem/dist/esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}
var init_poll = __esm({
  "node_modules/viem/dist/esm/utils/poll.js"() {
    init_wait();
  }
});

// node_modules/viem/dist/esm/actions/public/watchContractEvent.js
function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollContractEvent = () => {
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval
    ]);
    const strict = strict_ ?? false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await createContractEventFilter(client, {
              abi,
              address,
              args,
              eventName,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getFilterChanges(client, { filter });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                event: getAbiItem({
                  abi,
                  name: eventName
                })
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await uninstallFilter(client, { filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const topics = eventName ? encodeEventTopics({
          abi,
          eventName,
          args
        }) : [];
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName: eventName2, args: args2 } = decodeEventLog({
                abi,
                data: log.data,
                topics: log.topics,
                strict: strict_
              });
              const formatted = formatLog(log, {
                args: args2,
                eventName: eventName2
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName2;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName2 = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName: eventName2
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
var init_watchContractEvent = __esm({
  "node_modules/viem/dist/esm/actions/public/watchContractEvent.js"() {
    init_getAbiItem();
    init_observe();
    init_poll();
    init_stringify();
    init_abi();
    init_esm2();
    init_createContractEventFilter();
    init_getBlockNumber();
    init_getFilterChanges();
    init_getLogs();
    init_uninstallFilter();
  }
});

// node_modules/viem/dist/esm/actions/wallet/sendTransaction.js
async function sendTransaction(client, args) {
  const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = parseAccount(account_);
  try {
    assertRequest(args);
    let chainId;
    if (chain !== null) {
      chainId = await getChainId(client);
      assertCurrentChain({
        currentChainId: chainId,
        chain
      });
    }
    if (account.type === "local") {
      const request2 = await prepareRequest(client, {
        account,
        accessList,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
        ...rest
      });
      if (!chainId)
        chainId = await getChainId(client);
      const serializer = chain?.serializers?.transaction;
      const signedRequest = await account.signTransaction({
        ...request2,
        chainId
      }, { serializer });
      return await client.request({
        method: "eth_sendRawTransaction",
        params: [signedRequest]
      });
    }
    const format = chain?.formatters?.transactionRequest?.format || formatTransactionRequest;
    const request = format({
      ...extract(rest, { format }),
      accessList,
      data,
      from: account.address,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    return await client.request({
      method: "eth_sendTransaction",
      params: [request]
    });
  } catch (err) {
    throw getTransactionError(err, {
      ...args,
      account,
      chain: args.chain || void 0
    });
  }
}
var init_sendTransaction = __esm({
  "node_modules/viem/dist/esm/actions/wallet/sendTransaction.js"() {
    init_parseAccount();
    init_account();
    init_chain2();
    init_getTransactionError();
    init_extract();
    init_transactionRequest();
    init_assertRequest();
    init_prepareRequest();
    init_getChainId();
  }
});

// node_modules/viem/dist/esm/actions/wallet/writeContract.js
async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  const hash = await sendTransaction(client, {
    data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address,
    ...request
  });
  return hash;
}
var init_writeContract = __esm({
  "node_modules/viem/dist/esm/actions/wallet/writeContract.js"() {
    init_encodeFunctionData();
    init_sendTransaction();
  }
});

// node_modules/viem/dist/esm/actions/getContract.js
var init_getContract = __esm({
  "node_modules/viem/dist/esm/actions/getContract.js"() {
    init_createContractEventFilter();
    init_estimateContractGas();
    init_readContract();
    init_simulateContract();
    init_watchContractEvent();
    init_writeContract();
  }
});

// node_modules/viem/dist/esm/actions/wallet/addChain.js
async function addChain(client, { chain }) {
  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
  await client.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id),
        chainName: name,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
      }
    ]
  });
}
var init_addChain = __esm({
  "node_modules/viem/dist/esm/actions/wallet/addChain.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/clients/transports/createTransport.js
function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
  return {
    config: { key, name, request, retryCount, retryDelay, timeout, type },
    request: buildRequest(request, { retryCount, retryDelay }),
    value
  };
}
var init_createTransport = __esm({
  "node_modules/viem/dist/esm/clients/transports/createTransport.js"() {
    init_buildRequest();
  }
});

// node_modules/viem/dist/esm/clients/transports/custom.js
function custom(provider, config2 = {}) {
  const { key = "custom", name = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key,
    name,
    request: provider.request.bind(provider),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}
var init_custom = __esm({
  "node_modules/viem/dist/esm/clients/transports/custom.js"() {
    init_createTransport();
  }
});

// node_modules/viem/dist/esm/clients/transports/fallback.js
function fallback(transports_, config2 = {}) {
  const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config2;
  return ({ chain, pollingInterval = 4e3, timeout }) => {
    let transports = transports_;
    let onResponse = () => {
    };
    const transport = createTransport({
      key,
      name,
      async request({ method, params }) {
        const fetch = async (i = 0) => {
          const transport2 = transports[i]({ chain, retryCount: 0, timeout });
          try {
            const response = await transport2.request({
              method,
              params
            });
            onResponse({
              method,
              params,
              response,
              transport: transport2,
              status: "success"
            });
            return response;
          } catch (err) {
            onResponse({
              error: err,
              method,
              params,
              transport: transport2,
              status: "error"
            });
            if (isDeterministicError(err))
              throw err;
            if (i === transports.length - 1)
              throw err;
            return fetch(i + 1);
          }
        };
        return fetch();
      },
      retryCount,
      retryDelay,
      type: "fallback"
    }, {
      onResponse: (fn) => onResponse = fn,
      transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
    });
    if (rank) {
      const rankOptions = typeof rank === "object" ? rank : {};
      rankTransports({
        chain,
        interval: rankOptions.interval ?? pollingInterval,
        onTransports: (transports_2) => transports = transports_2,
        sampleCount: rankOptions.sampleCount,
        timeout: rankOptions.timeout,
        transports,
        weights: rankOptions.weights
      });
    }
    return transport;
  };
}
function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
  const samples = [];
  const rankTransports_ = async () => {
    const sample = await Promise.all(transports.map(async (transport) => {
      const transport_ = transport({ chain, retryCount: 0, timeout });
      const start = Date.now();
      let end;
      let success;
      try {
        await transport_.request({ method: "net_listening" });
        success = 1;
      } catch {
        success = 0;
      } finally {
        end = Date.now();
      }
      const latency = end - start;
      return { latency, success };
    }));
    samples.push(sample);
    if (samples.length > sampleCount)
      samples.shift();
    const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
    const scores = transports.map((_, i) => {
      const latencies = samples.map((sample2) => sample2[i].latency);
      const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
      const latencyScore = 1 - meanLatency / maxLatency;
      const successes = samples.map((sample2) => sample2[i].success);
      const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
      if (stabilityScore === 0)
        return [0, i];
      return [
        latencyWeight * latencyScore + stabilityWeight * stabilityScore,
        i
      ];
    }).sort((a, b) => b[0] - a[0]);
    onTransports(scores.map(([, i]) => transports[i]));
    await wait(interval);
    rankTransports_();
  };
  rankTransports_();
}
var init_fallback = __esm({
  "node_modules/viem/dist/esm/clients/transports/fallback.js"() {
    init_buildRequest();
    init_wait();
    init_createTransport();
  }
});

// node_modules/viem/dist/esm/errors/transport.js
var UrlRequiredError;
var init_transport = __esm({
  "node_modules/viem/dist/esm/errors/transport.js"() {
    init_base();
    UrlRequiredError = class extends BaseError {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
        });
      }
    };
  }
});

// node_modules/viem/dist/esm/clients/transports/http.js
function http(url, config2 = {}) {
  const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.http[0];
    if (!url_)
      throw new UrlRequiredError();
    return createTransport({
      key,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule } = createBatchScheduler({
          id: `${url}`,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpc.http(url_, {
            body: body2,
            fetchOptions,
            timeout
          })
        });
        const fn = async (body2) => batch ? schedule(body2) : [await rpc.http(url_, { body: body2, fetchOptions, timeout })];
        const [{ error, result }] = await fn(body);
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "http"
    }, {
      url
    });
  };
}
var init_http = __esm({
  "node_modules/viem/dist/esm/clients/transports/http.js"() {
    init_request();
    init_transport();
    init_createBatchScheduler();
    init_rpc2();
    init_createTransport();
  }
});

// node_modules/viem/dist/esm/actions/test/dropTransaction.js
var init_dropTransaction = __esm({
  "node_modules/viem/dist/esm/actions/test/dropTransaction.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/getAutomine.js
var init_getAutomine = __esm({
  "node_modules/viem/dist/esm/actions/test/getAutomine.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/getTxpoolContent.js
var init_getTxpoolContent = __esm({
  "node_modules/viem/dist/esm/actions/test/getTxpoolContent.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/getTxpoolStatus.js
var init_getTxpoolStatus = __esm({
  "node_modules/viem/dist/esm/actions/test/getTxpoolStatus.js"() {
    init_fromHex();
  }
});

// node_modules/viem/dist/esm/actions/test/impersonateAccount.js
var init_impersonateAccount = __esm({
  "node_modules/viem/dist/esm/actions/test/impersonateAccount.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/increaseTime.js
var init_increaseTime = __esm({
  "node_modules/viem/dist/esm/actions/test/increaseTime.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/inspectTxpool.js
var init_inspectTxpool = __esm({
  "node_modules/viem/dist/esm/actions/test/inspectTxpool.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/mine.js
var init_mine = __esm({
  "node_modules/viem/dist/esm/actions/test/mine.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/removeBlockTimestampInterval.js
var init_removeBlockTimestampInterval = __esm({
  "node_modules/viem/dist/esm/actions/test/removeBlockTimestampInterval.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/reset.js
var init_reset = __esm({
  "node_modules/viem/dist/esm/actions/test/reset.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/revert.js
var init_revert = __esm({
  "node_modules/viem/dist/esm/actions/test/revert.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/sendUnsignedTransaction.js
var init_sendUnsignedTransaction = __esm({
  "node_modules/viem/dist/esm/actions/test/sendUnsignedTransaction.js"() {
    init_extract();
    init_transactionRequest();
  }
});

// node_modules/viem/dist/esm/actions/test/setAutomine.js
var init_setAutomine = __esm({
  "node_modules/viem/dist/esm/actions/test/setAutomine.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/setBalance.js
var init_setBalance = __esm({
  "node_modules/viem/dist/esm/actions/test/setBalance.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/setBlockGasLimit.js
var init_setBlockGasLimit = __esm({
  "node_modules/viem/dist/esm/actions/test/setBlockGasLimit.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/setBlockTimestampInterval.js
var init_setBlockTimestampInterval = __esm({
  "node_modules/viem/dist/esm/actions/test/setBlockTimestampInterval.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/setCode.js
var init_setCode = __esm({
  "node_modules/viem/dist/esm/actions/test/setCode.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/setCoinbase.js
var init_setCoinbase = __esm({
  "node_modules/viem/dist/esm/actions/test/setCoinbase.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/setIntervalMining.js
var init_setIntervalMining = __esm({
  "node_modules/viem/dist/esm/actions/test/setIntervalMining.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/setLoggingEnabled.js
var init_setLoggingEnabled = __esm({
  "node_modules/viem/dist/esm/actions/test/setLoggingEnabled.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/setMinGasPrice.js
var init_setMinGasPrice = __esm({
  "node_modules/viem/dist/esm/actions/test/setMinGasPrice.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/setNextBlockBaseFeePerGas.js
var init_setNextBlockBaseFeePerGas = __esm({
  "node_modules/viem/dist/esm/actions/test/setNextBlockBaseFeePerGas.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/setNextBlockTimestamp.js
var init_setNextBlockTimestamp = __esm({
  "node_modules/viem/dist/esm/actions/test/setNextBlockTimestamp.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/setNonce.js
var init_setNonce = __esm({
  "node_modules/viem/dist/esm/actions/test/setNonce.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/setRpcUrl.js
var init_setRpcUrl = __esm({
  "node_modules/viem/dist/esm/actions/test/setRpcUrl.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/setStorageAt.js
var init_setStorageAt = __esm({
  "node_modules/viem/dist/esm/actions/test/setStorageAt.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/test/snapshot.js
var init_snapshot = __esm({
  "node_modules/viem/dist/esm/actions/test/snapshot.js"() {
  }
});

// node_modules/viem/dist/esm/actions/test/stopImpersonatingAccount.js
var init_stopImpersonatingAccount = __esm({
  "node_modules/viem/dist/esm/actions/test/stopImpersonatingAccount.js"() {
  }
});

// node_modules/viem/dist/esm/clients/decorators/test.js
var init_test = __esm({
  "node_modules/viem/dist/esm/clients/decorators/test.js"() {
    init_dropTransaction();
    init_getAutomine();
    init_getTxpoolContent();
    init_getTxpoolStatus();
    init_impersonateAccount();
    init_increaseTime();
    init_inspectTxpool();
    init_mine();
    init_removeBlockTimestampInterval();
    init_reset();
    init_revert();
    init_sendUnsignedTransaction();
    init_setAutomine();
    init_setBalance();
    init_setBlockGasLimit();
    init_setBlockTimestampInterval();
    init_setCode();
    init_setCoinbase();
    init_setIntervalMining();
    init_setLoggingEnabled();
    init_setMinGasPrice();
    init_setNextBlockBaseFeePerGas();
    init_setNextBlockTimestamp();
    init_setNonce();
    init_setRpcUrl();
    init_setStorageAt();
    init_snapshot();
    init_stopImpersonatingAccount();
  }
});

// node_modules/viem/dist/esm/clients/createTestClient.js
var init_createTestClient = __esm({
  "node_modules/viem/dist/esm/clients/createTestClient.js"() {
    init_createClient();
    init_test();
  }
});

// node_modules/viem/dist/esm/actions/wallet/deployContract.js
function deployContract(walletClient, { abi, args, bytecode, ...request }) {
  const calldata = encodeDeployData({
    abi,
    args,
    bytecode
  });
  return sendTransaction(walletClient, {
    ...request,
    data: calldata
  });
}
var init_deployContract = __esm({
  "node_modules/viem/dist/esm/actions/wallet/deployContract.js"() {
    init_encodeDeployData();
    init_sendTransaction();
  }
});

// node_modules/viem/dist/esm/actions/wallet/getAddresses.js
async function getAddresses(client) {
  const addresses = await client.request({ method: "eth_accounts" });
  return addresses.map((address) => checksumAddress(address));
}
var init_getAddresses = __esm({
  "node_modules/viem/dist/esm/actions/wallet/getAddresses.js"() {
    init_getAddress();
  }
});

// node_modules/viem/dist/esm/actions/wallet/getPermissions.js
async function getPermissions(client) {
  const permissions = await client.request({ method: "wallet_getPermissions" });
  return permissions;
}
var init_getPermissions = __esm({
  "node_modules/viem/dist/esm/actions/wallet/getPermissions.js"() {
  }
});

// node_modules/viem/dist/esm/actions/wallet/requestAddresses.js
async function requestAddresses(client) {
  const addresses = await client.request({ method: "eth_requestAccounts" });
  return addresses.map((address) => getAddress(address));
}
var init_requestAddresses = __esm({
  "node_modules/viem/dist/esm/actions/wallet/requestAddresses.js"() {
    init_getAddress();
  }
});

// node_modules/viem/dist/esm/actions/wallet/requestPermissions.js
async function requestPermissions(client, permissions) {
  return client.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  });
}
var init_requestPermissions = __esm({
  "node_modules/viem/dist/esm/actions/wallet/requestPermissions.js"() {
  }
});

// node_modules/viem/dist/esm/actions/wallet/signMessage.js
async function signMessage(client, { account: account_ = client.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  if (account.type === "local")
    return account.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex(message.raw);
    return message.raw;
  })();
  return client.request({
    method: "personal_sign",
    params: [message_, account.address]
  });
}
var init_signMessage = __esm({
  "node_modules/viem/dist/esm/actions/wallet/signMessage.js"() {
    init_parseAccount();
    init_account();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/wallet/signTypedData.js
async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account = parseAccount(account_);
  const types = {
    EIP712Domain: [
      typeof domain?.name === "string" && { name: "name", type: "string" },
      domain?.version && { name: "version", type: "string" },
      typeof domain?.chainId === "number" && {
        name: "chainId",
        type: "uint256"
      },
      domain?.verifyingContract && {
        name: "verifyingContract",
        type: "address"
      },
      domain?.salt && { name: "salt", type: "bytes32" }
    ].filter(Boolean),
    ...types_
  };
  validateTypedData({
    domain,
    message,
    primaryType,
    types
  });
  if (account.type === "local")
    return account.signTypedData({
      domain,
      primaryType,
      types,
      message
    });
  const typedData = stringify({ domain: domain ?? {}, primaryType, types, message }, (_, value) => isHex(value) ? value.toLowerCase() : value);
  return client.request({
    method: "eth_signTypedData_v4",
    params: [account.address, typedData]
  });
}
var init_signTypedData = __esm({
  "node_modules/viem/dist/esm/actions/wallet/signTypedData.js"() {
    init_parseAccount();
    init_account();
    init_isHex();
    init_stringify();
    init_typedData();
  }
});

// node_modules/viem/dist/esm/actions/wallet/switchChain.js
async function switchChain(client, { id }) {
  await client.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id)
      }
    ]
  });
}
var init_switchChain = __esm({
  "node_modules/viem/dist/esm/actions/wallet/switchChain.js"() {
    init_toHex();
  }
});

// node_modules/viem/dist/esm/actions/wallet/watchAsset.js
async function watchAsset(client, params) {
  const added = await client.request({
    method: "wallet_watchAsset",
    params
  });
  return added;
}
var init_watchAsset = __esm({
  "node_modules/viem/dist/esm/actions/wallet/watchAsset.js"() {
  }
});

// node_modules/viem/dist/esm/clients/decorators/wallet.js
function walletActions(client) {
  return {
    addChain: (args) => addChain(client, args),
    deployContract: (args) => deployContract(client, args),
    getAddresses: () => getAddresses(client),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args) => requestPermissions(client, args),
    sendTransaction: (args) => sendTransaction(client, args),
    signMessage: (args) => signMessage(client, args),
    signTypedData: (args) => signTypedData(client, args),
    switchChain: (args) => switchChain(client, args),
    watchAsset: (args) => watchAsset(client, args),
    writeContract: (args) => writeContract(client, args)
  };
}
var init_wallet = __esm({
  "node_modules/viem/dist/esm/clients/decorators/wallet.js"() {
    init_getChainId();
    init_addChain();
    init_deployContract();
    init_getAddresses();
    init_getPermissions();
    init_requestAddresses();
    init_requestPermissions();
    init_sendTransaction();
    init_signMessage();
    init_signTypedData();
    init_switchChain();
    init_watchAsset();
    init_writeContract();
  }
});

// node_modules/viem/dist/esm/clients/createWalletClient.js
function createWalletClient(parameters) {
  const { key = "wallet", name = "Wallet Client", transport } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    transport: (opts) => transport({ ...opts, retryCount: 0 }),
    type: "walletClient"
  });
  return client.extend(walletActions);
}
var init_createWalletClient = __esm({
  "node_modules/viem/dist/esm/clients/createWalletClient.js"() {
    init_createClient();
    init_wallet();
  }
});

// node_modules/viem/dist/esm/clients/transports/webSocket.js
function webSocket(url, config2 = {}) {
  const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config2;
  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
    if (!url_)
      throw new UrlRequiredError();
    return createTransport({
      key,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const socket = await getSocket(url_);
        const { error, result } = await rpc.webSocketAsync(socket, {
          body,
          timeout
        });
        if (error)
          throw new RpcRequestError({
            body,
            error,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout,
      type: "webSocket"
    }, {
      getSocket() {
        return getSocket(url_);
      },
      async subscribe({ params, onData, onError }) {
        const socket = await getSocket(url_);
        const { result: subscriptionId } = await new Promise((resolve, reject) => rpc.webSocket(socket, {
          body: {
            method: "eth_subscribe",
            params
          },
          onResponse(response) {
            if (response.error) {
              reject(response.error);
              onError?.(response.error);
              return;
            }
            if (typeof response.id === "number") {
              resolve(response);
              return;
            }
            if (response.method !== "eth_subscription")
              return;
            onData(response.params);
          }
        }));
        return {
          subscriptionId,
          async unsubscribe() {
            return new Promise((resolve) => rpc.webSocket(socket, {
              body: {
                method: "eth_unsubscribe",
                params: [subscriptionId]
              },
              onResponse: resolve
            }));
          }
        };
      }
    });
  };
}
var init_webSocket = __esm({
  "node_modules/viem/dist/esm/clients/transports/webSocket.js"() {
    init_request();
    init_transport();
    init_rpc2();
    init_createTransport();
  }
});

// node_modules/viem/dist/esm/constants/address.js
var zeroAddress;
var init_address2 = __esm({
  "node_modules/viem/dist/esm/constants/address.js"() {
    zeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/viem/dist/esm/constants/number.js
var maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;
var init_number = __esm({
  "node_modules/viem/dist/esm/constants/number.js"() {
    maxInt8 = 2n ** (8n - 1n);
    maxInt16 = 2n ** (16n - 1n);
    maxInt24 = 2n ** (24n - 1n);
    maxInt32 = 2n ** (32n - 1n);
    maxInt40 = 2n ** (40n - 1n);
    maxInt48 = 2n ** (48n - 1n);
    maxInt56 = 2n ** (56n - 1n);
    maxInt64 = 2n ** (64n - 1n);
    maxInt72 = 2n ** (72n - 1n);
    maxInt80 = 2n ** (80n - 1n);
    maxInt88 = 2n ** (88n - 1n);
    maxInt96 = 2n ** (96n - 1n);
    maxInt104 = 2n ** (104n - 1n);
    maxInt112 = 2n ** (112n - 1n);
    maxInt120 = 2n ** (120n - 1n);
    maxInt128 = 2n ** (128n - 1n);
    maxInt136 = 2n ** (136n - 1n);
    maxInt144 = 2n ** (144n - 1n);
    maxInt152 = 2n ** (152n - 1n);
    maxInt160 = 2n ** (160n - 1n);
    maxInt168 = 2n ** (168n - 1n);
    maxInt176 = 2n ** (176n - 1n);
    maxInt184 = 2n ** (184n - 1n);
    maxInt192 = 2n ** (192n - 1n);
    maxInt200 = 2n ** (200n - 1n);
    maxInt208 = 2n ** (208n - 1n);
    maxInt216 = 2n ** (216n - 1n);
    maxInt224 = 2n ** (224n - 1n);
    maxInt232 = 2n ** (232n - 1n);
    maxInt240 = 2n ** (240n - 1n);
    maxInt248 = 2n ** (248n - 1n);
    maxInt256 = 2n ** (256n - 1n);
    minInt8 = -(2n ** 8n);
    minInt16 = -(2n ** 16n);
    minInt24 = -(2n ** 24n);
    minInt32 = -(2n ** 32n);
    minInt40 = -(2n ** 40n);
    minInt48 = -(2n ** 48n);
    minInt56 = -(2n ** 56n);
    minInt64 = -(2n ** 64n);
    minInt72 = -(2n ** 72n);
    minInt80 = -(2n ** 80n);
    minInt88 = -(2n ** 88n);
    minInt96 = -(2n ** 96n);
    minInt104 = -(2n ** 104n);
    minInt112 = -(2n ** 112n);
    minInt120 = -(2n ** 120n);
    minInt128 = -(2n ** 128n);
    minInt136 = -(2n ** 136n);
    minInt144 = -(2n ** 144n);
    minInt152 = -(2n ** 152n);
    minInt160 = -(2n ** 160n);
    minInt168 = -(2n ** 168n);
    minInt176 = -(2n ** 176n);
    minInt184 = -(2n ** 184n);
    minInt192 = -(2n ** 192n);
    minInt200 = -(2n ** 200n);
    minInt208 = -(2n ** 208n);
    minInt216 = -(2n ** 216n);
    minInt224 = -(2n ** 224n);
    minInt232 = -(2n ** 232n);
    minInt240 = -(2n ** 240n);
    minInt248 = -(2n ** 248n);
    minInt256 = -(2n ** 256n);
    maxUint8 = 2n ** 8n;
    maxUint16 = 2n ** 16n;
    maxUint24 = 2n ** 24n;
    maxUint32 = 2n ** 32n;
    maxUint40 = 2n ** 40n;
    maxUint48 = 2n ** 48n;
    maxUint56 = 2n ** 56n;
    maxUint64 = 2n ** 64n;
    maxUint72 = 2n ** 72n;
    maxUint80 = 2n ** 80n;
    maxUint88 = 2n ** 88n;
    maxUint96 = 2n ** 96n;
    maxUint104 = 2n ** 104n;
    maxUint112 = 2n ** 112n;
    maxUint120 = 2n ** 120n;
    maxUint128 = 2n ** 128n;
    maxUint136 = 2n ** 136n;
    maxUint144 = 2n ** 144n;
    maxUint152 = 2n ** 152n;
    maxUint160 = 2n ** 160n;
    maxUint168 = 2n ** 168n;
    maxUint176 = 2n ** 176n;
    maxUint184 = 2n ** 184n;
    maxUint192 = 2n ** 192n;
    maxUint200 = 2n ** 200n;
    maxUint208 = 2n ** 208n;
    maxUint216 = 2n ** 216n;
    maxUint224 = 2n ** 224n;
    maxUint232 = 2n ** 232n;
    maxUint240 = 2n ** 240n;
    maxUint248 = 2n ** 248n;
    maxUint256 = 2n ** 256n;
  }
});

// node_modules/viem/dist/esm/utils/abi/decodeDeployData.js
var init_decodeDeployData = __esm({
  "node_modules/viem/dist/esm/utils/abi/decodeDeployData.js"() {
    init_abi();
    init_decodeAbiParameters();
  }
});

// node_modules/viem/dist/esm/utils/signature/hexToSignature.js
var init_hexToSignature = __esm({
  "node_modules/viem/dist/esm/utils/signature/hexToSignature.js"() {
    init_secp256k1();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/utils/signature/signatureToHex.js
var init_signatureToHex = __esm({
  "node_modules/viem/dist/esm/utils/signature/signatureToHex.js"() {
    init_secp256k1();
    init_fromHex();
    init_toHex();
  }
});

// node_modules/viem/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/viem/dist/esm/index.js"() {
    init_esm();
    init_getContract();
    init_addChain();
    init_call();
    init_createClient();
    init_custom();
    init_fallback();
    init_http();
    init_createPublicClient();
    init_createTestClient();
    init_public();
    init_test();
    init_wallet();
    init_createTransport();
    init_createWalletClient();
    init_webSocket();
    init_abis();
    init_address2();
    init_unit();
    init_number();
    init_abi();
    init_base();
    init_block2();
    init_contract();
    init_rpc();
    init_chain();
    init_encoding();
    init_ens();
    init_estimateGas();
    init_node();
    init_log2();
    init_request();
    init_address();
    init_transaction2();
    init_data();
    init_transport();
    init_labelhash();
    init_namehash();
    init_block();
    init_log();
    init_decodeAbiParameters();
    init_decodeDeployData();
    init_decodeErrorResult();
    init_decodeEventLog();
    init_decodeFunctionData();
    init_decodeFunctionResult();
    init_encodeAbiParameters();
    init_encodeDeployData();
    init_encodeErrorResult();
    init_encodeEventTopics();
    init_encodeFunctionData();
    init_encodeFunctionResult();
    init_transaction();
    init_transactionReceipt();
    init_transactionRequest();
    init_getAbiItem();
    init_getContractAddress();
    init_getSerializedTransactionType();
    init_getTransactionType();
    init_hashTypedData();
    init_hexToSignature();
    init_recoverAddress();
    init_recoverMessageAddress();
    init_recoverPublicKey();
    init_recoverTypedDataAddress();
    init_signatureToHex();
    init_toRlp();
    init_verifyMessage();
    init_verifyTypedData();
    init_assertRequest();
    init_assertTransaction();
    init_toBytes();
    init_toHex();
    init_fromBytes();
    init_ccip();
    init_concat();
    init_chain2();
    init_encodePacked();
    init_formatEther();
    init_formatGwei();
    init_formatUnits();
    init_fromHex();
    init_fromRlp();
    init_getAddress();
    init_getContractError();
    init_getEventSelector();
    init_getFunctionSelector();
    init_hashMessage();
    init_isAddress();
    init_isAddressEqual();
    init_isBytes();
    init_isHash();
    init_isHex();
    init_keccak256();
    init_pad();
    init_parseEther();
    init_parseGwei();
    init_parseTransaction();
    init_parseUnits();
    init_prepareRequest();
    init_serializeAccessList();
    init_serializeTransaction();
    init_size();
    init_slice();
    init_stringify();
    init_trim();
    init_typedData();
  }
});

// node_modules/viem/dist/esm/utils/data/isBytesEqual.js
function isBytesEqual(a_, b_) {
  const a = isHex(a_) ? toBytes(a_) : a_;
  const b = isHex(b_) ? toBytes(b_) : b_;
  return equalBytes(a, b);
}
var init_isBytesEqual = __esm({
  "node_modules/viem/dist/esm/utils/data/isBytesEqual.js"() {
    init_esm2();
    init_utils();
  }
});

// node_modules/viem/dist/esm/actions/public/verifyHash.js
async function verifyHash(client, { address, hash, signature, ...callRequest }) {
  const signatureHex = isHex(signature) ? signature : toHex(signature);
  try {
    const { data } = await call(client, {
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash, signatureHex],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...callRequest
    });
    return isBytesEqual(data ?? "0x0", "0x1");
  } catch (error) {
    if (error instanceof CallExecutionError) {
      return false;
    }
    throw error;
  }
}
var init_verifyHash = __esm({
  "node_modules/viem/dist/esm/actions/public/verifyHash.js"() {
    init_abis();
    init_contracts();
    init_contract();
    init_isBytesEqual();
    init_utils2();
    init_call();
  }
});

// node_modules/viem/dist/esm/actions/public/verifyMessage.js
async function verifyMessage2(client, { address, message, signature, ...callRequest }) {
  const hash = hashMessage(message);
  return verifyHash(client, {
    address,
    hash,
    signature,
    ...callRequest
  });
}
var init_verifyMessage2 = __esm({
  "node_modules/viem/dist/esm/actions/public/verifyMessage.js"() {
    init_utils2();
    init_verifyHash();
  }
});

// node_modules/viem/dist/esm/actions/public/verifyTypedData.js
async function verifyTypedData2(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
  const hash = hashTypedData({ message, primaryType, types, domain });
  return verifyHash(client, {
    address,
    hash,
    signature,
    ...callRequest
  });
}
var init_verifyTypedData2 = __esm({
  "node_modules/viem/dist/esm/actions/public/verifyTypedData.js"() {
    init_hashTypedData();
    init_verifyHash();
  }
});

// node_modules/viem/dist/esm/actions/public/watchBlockNumber.js
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {
      try {
        const blockNumber = await getBlockNumber(client, { cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
              emit.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            if (!active)
              return;
            const blockNumber = hexToBigInt(data.result?.number);
            onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
var init_watchBlockNumber = __esm({
  "node_modules/viem/dist/esm/actions/public/watchBlockNumber.js"() {
    init_fromHex();
    init_observe();
    init_poll();
    init_stringify();
    init_getBlockNumber();
  }
});

// node_modules/viem/dist/esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  return new Promise((resolve, reject) => {
    if (timeout)
      setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash })), timeout);
    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
      const _unwatch = watchBlockNumber(client, {
        emitMissed: true,
        emitOnBegin: true,
        poll: true,
        pollingInterval,
        async onBlockNumber(blockNumber_) {
          if (retrying)
            return;
          let blockNumber = blockNumber_;
          const done = (fn) => {
            _unwatch();
            fn();
            _unobserve();
          };
          try {
            if (receipt) {
              if (blockNumber - receipt.blockNumber + 1n < confirmations)
                return;
              done(() => emit.resolve(receipt));
              return;
            }
            if (!transaction) {
              retrying = true;
              await withRetry(async () => {
                transaction = await getTransaction(client, { hash });
                if (transaction.blockNumber)
                  blockNumber = transaction.blockNumber;
              }, {
                delay: ({ count }) => ~~(1 << count) * 200,
                retryCount: 6
              });
              retrying = false;
            }
            receipt = await getTransactionReceipt(client, { hash });
            if (confirmations > 0 && blockNumber - receipt.blockNumber + 1n < confirmations)
              return;
            done(() => emit.resolve(receipt));
          } catch (err) {
            if (transaction && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {
              replacedTransaction = transaction;
              const block = await getBlock(client, {
                blockNumber,
                includeTransactions: true
              });
              const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
              if (!replacementTransaction)
                return;
              receipt = await getTransactionReceipt(client, {
                hash: replacementTransaction.hash
              });
              if (blockNumber - receipt.blockNumber + 1n < confirmations)
                return;
              let reason = "replaced";
              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                reason = "repriced";
              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                reason = "cancelled";
              }
              done(() => {
                emit.onReplaced?.({
                  reason,
                  replacedTransaction,
                  transaction: replacementTransaction,
                  transactionReceipt: receipt
                });
                emit.resolve(receipt);
              });
            } else {
              done(() => emit.reject(err));
            }
          }
        }
      });
    });
  });
}
var init_waitForTransactionReceipt = __esm({
  "node_modules/viem/dist/esm/actions/public/waitForTransactionReceipt.js"() {
    init_transaction2();
    init_observe();
    init_withRetry();
    init_stringify();
    init_getBlock();
    init_getTransaction();
    init_getTransactionReceipt();
    init_watchBlockNumber();
  }
});

// node_modules/viem/dist/esm/actions/public/watchBlocks.js
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {
      try {
        const block = await getBlock(client, {
          blockTag,
          includeTransactions
        });
        if (block.number && prevBlock?.number) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = prevBlock?.number + 1n; i < block.number; i++) {
              const block2 = await getBlock(client, {
                blockNumber: i,
                includeTransactions
              });
              emit.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
          emit.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err) {
        emit.onError?.(err);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newHeads"],
          onData(data) {
            if (!active)
              return;
            const format = client.chain?.formatters?.block?.format || formatBlock;
            const block = format(data.result);
            onBlock(block, prevBlock);
            prevBlock = block;
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}
var init_watchBlocks = __esm({
  "node_modules/viem/dist/esm/actions/public/watchBlocks.js"() {
    init_block();
    init_observe();
    init_poll();
    init_stringify();
    init_getBlock();
  }
});

// node_modules/viem/dist/esm/actions/public/watchEvent.js
function watchEvent(client, { address, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const strict = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await createEventFilter(client, {
              address,
              args,
              event,
              events,
              strict
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getFilterChanges(client, { filter });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await uninstallFilter(client, { filter });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const events_ = events ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          topics = [
            events_.flatMap((event2) => encodeEventTopics({
              abi: [event2],
              eventName: event2.name,
              args
            }))
          ];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            if (!active)
              return;
            const log = data.result;
            try {
              const { eventName, args: args2 } = decodeEventLog({
                abi: events_,
                data: log.data,
                topics: log.topics,
                strict
              });
              const formatted = formatLog(log, {
                args: args2,
                eventName
              });
              onLogs([formatted]);
            } catch (err) {
              let eventName;
              let isUnnamed;
              if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}
var init_watchEvent = __esm({
  "node_modules/viem/dist/esm/actions/public/watchEvent.js"() {
    init_observe();
    init_poll();
    init_stringify();
    init_abi();
    init_rpc();
    init_utils2();
    init_createEventFilter();
    init_getBlockNumber();
    init_getFilterChanges();
    init_getLogs();
    init_uninstallFilter();
  }
});

// node_modules/viem/dist/esm/actions/public/watchPendingTransactions.js
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError }, (emit) => {
      let filter;
      const unwatch = poll(async () => {
        try {
          if (!filter) {
            try {
              filter = await createPendingTransactionFilter(client);
              return;
            } catch (err) {
              unwatch();
              throw err;
            }
          }
          const hashes = await getFilterChanges(client, { filter });
          if (hashes.length === 0)
            return;
          if (batch)
            emit.onTransactions(hashes);
          else
            hashes.forEach((hash) => emit.onTransactions([hash]));
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await uninstallFilter(client, { filter });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active = true;
    let unsubscribe = () => active = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error) {
            onError?.(error);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active)
          unsubscribe();
      } catch (err) {
        onError?.(err);
      }
    })();
    return unsubscribe;
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}
var init_watchPendingTransactions = __esm({
  "node_modules/viem/dist/esm/actions/public/watchPendingTransactions.js"() {
    init_observe();
    init_poll();
    init_stringify();
    init_createPendingTransactionFilter();
    init_getFilterChanges();
    init_uninstallFilter();
  }
});

// node_modules/viem/dist/esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args) => call(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getBytecode(client, args),
    getChainId: () => getChainId(client),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    readContract: (args) => readContract(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage2(client, args),
    verifyTypedData: (args) => verifyTypedData2(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  };
}
var init_public = __esm({
  "node_modules/viem/dist/esm/clients/decorators/public.js"() {
    init_getEnsAddress();
    init_getEnsAvatar();
    init_getEnsName();
    init_getEnsResolver();
    init_getEnsText();
    init_call();
    init_createBlockFilter();
    init_createContractEventFilter();
    init_createEventFilter();
    init_createPendingTransactionFilter();
    init_estimateContractGas();
    init_estimateGas2();
    init_getBalance();
    init_getBlock();
    init_getBlockNumber();
    init_getBlockTransactionCount();
    init_getBytecode();
    init_getChainId();
    init_getFeeHistory();
    init_getFilterChanges();
    init_getFilterLogs();
    init_getGasPrice();
    init_getLogs();
    init_getStorageAt();
    init_getTransaction();
    init_getTransactionConfirmations();
    init_getTransactionCount();
    init_getTransactionReceipt();
    init_multicall();
    init_readContract();
    init_simulateContract();
    init_uninstallFilter();
    init_verifyMessage2();
    init_verifyTypedData2();
    init_waitForTransactionReceipt();
    init_watchBlockNumber();
    init_watchBlocks();
    init_watchContractEvent();
    init_watchEvent();
    init_watchPendingTransactions();
  }
});

// node_modules/viem/dist/esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}
var init_createPublicClient = __esm({
  "node_modules/viem/dist/esm/clients/createPublicClient.js"() {
    init_createClient();
    init_public();
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@wagmi/connectors/dist/chunk-QYMCVNHT.js
var import_eventemitter3, __defProp, __defNormalProp, __publicField, __accessCheck, __privateGet2, __privateAdd2, __privateSet2, __privateMethod2, Connector;
var init_chunk_QYMCVNHT = __esm({
  "node_modules/@wagmi/connectors/dist/chunk-QYMCVNHT.js"() {
    import_eventemitter3 = __toESM(require_eventemitter3(), 1);
    init_chains();
    __defProp = Object.defineProperty;
    __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    __privateGet2 = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    __privateAdd2 = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    __privateSet2 = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    __privateMethod2 = (obj, member, method) => {
      __accessCheck(obj, member, "access private method");
      return method;
    };
    Connector = class extends import_eventemitter3.default {
      constructor({
        chains = [mainnet, goerli],
        options
      }) {
        super();
        __publicField(this, "chains");
        __publicField(this, "options");
        __publicField(this, "storage");
        this.chains = chains;
        this.options = options;
      }
      getBlockExplorerUrls(chain) {
        const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
        if (blockExplorer)
          return [
            blockExplorer.url,
            ...Object.values(blockExplorers).map((x) => x.url)
          ];
      }
      isChainUnsupported(chainId) {
        return !this.chains.some((x) => x.id === chainId);
      }
      setStorage(storage) {
        this.storage = storage;
      }
    };
  }
});

// node_modules/@wagmi/connectors/dist/chunk-ZCAPXGBX.js
var ChainNotConfiguredForConnectorError, ConnectorNotFoundError;
var init_chunk_ZCAPXGBX = __esm({
  "node_modules/@wagmi/connectors/dist/chunk-ZCAPXGBX.js"() {
    init_chunk_QYMCVNHT();
    ChainNotConfiguredForConnectorError = class extends Error {
      constructor({
        chainId,
        connectorId
      }) {
        super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
        __publicField(this, "name", "ChainNotConfiguredForConnectorError");
      }
    };
    ConnectorNotFoundError = class extends Error {
      constructor() {
        super(...arguments);
        __publicField(this, "name", "ConnectorNotFoundError");
        __publicField(this, "message", "Connector not found");
      }
    };
  }
});

// node_modules/@wagmi/connectors/dist/chunk-OQILYQDO.js
function normalizeChainId(chainId) {
  if (typeof chainId === "string")
    return Number.parseInt(
      chainId,
      chainId.trim().substring(0, 2) === "0x" ? 16 : 10
    );
  if (typeof chainId === "bigint")
    return Number(chainId);
  return chainId;
}
var init_chunk_OQILYQDO = __esm({
  "node_modules/@wagmi/connectors/dist/chunk-OQILYQDO.js"() {
  }
});

// node_modules/@wagmi/connectors/dist/index.js
var init_dist = __esm({
  "node_modules/@wagmi/connectors/dist/index.js"() {
    init_chunk_ZCAPXGBX();
    init_chunk_OQILYQDO();
    init_chunk_QYMCVNHT();
  }
});

// node_modules/@wagmi/connectors/dist/chunk-YZRVUC6Y.js
function getInjectedName(ethereum) {
  if (!ethereum)
    return "Injected";
  const getName = (provider) => {
    if (provider.isApexWallet)
      return "Apex Wallet";
    if (provider.isAvalanche)
      return "Core Wallet";
    if (provider.isBackpack)
      return "Backpack";
    if (provider.isBifrost)
      return "Bifrost Wallet";
    if (provider.isBitKeep)
      return "BitKeep";
    if (provider.isBitski)
      return "Bitski";
    if (provider.isBlockWallet)
      return "BlockWallet";
    if (provider.isBraveWallet)
      return "Brave Wallet";
    if (provider.isCoin98)
      return "Coin98 Wallet";
    if (provider.isCoinbaseWallet)
      return "Coinbase Wallet";
    if (provider.isDawn)
      return "Dawn Wallet";
    if (provider.isDefiant)
      return "Defiant";
    if (provider.isDesig)
      return "Desig Wallet";
    if (provider.isEnkrypt)
      return "Enkrypt";
    if (provider.isExodus)
      return "Exodus";
    if (provider.isFordefi)
      return "Fordefi";
    if (provider.isFrame)
      return "Frame";
    if (provider.isFrontier)
      return "Frontier Wallet";
    if (provider.isGamestop)
      return "GameStop Wallet";
    if (provider.isHaqqWallet)
      return "HAQQ Wallet";
    if (provider.isHyperPay)
      return "HyperPay Wallet";
    if (provider.isImToken)
      return "ImToken";
    if (provider.isHaloWallet)
      return "Halo Wallet";
    if (provider.isKuCoinWallet)
      return "KuCoin Wallet";
    if (provider.isMathWallet)
      return "MathWallet";
    if (provider.isNovaWallet)
      return "Nova Wallet";
    if (provider.isOkxWallet || provider.isOKExWallet)
      return "OKX Wallet";
    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)
      return "1inch Wallet";
    if (provider.isOpera)
      return "Opera";
    if (provider.isPhantom)
      return "Phantom";
    if (provider.isPortal)
      return "Ripio Portal";
    if (provider.isRabby)
      return "Rabby Wallet";
    if (provider.isRainbow)
      return "Rainbow";
    if (provider.isStatus)
      return "Status";
    if (provider.isSubWallet)
      return "SubWallet";
    if (provider.isTalisman)
      return "Talisman";
    if (provider.isTally)
      return "Taho";
    if (provider.isTokenPocket)
      return "TokenPocket";
    if (provider.isTokenary)
      return "Tokenary";
    if (provider.isTrust || provider.isTrustWallet)
      return "Trust Wallet";
    if (provider.isTTWallet)
      return "TTWallet";
    if (provider.isXDEFI)
      return "XDEFI Wallet";
    if (provider.isZerion)
      return "Zerion";
    if (provider.isMetaMask)
      return "MetaMask";
  };
  if (ethereum.providers?.length) {
    const nameSet = /* @__PURE__ */ new Set();
    let unknownCount = 1;
    for (const provider of ethereum.providers) {
      let name = getName(provider);
      if (!name) {
        name = `Unknown Wallet #${unknownCount}`;
        unknownCount += 1;
      }
      nameSet.add(name);
    }
    const names = [...nameSet];
    if (names.length)
      return names;
    return names[0] ?? "Injected";
  }
  return getName(ethereum) ?? "Injected";
}
var _provider, InjectedConnector;
var init_chunk_YZRVUC6Y = __esm({
  "node_modules/@wagmi/connectors/dist/chunk-YZRVUC6Y.js"() {
    init_chunk_ZCAPXGBX();
    init_chunk_OQILYQDO();
    init_chunk_QYMCVNHT();
    init_esm2();
    InjectedConnector = class extends Connector {
      constructor({
        chains,
        options: options_
      } = {}) {
        const options = {
          shimDisconnect: true,
          getProvider() {
            if (typeof window === "undefined")
              return;
            const ethereum = window.ethereum;
            if (ethereum?.providers)
              return ethereum.providers[0];
            return ethereum;
          },
          ...options_
        };
        super({ chains, options });
        __publicField(this, "id", "injected");
        __publicField(this, "name");
        __publicField(this, "ready");
        __privateAdd2(this, _provider, void 0);
        __publicField(this, "shimDisconnectKey", `${this.id}.shimDisconnect`);
        __publicField(this, "onAccountsChanged", (accounts) => {
          if (accounts.length === 0)
            this.emit("disconnect");
          else
            this.emit("change", {
              account: getAddress(accounts[0])
            });
        });
        __publicField(this, "onChainChanged", (chainId) => {
          const id = normalizeChainId(chainId);
          const unsupported = this.isChainUnsupported(id);
          this.emit("change", { chain: { id, unsupported } });
        });
        __publicField(this, "onDisconnect", async (error) => {
          if (error.code === 1013) {
            const provider2 = await this.getProvider();
            if (provider2) {
              const isAuthorized = await this.getAccount();
              if (isAuthorized)
                return;
            }
          }
          this.emit("disconnect");
          if (this.options.shimDisconnect)
            this.storage?.removeItem(this.shimDisconnectKey);
        });
        const provider = options.getProvider();
        if (typeof options.name === "string")
          this.name = options.name;
        else if (provider) {
          const detectedName = getInjectedName(provider);
          if (options.name)
            this.name = options.name(detectedName);
          else {
            if (typeof detectedName === "string")
              this.name = detectedName;
            else
              this.name = detectedName[0];
          }
        } else
          this.name = "Injected";
        this.ready = !!provider;
      }
      async connect({ chainId } = {}) {
        try {
          const provider = await this.getProvider();
          if (!provider)
            throw new ConnectorNotFoundError();
          if (provider.on) {
            provider.on("accountsChanged", this.onAccountsChanged);
            provider.on("chainChanged", this.onChainChanged);
            provider.on("disconnect", this.onDisconnect);
          }
          this.emit("message", { type: "connecting" });
          const accounts = await provider.request({
            method: "eth_requestAccounts"
          });
          const account = getAddress(accounts[0]);
          let id = await this.getChainId();
          let unsupported = this.isChainUnsupported(id);
          if (chainId && id !== chainId) {
            const chain = await this.switchChain(chainId);
            id = chain.id;
            unsupported = this.isChainUnsupported(id);
          }
          if (this.options.shimDisconnect)
            this.storage?.setItem(this.shimDisconnectKey, true);
          return { account, chain: { id, unsupported } };
        } catch (error) {
          if (this.isUserRejectedRequestError(error))
            throw new UserRejectedRequestError(error);
          if (error.code === -32002)
            throw new ResourceUnavailableRpcError(error);
          throw error;
        }
      }
      async disconnect() {
        const provider = await this.getProvider();
        if (!provider?.removeListener)
          return;
        provider.removeListener("accountsChanged", this.onAccountsChanged);
        provider.removeListener("chainChanged", this.onChainChanged);
        provider.removeListener("disconnect", this.onDisconnect);
        if (this.options.shimDisconnect)
          this.storage?.removeItem(this.shimDisconnectKey);
      }
      async getAccount() {
        const provider = await this.getProvider();
        if (!provider)
          throw new ConnectorNotFoundError();
        const accounts = await provider.request({
          method: "eth_accounts"
        });
        return getAddress(accounts[0]);
      }
      async getChainId() {
        const provider = await this.getProvider();
        if (!provider)
          throw new ConnectorNotFoundError();
        return provider.request({ method: "eth_chainId" }).then(normalizeChainId);
      }
      async getProvider() {
        const provider = this.options.getProvider();
        if (provider)
          __privateSet2(this, _provider, provider);
        return __privateGet2(this, _provider);
      }
      async getWalletClient({
        chainId
      } = {}) {
        const [provider, account] = await Promise.all([
          this.getProvider(),
          this.getAccount()
        ]);
        const chain = this.chains.find((x) => x.id === chainId);
        if (!provider)
          throw new Error("provider is required.");
        return createWalletClient({
          account,
          chain,
          transport: custom(provider)
        });
      }
      async isAuthorized() {
        try {
          if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey))
            return false;
          const provider = await this.getProvider();
          if (!provider)
            throw new ConnectorNotFoundError();
          const account = await this.getAccount();
          return !!account;
        } catch {
          return false;
        }
      }
      async switchChain(chainId) {
        const provider = await this.getProvider();
        if (!provider)
          throw new ConnectorNotFoundError();
        const id = numberToHex(chainId);
        try {
          await Promise.all([
            provider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: id }]
            }),
            new Promise(
              (res) => this.on("change", ({ chain }) => {
                if (chain?.id === chainId)
                  res();
              })
            )
          ]);
          return this.chains.find((x) => x.id === chainId) ?? {
            id: chainId,
            name: `Chain ${id}`,
            network: `${id}`,
            nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
            rpcUrls: { default: { http: [""] }, public: { http: [""] } }
          };
        } catch (error) {
          const chain = this.chains.find((x) => x.id === chainId);
          if (!chain)
            throw new ChainNotConfiguredForConnectorError({
              chainId,
              connectorId: this.id
            });
          if (error.code === 4902 || error?.data?.originalError?.code === 4902) {
            try {
              await provider.request({
                method: "wallet_addEthereumChain",
                params: [
                  {
                    chainId: id,
                    chainName: chain.name,
                    nativeCurrency: chain.nativeCurrency,
                    rpcUrls: [chain.rpcUrls.public?.http[0] ?? ""],
                    blockExplorerUrls: this.getBlockExplorerUrls(chain)
                  }
                ]
              });
              const currentChainId = await this.getChainId();
              if (currentChainId !== chainId)
                throw new UserRejectedRequestError(
                  new Error("User rejected switch after adding network.")
                );
              return chain;
            } catch (error2) {
              throw new UserRejectedRequestError(error2);
            }
          }
          if (this.isUserRejectedRequestError(error))
            throw new UserRejectedRequestError(error);
          throw new SwitchChainError(error);
        }
      }
      async watchAsset({
        address,
        decimals = 18,
        image,
        symbol
      }) {
        const provider = await this.getProvider();
        if (!provider)
          throw new ConnectorNotFoundError();
        return provider.request({
          method: "wallet_watchAsset",
          params: {
            type: "ERC20",
            options: {
              address,
              decimals,
              image,
              symbol
            }
          }
        });
      }
      isUserRejectedRequestError(error) {
        return error.code === 4001;
      }
    };
    _provider = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@wagmi/connectors/dist/injected.js
var init_injected = __esm({
  "node_modules/@wagmi/connectors/dist/injected.js"() {
    init_chunk_YZRVUC6Y();
    init_chunk_ZCAPXGBX();
    init_chunk_OQILYQDO();
    init_chunk_QYMCVNHT();
  }
});

// node_modules/@wagmi/core/dist/chunk-BVC4KGLQ.js
var init_chunk_BVC4KGLQ = __esm({
  "node_modules/@wagmi/core/dist/chunk-BVC4KGLQ.js"() {
    init_dist();
    init_injected();
  }
});

// node_modules/zustand/esm/middleware.mjs
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
var subscribeWithSelectorImpl, subscribeWithSelector, toThenable, oldImpl, newImpl, persistImpl, persist;
var init_middleware = __esm({
  "node_modules/zustand/esm/middleware.mjs"() {
    subscribeWithSelectorImpl = (fn) => (set, get, api) => {
      const origSubscribe = api.subscribe;
      api.subscribe = (selector, optListener, options) => {
        let listener = selector;
        if (optListener) {
          const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
          let currentSlice = selector(api.getState());
          listener = (state) => {
            const nextSlice = selector(state);
            if (!equalityFn(currentSlice, nextSlice)) {
              const previousSlice = currentSlice;
              optListener(currentSlice = nextSlice, previousSlice);
            }
          };
          if (options == null ? void 0 : options.fireImmediately) {
            optListener(currentSlice, currentSlice);
          }
        }
        return origSubscribe(listener);
      };
      const initialState = fn(set, get, api);
      return initialState;
    };
    subscribeWithSelector = subscribeWithSelectorImpl;
    toThenable = (fn) => (input) => {
      try {
        const result = fn(input);
        if (result instanceof Promise) {
          return result;
        }
        return {
          then(onFulfilled) {
            return toThenable(onFulfilled)(result);
          },
          catch(_onRejected) {
            return this;
          }
        };
      } catch (e) {
        return {
          then(_onFulfilled) {
            return this;
          },
          catch(onRejected) {
            return toThenable(onRejected)(e);
          }
        };
      }
    };
    oldImpl = (config2, baseOptions) => (set, get, api) => {
      let options = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage;
      try {
        storage = options.getStorage();
      } catch (e) {
      }
      if (!storage) {
        return config2(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const thenableSerialize = toThenable(options.serialize);
      const setItem = () => {
        const state = options.partialize({ ...get() });
        let errorInSync;
        const thenable = thenableSerialize({ state, version: options.version }).then(
          (serializedValue) => storage.setItem(options.name, serializedValue)
        ).catch((e) => {
          errorInSync = e;
        });
        if (errorInSync) {
          throw errorInSync;
        }
        return thenable;
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config2(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      let stateFromStorage;
      const hydrate = () => {
        var _a;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => cb(get()));
        const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
          if (storageValue) {
            return options.deserialize(storageValue);
          }
        }).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.getStorage) {
            storage = newOptions.getStorage();
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      hydrate();
      return stateFromStorage || configResult;
    };
    newImpl = (config2, baseOptions) => (set, get, api) => {
      let options = {
        storage: createJSONStorage(() => localStorage),
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage = options.storage;
      if (!storage) {
        return config2(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const setItem = () => {
        const state = options.partialize({ ...get() });
        return storage.setItem(options.name, {
          state,
          version: options.version
        });
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config2(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      let stateFromStorage;
      const hydrate = () => {
        var _a, _b;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => {
          var _a2;
          return cb((_a2 = get()) != null ? _a2 : configResult);
        });
        const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          stateFromStorage = get();
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.storage) {
            storage = newOptions.storage;
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      if (!options.skipHydration) {
        hydrate();
      }
      return stateFromStorage || configResult;
    };
    persistImpl = (config2, baseOptions) => {
      if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
          );
        }
        return oldImpl(config2, baseOptions);
      }
      return newImpl(config2, baseOptions);
    };
    persist = persistImpl;
  }
});

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl, createStore;
var init_vanilla = __esm({
  "node_modules/zustand/esm/vanilla.mjs"() {
    createStoreImpl = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, subscribe, destroy };
      state = createState(setState, getState, api);
      return api;
    };
    createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
  }
});

// node_modules/zustand/esm/shallow.mjs
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
var init_shallow = __esm({
  "node_modules/zustand/esm/shallow.mjs"() {
  }
});

// node_modules/@wagmi/core/dist/chunk-LAFZBYO7.js
function configureChains(defaultChains, providers, {
  batch = { multicall: { wait: 32 } },
  pollingInterval = 4e3,
  rank,
  retryCount,
  retryDelay,
  stallTimeout
} = {}) {
  if (!defaultChains.length)
    throw new Error("must have at least one chain");
  let chains = [];
  const httpUrls = {};
  const wsUrls = {};
  for (const chain of defaultChains) {
    let configExists = false;
    for (const provider of providers) {
      const apiConfig = provider(chain);
      if (!apiConfig)
        continue;
      configExists = true;
      if (!chains.some(({ id }) => id === chain.id)) {
        chains = [...chains, apiConfig.chain];
      }
      httpUrls[chain.id] = [
        ...httpUrls[chain.id] || [],
        ...apiConfig.rpcUrls.http
      ];
      if (apiConfig.rpcUrls.webSocket) {
        wsUrls[chain.id] = [
          ...wsUrls[chain.id] || [],
          ...apiConfig.rpcUrls.webSocket
        ];
      }
    }
    if (!configExists) {
      throw new Error(
        [
          `Could not find valid provider configuration for chain "${chain.name}".
`,
          "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
          "Read more: https://wagmi.sh/core/providers/jsonRpc"
        ].join("\n")
      );
    }
  }
  return {
    chains,
    publicClient: ({ chainId }) => {
      const activeChain = chains.find((x) => x.id === chainId) ?? defaultChains[0];
      const chainHttpUrls = httpUrls[activeChain.id];
      if (!chainHttpUrls || !chainHttpUrls[0])
        throw new Error(`No providers configured for chain "${activeChain.id}"`);
      const publicClient = createPublicClient({
        batch,
        chain: activeChain,
        transport: fallback(
          chainHttpUrls.map((url) => http(url, { timeout: stallTimeout })),
          { rank, retryCount, retryDelay }
        ),
        pollingInterval
      });
      return Object.assign(publicClient, {
        chains
      });
    },
    webSocketPublicClient: ({ chainId }) => {
      const activeChain = chains.find((x) => x.id === chainId) ?? defaultChains[0];
      const chainWsUrls = wsUrls[activeChain.id];
      if (!chainWsUrls || !chainWsUrls[0])
        return void 0;
      const publicClient = createPublicClient({
        batch,
        chain: activeChain,
        transport: fallback(
          chainWsUrls.map((url) => webSocket(url, { timeout: stallTimeout })),
          { rank, retryCount, retryDelay }
        ),
        pollingInterval
      });
      return Object.assign(publicClient, {
        chains
      });
    }
  };
}
function deepEqual(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a === "object" && typeof b === "object") {
    if (a.constructor !== b.constructor)
      return false;
    let length;
    let i;
    if (Array.isArray(a) && Array.isArray(b)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!deepEqual(a[i], b[i]))
          return false;
      return true;
    }
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    const keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key && !deepEqual(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}
function deserialize(cachedString) {
  const cache = JSON.parse(cachedString);
  const deserializedCacheWithBigInts = findAndReplace(cache, {
    find: (data) => typeof data === "string" && data.startsWith("#bigint."),
    replace: (data) => BigInt(data.replace("#bigint.", ""))
  });
  return deserializedCacheWithBigInts;
}
function getUnit(unit) {
  if (typeof unit === "number")
    return unit;
  if (unit === "wei")
    return 0;
  return Math.abs(weiUnits[unit]);
}
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length } = array;
  for (let index2 = 0; index2 < length; ++index2) {
    if (array[index2] === value) {
      return index2 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(
            this,
            key,
            value,
            getReferenceKey(keys, valueCutoff)
          ) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize(value, replacer, indent, circularReplacer) {
  return JSON.stringify(
    value,
    createReplacer((key, value_) => {
      const value2 = typeof value_ === "bigint" ? `#bigint.${value_.toString()}` : value_;
      return replacer?.(key, value2) || value2;
    }, circularReplacer),
    indent ?? void 0
  );
}
function createStorage({
  deserialize: deserialize2 = deserialize,
  key: prefix = "wagmi",
  serialize: serialize2 = serialize,
  storage
}) {
  return {
    ...storage,
    getItem: (key, defaultState = null) => {
      const value = storage.getItem(`${prefix}.${key}`);
      try {
        return value ? deserialize2(value) : defaultState;
      } catch (error) {
        console.warn(error);
        return defaultState;
      }
    },
    setItem: (key, value) => {
      if (value === null) {
        storage.removeItem(`${prefix}.${key}`);
      } else {
        try {
          storage.setItem(`${prefix}.${key}`, serialize2(value));
        } catch (err) {
          console.error(err);
        }
      }
    },
    removeItem: (key) => storage.removeItem(`${prefix}.${key}`)
  };
}
function createConfig(args) {
  const config_ = new Config(args);
  config = config_;
  return config_;
}
function getConfig() {
  if (!config) {
    throw new Error(
      "No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config"
    );
  }
  return config;
}
async function connect({ chainId, connector }) {
  const config2 = getConfig();
  const activeConnector = config2.connector;
  if (activeConnector && connector.id === activeConnector.id)
    throw new ConnectorAlreadyConnectedError();
  try {
    config2.setState((x) => ({ ...x, status: "connecting" }));
    const data = await connector.connect({ chainId });
    config2.setLastUsedConnector(connector.id);
    config2.setState((x) => ({
      ...x,
      connector,
      chains: connector?.chains,
      data,
      status: "connected"
    }));
    config2.storage.setItem("connected", true);
    return { ...data, connector };
  } catch (err) {
    config2.setState((x) => {
      return {
        ...x,
        status: x.connector ? "connected" : "disconnected"
      };
    });
    throw err;
  }
}
async function disconnect() {
  const config2 = getConfig();
  if (config2.connector)
    await config2.connector.disconnect();
  config2.clearState();
  config2.storage.removeItem("connected");
}
function getPublicClient({ chainId } = {}) {
  const config2 = getConfig();
  if (chainId)
    return config2.getPublicClient({ chainId }) || config2.publicClient;
  return config2.publicClient;
}
function watchPublicClient(args, callback) {
  const config2 = getConfig();
  const handleChange = async () => callback(getPublicClient(args));
  const unsubscribe = config2.subscribe(
    ({ publicClient }) => publicClient,
    handleChange
  );
  return unsubscribe;
}
async function multicall2({
  chainId,
  contracts,
  blockNumber,
  blockTag,
  ...args
}) {
  const publicClient = getPublicClient({ chainId });
  if (!publicClient.chains)
    throw new ConfigChainsNotFound();
  if (chainId && publicClient.chain.id !== chainId)
    throw new ChainNotConfiguredError({ chainId });
  return publicClient.multicall({
    allowFailure: args.allowFailure ?? true,
    blockNumber,
    blockTag,
    contracts
  });
}
async function readContract2({
  address,
  account,
  chainId,
  abi,
  args,
  functionName,
  blockNumber,
  blockTag
}) {
  const publicClient = getPublicClient({ chainId });
  return publicClient.readContract({
    abi,
    address,
    account,
    functionName,
    args,
    blockNumber,
    blockTag
  });
}
async function readContracts({
  contracts,
  blockNumber,
  blockTag,
  ...args
}) {
  const { allowFailure = true } = args;
  try {
    const publicClient = getPublicClient();
    const contractsByChainId = contracts.reduce((contracts2, contract, index2) => {
      const chainId = contract.chainId ?? publicClient.chain.id;
      return {
        ...contracts2,
        [chainId]: [...contracts2[chainId] || [], { contract, index: index2 }]
      };
    }, {});
    const promises = () => Object.entries(contractsByChainId).map(
      ([chainId, contracts2]) => multicall2({
        allowFailure,
        chainId: parseInt(chainId),
        contracts: contracts2.map(
          ({ contract }) => contract
        ),
        blockNumber,
        blockTag
      })
    );
    const multicallResults = (await Promise.all(promises())).flat();
    const resultIndexes = Object.values(contractsByChainId).flatMap(
      (contracts2) => contracts2.map(({ index: index2 }) => index2)
    );
    return multicallResults.reduce((results, result, index2) => {
      if (results)
        results[resultIndexes[index2]] = result;
      return results;
    }, []);
  } catch (err) {
    if (err instanceof ContractFunctionExecutionError)
      throw err;
    const promises = () => contracts.map(
      (contract) => readContract2({ ...contract, blockNumber, blockTag })
    );
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result) => {
        if (result.status === "fulfilled")
          return { result: result.value, status: "success" };
        return { error: result.reason, result: void 0, status: "failure" };
      });
    return await Promise.all(promises());
  }
}
async function fetchBalance({
  address,
  chainId,
  formatUnits: unit,
  token
}) {
  const config2 = getConfig();
  const publicClient = getPublicClient({ chainId });
  if (token) {
    const fetchContractBalance = async ({ abi }) => {
      const erc20Config = { abi, address: token, chainId };
      const [value2, decimals, symbol] = await readContracts({
        allowFailure: false,
        contracts: [
          {
            ...erc20Config,
            functionName: "balanceOf",
            args: [address]
          },
          { ...erc20Config, functionName: "decimals" },
          { ...erc20Config, functionName: "symbol" }
        ]
      });
      return {
        decimals,
        formatted: formatUnits(value2 ?? "0", getUnit(unit ?? decimals)),
        symbol,
        value: value2
      };
    };
    try {
      return await fetchContractBalance({ abi: erc20ABI });
    } catch (err) {
      if (err instanceof ContractFunctionExecutionError) {
        const { symbol, ...rest } = await fetchContractBalance({
          abi: erc20ABI_bytes32
        });
        return {
          symbol: hexToString(trim(symbol, { dir: "right" })),
          ...rest
        };
      }
      throw err;
    }
  }
  const chains = [
    ...config2.publicClient.chains || [],
    ...config2.chains ?? []
  ];
  const value = await publicClient.getBalance({ address });
  const chain = chains.find((x) => x.id === publicClient.chain.id);
  return {
    decimals: chain?.nativeCurrency.decimals ?? 18,
    formatted: formatUnits(value ?? "0", getUnit(unit ?? 18)),
    symbol: chain?.nativeCurrency.symbol ?? "ETH",
    value
  };
}
function getAccount() {
  const { data, connector, status } = getConfig();
  switch (status) {
    case "connected":
      return {
        address: data?.account,
        connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address: data?.account,
        connector,
        isConnected: !!data?.account,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address: data?.account,
        connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}
function getNetwork() {
  const config2 = getConfig();
  const chainId = config2.data?.chain?.id;
  const activeChains = config2.chains ?? [];
  const activeChain = [
    ...config2.publicClient?.chains || [],
    ...activeChains
  ].find((x) => x.id === chainId) ?? {
    id: chainId,
    name: `Chain ${chainId}`,
    network: `${chainId}`,
    nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
    rpcUrls: {
      default: { http: [""] },
      public: { http: [""] }
    }
  };
  return {
    chain: chainId ? {
      ...activeChain,
      ...config2.data?.chain,
      id: chainId
    } : void 0,
    chains: activeChains
  };
}
async function switchNetwork({
  chainId
}) {
  const { connector } = getConfig();
  if (!connector)
    throw new ConnectorNotFoundError();
  if (!connector.switchChain)
    throw new SwitchChainNotSupportedError({
      connector
    });
  return connector.switchChain(chainId);
}
function watchAccount(callback, { selector = (x) => x } = {}) {
  const config2 = getConfig();
  const handleChange = () => callback(getAccount());
  const unsubscribe = config2.subscribe(
    ({ data, connector, status }) => selector({
      address: data?.account,
      connector,
      status
    }),
    handleChange,
    {
      equalityFn: shallow
    }
  );
  return unsubscribe;
}
function watchNetwork(callback, { selector = (x) => x } = {}) {
  const config2 = getConfig();
  const handleChange = () => callback(getNetwork());
  const unsubscribe = config2.subscribe(
    ({ data, chains }) => selector({ chainId: data?.chain?.id, chains }),
    handleChange,
    {
      equalityFn: shallow
    }
  );
  return unsubscribe;
}
async function fetchEnsAvatar({
  name,
  chainId
}) {
  const publicClient = getPublicClient({ chainId });
  const avatar = await publicClient.getEnsAvatar({ name: normalize(name) });
  return avatar;
}
async function fetchEnsName({
  address,
  chainId
}) {
  const publicClient = getPublicClient({ chainId });
  return publicClient.getEnsName({
    address: getAddress(address)
  });
}
var ChainNotConfiguredError, ConnectorAlreadyConnectedError, ConfigChainsNotFound, SwitchChainNotSupportedError, findAndReplace, noopStorage, storeKey, _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn, Config, config, erc20ABI, erc20ABI_bytes32;
var init_chunk_LAFZBYO7 = __esm({
  "node_modules/@wagmi/core/dist/chunk-LAFZBYO7.js"() {
    init_chunk_BVC4KGLQ();
    init_chunk_MQXBDTVK();
    init_esm2();
    init_dist();
    init_esm2();
    init_middleware();
    init_vanilla();
    init_esm2();
    init_esm2();
    init_shallow();
    init_esm2();
    init_esm2();
    init_shallow();
    init_shallow();
    init_shallow();
    init_shallow();
    init_esm2();
    init_ens2();
    init_ens2();
    init_esm2();
    init_ens2();
    init_esm2();
    init_esm2();
    init_esm2();
    init_shallow();
    ChainNotConfiguredError = class extends Error {
      constructor({
        chainId,
        connectorId
      }) {
        super(
          `Chain "${chainId}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`
        );
        this.name = "ChainNotConfigured";
      }
    };
    ConnectorAlreadyConnectedError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConnectorAlreadyConnectedError";
        this.message = "Connector already connected";
      }
    };
    ConfigChainsNotFound = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConfigChainsNotFound";
        this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work.";
      }
    };
    SwitchChainNotSupportedError = class extends Error {
      constructor({ connector }) {
        super(`"${connector.name}" does not support programmatic chain switching.`);
        this.name = "SwitchChainNotSupportedError";
      }
    };
    findAndReplace = (cacheRef, {
      find,
      replace
    }) => {
      if (cacheRef && find(cacheRef)) {
        return replace(cacheRef);
      }
      if (typeof cacheRef !== "object") {
        return cacheRef;
      }
      if (Array.isArray(cacheRef)) {
        return cacheRef.map((item) => findAndReplace(item, { find, replace }));
      }
      if (cacheRef instanceof Object) {
        return Object.entries(cacheRef).reduce(
          (curr, [key, value]) => ({
            ...curr,
            [key]: findAndReplace(value, { find, replace })
          }),
          {}
        );
      }
      return cacheRef;
    };
    noopStorage = {
      getItem: (_key) => "",
      setItem: (_key, _value) => null,
      removeItem: (_key) => null
    };
    storeKey = "store";
    Config = class {
      constructor({
        autoConnect = false,
        connectors = [new InjectedConnector()],
        publicClient,
        storage = createStorage({
          storage: typeof window !== "undefined" ? window.localStorage : noopStorage
        }),
        logger = {
          warn: console.warn
        },
        webSocketPublicClient
      }) {
        __privateAdd(this, _addEffects);
        this.publicClients = /* @__PURE__ */ new Map();
        this.webSocketPublicClients = /* @__PURE__ */ new Map();
        __privateAdd(this, _isAutoConnecting, void 0);
        __privateAdd(this, _lastUsedConnector, void 0);
        this.args = {
          autoConnect,
          connectors,
          logger,
          publicClient,
          storage,
          webSocketPublicClient
        };
        let status = "disconnected";
        let chainId;
        if (autoConnect) {
          try {
            const rawState = storage.getItem(storeKey);
            const data = rawState?.state?.data;
            status = data?.account ? "reconnecting" : "connecting";
            chainId = data?.chain?.id;
          } catch (_error) {
          }
        }
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector) => connector.setStorage(storage));
        this.store = createStore(
          subscribeWithSelector(
            persist(
              () => ({
                connectors: connectors_,
                publicClient: this.getPublicClient({ chainId }),
                status,
                webSocketPublicClient: this.getWebSocketPublicClient({ chainId })
              }),
              {
                name: storeKey,
                storage,
                partialize: (state) => ({
                  ...autoConnect && {
                    data: {
                      account: state?.data?.account,
                      chain: state?.data?.chain
                    }
                  },
                  chains: state?.chains
                }),
                version: 2
              }
            )
          )
        );
        this.storage = storage;
        __privateSet(this, _lastUsedConnector, storage?.getItem("wallet"));
        __privateMethod(this, _addEffects, addEffects_fn).call(this);
        if (autoConnect && typeof window !== "undefined")
          setTimeout(async () => await this.autoConnect(), 0);
      }
      get chains() {
        return this.store.getState().chains;
      }
      get connectors() {
        return this.store.getState().connectors;
      }
      get connector() {
        return this.store.getState().connector;
      }
      get data() {
        return this.store.getState().data;
      }
      get error() {
        return this.store.getState().error;
      }
      get lastUsedChainId() {
        return this.data?.chain?.id;
      }
      get publicClient() {
        return this.store.getState().publicClient;
      }
      get status() {
        return this.store.getState().status;
      }
      get subscribe() {
        return this.store.subscribe;
      }
      get webSocketPublicClient() {
        return this.store.getState().webSocketPublicClient;
      }
      setState(updater) {
        const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
        this.store.setState(newState, true);
      }
      clearState() {
        this.setState((x) => ({
          ...x,
          chains: void 0,
          connector: void 0,
          data: void 0,
          error: void 0,
          status: "disconnected"
        }));
      }
      async destroy() {
        if (this.connector)
          await this.connector.disconnect?.();
        __privateSet(this, _isAutoConnecting, false);
        this.clearState();
        this.store.destroy();
      }
      async autoConnect() {
        if (__privateGet(this, _isAutoConnecting))
          return;
        __privateSet(this, _isAutoConnecting, true);
        this.setState((x) => ({
          ...x,
          status: x.data?.account ? "reconnecting" : "connecting"
        }));
        const sorted = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(
          (x) => x.id === __privateGet(this, _lastUsedConnector) ? -1 : 1
        ) : this.connectors;
        let connected = false;
        for (const connector of sorted) {
          if (!connector.ready || !connector.isAuthorized)
            continue;
          const isAuthorized = await connector.isAuthorized();
          if (!isAuthorized)
            continue;
          const data = await connector.connect();
          this.setState((x) => ({
            ...x,
            connector,
            chains: connector?.chains,
            data,
            status: "connected"
          }));
          connected = true;
          break;
        }
        if (!connected)
          this.setState((x) => ({
            ...x,
            data: void 0,
            status: "disconnected"
          }));
        __privateSet(this, _isAutoConnecting, false);
        return this.data;
      }
      setConnectors(connectors) {
        this.args = {
          ...this.args,
          connectors
        };
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector) => connector.setStorage(this.args.storage));
        this.setState((x) => ({
          ...x,
          connectors: connectors_
        }));
      }
      getPublicClient({ chainId } = {}) {
        let publicClient_ = this.publicClients.get(-1);
        if (publicClient_ && publicClient_?.chain.id === chainId)
          return publicClient_;
        publicClient_ = this.publicClients.get(chainId ?? -1);
        if (publicClient_)
          return publicClient_;
        const { publicClient } = this.args;
        publicClient_ = typeof publicClient === "function" ? publicClient({ chainId }) : publicClient;
        this.publicClients.set(chainId ?? -1, publicClient_);
        return publicClient_;
      }
      setPublicClient(publicClient) {
        const chainId = this.data?.chain?.id;
        this.args = {
          ...this.args,
          publicClient
        };
        this.publicClients.clear();
        this.setState((x) => ({
          ...x,
          publicClient: this.getPublicClient({ chainId })
        }));
      }
      getWebSocketPublicClient({ chainId } = {}) {
        let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);
        if (webSocketPublicClient_ && webSocketPublicClient_?.chain.id === chainId)
          return webSocketPublicClient_;
        webSocketPublicClient_ = this.webSocketPublicClients.get(chainId ?? -1);
        if (webSocketPublicClient_)
          return webSocketPublicClient_;
        const { webSocketPublicClient } = this.args;
        webSocketPublicClient_ = typeof webSocketPublicClient === "function" ? webSocketPublicClient({ chainId }) : webSocketPublicClient;
        if (webSocketPublicClient_)
          this.webSocketPublicClients.set(chainId ?? -1, webSocketPublicClient_);
        return webSocketPublicClient_;
      }
      setWebSocketPublicClient(webSocketPublicClient) {
        const chainId = this.data?.chain?.id;
        this.args = {
          ...this.args,
          webSocketPublicClient
        };
        this.webSocketPublicClients.clear();
        this.setState((x) => ({
          ...x,
          webSocketPublicClient: this.getWebSocketPublicClient({
            chainId
          })
        }));
      }
      setLastUsedConnector(lastUsedConnector = null) {
        this.storage?.setItem("wallet", lastUsedConnector);
      }
    };
    _isAutoConnecting = /* @__PURE__ */ new WeakMap();
    _lastUsedConnector = /* @__PURE__ */ new WeakMap();
    _addEffects = /* @__PURE__ */ new WeakSet();
    addEffects_fn = function() {
      const onChange = (data) => {
        this.setState((x) => ({
          ...x,
          data: { ...x.data, ...data }
        }));
      };
      const onDisconnect = () => {
        this.clearState();
      };
      const onError = (error) => {
        this.setState((x) => ({ ...x, error }));
      };
      this.store.subscribe(
        ({ connector }) => connector,
        (connector, prevConnector) => {
          prevConnector?.off?.("change", onChange);
          prevConnector?.off?.("disconnect", onDisconnect);
          prevConnector?.off?.("error", onError);
          if (!connector)
            return;
          connector.on?.("change", onChange);
          connector.on?.("disconnect", onDisconnect);
          connector.on?.("error", onError);
        }
      );
      const { publicClient, webSocketPublicClient } = this.args;
      const subscribePublicClient = typeof publicClient === "function";
      const subscribeWebSocketPublicClient = typeof webSocketPublicClient === "function";
      if (subscribePublicClient || subscribeWebSocketPublicClient)
        this.store.subscribe(
          ({ data }) => data?.chain?.id,
          (chainId) => {
            this.setState((x) => ({
              ...x,
              publicClient: this.getPublicClient({ chainId }),
              webSocketPublicClient: this.getWebSocketPublicClient({
                chainId
              })
            }));
          }
        );
    };
    erc20ABI = [
      {
        type: "event",
        name: "Approval",
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "event",
        name: "Transfer",
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "spender",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "spender",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
          {
            name: "account",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint8"
          }
        ]
      },
      {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "string"
          }
        ]
      },
      {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "string"
          }
        ]
      },
      {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      }
    ];
    erc20ABI_bytes32 = [
      {
        type: "event",
        name: "Approval",
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "event",
        name: "Transfer",
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "spender",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "spender",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
          {
            name: "account",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint8"
          }
        ]
      },
      {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ]
      },
      {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ]
      },
      {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      }
    ];
  }
});

// node_modules/@wagmi/core/dist/chunk-KX4UEHS5.js
var init_chunk_KX4UEHS5 = __esm({
  "node_modules/@wagmi/core/dist/chunk-KX4UEHS5.js"() {
  }
});

// node_modules/@wagmi/core/dist/chunk-EQOEZP46.js
var init_chunk_EQOEZP46 = __esm({
  "node_modules/@wagmi/core/dist/chunk-EQOEZP46.js"() {
    init_injected();
  }
});

// node_modules/@wagmi/core/dist/index.js
var init_dist2 = __esm({
  "node_modules/@wagmi/core/dist/index.js"() {
    init_chunk_KX4UEHS5();
    init_chunk_LAFZBYO7();
    init_chunk_GUCHKZEA();
    init_chunk_BVC4KGLQ();
    init_chunk_EQOEZP46();
    init_chunk_MQXBDTVK();
  }
});

export {
  __publicField,
  __privateGet2 as __privateGet,
  __privateAdd2 as __privateAdd,
  __privateSet2 as __privateSet,
  __privateMethod2 as __privateMethod,
  Connector,
  init_chunk_QYMCVNHT,
  ConnectorNotFoundError,
  init_chunk_ZCAPXGBX,
  normalizeChainId,
  init_chunk_OQILYQDO,
  custom,
  createPublicClient,
  createWalletClient,
  zeroAddress,
  init_esm2 as init_esm,
  InjectedConnector,
  init_chunk_BVC4KGLQ,
  configureChains,
  deepEqual,
  noopStorage,
  createStorage,
  createConfig,
  connect,
  disconnect,
  getPublicClient,
  watchPublicClient,
  fetchBalance,
  getAccount,
  getNetwork,
  switchNetwork,
  watchAccount,
  watchNetwork,
  fetchEnsAvatar,
  fetchEnsName,
  init_chunk_LAFZBYO7,
  init_dist2 as init_dist
};
//# sourceMappingURL=chunk-M75A2V3Z.js.map
